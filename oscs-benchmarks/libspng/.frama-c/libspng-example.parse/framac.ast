/* Generated by Frama-C */
#include "__fc_builtin.h"
#include "errno.h"
#include "inttypes.h"
#include "math.h"
#include "stdarg.h"
#include "stddef.h"
#include "stdint.h"
#include "stdio.c"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "strings.h"
enum spng_errno {
    SPNG_IO_ERROR = -2,
    SPNG_IO_EOF = -1,
    SPNG_OK = 0,
    SPNG_EINVAL = 1,
    SPNG_EMEM = 2,
    SPNG_EOVERFLOW = 3,
    SPNG_ESIGNATURE = 4,
    SPNG_EWIDTH = 5,
    SPNG_EHEIGHT = 6,
    SPNG_EUSER_WIDTH = 7,
    SPNG_EUSER_HEIGHT = 8,
    SPNG_EBIT_DEPTH = 9,
    SPNG_ECOLOR_TYPE = 10,
    SPNG_ECOMPRESSION_METHOD = 11,
    SPNG_EFILTER_METHOD = 12,
    SPNG_EINTERLACE_METHOD = 13,
    SPNG_EIHDR_SIZE = 14,
    SPNG_ENOIHDR = 15,
    SPNG_ECHUNK_POS = 16,
    SPNG_ECHUNK_SIZE = 17,
    SPNG_ECHUNK_CRC = 18,
    SPNG_ECHUNK_TYPE = 19,
    SPNG_ECHUNK_UNKNOWN_CRITICAL = 20,
    SPNG_EDUP_PLTE = 21,
    SPNG_EDUP_CHRM = 22,
    SPNG_EDUP_GAMA = 23,
    SPNG_EDUP_ICCP = 24,
    SPNG_EDUP_SBIT = 25,
    SPNG_EDUP_SRGB = 26,
    SPNG_EDUP_BKGD = 27,
    SPNG_EDUP_HIST = 28,
    SPNG_EDUP_TRNS = 29,
    SPNG_EDUP_PHYS = 30,
    SPNG_EDUP_TIME = 31,
    SPNG_EDUP_OFFS = 32,
    SPNG_EDUP_EXIF = 33,
    SPNG_ECHRM = 34,
    SPNG_EPLTE_IDX = 35,
    SPNG_ETRNS_COLOR_TYPE = 36,
    SPNG_ETRNS_NO_PLTE = 37,
    SPNG_EGAMA = 38,
    SPNG_EICCP_NAME = 39,
    SPNG_EICCP_COMPRESSION_METHOD = 40,
    SPNG_ESBIT = 41,
    SPNG_ESRGB = 42,
    SPNG_ETEXT = 43,
    SPNG_ETEXT_KEYWORD = 44,
    SPNG_EZTXT = 45,
    SPNG_EZTXT_COMPRESSION_METHOD = 46,
    SPNG_EITXT = 47,
    SPNG_EITXT_COMPRESSION_FLAG = 48,
    SPNG_EITXT_COMPRESSION_METHOD = 49,
    SPNG_EITXT_LANG_TAG = 50,
    SPNG_EITXT_TRANSLATED_KEY = 51,
    SPNG_EBKGD_NO_PLTE = 52,
    SPNG_EBKGD_PLTE_IDX = 53,
    SPNG_EHIST_NO_PLTE = 54,
    SPNG_EPHYS = 55,
    SPNG_ESPLT_NAME = 56,
    SPNG_ESPLT_DUP_NAME = 57,
    SPNG_ESPLT_DEPTH = 58,
    SPNG_ETIME = 59,
    SPNG_EOFFS = 60,
    SPNG_EEXIF = 61,
    SPNG_EIDAT_TOO_SHORT = 62,
    SPNG_EIDAT_STREAM = 63,
    SPNG_EZLIB = 64,
    SPNG_EFILTER = 65,
    SPNG_EBUFSIZ = 66,
    SPNG_EIO = 67,
    SPNG_EOF = 68,
    SPNG_EBUF_SET = 69,
    SPNG_EBADSTATE = 70,
    SPNG_EFMT = 71,
    SPNG_EFLAGS = 72,
    SPNG_ECHUNKAVAIL = 73,
    SPNG_ENCODE_ONLY = 74
};
enum spng_text_type {
    SPNG_TEXT = 1,
    SPNG_ZTXT = 2,
    SPNG_ITXT = 3
};
enum spng_color_type {
    SPNG_COLOR_TYPE_GRAYSCALE = 0,
    SPNG_COLOR_TYPE_TRUECOLOR = 2,
    SPNG_COLOR_TYPE_INDEXED = 3,
    SPNG_COLOR_TYPE_GRAYSCALE_ALPHA = 4,
    SPNG_COLOR_TYPE_TRUECOLOR_ALPHA = 6
};
enum spng_format {
    SPNG_FMT_RGBA8 = 1,
    SPNG_FMT_RGBA16 = 2
};
enum spng_decode_flags {
    SPNG_DECODE_USE_TRNS = 1,
    SPNG_DECODE_USE_GAMA = 2,
    SPNG_DECODE_USE_SBIT = 8
};
enum spng_crc_action {
    SPNG_CRC_ERROR = 0,
    SPNG_CRC_DISCARD = 1,
    SPNG_CRC_USE = 2
};
struct spng_ihdr {
   uint32_t width ;
   uint32_t height ;
   uint8_t bit_depth ;
   uint8_t color_type ;
   uint8_t compression_method ;
   uint8_t filter_method ;
   uint8_t interlace_method ;
};
struct spng_plte_entry {
   uint8_t red ;
   uint8_t green ;
   uint8_t blue ;
   uint8_t alpha ;
};
struct spng_plte {
   uint32_t n_entries ;
   struct spng_plte_entry entries[256] ;
};
struct spng_trns {
   uint16_t gray ;
   uint16_t red ;
   uint16_t green ;
   uint16_t blue ;
   uint32_t n_type3_entries ;
   uint8_t type3_alpha[256] ;
};
struct spng_chrm_int {
   uint32_t white_point_x ;
   uint32_t white_point_y ;
   uint32_t red_x ;
   uint32_t red_y ;
   uint32_t green_x ;
   uint32_t green_y ;
   uint32_t blue_x ;
   uint32_t blue_y ;
};
struct spng_chrm {
   double white_point_x ;
   double white_point_y ;
   double red_x ;
   double red_y ;
   double green_x ;
   double green_y ;
   double blue_x ;
   double blue_y ;
};
struct spng_iccp {
   char profile_name[80] ;
   size_t profile_len ;
   char *profile ;
};
struct spng_sbit {
   uint8_t grayscale_bits ;
   uint8_t red_bits ;
   uint8_t green_bits ;
   uint8_t blue_bits ;
   uint8_t alpha_bits ;
};
struct spng_text {
   char keyword[80] ;
   int type ;
   size_t length ;
   char *text ;
   uint8_t compression_flag ;
   uint8_t compression_method ;
   char *language_tag ;
   char *translated_keyword ;
};
struct spng_bkgd {
   uint16_t gray ;
   uint16_t red ;
   uint16_t green ;
   uint16_t blue ;
   uint16_t plte_index ;
};
struct spng_hist {
   uint16_t frequency[256] ;
};
struct spng_phys {
   uint32_t ppu_x ;
   uint32_t ppu_y ;
   uint8_t unit_specifier ;
};
struct spng_splt_entry {
   uint16_t red ;
   uint16_t green ;
   uint16_t blue ;
   uint16_t alpha ;
   uint16_t frequency ;
};
struct spng_splt {
   char name[80] ;
   uint8_t sample_depth ;
   uint32_t n_entries ;
   struct spng_splt_entry *entries ;
};
struct spng_time {
   uint16_t year ;
   uint8_t month ;
   uint8_t day ;
   uint8_t hour ;
   uint8_t minute ;
   uint8_t second ;
};
struct spng_offs {
   int32_t x ;
   int32_t y ;
   uint8_t unit_specifier ;
};
struct spng_exif {
   size_t length ;
   char *data ;
};
struct spng_chunk {
   size_t offset ;
   uint32_t length ;
   uint8_t type[4] ;
   uint32_t crc ;
};
typedef void *spng_malloc_fn(size_t size);
typedef void *spng_realloc_fn(void *ptr, size_t size);
typedef void *spng_calloc_fn(size_t count, size_t size);
typedef void spng_free_fn(void *ptr);
struct spng_alloc {
   spng_malloc_fn *malloc_fn ;
   spng_realloc_fn *realloc_fn ;
   spng_calloc_fn *calloc_fn ;
   spng_free_fn *free_fn ;
};
typedef struct spng_ctx spng_ctx;
typedef int spng_read_fn(spng_ctx *ctx, void *user, void *dest, size_t length);
struct z_stream_s {
   unsigned char const *next_in ;
   unsigned int avail_in ;
   unsigned long total_in ;
   unsigned char *next_out ;
   unsigned int avail_out ;
   unsigned long total_out ;
   void *(*zalloc)(void *opaque, unsigned int items, unsigned int size) ;
   void (*zfree)(void *opaque, void *address) ;
   void *opaque ;
   int data_type ;
   unsigned long adler ;
};
typedef struct z_stream_s z_stream;
typedef z_stream *z_streamp;
struct spng_subimage {
   uint32_t width ;
   uint32_t height ;
   size_t scanline_width ;
};
struct spng_plte_entry16 {
   uint16_t red ;
   uint16_t green ;
   uint16_t blue ;
   uint16_t alpha ;
};
struct spng_chunk_bitfield {
   unsigned int ihdr : 1 ;
   unsigned int plte : 1 ;
   unsigned int chrm : 1 ;
   unsigned int iccp : 1 ;
   unsigned int gama : 1 ;
   unsigned int sbit : 1 ;
   unsigned int srgb : 1 ;
   unsigned int text : 1 ;
   unsigned int bkgd : 1 ;
   unsigned int hist : 1 ;
   unsigned int trns : 1 ;
   unsigned int phys : 1 ;
   unsigned int splt : 1 ;
   unsigned int time : 1 ;
   unsigned int offs : 1 ;
   unsigned int exif : 1 ;
};
struct spng_ctx {
   size_t data_size ;
   size_t bytes_read ;
   unsigned char *stream_buf ;
   unsigned char const *data ;
   spng_read_fn *read_fn ;
   void *read_user_ptr ;
   unsigned char const *png_buf ;
   size_t bytes_left ;
   size_t last_read_size ;
   struct spng_chunk current_chunk ;
   uint32_t cur_chunk_bytes_left ;
   uint32_t cur_actual_crc ;
   struct spng_alloc alloc ;
   unsigned int valid_state : 1 ;
   unsigned int streaming : 1 ;
   unsigned int encode_only : 1 ;
   unsigned int have_first_idat : 1 ;
   unsigned int have_last_idat : 1 ;
   struct spng_chunk_bitfield file ;
   struct spng_chunk_bitfield user ;
   struct spng_chunk_bitfield stored ;
   struct spng_chunk first_idat ;
   struct spng_chunk last_idat ;
   uint32_t max_width ;
   uint32_t max_height ;
   uint32_t max_chunk_size ;
   size_t chunk_cache_limit ;
   size_t chunk_cache_usage ;
   int crc_action_critical ;
   int crc_action_ancillary ;
   struct spng_ihdr ihdr ;
   size_t plte_offset ;
   struct spng_plte plte ;
   struct spng_chrm_int chrm_int ;
   struct spng_iccp iccp ;
   uint32_t gama ;
   uint16_t *gamma_lut ;
   struct spng_sbit sbit ;
   uint8_t srgb_rendering_intent ;
   uint32_t n_text ;
   struct spng_text *text_list ;
   struct spng_bkgd bkgd ;
   struct spng_hist hist ;
   struct spng_trns trns ;
   struct spng_phys phys ;
   uint32_t n_splt ;
   struct spng_splt *splt_list ;
   struct spng_time time ;
   struct spng_offs offs ;
   struct spng_exif exif ;
   uint16_t gamma_lut8[256] ;
};
int main(int argc, char **argv);

int eva_main(void)
{
  char argv0[256];
  char argv1[256];
  char argv2[256];
  char argv3[256];
  char argv4[256];
  int tmp_0;
  int argc = Frama_C_interval(0,5);
  char *argv[6] = {argv0, argv1, argv2, argv3, argv4, (char *)0};
  {
    int i = 0;
    /*@ loop unroll 5; */
    while (i < 5) {
      Frama_C_make_unknown(argv[i],(size_t)255);
      *(argv[i] + 255) = (char)0;
      i ++;
    }
  }
  tmp_0 = main(argc,argv);
  return tmp_0;
}

spng_ctx *spng_ctx_new(int flags);

spng_ctx *spng_ctx_new2(struct spng_alloc *alloc, int flags);

void spng_ctx_free(spng_ctx *ctx);

int spng_set_png_buffer(spng_ctx *ctx, void const *buf, size_t size);

int spng_set_png_stream(spng_ctx *ctx, spng_read_fn *read_func, void *user);

int spng_set_image_limits(spng_ctx *ctx, uint32_t width, uint32_t height);

int spng_get_image_limits(spng_ctx *ctx, uint32_t *width, uint32_t *height);

int spng_set_chunk_limits(spng_ctx *ctx, size_t chunk_size,
                          size_t cache_limit);

int spng_get_chunk_limits(spng_ctx *ctx, size_t *chunk_size,
                          size_t *cache_limit);

int spng_set_crc_action(spng_ctx *ctx, int critical, int ancillary);

int spng_decoded_image_size(spng_ctx *ctx, int fmt, size_t *out);

int spng_decode_image(spng_ctx *ctx, unsigned char *out, size_t out_size,
                      int fmt, int flags);

int spng_get_ihdr(spng_ctx *ctx, struct spng_ihdr *ihdr);

int spng_get_plte(spng_ctx *ctx, struct spng_plte *plte);

int spng_get_trns(spng_ctx *ctx, struct spng_trns *trns);

int spng_get_chrm(spng_ctx *ctx, struct spng_chrm *chrm);

int spng_get_chrm_int(spng_ctx *ctx, struct spng_chrm_int *chrm);

int spng_get_gama(spng_ctx *ctx, double *gamma);

int spng_get_iccp(spng_ctx *ctx, struct spng_iccp *iccp);

int spng_get_sbit(spng_ctx *ctx, struct spng_sbit *sbit);

int spng_get_srgb(spng_ctx *ctx, uint8_t *rendering_intent);

int spng_get_text(spng_ctx *ctx, struct spng_text *text, uint32_t *n_text);

int spng_get_bkgd(spng_ctx *ctx, struct spng_bkgd *bkgd);

int spng_get_hist(spng_ctx *ctx, struct spng_hist *hist);

int spng_get_phys(spng_ctx *ctx, struct spng_phys *phys);

int spng_get_splt(spng_ctx *ctx, struct spng_splt *splt, uint32_t *n_splt);

int spng_get_time(spng_ctx *ctx, struct spng_time *time);

int spng_get_offs(spng_ctx *ctx, struct spng_offs *offs);

int spng_get_exif(spng_ctx *ctx, struct spng_exif *exif);

int spng_set_ihdr(spng_ctx *ctx, struct spng_ihdr *ihdr);

int spng_set_plte(spng_ctx *ctx, struct spng_plte *plte);

int spng_set_trns(spng_ctx *ctx, struct spng_trns *trns);

int spng_set_chrm(spng_ctx *ctx, struct spng_chrm *chrm);

int spng_set_chrm_int(spng_ctx *ctx, struct spng_chrm_int *chrm_int);

int spng_set_gama(spng_ctx *ctx, double gamma);

int spng_set_iccp(spng_ctx *ctx, struct spng_iccp *iccp);

int spng_set_sbit(spng_ctx *ctx, struct spng_sbit *sbit);

int spng_set_srgb(spng_ctx *ctx, uint8_t rendering_intent);

int spng_set_text(spng_ctx *ctx, struct spng_text *text, uint32_t n_text);

int spng_set_bkgd(spng_ctx *ctx, struct spng_bkgd *bkgd);

int spng_set_hist(spng_ctx *ctx, struct spng_hist *hist);

int spng_set_phys(spng_ctx *ctx, struct spng_phys *phys);

int spng_set_splt(spng_ctx *ctx, struct spng_splt *splt, uint32_t n_splt);

int spng_set_time(spng_ctx *ctx, struct spng_time *time);

int spng_set_offs(spng_ctx *ctx, struct spng_offs *offs);

int spng_set_exif(spng_ctx *ctx, struct spng_exif *exif);

char const *spng_strerror(int err);

char const *spng_version_string(void);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_1(char const * restrict format);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_2(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_3(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_4(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_5(char const * restrict format);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_6(char const * restrict format, char *param0);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_7(char const * restrict format, char *param0);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_8(char const * restrict format, char *param0);

/*@ requires valid_read_string(param4);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param4 + (0 ..))),
            (indirect: param3), (indirect: param2), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param4 + (0 ..)), param3, param2, param1, param0;
 */
int printf_va_9(char const * restrict format, unsigned int param0,
                unsigned int param1, int param2, int param3, char *param4);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param2),
            (indirect: param1), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param2, param1, param0;
 */
int printf_va_10(char const * restrict format, int param0, int param1,
                 int param2);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_11(char const * restrict format, char *param0);

int main(int argc, char **argv)
{
  FILE *png;
  size_t tmp_0;
  struct spng_ihdr ihdr;
  char *clr_type_str;
  size_t out_size;
  int r = 0;
  char *pngbuf = (char *)0;
  spng_ctx *ctx = (spng_ctx *)0;
  unsigned char *out = (unsigned char *)0;
  if (argc < 2) {
    printf("no input file\n"); /* printf_va_1 */
    goto err;
  }
  png = fopen((char const *)*(argv + 1),"rb");
  if (png == (FILE *)0) {
    printf("error opening input file %s\n",*(argv + 1)); /* printf_va_2 */
    goto err;
  }
  fseek(png,(long)0,2);
  long siz_pngbuf = ftell(png);
  rewind(png);
  if (siz_pngbuf < (long)1) goto err;
  pngbuf = (char *)malloc((size_t)siz_pngbuf);
  if (pngbuf == (char *)0) {
    printf("malloc() failed\n"); /* printf_va_3 */
    goto err;
  }
  tmp_0 = fread((void *)pngbuf,(size_t)siz_pngbuf,(size_t)1,png);
  if (tmp_0 != (size_t)1) {
    printf("fread() failed\n"); /* printf_va_4 */
    goto err;
  }
  ctx = spng_ctx_new(0);
  if (ctx == (spng_ctx *)0) {
    printf("spng_ctx_new() failed\n"); /* printf_va_5 */
    goto err;
  }
  r = spng_set_crc_action(ctx,SPNG_CRC_USE,SPNG_CRC_USE);
  if (r) {
    char const *tmp_1;
    tmp_1 = spng_strerror(r);
    printf("spng_set_crc_action() error: %s\n",(char *)tmp_1); /* printf_va_6 */
    goto err;
  }
  r = spng_set_png_buffer(ctx,(void const *)pngbuf,(size_t)siz_pngbuf);
  if (r) {
    char const *tmp_2;
    tmp_2 = spng_strerror(r);
    printf("spng_set_png_buffer() error: %s\n",(char *)tmp_2); /* printf_va_7 */
    goto err;
  }
  r = spng_get_ihdr(ctx,& ihdr);
  if (r) {
    char const *tmp_3;
    tmp_3 = spng_strerror(r);
    printf("spng_get_ihdr() error: %s\n",(char *)tmp_3); /* printf_va_8 */
    goto err;
  }
  if ((int)ihdr.color_type == SPNG_COLOR_TYPE_GRAYSCALE) clr_type_str = (char *)"grayscale";
  else 
    if ((int)ihdr.color_type == SPNG_COLOR_TYPE_TRUECOLOR) clr_type_str = (char *)"truecolor";
    else 
      if ((int)ihdr.color_type == SPNG_COLOR_TYPE_INDEXED) clr_type_str = (char *)"indexed color";
      else 
        if ((int)ihdr.color_type == SPNG_COLOR_TYPE_GRAYSCALE_ALPHA) 
          clr_type_str = (char *)"grayscale with alpha";
        else clr_type_str = (char *)"truecolor with alpha";
  printf("width: %u\nheight: %u\nbit depth: %hhu\ncolor type: %hhu - %s\n",
         ihdr.width,ihdr.height,(int)ihdr.bit_depth,(int)ihdr.color_type,
         clr_type_str); /* printf_va_9 */
  printf("compression method: %hhu\nfilter method: %hhu\ninterlace method: %hhu\n",
         (int)ihdr.compression_method,(int)ihdr.filter_method,
         (int)ihdr.interlace_method); /* printf_va_10 */
  r = spng_decoded_image_size(ctx,SPNG_FMT_RGBA8,& out_size);
  if (r) goto err;
  out = (unsigned char *)malloc(out_size);
  if (out == (unsigned char *)0) goto err;
  r = spng_decode_image(ctx,out,out_size,SPNG_FMT_RGBA8,0);
  if (r) {
    char const *tmp_4;
    tmp_4 = spng_strerror(r);
    printf("spng_decode_image() error: %s\n",(char *)tmp_4); /* printf_va_11 */
    goto err;
  }
  err: spng_ctx_free(ctx);
  free((void *)out);
  free((void *)pngbuf);
  return r;
}

int inflateInit(z_streamp strm)
{
  int __retres;
  if (strm == (z_streamp)0) {
    __retres = 1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int inflate(z_streamp stream, int flush)
{
  int __retres;
  if (stream == (z_streamp)0) {
    __retres = -2;
    goto return_label;
  }
  if (stream->avail_in == (unsigned int)0) {
    __retres = -5;
    goto return_label;
  }
  else 
    if (stream->avail_out == (unsigned int)0) {
      __retres = -5;
      goto return_label;
    }
  stream->next_in += stream->avail_in;
  stream->next_out += stream->avail_out;
  __retres = 0;
  return_label: return __retres;
}

int inflateEnd(z_streamp stream)
{
  int __retres;
  if (stream == (z_streamp)0) {
    __retres = 1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

unsigned long crc32(unsigned long crc, unsigned char *buf, unsigned int len)
{
  unsigned long __retres;
  if (buf == (unsigned char *)0) {
    __retres = (unsigned long)0;
    goto return_label;
  }
  __retres = crc + (unsigned long)len;
  return_label: return __retres;
}

static uint32_t const png_u32max = (uint32_t)2147483647;
static int32_t const png_s32min = -2147483647;
static uint8_t const type_ihdr[4] =
  {(uint8_t)73, (uint8_t)72, (uint8_t)68, (uint8_t)82};
static uint8_t const type_plte[4] =
  {(uint8_t)80, (uint8_t)76, (uint8_t)84, (uint8_t)69};
static uint8_t const type_idat[4] =
  {(uint8_t)73, (uint8_t)68, (uint8_t)65, (uint8_t)84};
static uint8_t const type_iend[4] =
  {(uint8_t)73, (uint8_t)69, (uint8_t)78, (uint8_t)68};
static uint8_t const type_trns[4] =
  {(uint8_t)116, (uint8_t)82, (uint8_t)78, (uint8_t)83};
static uint8_t const type_chrm[4] =
  {(uint8_t)99, (uint8_t)72, (uint8_t)82, (uint8_t)77};
static uint8_t const type_gama[4] =
  {(uint8_t)103, (uint8_t)65, (uint8_t)77, (uint8_t)65};
static uint8_t const type_iccp[4] =
  {(uint8_t)105, (uint8_t)67, (uint8_t)67, (uint8_t)80};
static uint8_t const type_sbit[4] =
  {(uint8_t)115, (uint8_t)66, (uint8_t)73, (uint8_t)84};
static uint8_t const type_srgb[4] =
  {(uint8_t)115, (uint8_t)82, (uint8_t)71, (uint8_t)66};
static uint8_t const type_text[4] =
  {(uint8_t)116, (uint8_t)69, (uint8_t)88, (uint8_t)116};
static uint8_t const type_ztxt[4] =
  {(uint8_t)122, (uint8_t)84, (uint8_t)88, (uint8_t)116};
static uint8_t const type_itxt[4] =
  {(uint8_t)105, (uint8_t)84, (uint8_t)88, (uint8_t)116};
static uint8_t const type_bkgd[4] =
  {(uint8_t)98, (uint8_t)75, (uint8_t)71, (uint8_t)68};
static uint8_t const type_hist[4] =
  {(uint8_t)104, (uint8_t)73, (uint8_t)83, (uint8_t)84};
static uint8_t const type_phys[4] =
  {(uint8_t)112, (uint8_t)72, (uint8_t)89, (uint8_t)115};
static uint8_t const type_splt[4] =
  {(uint8_t)115, (uint8_t)80, (uint8_t)76, (uint8_t)84};
static uint8_t const type_time[4] =
  {(uint8_t)116, (uint8_t)73, (uint8_t)77, (uint8_t)69};
static uint8_t const type_offs[4] =
  {(uint8_t)111, (uint8_t)70, (uint8_t)70, (uint8_t)115};
static uint8_t const type_exif[4] =
  {(uint8_t)101, (uint8_t)88, (uint8_t)73, (uint8_t)102};
__inline static void *spng__malloc(spng_ctx *ctx, size_t size)
{
  void *tmp;
  tmp = (*(ctx->alloc.malloc_fn))(size);
  return tmp;
}

__inline static void *spng__calloc(spng_ctx *ctx, size_t nmemb, size_t size)
{
  void *tmp;
  tmp = (*(ctx->alloc.calloc_fn))(nmemb,size);
  return tmp;
}

__inline static void *spng__realloc(spng_ctx *ctx, void *ptr, size_t size)
{
  void *tmp;
  tmp = (*(ctx->alloc.realloc_fn))(ptr,size);
  return tmp;
}

__inline static void spng__free(spng_ctx *ctx, void *ptr)
{
  (*(ctx->alloc.free_fn))(ptr);
  return;
}

static void *spng__zalloc(void *opaque, unsigned int items, unsigned int size)
{
  void *__retres;
  void *tmp;
  spng_ctx *ctx = (spng_ctx *)opaque;
  if (size > 4294967295U / items) {
    __retres = (void *)0;
    goto return_label;
  }
  size_t len = items * size;
  tmp = spng__malloc(ctx,len);
  __retres = tmp;
  return_label: return __retres;
}

static void spng__zfree(void *opqaue, void *ptr)
{
  spng_ctx *ctx = (spng_ctx *)opqaue;
  spng__free(ctx,ptr);
  return;
}

__inline static uint16_t read_u16(void const *_data)
{
  uint16_t __retres;
  unsigned char const *data = (unsigned char const *)_data;
  __retres = (uint16_t)((((unsigned int)*(data + 0) & 0xffU) << 8) | (
                        (unsigned int)*(data + 1) & 0xffU));
  return __retres;
}

__inline static uint32_t read_u32(void const *_data)
{
  uint32_t __retres;
  unsigned char const *data = (unsigned char const *)_data;
  __retres = (uint32_t)((((((unsigned long)*(data + 0) & 0xffUL) << 24) | (
                          ((unsigned long)*(data + 1) & 0xffUL) << 16)) | (
                         ((unsigned long)*(data + 2) & 0xffUL) << 8)) | (
                        (unsigned long)*(data + 3) & 0xffUL));
  return __retres;
}

__inline static int32_t read_s32(void const *_data)
{
  int32_t ret;
  unsigned char const *data = (unsigned char const *)_data;
  uint32_t val =
    (uint32_t)((((((unsigned long)*(data + 0) & 0xffUL) << 24) | (((unsigned long)*(
                                                                   data + 1) & 0xffUL) << 16)) | (
                ((unsigned long)*(data + 2) & 0xffUL) << 8)) | ((unsigned long)*(
                                                                data + 3) & 0xffUL));
  memcpy((void *)(& ret),(void const *)(& val),(size_t)4);
  return ret;
}

static int is_critical_chunk(struct spng_chunk *chunk)
{
  int __retres;
  if (chunk == (struct spng_chunk *)0) {
    __retres = 0;
    goto return_label;
  }
  if (((int)chunk->type[0] & (1 << 5)) == 0) {
    __retres = 1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

__inline static int read_data(spng_ctx *ctx, size_t bytes)
{
  int __retres;
  int ret;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  if (! bytes) {
    __retres = 0;
    goto return_label;
  }
  if (ctx->streaming) 
    if (bytes > ctx->data_size) {
      void *buf = spng__realloc(ctx,(void *)ctx->stream_buf,bytes);
      if (buf == (void *)0) {
        __retres = SPNG_EMEM;
        goto return_label;
      }
      ctx->stream_buf = (unsigned char *)buf;
      ctx->data = (unsigned char const *)ctx->stream_buf;
      ctx->data_size = bytes;
    }
  ret = (*(ctx->read_fn))(ctx,ctx->read_user_ptr,(void *)ctx->stream_buf,
                          bytes);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  ctx->bytes_read += bytes;
  if (ctx->bytes_read < bytes) {
    __retres = SPNG_EOVERFLOW;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

__inline static int read_and_check_crc(spng_ctx *ctx)
{
  int __retres;
  int ret;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  ret = read_data(ctx,(size_t)4);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  ctx->current_chunk.crc = read_u32((void const *)ctx->data);
  if (ctx->cur_actual_crc != ctx->current_chunk.crc) {
    int tmp;
    tmp = is_critical_chunk(& ctx->current_chunk);
    if (tmp) {
      if (ctx->crc_action_critical == SPNG_CRC_USE) {
        __retres = 0;
        goto return_label;
      }
    }
    else {
      if (ctx->crc_action_ancillary == SPNG_CRC_USE) {
        __retres = 0;
        goto return_label;
      }
      if (ctx->crc_action_ancillary == SPNG_CRC_DISCARD) {
        __retres = - SPNG_CRC_DISCARD;
        goto return_label;
      }
    }
    __retres = SPNG_ECHUNK_CRC;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

__inline static int read_header(spng_ctx *ctx, int *discard)
{
  int __retres;
  int ret;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  struct spng_chunk chunk =
    {.offset = (size_t)0,
     .length = 0U,
     .type = {(unsigned char)0,
              (unsigned char)0,
              (unsigned char)0,
              (unsigned char)0},
     .crc = 0U};
  ret = read_and_check_crc(ctx);
  if (ret) 
    if (ret == - SPNG_CRC_DISCARD) {
      if (discard != (int *)0) *discard = 1;
    }
    else {
      __retres = ret;
      goto return_label;
    }
  ret = read_data(ctx,(size_t)8);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  chunk.offset = ctx->bytes_read - (size_t)8;
  chunk.length = read_u32((void const *)ctx->data);
  memcpy((void *)(& chunk.type),(void const *)(ctx->data + 4),(size_t)4);
  if (chunk.length > png_u32max) {
    __retres = SPNG_ECHUNK_SIZE;
    goto return_label;
  }
  ctx->cur_chunk_bytes_left = chunk.length;
  ctx->cur_actual_crc = (uint32_t)crc32((unsigned long)0,(unsigned char *)0,
                                        (unsigned int)0);
  ctx->cur_actual_crc = (uint32_t)crc32((unsigned long)ctx->cur_actual_crc,
                                        chunk.type,(unsigned int)4);
  memcpy((void *)(& ctx->current_chunk),(void const *)(& chunk),
         sizeof(struct spng_chunk));
  __retres = 0;
  return_label: return __retres;
}

static int read_chunk_bytes(spng_ctx *ctx, uint32_t bytes)
{
  int __retres;
  int ret;
  int tmp;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  if (! bytes) {
    __retres = 0;
    goto return_label;
  }
  if (bytes > ctx->cur_chunk_bytes_left) {
    __retres = 1;
    goto return_label;
  }
  ret = read_data(ctx,bytes);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  tmp = is_critical_chunk(& ctx->current_chunk);
  if (tmp) {
    if (ctx->crc_action_critical == SPNG_CRC_USE) goto skip_crc;
    else goto _LAND;
  }
  else {
    _LAND: ;
    if (ctx->crc_action_ancillary == SPNG_CRC_USE) goto skip_crc;
  }
  ctx->cur_actual_crc = (uint32_t)crc32((unsigned long)ctx->cur_actual_crc,
                                        (unsigned char *)ctx->data,bytes);
  skip_crc: ctx->cur_chunk_bytes_left -= bytes;
  __retres = ret;
  return_label: return __retres;
}

static int discard_chunk_bytes(spng_ctx *ctx, uint32_t bytes)
{
  int __retres;
  int ret;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  if (ctx->streaming) 
    while (bytes) {
      uint32_t len = (uint32_t)8192;
      if (len > bytes) len = bytes;
      ret = read_chunk_bytes(ctx,len);
      if (ret) {
        __retres = ret;
        goto return_label;
      }
      bytes -= len;
    }
  else {
    ret = read_chunk_bytes(ctx,bytes);
    if (ret) {
      __retres = ret;
      goto return_label;
    }
  }
  __retres = 0;
  return_label: return __retres;
}

static int read_idat_bytes(spng_ctx *ctx, uint32_t *bytes_read)
{
  int __retres;
  int tmp;
  int ret;
  uint32_t len;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (bytes_read == (uint32_t *)0) {
      __retres = 1;
      goto return_label;
    }
  tmp = memcmp((void const *)(ctx->current_chunk.type),
               (void const *)(type_idat),(size_t)4);
  if (tmp) {
    __retres = SPNG_EIDAT_TOO_SHORT;
    goto return_label;
  }
  while (! ctx->cur_chunk_bytes_left) {
    int tmp_0;
    ret = read_header(ctx,(int *)0);
    if (ret) {
      __retres = ret;
      goto return_label;
    }
    tmp_0 = memcmp((void const *)(ctx->current_chunk.type),
                   (void const *)(type_idat),(size_t)4);
    if (tmp_0) {
      __retres = SPNG_EIDAT_TOO_SHORT;
      goto return_label;
    }
  }
  if (ctx->streaming) {
    len = (uint32_t)8192;
    if (len > ctx->current_chunk.length) len = ctx->current_chunk.length;
  }
  else len = ctx->current_chunk.length;
  ret = read_chunk_bytes(ctx,len);
  *bytes_read = len;
  __retres = ret;
  return_label: return __retres;
}

static int read_scanline_bytes(spng_ctx *ctx, z_stream *stream,
                               unsigned char *dest, size_t len)
{
  int __retres;
  int ret;
  uint32_t bytes_read;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (stream == (z_stream *)0) {
      __retres = 1;
      goto return_label;
    }
    else 
      if (dest == (unsigned char *)0) {
        __retres = 1;
        goto return_label;
      }
  stream->avail_out = len;
  stream->next_out = dest;
  if (! stream->avail_in) {
    ret = read_idat_bytes(ctx,& bytes_read);
    if (ret) {
      __retres = ret;
      goto return_label;
    }
    stream->avail_in = bytes_read;
    stream->next_in = ctx->data;
  }
  while (1) {
    ret = inflate(stream,2);
    if (ret != 0) 
      if (ret == 1) {
        if (stream->avail_out != (unsigned int)0) {
          __retres = SPNG_EIDAT_TOO_SHORT;
          goto return_label;
        }
      }
      else 
        if (ret != -5) {
          __retres = SPNG_EIDAT_STREAM;
          goto return_label;
        }
    if (stream->avail_out != (unsigned int)0) 
      if (stream->avail_in == (unsigned int)0) {
        ret = read_idat_bytes(ctx,& bytes_read);
        if (ret) {
          __retres = ret;
          goto return_label;
        }
        stream->avail_in = bytes_read;
        stream->next_in = ctx->data;
      }
    if (! (stream->avail_out != (unsigned int)0)) break;
  }
  __retres = 0;
  return_label: return __retres;
}

static uint8_t paeth(uint8_t a, uint8_t b, uint8_t c)
{
  uint8_t __retres;
  int tmp;
  int tmp_0;
  int tmp_1;
  int16_t p =
    (int16_t)(((int)((int16_t)a) + (int)((int16_t)b)) - (int)((int16_t)c));
  tmp = abs((int)p - (int)((int16_t)a));
  int16_t pa = (int16_t)tmp;
  tmp_0 = abs((int)p - (int)((int16_t)b));
  int16_t pb = (int16_t)tmp_0;
  tmp_1 = abs((int)p - (int)((int16_t)c));
  int16_t pc = (int16_t)tmp_1;
  if ((int)pa <= (int)pb) {
    if ((int)pa <= (int)pc) {
      __retres = a;
      goto return_label;
    }
    else goto _LAND;
  }
  else {
    _LAND: ;
    if ((int)pb <= (int)pc) {
      __retres = b;
      goto return_label;
    }
  }
  __retres = c;
  return_label: return __retres;
}

static int defilter_scanline(unsigned char const *prev_scanline,
                             unsigned char *scanline, size_t scanline_width,
                             unsigned int bytes_per_pixel,
                             unsigned int filter)
{
  int __retres;
  size_t i;
  if (prev_scanline == (unsigned char const *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (scanline == (unsigned char *)0) {
      __retres = 1;
      goto return_label;
    }
    else 
      if (! scanline_width) {
        __retres = 1;
        goto return_label;
      }
  if (filter == (unsigned int)0) {
    __retres = 0;
    goto return_label;
  }
  if (filter > (unsigned int)4) {
    __retres = SPNG_EFILTER;
    goto return_label;
  }
  i = (size_t)0;
  while (i < scanline_width) {
    {
      uint8_t x;
      uint8_t a;
      uint8_t b;
      uint8_t c;
      if (i >= bytes_per_pixel) {
        memcpy((void *)(& a),
               (void const *)((scanline + i) - bytes_per_pixel),(size_t)1);
        memcpy((void *)(& b),(void const *)(prev_scanline + i),(size_t)1);
        memcpy((void *)(& c),
               (void const *)((prev_scanline + i) - bytes_per_pixel),
               (size_t)1);
      }
      else {
        a = (uint8_t)0;
        memcpy((void *)(& b),(void const *)(prev_scanline + i),(size_t)1);
        c = (uint8_t)0;
      }
      memcpy((void *)(& x),(void const *)(scanline + i),(size_t)1);
      switch (filter) {
        case (unsigned int)1: {
                                x = (uint8_t)((int)x + (int)a);
                                break;
                              }
        case (unsigned int)2: {
                                x = (uint8_t)((int)x + (int)b);
                                break;
                              }
        case (unsigned int)3:
        {
          uint16_t avg = (uint16_t)(((int)a + (int)b) / 2);
          x = (uint8_t)((int)x + (int)avg);
          break;
        }
        case (unsigned int)4:
        {
          uint8_t tmp;
          tmp = paeth(a,b,c);
          x = (uint8_t)((int)x + (int)tmp);
          break;
        }
      }
      memcpy((void *)(scanline + i),(void const *)(& x),(size_t)1);
    }
    i ++;
  }
  __retres = 0;
  return_label: return __retres;
}

static uint16_t sample_to_target(uint16_t sample, unsigned int bit_depth,
                                 unsigned int sbits, unsigned int target)
{
  uint16_t __retres;
  if (bit_depth == sbits) {
    if (target == sbits) {
      __retres = sample;
      goto return_label;
    }
  }
  else sample = (uint16_t)((int)sample >> (bit_depth - sbits));
  if (target < sbits) {
    __retres = (uint16_t)((int)sample >> (sbits - target));
    goto return_label;
  }
  int8_t shift_amount = (int8_t)(target - sbits);
  uint16_t sample_bits = sample;
  sample = (uint16_t)0;
  while ((int)shift_amount >= 0) {
    sample = (uint16_t)((int)sample | ((int)sample_bits << (int)shift_amount));
    shift_amount = (int8_t)((unsigned int)shift_amount - sbits);
  }
  int8_t partial = (int8_t)((int)shift_amount + (int)((int8_t)sbits));
  if ((int)partial != 0) {
    int tmp;
    tmp = abs((int)shift_amount);
    sample = (uint16_t)((int)sample | ((int)sample_bits >> tmp));
  }
  __retres = sample;
  return_label: return __retres;
}

__inline static void gamma_correct_row(unsigned char *row, uint32_t pixels,
                                       int fmt, uint16_t const *gamma_lut)
{
  uint32_t i;
  if (fmt == SPNG_FMT_RGBA8) {
    i = (uint32_t)0;
    while (i < pixels) {
      {
        unsigned char px[4];
        memcpy((void *)(px),(void const *)(row + i * (uint32_t)4),(size_t)4);
        px[0] = (unsigned char)*(gamma_lut + px[0]);
        px[1] = (unsigned char)*(gamma_lut + px[1]);
        px[2] = (unsigned char)*(gamma_lut + px[2]);
        memcpy((void *)(row + i * (uint32_t)4),(void const *)(px),(size_t)4);
      }
      i ++;
    }
  }
  else 
    if (fmt == SPNG_FMT_RGBA16) {
      i = (uint32_t)0;
      while (i < pixels) {
        {
          uint16_t px_0[4];
          memcpy((void *)(px_0),(void const *)(row + i * (uint32_t)8),
                 (size_t)8);
          px_0[0] = *(gamma_lut + px_0[0]);
          px_0[1] = *(gamma_lut + px_0[1]);
          px_0[2] = *(gamma_lut + px_0[2]);
          memcpy((void *)(row + i * (uint32_t)8),(void const *)(px_0),
                 (size_t)8);
        }
        i ++;
      }
    }
  return;
}

__inline static void trns_row(unsigned char *row,
                              unsigned char const *scanline,
                              unsigned char const *trns, uint32_t pixels,
                              int fmt, unsigned int ctype, unsigned int depth)
{
  uint32_t i;
  if (ctype != (unsigned int)SPNG_COLOR_TYPE_TRUECOLOR) goto return_label;
  unsigned int scanline_stride = (unsigned int)3;
  if (depth == (unsigned int)16) scanline_stride = (unsigned int)6;
  if (fmt == SPNG_FMT_RGBA8) {
    i = (uint32_t)0;
    while (i < pixels) {
      {
        int tmp;
        tmp = memcmp((void const *)scanline,(void const *)trns,
                     scanline_stride);
        if (! tmp) *(row + 3) = (unsigned char)0;
      }
      i ++;
      scanline += scanline_stride;
      row += 4;
    }
  }
  else 
    if (fmt == SPNG_FMT_RGBA16) {
      i = (uint32_t)0;
      while (i < pixels) {
        {
          int tmp_0;
          tmp_0 = memcmp((void const *)scanline,(void const *)trns,
                         scanline_stride);
          if (! tmp_0) memset((void *)(row + 6),0,(size_t)2);
        }
        i ++;
        scanline += scanline_stride;
        row += 8;
      }
    }
  return_label: return;
}

__inline static void scale_row(unsigned char *row, uint32_t pixels, int fmt,
                               unsigned int depth, struct spng_sbit *sbit)
{
  uint32_t i;
  if (fmt == SPNG_FMT_RGBA8) {
    unsigned char px[4];
    i = (uint32_t)0;
    while (i < pixels) {
      {
        uint16_t tmp;
        uint16_t tmp_0;
        uint16_t tmp_1;
        uint16_t tmp_2;
        memcpy((void *)(px),(void const *)(row + i * (uint32_t)4),(size_t)4);
        tmp = sample_to_target((uint16_t)px[0],depth,
                               (unsigned int)sbit->red_bits,(unsigned int)8);
        px[0] = (unsigned char)tmp;
        tmp_0 = sample_to_target((uint16_t)px[1],depth,
                                 (unsigned int)sbit->green_bits,
                                 (unsigned int)8);
        px[1] = (unsigned char)tmp_0;
        tmp_1 = sample_to_target((uint16_t)px[2],depth,
                                 (unsigned int)sbit->blue_bits,
                                 (unsigned int)8);
        px[2] = (unsigned char)tmp_1;
        tmp_2 = sample_to_target((uint16_t)px[3],depth,
                                 (unsigned int)sbit->alpha_bits,
                                 (unsigned int)8);
        px[3] = (unsigned char)tmp_2;
        memcpy((void *)(row + i * (uint32_t)4),(void const *)(px),(size_t)4);
      }
      i ++;
    }
  }
  else 
    if (fmt == SPNG_FMT_RGBA16) {
      uint16_t px_0[4];
      i = (uint32_t)0;
      while (i < pixels) {
        memcpy((void *)(px_0),(void const *)(row + i * (uint32_t)8),
               (size_t)8);
        px_0[0] = sample_to_target(px_0[0],depth,
                                   (unsigned int)sbit->red_bits,
                                   (unsigned int)16);
        px_0[1] = sample_to_target(px_0[1],depth,
                                   (unsigned int)sbit->green_bits,
                                   (unsigned int)16);
        px_0[2] = sample_to_target(px_0[2],depth,
                                   (unsigned int)sbit->blue_bits,
                                   (unsigned int)16);
        px_0[3] = sample_to_target(px_0[3],depth,
                                   (unsigned int)sbit->alpha_bits,
                                   (unsigned int)16);
        memcpy((void *)(row + i * (uint32_t)8),(void const *)(px_0),
               (size_t)8);
        i ++;
      }
    }
  return;
}

static int check_ihdr(struct spng_ihdr const *ihdr, uint32_t max_width,
                      uint32_t max_height)
{
  int __retres;
  if (ihdr->width > png_u32max) {
    __retres = SPNG_EWIDTH;
    goto return_label;
  }
  else 
    if (ihdr->width > max_width) {
      __retres = SPNG_EWIDTH;
      goto return_label;
    }
    else 
      if (! ihdr->width) {
        __retres = SPNG_EWIDTH;
        goto return_label;
      }
  if (ihdr->height > png_u32max) {
    __retres = SPNG_EHEIGHT;
    goto return_label;
  }
  else 
    if (ihdr->height > max_height) {
      __retres = SPNG_EHEIGHT;
      goto return_label;
    }
    else 
      if (! ihdr->height) {
        __retres = SPNG_EHEIGHT;
        goto return_label;
      }
  switch ((int)ihdr->color_type) {
    case SPNG_COLOR_TYPE_GRAYSCALE:
    {
      if (! ((int)ihdr->bit_depth == 1)) 
        if (! ((int)ihdr->bit_depth == 2)) 
          if (! ((int)ihdr->bit_depth == 4)) 
            if (! ((int)ihdr->bit_depth == 8)) 
              if (! ((int)ihdr->bit_depth == 16)) {
                __retres = SPNG_EBIT_DEPTH;
                goto return_label;
              }
      break;
    }
    case SPNG_COLOR_TYPE_TRUECOLOR: case SPNG_COLOR_TYPE_GRAYSCALE_ALPHA:
    case SPNG_COLOR_TYPE_TRUECOLOR_ALPHA:
    {
      if (! ((int)ihdr->bit_depth == 8)) 
        if (! ((int)ihdr->bit_depth == 16)) {
          __retres = SPNG_EBIT_DEPTH;
          goto return_label;
        }
      break;
    }
    case SPNG_COLOR_TYPE_INDEXED:
    {
      if (! ((int)ihdr->bit_depth == 1)) 
        if (! ((int)ihdr->bit_depth == 2)) 
          if (! ((int)ihdr->bit_depth == 4)) 
            if (! ((int)ihdr->bit_depth == 8)) {
              __retres = SPNG_EBIT_DEPTH;
              goto return_label;
            }
      break;
    }
    default: __retres = SPNG_ECOLOR_TYPE;
    goto return_label;
  }
  if (ihdr->compression_method) {
    __retres = SPNG_ECOMPRESSION_METHOD;
    goto return_label;
  }
  if (ihdr->filter_method) {
    __retres = SPNG_EFILTER_METHOD;
    goto return_label;
  }
  if (! ((int)ihdr->interlace_method == 0)) 
    if (! ((int)ihdr->interlace_method == 1)) {
      __retres = SPNG_EINTERLACE_METHOD;
      goto return_label;
    }
  __retres = 0;
  return_label: return __retres;
}

static int check_plte(struct spng_plte const *plte,
                      struct spng_ihdr const *ihdr)
{
  int __retres;
  if (plte == (struct spng_plte const *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (ihdr == (struct spng_ihdr const *)0) {
      __retres = 1;
      goto return_label;
    }
  if (plte->n_entries == (uint32_t)0) {
    __retres = 1;
    goto return_label;
  }
  if (plte->n_entries > (uint32_t)256) {
    __retres = 1;
    goto return_label;
  }
  if ((int)ihdr->color_type == SPNG_COLOR_TYPE_INDEXED) 
    if (plte->n_entries > 1U << (int)ihdr->bit_depth) {
      __retres = 1;
      goto return_label;
    }
  __retres = 0;
  return_label: return __retres;
}

static int check_sbit(struct spng_sbit const *sbit,
                      struct spng_ihdr const *ihdr)
{
  int __retres;
  if (sbit == (struct spng_sbit const *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (ihdr == (struct spng_ihdr const *)0) {
      __retres = 1;
      goto return_label;
    }
  if ((int)ihdr->color_type == 0) {
    if ((int)sbit->grayscale_bits == 0) {
      __retres = SPNG_ESBIT;
      goto return_label;
    }
    if ((int)sbit->grayscale_bits > (int)ihdr->bit_depth) {
      __retres = SPNG_ESBIT;
      goto return_label;
    }
  }
  else 
    if ((int)ihdr->color_type == 2) goto _LOR;
    else 
      if ((int)ihdr->color_type == 3) {
        _LOR:
        {
          uint8_t bit_depth;
          if ((int)sbit->red_bits == 0) {
            __retres = SPNG_ESBIT;
            goto return_label;
          }
          if ((int)sbit->green_bits == 0) {
            __retres = SPNG_ESBIT;
            goto return_label;
          }
          if ((int)sbit->blue_bits == 0) {
            __retres = SPNG_ESBIT;
            goto return_label;
          }
          if ((int)ihdr->color_type == 3) bit_depth = (uint8_t)8;
          else bit_depth = ihdr->bit_depth;
          if ((int)sbit->red_bits > (int)bit_depth) {
            __retres = SPNG_ESBIT;
            goto return_label;
          }
          if ((int)sbit->green_bits > (int)bit_depth) {
            __retres = SPNG_ESBIT;
            goto return_label;
          }
          if ((int)sbit->blue_bits > (int)bit_depth) {
            __retres = SPNG_ESBIT;
            goto return_label;
          }
        }
      }
      else 
        if ((int)ihdr->color_type == 4) {
          if ((int)sbit->grayscale_bits == 0) {
            __retres = SPNG_ESBIT;
            goto return_label;
          }
          if ((int)sbit->alpha_bits == 0) {
            __retres = SPNG_ESBIT;
            goto return_label;
          }
          if ((int)sbit->grayscale_bits > (int)ihdr->bit_depth) {
            __retres = SPNG_ESBIT;
            goto return_label;
          }
          if ((int)sbit->alpha_bits > (int)ihdr->bit_depth) {
            __retres = SPNG_ESBIT;
            goto return_label;
          }
        }
        else 
          if ((int)ihdr->color_type == 6) {
            if ((int)sbit->red_bits == 0) {
              __retres = SPNG_ESBIT;
              goto return_label;
            }
            if ((int)sbit->green_bits == 0) {
              __retres = SPNG_ESBIT;
              goto return_label;
            }
            if ((int)sbit->blue_bits == 0) {
              __retres = SPNG_ESBIT;
              goto return_label;
            }
            if ((int)sbit->alpha_bits == 0) {
              __retres = SPNG_ESBIT;
              goto return_label;
            }
            if ((int)sbit->red_bits > (int)ihdr->bit_depth) {
              __retres = SPNG_ESBIT;
              goto return_label;
            }
            if ((int)sbit->green_bits > (int)ihdr->bit_depth) {
              __retres = SPNG_ESBIT;
              goto return_label;
            }
            if ((int)sbit->blue_bits > (int)ihdr->bit_depth) {
              __retres = SPNG_ESBIT;
              goto return_label;
            }
            if ((int)sbit->alpha_bits > (int)ihdr->bit_depth) {
              __retres = SPNG_ESBIT;
              goto return_label;
            }
          }
  __retres = 0;
  return_label: return __retres;
}

static int check_chrm_int(struct spng_chrm_int const *chrm_int)
{
  int __retres;
  if (chrm_int == (struct spng_chrm_int const *)0) {
    __retres = 1;
    goto return_label;
  }
  if (chrm_int->white_point_x > png_u32max) {
    __retres = SPNG_ECHRM;
    goto return_label;
  }
  else 
    if (chrm_int->white_point_y > png_u32max) {
      __retres = SPNG_ECHRM;
      goto return_label;
    }
    else 
      if (chrm_int->red_x > png_u32max) {
        __retres = SPNG_ECHRM;
        goto return_label;
      }
      else 
        if (chrm_int->red_y > png_u32max) {
          __retres = SPNG_ECHRM;
          goto return_label;
        }
        else 
          if (chrm_int->green_x > png_u32max) {
            __retres = SPNG_ECHRM;
            goto return_label;
          }
          else 
            if (chrm_int->green_y > png_u32max) {
              __retres = SPNG_ECHRM;
              goto return_label;
            }
            else 
              if (chrm_int->blue_x > png_u32max) {
                __retres = SPNG_ECHRM;
                goto return_label;
              }
              else 
                if (chrm_int->blue_y > png_u32max) {
                  __retres = SPNG_ECHRM;
                  goto return_label;
                }
  __retres = 0;
  return_label: return __retres;
}

static int check_phys(struct spng_phys const *phys)
{
  int __retres;
  if (phys == (struct spng_phys const *)0) {
    __retres = 1;
    goto return_label;
  }
  if ((int)phys->unit_specifier > 1) {
    __retres = SPNG_EPHYS;
    goto return_label;
  }
  if (phys->ppu_x > png_u32max) {
    __retres = SPNG_EPHYS;
    goto return_label;
  }
  if (phys->ppu_y > png_u32max) {
    __retres = SPNG_EPHYS;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static int check_time(struct spng_time const *time)
{
  int __retres;
  if (time == (struct spng_time const *)0) {
    __retres = 1;
    goto return_label;
  }
  if ((int)time->month == 0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if ((int)time->month > 12) {
      __retres = 1;
      goto return_label;
    }
  if ((int)time->day == 0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if ((int)time->day > 31) {
      __retres = 1;
      goto return_label;
    }
  if ((int)time->hour > 23) {
    __retres = 1;
    goto return_label;
  }
  if ((int)time->minute > 59) {
    __retres = 1;
    goto return_label;
  }
  if ((int)time->second > 60) {
    __retres = 1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static int check_offs(struct spng_offs const *offs)
{
  int __retres;
  if (offs == (struct spng_offs const *)0) {
    __retres = 1;
    goto return_label;
  }
  if (offs->x < png_s32min) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (offs->y < png_s32min) {
      __retres = 1;
      goto return_label;
    }
  if ((int)offs->unit_specifier > 1) {
    __retres = 1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static int check_exif(struct spng_exif const *exif)
{
  int __retres;
  int tmp;
  if (exif == (struct spng_exif const *)0) {
    __retres = 1;
    goto return_label;
  }
  if (exif->length < (size_t)4) {
    __retres = SPNG_ECHUNK_SIZE;
    goto return_label;
  }
  if (exif->length > png_u32max) {
    __retres = SPNG_ECHUNK_SIZE;
    goto return_label;
  }
  uint8_t const exif_le[4] =
    {(uint8_t)73, (uint8_t)73, (uint8_t)42, (uint8_t)0};
  uint8_t const exif_be[4] =
    {(uint8_t)77, (uint8_t)77, (uint8_t)0, (uint8_t)42};
  tmp = memcmp((void const *)exif->data,(void const *)(exif_le),(size_t)4);
  if (tmp) {
    int tmp_0;
    tmp_0 = memcmp((void const *)exif->data,(void const *)(exif_be),
                   (size_t)4);
    if (tmp_0) {
      __retres = 1;
      goto return_label;
    }
  }
  __retres = 0;
  return_label: return __retres;
}

static int check_png_keyword(char const str[80])
{
  int __retres;
  char *tmp_0;
  uint8_t c;
  if (str == (char const *)0) {
    __retres = 1;
    goto return_label;
  }
  char *end = memchr((void const *)str,'\000',(size_t)80);
  if (end == (char *)0) {
    __retres = 1;
    goto return_label;
  }
  if ((void *)end == (void *)str) {
    __retres = 1;
    goto return_label;
  }
  if ((int)*(str + 0) == ' ') {
    __retres = 1;
    goto return_label;
  }
  if ((int)*(end + -1) == ' ') {
    __retres = 1;
    goto return_label;
  }
  tmp_0 = strstr(str,"  ");
  if (tmp_0 != (char *)0) {
    __retres = 1;
    goto return_label;
  }
  while ((void *)str != (void *)end) {
    memcpy((void *)(& c),(void const *)str,(size_t)1);
    if ((int)c >= 32) {
      if ((int)c <= 126) str ++; else goto _LAND;
    }
    else {
      _LAND: ;
      if ((int)c >= 161) str ++;
      else {
        __retres = 1;
        goto return_label;
      }
    }
  }
  __retres = 0;
  return_label: return __retres;
}

static int check_png_text(char const *str, size_t len)
{
  int __retres;
  uint8_t c;
  if (str == (char const *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (len == (size_t)0) {
      __retres = 1;
      goto return_label;
    }
  size_t i = (size_t)0;
  while (i < len) {
    memcpy((void *)(& c),(void const *)(str + i),(size_t)1);
    if ((int)c >= 32) {
      if ((int)c <= 126) i ++; else goto _LAND;
    }
    else {
      _LAND: ;
      if ((int)c >= 161) i ++;
      else 
        if ((int)c == 10) i ++;
        else {
          __retres = 1;
          goto return_label;
        }
    }
  }
  __retres = 0;
  return_label: return __retres;
}

static int chunk_fits_in_cache(spng_ctx *ctx, size_t *new_usage)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 0;
    goto return_label;
  }
  else 
    if (new_usage == (size_t *)0) {
      __retres = 0;
      goto return_label;
    }
  size_t usage = ctx->chunk_cache_usage + ctx->current_chunk.length;
  if (usage < ctx->chunk_cache_usage) {
    __retres = 0;
    goto return_label;
  }
  if (usage > ctx->chunk_cache_limit) {
    __retres = 0;
    goto return_label;
  }
  *new_usage = usage;
  __retres = 1;
  return_label: return __retres;
}

static int read_chunks_before_idat(spng_ctx *ctx)
{
  int __retres;
  int ret;
  unsigned char const *data;
  struct spng_chunk chunk;
  int tmp;
  int tmp_0;
  struct spng_chunk_bitfield stored;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  if (ctx->data == (unsigned char const *)0) {
    __retres = 1;
    goto return_label;
  }
  if (! ctx->valid_state) {
    __retres = SPNG_EBADSTATE;
    goto return_label;
  }
  if (ctx->first_idat.offset) {
    __retres = 0;
    goto return_label;
  }
  int discard = 0;
  chunk.offset = (size_t)8;
  chunk.length = (uint32_t)13;
  size_t sizeof_sig_ihdr = (size_t)29;
  ret = read_data(ctx,sizeof_sig_ihdr);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  data = ctx->data;
  uint8_t signature[8] =
    {(uint8_t)137,
     (uint8_t)80,
     (uint8_t)78,
     (uint8_t)71,
     (uint8_t)13,
     (uint8_t)10,
     (uint8_t)26,
     (uint8_t)10};
  tmp = memcmp((void const *)data,(void const *)(signature),
               sizeof(signature));
  if (tmp) {
    __retres = SPNG_ESIGNATURE;
    goto return_label;
  }
  chunk.length = read_u32((void const *)(data + 8));
  memcpy((void *)(& chunk.type),(void const *)(data + 12),(size_t)4);
  if (chunk.length != (uint32_t)13) {
    __retres = SPNG_EIHDR_SIZE;
    goto return_label;
  }
  tmp_0 = memcmp((void const *)(chunk.type),(void const *)(type_ihdr),
                 (size_t)4);
  if (tmp_0) {
    __retres = SPNG_ENOIHDR;
    goto return_label;
  }
  ctx->cur_actual_crc = (uint32_t)crc32((unsigned long)0,(unsigned char *)0,
                                        (unsigned int)0);
  ctx->cur_actual_crc = (uint32_t)crc32((unsigned long)ctx->cur_actual_crc,
                                        (unsigned char *)(data + 12),
                                        (unsigned int)17);
  ctx->ihdr.width = read_u32((void const *)(data + 16));
  ctx->ihdr.height = read_u32((void const *)(data + 20));
  memcpy((void *)(& ctx->ihdr.bit_depth),(void const *)(data + 24),(size_t)1);
  memcpy((void *)(& ctx->ihdr.color_type),(void const *)(data + 25),
         (size_t)1);
  memcpy((void *)(& ctx->ihdr.compression_method),(void const *)(data + 26),
         (size_t)1);
  memcpy((void *)(& ctx->ihdr.filter_method),(void const *)(data + 27),
         (size_t)1);
  memcpy((void *)(& ctx->ihdr.interlace_method),(void const *)(data + 28),
         (size_t)1);
  if (! ctx->max_width) ctx->max_width = png_u32max;
  if (! ctx->max_height) ctx->max_height = png_u32max;
  ret = check_ihdr((struct spng_ihdr const *)(& ctx->ihdr),ctx->max_width,
                   ctx->max_height);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  ctx->file.ihdr = (unsigned int)1;
  ctx->stored.ihdr = (unsigned int)1;
  memcpy((void *)(& stored),(void const *)(& ctx->stored),
         sizeof(struct spng_chunk_bitfield));
  while (1) {
    ret = read_header(ctx,& discard);
    if (ret) break;
    {
      int tmp_1;
      int tmp_2;
      int tmp_42;
      if (discard) memcpy((void *)(& ctx->stored),(void const *)(& stored),
                          sizeof(struct spng_chunk_bitfield));
      memcpy((void *)(& stored),(void const *)(& ctx->stored),
             sizeof(struct spng_chunk_bitfield));
      memcpy((void *)(& chunk),(void const *)(& ctx->current_chunk),
             sizeof(struct spng_chunk));
      tmp_1 = memcmp((void const *)(chunk.type),(void const *)(type_idat),
                     (size_t)4);
      if (! tmp_1) {
        memcpy((void *)(& ctx->first_idat),(void const *)(& chunk),
               sizeof(struct spng_chunk));
        __retres = 0;
        goto return_label;
      }
      tmp_2 = chunk_fits_in_cache(ctx,& ctx->chunk_cache_usage);
      if (! tmp_2) {
        ret = discard_chunk_bytes(ctx,chunk.length);
        if (ret) {
          __retres = ret;
          goto return_label;
        }
        continue;
      }
      ret = read_chunk_bytes(ctx,chunk.length);
      if (ret) {
        __retres = ret;
        goto return_label;
      }
      data = ctx->data;
      tmp_42 = is_critical_chunk(& chunk);
      if (tmp_42) {
        int tmp_6;
        tmp_6 = memcmp((void const *)(chunk.type),(void const *)(type_plte),
                       (size_t)4);
        if (tmp_6) {
          int tmp_5;
          tmp_5 = memcmp((void const *)(chunk.type),
                         (void const *)(type_iend),(size_t)4);
          if (tmp_5) {
            int tmp_4;
            tmp_4 = memcmp((void const *)(chunk.type),
                           (void const *)(type_ihdr),(size_t)4);
            if (tmp_4) {
              __retres = SPNG_ECHUNK_UNKNOWN_CRITICAL;
              goto return_label;
            }
            else {
              __retres = SPNG_ECHUNK_POS;
              goto return_label;
            }
          }
          else {
            __retres = SPNG_ECHUNK_POS;
            goto return_label;
          }
        }
        else {
          int tmp_3;
          size_t i;
          if (chunk.length % (unsigned int)3 != (unsigned int)0) {
            __retres = SPNG_ECHUNK_SIZE;
            goto return_label;
          }
          ctx->plte.n_entries = chunk.length / (uint32_t)3;
          tmp_3 = check_plte((struct spng_plte const *)(& ctx->plte),
                             (struct spng_ihdr const *)(& ctx->ihdr));
          if (tmp_3) {
            __retres = SPNG_ECHUNK_SIZE;
            goto return_label;
          }
          i = (size_t)0;
          while (i < ctx->plte.n_entries) {
            memcpy((void *)(& ctx->plte.entries[i].red),
                   (void const *)(data + i * (size_t)3),(size_t)1);
            memcpy((void *)(& ctx->plte.entries[i].green),
                   (void const *)((data + i * (size_t)3) + 1),(size_t)1);
            memcpy((void *)(& ctx->plte.entries[i].blue),
                   (void const *)((data + i * (size_t)3) + 2),(size_t)1);
            i ++;
          }
          ctx->plte_offset = chunk.offset;
          ctx->file.plte = (unsigned int)1;
        }
      }
      else {
        int tmp_41;
        tmp_41 = memcmp((void const *)(chunk.type),(void const *)(type_chrm),
                        (size_t)4);
        if (tmp_41) {
          int tmp_40;
          tmp_40 = memcmp((void const *)(chunk.type),
                          (void const *)(type_gama),(size_t)4);
          if (tmp_40) {
            int tmp_39;
            tmp_39 = memcmp((void const *)(chunk.type),
                            (void const *)(type_iccp),(size_t)4);
            if (tmp_39) {
              int tmp_38;
              tmp_38 = memcmp((void const *)(chunk.type),
                              (void const *)(type_sbit),(size_t)4);
              if (tmp_38) {
                int tmp_37;
                tmp_37 = memcmp((void const *)(chunk.type),
                                (void const *)(type_srgb),(size_t)4);
                if (tmp_37) {
                  int tmp_36;
                  tmp_36 = memcmp((void const *)(chunk.type),
                                  (void const *)(type_bkgd),(size_t)4);
                  if (tmp_36) {
                    int tmp_35;
                    tmp_35 = memcmp((void const *)(chunk.type),
                                    (void const *)(type_trns),(size_t)4);
                    if (tmp_35) {
                      int tmp_34;
                      tmp_34 = memcmp((void const *)(chunk.type),
                                      (void const *)(type_hist),(size_t)4);
                      if (tmp_34) {
                        int tmp_33;
                        tmp_33 = memcmp((void const *)(chunk.type),
                                        (void const *)(type_phys),(size_t)4);
                        if (tmp_33) {
                          int tmp_32;
                          tmp_32 = memcmp((void const *)(chunk.type),
                                          (void const *)(type_time),
                                          (size_t)4);
                          if (tmp_32) {
                            int tmp_31;
                            tmp_31 = memcmp((void const *)(chunk.type),
                                            (void const *)(type_offs),
                                            (size_t)4);
                            if (tmp_31) {
                              int tmp_30;
                              tmp_30 = memcmp((void const *)(chunk.type),
                                              (void const *)(type_splt),
                                              (size_t)4);
                              if (tmp_30) {
                                int tmp_27;
                                tmp_27 = memcmp((void const *)(chunk.type),
                                                (void const *)(type_text),
                                                (size_t)4);
                                if (tmp_27) {
                                  int tmp_28;
                                  tmp_28 = memcmp((void const *)(chunk.type),
                                                  (void const *)(type_ztxt),
                                                  (size_t)4);
                                  if (tmp_28) {
                                    int tmp_29;
                                    tmp_29 = memcmp((void const *)(chunk.type),
                                                    (void const *)(type_itxt),
                                                    (size_t)4);
                                    if (tmp_29) {
                                      int tmp_26;
                                      tmp_26 = memcmp((void const *)(chunk.type),
                                                      (void const *)(type_exif),
                                                      (size_t)4);
                                      if (! tmp_26) {
                                        struct spng_exif exif;
                                        int tmp_25;
                                        if (ctx->file.exif) {
                                          __retres = SPNG_EDUP_EXIF;
                                          goto return_label;
                                        }
                                        ctx->file.exif = (unsigned int)1;
                                        if (! chunk.length) {
                                          __retres = SPNG_EEXIF;
                                          goto return_label;
                                        }
                                        exif.data = (char *)spng__malloc
                                        (ctx,chunk.length);
                                        if (exif.data == (char *)0) {
                                          __retres = SPNG_EMEM;
                                          goto return_label;
                                        }
                                        memcpy((void *)exif.data,
                                               (void const *)data,
                                               chunk.length);
                                        exif.length = chunk.length;
                                        tmp_25 = check_exif((struct spng_exif const *)(& exif));
                                        if (tmp_25) {
                                          spng__free(ctx,(void *)exif.data);
                                          __retres = SPNG_EEXIF;
                                          goto return_label;
                                        }
                                        if (! ctx->user.exif) memcpy((void *)(& ctx->exif),
                                                                    (void const *)(& exif),
                                                                    sizeof(struct spng_exif));
                                        else spng__free(ctx,
                                                        (void *)exif.data);
                                        ctx->stored.exif = (unsigned int)1;
                                      }
                                    }
                                    else {
                                      _LOR_2:
                                      {
                                        ctx->file.text = (unsigned int)1;
                                        continue;
                                      }
                                    }
                                  }
                                  else goto _LOR_2;
                                }
                                else goto _LOR_2;
                              }
                              else {
                                uint32_t tmp_21;
                                int tmp_23;
                                size_t k_1;
                                if (ctx->user.splt) continue;
                                if (! chunk.length) {
                                  __retres = SPNG_ECHUNK_SIZE;
                                  goto return_label;
                                }
                                ctx->file.splt = (unsigned int)1;
                                if (! ctx->stored.splt) {
                                  ctx->n_splt = (uint32_t)1;
                                  ctx->splt_list = (struct spng_splt *)spng__calloc
                                  (ctx,(size_t)1,sizeof(struct spng_splt));
                                  if (ctx->splt_list == (struct spng_splt *)0) {
                                    __retres = SPNG_EMEM;
                                    goto return_label;
                                  }
                                }
                                else {
                                  (ctx->n_splt) ++;
                                  if (ctx->n_splt < (uint32_t)1) {
                                    __retres = SPNG_EOVERFLOW;
                                    goto return_label;
                                  }
                                  if (sizeof(struct spng_splt) > 4294967295U / ctx->n_splt) {
                                    __retres = SPNG_EOVERFLOW;
                                    goto return_label;
                                  }
                                  void *buf =
                                    spng__realloc(ctx,(void *)ctx->splt_list,
                                                  ctx->n_splt * sizeof(struct spng_splt));
                                  if (buf == (void *)0) {
                                    __retres = SPNG_EMEM;
                                    goto return_label;
                                  }
                                  ctx->splt_list = (struct spng_splt *)buf;
                                  memset((void *)(ctx->splt_list + (ctx->n_splt - (uint32_t)1)),
                                         0,sizeof(struct spng_splt));
                                }
                                uint32_t i_0 = ctx->n_splt - (uint32_t)1;
                                if (chunk.length > (uint32_t)80) tmp_21 = (uint32_t)80;
                                else tmp_21 = chunk.length;
                                size_t keyword_len = tmp_21;
                                char *keyword_nul =
                                  memchr((void const *)data,'\000',
                                         keyword_len);
                                if (keyword_nul == (char *)0) {
                                  __retres = SPNG_ESPLT_NAME;
                                  goto return_label;
                                }
                                memcpy((void *)(& (ctx->splt_list + i_0)->name),
                                       (void const *)data,keyword_len);
                                tmp_23 = check_png_keyword((char const *)((
                                                           ctx->splt_list + i_0)->name));
                                if (tmp_23) {
                                  __retres = SPNG_ESPLT_NAME;
                                  goto return_label;
                                }
                                keyword_len = strlen((char const *)((
                                                     ctx->splt_list + i_0)->name));
                                if ((chunk.length - keyword_len) - (uint32_t)1 == (uint32_t)0) {
                                  __retres = SPNG_ECHUNK_SIZE;
                                  goto return_label;
                                }
                                memcpy((void *)(& (ctx->splt_list + i_0)->sample_depth),
                                       (void const *)((data + keyword_len) + 1),
                                       (size_t)1);
                                if (ctx->n_splt > (uint32_t)1) {
                                  uint32_t j;
                                  j = (uint32_t)0;
                                  while (j < i_0) {
                                    {
                                      int tmp_24;
                                      tmp_24 = strcmp((char const *)((
                                                      ctx->splt_list + j)->name),
                                                      (char const *)((
                                                      ctx->splt_list + i_0)->name));
                                      if (! tmp_24) {
                                        __retres = SPNG_ESPLT_DUP_NAME;
                                        goto return_label;
                                      }
                                    }
                                    j ++;
                                  }
                                }
                                if ((int)(ctx->splt_list + i_0)->sample_depth == 16) {
                                  if (((chunk.length - keyword_len) - (uint32_t)2) % (unsigned int)10 != (unsigned int)0) {
                                    __retres = SPNG_ECHUNK_SIZE;
                                    goto return_label;
                                  }
                                  (ctx->splt_list + i_0)->n_entries = 
                                  ((chunk.length - keyword_len) - (uint32_t)2) / (uint32_t)10;
                                }
                                else 
                                  if ((int)(ctx->splt_list + i_0)->sample_depth == 8) {
                                    if (((chunk.length - keyword_len) - (uint32_t)2) % (unsigned int)6 != (unsigned int)0) {
                                      __retres = SPNG_ECHUNK_SIZE;
                                      goto return_label;
                                    }
                                    (ctx->splt_list + i_0)->n_entries = 
                                    ((chunk.length - keyword_len) - (uint32_t)2) / (uint32_t)6;
                                  }
                                  else {
                                    __retres = SPNG_ESPLT_DEPTH;
                                    goto return_label;
                                  }
                                if ((ctx->splt_list + i_0)->n_entries == (uint32_t)0) {
                                  __retres = SPNG_ECHUNK_SIZE;
                                  goto return_label;
                                }
                                if (sizeof(struct spng_splt_entry) > 
                                    4294967295U / (ctx->splt_list + i_0)->n_entries) {
                                  __retres = SPNG_EOVERFLOW;
                                  goto return_label;
                                }
                                (ctx->splt_list + i_0)->entries = (struct spng_splt_entry *)spng__malloc
                                (ctx,
                                 sizeof(struct spng_splt_entry) * (ctx->splt_list + i_0)->n_entries);
                                if ((ctx->splt_list + i_0)->entries == (struct spng_splt_entry *)0) {
                                  __retres = SPNG_EMEM;
                                  goto return_label;
                                }
                                unsigned char const *splt =
                                  (data + keyword_len) + 2;
                                if ((int)(ctx->splt_list + i_0)->sample_depth == 16) {
                                  k_1 = (size_t)0;
                                  while (k_1 < (ctx->splt_list + i_0)->n_entries) {
                                    ((ctx->splt_list + i_0)->entries + k_1)->red = read_u16
                                    ((void const *)(splt + k_1 * (size_t)10));
                                    ((ctx->splt_list + i_0)->entries + k_1)->green = read_u16
                                    ((void const *)((splt + k_1 * (size_t)10) + 2));
                                    ((ctx->splt_list + i_0)->entries + k_1)->blue = read_u16
                                    ((void const *)((splt + k_1 * (size_t)10) + 4));
                                    ((ctx->splt_list + i_0)->entries + k_1)->alpha = read_u16
                                    ((void const *)((splt + k_1 * (size_t)10) + 6));
                                    ((ctx->splt_list + i_0)->entries + k_1)->frequency = read_u16
                                    ((void const *)((splt + k_1 * (size_t)10) + 8));
                                    k_1 ++;
                                  }
                                }
                                else 
                                  if ((int)(ctx->splt_list + i_0)->sample_depth == 8) {
                                    k_1 = (size_t)0;
                                    while (k_1 < (ctx->splt_list + i_0)->n_entries) {
                                      {
                                        uint8_t red;
                                        uint8_t green;
                                        uint8_t blue;
                                        uint8_t alpha;
                                        memcpy((void *)(& red),
                                               (void const *)(splt + 
                                                              k_1 * (size_t)6),
                                               (size_t)1);
                                        memcpy((void *)(& green),
                                               (void const *)((splt + 
                                                               k_1 * (size_t)6) + 1),
                                               (size_t)1);
                                        memcpy((void *)(& blue),
                                               (void const *)((splt + 
                                                               k_1 * (size_t)6) + 2),
                                               (size_t)1);
                                        memcpy((void *)(& alpha),
                                               (void const *)((splt + 
                                                               k_1 * (size_t)6) + 3),
                                               (size_t)1);
                                        ((ctx->splt_list + i_0)->entries + k_1)->frequency = read_u16
                                        ((void const *)((splt + k_1 * (size_t)6) + 4));
                                        ((ctx->splt_list + i_0)->entries + k_1)->red = (uint16_t)red;
                                        ((ctx->splt_list + i_0)->entries + k_1)->green = (uint16_t)green;
                                        ((ctx->splt_list + i_0)->entries + k_1)->blue = (uint16_t)blue;
                                        ((ctx->splt_list + i_0)->entries + k_1)->alpha = (uint16_t)alpha;
                                      }
                                      k_1 ++;
                                    }
                                  }
                                ctx->stored.splt = (unsigned int)1;
                              }
                            }
                            else {
                              int tmp_19;
                              if (ctx->file.offs) {
                                __retres = SPNG_EDUP_OFFS;
                                goto return_label;
                              }
                              if (chunk.length != (uint32_t)9) {
                                __retres = SPNG_ECHUNK_SIZE;
                                goto return_label;
                              }
                              ctx->offs.x = read_s32((void const *)data);
                              ctx->offs.y = read_s32((void const *)(data + 4));
                              memcpy((void *)(& ctx->offs.unit_specifier),
                                     (void const *)(data + 8),(size_t)1);
                              tmp_19 = check_offs((struct spng_offs const *)(& ctx->offs));
                              if (tmp_19) {
                                __retres = SPNG_EOFFS;
                                goto return_label;
                              }
                              ctx->file.offs = (unsigned int)1;
                              ctx->stored.offs = (unsigned int)1;
                            }
                          }
                          else {
                            struct spng_time time;
                            int tmp_18;
                            if (ctx->file.time) {
                              __retres = SPNG_EDUP_TIME;
                              goto return_label;
                            }
                            if (chunk.length != (uint32_t)7) {
                              __retres = SPNG_ECHUNK_SIZE;
                              goto return_label;
                            }
                            time.year = read_u16((void const *)data);
                            memcpy((void *)(& time.month),
                                   (void const *)(data + 2),(size_t)1);
                            memcpy((void *)(& time.day),
                                   (void const *)(data + 3),(size_t)1);
                            memcpy((void *)(& time.hour),
                                   (void const *)(data + 4),(size_t)1);
                            memcpy((void *)(& time.minute),
                                   (void const *)(data + 5),(size_t)1);
                            memcpy((void *)(& time.second),
                                   (void const *)(data + 6),(size_t)1);
                            tmp_18 = check_time((struct spng_time const *)(& time));
                            if (tmp_18) {
                              __retres = SPNG_ETIME;
                              goto return_label;
                            }
                            ctx->file.time = (unsigned int)1;
                            if (! ctx->user.time) memcpy((void *)(& ctx->time),
                                                         (void const *)(& time),
                                                         sizeof(struct spng_time));
                            ctx->stored.time = (unsigned int)1;
                          }
                        }
                        else {
                          int tmp_17;
                          if (ctx->file.phys) {
                            __retres = SPNG_EDUP_PHYS;
                            goto return_label;
                          }
                          if (chunk.length != (uint32_t)9) {
                            __retres = SPNG_ECHUNK_SIZE;
                            goto return_label;
                          }
                          ctx->phys.ppu_x = read_u32((void const *)data);
                          ctx->phys.ppu_y = read_u32((void const *)(data + 4));
                          memcpy((void *)(& ctx->phys.unit_specifier),
                                 (void const *)(data + 8),(size_t)1);
                          tmp_17 = check_phys((struct spng_phys const *)(& ctx->phys));
                          if (tmp_17) {
                            __retres = SPNG_EPHYS;
                            goto return_label;
                          }
                          ctx->file.phys = (unsigned int)1;
                          ctx->stored.phys = (unsigned int)1;
                        }
                      }
                      else {
                        size_t k_0;
                        if (! ctx->file.plte) {
                          __retres = SPNG_EHIST_NO_PLTE;
                          goto return_label;
                        }
                        if (chunk.offset < ctx->plte_offset) {
                          __retres = SPNG_ECHUNK_POS;
                          goto return_label;
                        }
                        if (ctx->file.hist) {
                          __retres = SPNG_EDUP_HIST;
                          goto return_label;
                        }
                        if (chunk.length / (uint32_t)2 != ctx->plte.n_entries) {
                          __retres = SPNG_ECHUNK_SIZE;
                          goto return_label;
                        }
                        k_0 = (size_t)0;
                        while (k_0 < chunk.length / (uint32_t)2) {
                          ctx->hist.frequency[k_0] = read_u16((void const *)(
                                                              data + 
                                                              k_0 * (size_t)2));
                          k_0 ++;
                        }
                        ctx->file.hist = (unsigned int)1;
                        ctx->stored.hist = (unsigned int)1;
                      }
                    }
                    else {
                      if (ctx->file.plte) 
                        if (chunk.offset < ctx->plte_offset) {
                          __retres = SPNG_ECHUNK_POS;
                          goto return_label;
                        }
                      if (ctx->file.trns) {
                        __retres = SPNG_EDUP_TRNS;
                        goto return_label;
                      }
                      if (! chunk.length) {
                        __retres = SPNG_ECHUNK_SIZE;
                        goto return_label;
                      }
                      uint16_t mask_0 = (uint16_t)(~ 0);
                      if ((int)ctx->ihdr.bit_depth < 16) mask_0 = (uint16_t)(
                                                         (1 << (int)ctx->ihdr.bit_depth) - 1);
                      if ((int)ctx->ihdr.color_type == 0) {
                        uint16_t tmp_13;
                        if (chunk.length != (uint32_t)2) {
                          __retres = SPNG_ECHUNK_SIZE;
                          goto return_label;
                        }
                        tmp_13 = read_u16((void const *)data);
                        ctx->trns.gray = (uint16_t)((int)tmp_13 & (int)mask_0);
                      }
                      else 
                        if ((int)ctx->ihdr.color_type == 2) {
                          uint16_t tmp_14;
                          uint16_t tmp_15;
                          uint16_t tmp_16;
                          if (chunk.length != (uint32_t)6) {
                            __retres = SPNG_ECHUNK_SIZE;
                            goto return_label;
                          }
                          tmp_14 = read_u16((void const *)data);
                          ctx->trns.red = (uint16_t)((int)tmp_14 & (int)mask_0);
                          tmp_15 = read_u16((void const *)(data + 2));
                          ctx->trns.green = (uint16_t)((int)tmp_15 & (int)mask_0);
                          tmp_16 = read_u16((void const *)(data + 4));
                          ctx->trns.blue = (uint16_t)((int)tmp_16 & (int)mask_0);
                        }
                        else 
                          if ((int)ctx->ihdr.color_type == 3) {
                            size_t k;
                            if (chunk.length > ctx->plte.n_entries) {
                              __retres = SPNG_ECHUNK_SIZE;
                              goto return_label;
                            }
                            if (! ctx->file.plte) {
                              __retres = SPNG_ETRNS_NO_PLTE;
                              goto return_label;
                            }
                            k = (size_t)0;
                            while (k < chunk.length) {
                              memcpy((void *)(& ctx->trns.type3_alpha[k]),
                                     (void const *)(data + k),(size_t)1);
                              k ++;
                            }
                            ctx->trns.n_type3_entries = chunk.length;
                          }
                          else {
                            __retres = SPNG_ETRNS_COLOR_TYPE;
                            goto return_label;
                          }
                      ctx->file.trns = (unsigned int)1;
                      ctx->stored.trns = (unsigned int)1;
                    }
                  }
                  else {
                    if (ctx->file.plte) 
                      if (chunk.offset < ctx->plte_offset) {
                        __retres = SPNG_ECHUNK_POS;
                        goto return_label;
                      }
                    if (ctx->file.bkgd) {
                      __retres = SPNG_EDUP_BKGD;
                      goto return_label;
                    }
                    uint16_t mask = (uint16_t)(~ 0);
                    if ((int)ctx->ihdr.bit_depth < 16) mask = (uint16_t)(
                                                       (1 << (int)ctx->ihdr.bit_depth) - 1);
                    if ((int)ctx->ihdr.color_type == 0) goto _LOR_1;
                    else 
                      if ((int)ctx->ihdr.color_type == 4) {
                        _LOR_1:
                        {
                          uint16_t tmp_9;
                          if (chunk.length != (uint32_t)2) {
                            __retres = SPNG_ECHUNK_SIZE;
                            goto return_label;
                          }
                          tmp_9 = read_u16((void const *)data);
                          ctx->bkgd.gray = (uint16_t)((int)tmp_9 & (int)mask);
                        }
                      }
                      else 
                        if ((int)ctx->ihdr.color_type == 2) goto _LOR_0;
                        else 
                          if ((int)ctx->ihdr.color_type == 6) {
                            _LOR_0:
                            {
                              uint16_t tmp_10;
                              uint16_t tmp_11;
                              uint16_t tmp_12;
                              if (chunk.length != (uint32_t)6) {
                                __retres = SPNG_ECHUNK_SIZE;
                                goto return_label;
                              }
                              tmp_10 = read_u16((void const *)data);
                              ctx->bkgd.red = (uint16_t)((int)tmp_10 & (int)mask);
                              tmp_11 = read_u16((void const *)(data + 2));
                              ctx->bkgd.green = (uint16_t)((int)tmp_11 & (int)mask);
                              tmp_12 = read_u16((void const *)(data + 4));
                              ctx->bkgd.blue = (uint16_t)((int)tmp_12 & (int)mask);
                            }
                          }
                          else 
                            if ((int)ctx->ihdr.color_type == 3) {
                              if (chunk.length != (uint32_t)1) {
                                __retres = SPNG_ECHUNK_SIZE;
                                goto return_label;
                              }
                              if (! ctx->file.plte) {
                                __retres = SPNG_EBKGD_NO_PLTE;
                                goto return_label;
                              }
                              memcpy((void *)(& ctx->bkgd.plte_index),
                                     (void const *)data,(size_t)1);
                              if ((uint32_t)ctx->bkgd.plte_index >= ctx->plte.n_entries) {
                                __retres = SPNG_EBKGD_PLTE_IDX;
                                goto return_label;
                              }
                            }
                    ctx->file.bkgd = (unsigned int)1;
                    ctx->stored.bkgd = (unsigned int)1;
                  }
                }
                else {
                  if (ctx->file.plte) 
                    if (chunk.offset > ctx->plte_offset) {
                      __retres = SPNG_ECHUNK_POS;
                      goto return_label;
                    }
                  if (ctx->file.srgb) {
                    __retres = SPNG_EDUP_SRGB;
                    goto return_label;
                  }
                  if (chunk.length != (uint32_t)1) {
                    __retres = SPNG_ECHUNK_SIZE;
                    goto return_label;
                  }
                  memcpy((void *)(& ctx->srgb_rendering_intent),
                         (void const *)data,(size_t)1);
                  if ((int)ctx->srgb_rendering_intent > 3) {
                    __retres = SPNG_ESRGB;
                    goto return_label;
                  }
                  ctx->file.srgb = (unsigned int)1;
                  ctx->stored.srgb = (unsigned int)1;
                }
              }
              else {
                int tmp_8;
                if (ctx->file.plte) 
                  if (chunk.offset > ctx->plte_offset) {
                    __retres = SPNG_ECHUNK_POS;
                    goto return_label;
                  }
                if (ctx->file.sbit) {
                  __retres = SPNG_EDUP_SBIT;
                  goto return_label;
                }
                if ((int)ctx->ihdr.color_type == 0) {
                  if (chunk.length != (uint32_t)1) {
                    __retres = SPNG_ECHUNK_SIZE;
                    goto return_label;
                  }
                  memcpy((void *)(& ctx->sbit.grayscale_bits),
                         (void const *)data,(size_t)1);
                }
                else 
                  if ((int)ctx->ihdr.color_type == 2) goto _LOR;
                  else 
                    if ((int)ctx->ihdr.color_type == 3) {
                      _LOR:
                      {
                        if (chunk.length != (uint32_t)3) {
                          __retres = SPNG_ECHUNK_SIZE;
                          goto return_label;
                        }
                        memcpy((void *)(& ctx->sbit.red_bits),
                               (void const *)data,(size_t)1);
                        memcpy((void *)(& ctx->sbit.green_bits),
                               (void const *)(data + 1),(size_t)1);
                        memcpy((void *)(& ctx->sbit.blue_bits),
                               (void const *)(data + 2),(size_t)1);
                      }
                    }
                    else 
                      if ((int)ctx->ihdr.color_type == 4) {
                        if (chunk.length != (uint32_t)2) {
                          __retres = SPNG_ECHUNK_SIZE;
                          goto return_label;
                        }
                        memcpy((void *)(& ctx->sbit.grayscale_bits),
                               (void const *)data,(size_t)1);
                        memcpy((void *)(& ctx->sbit.alpha_bits),
                               (void const *)(data + 1),(size_t)1);
                      }
                      else 
                        if ((int)ctx->ihdr.color_type == 6) {
                          if (chunk.length != (uint32_t)4) {
                            __retres = SPNG_ECHUNK_SIZE;
                            goto return_label;
                          }
                          memcpy((void *)(& ctx->sbit.red_bits),
                                 (void const *)data,(size_t)1);
                          memcpy((void *)(& ctx->sbit.green_bits),
                                 (void const *)(data + 1),(size_t)1);
                          memcpy((void *)(& ctx->sbit.blue_bits),
                                 (void const *)(data + 2),(size_t)1);
                          memcpy((void *)(& ctx->sbit.alpha_bits),
                                 (void const *)(data + 3),(size_t)1);
                        }
                tmp_8 = check_sbit((struct spng_sbit const *)(& ctx->sbit),
                                   (struct spng_ihdr const *)(& ctx->ihdr));
                if (tmp_8) {
                  __retres = SPNG_ESBIT;
                  goto return_label;
                }
                ctx->file.sbit = (unsigned int)1;
                ctx->stored.sbit = (unsigned int)1;
              }
            }
            else {
              if (ctx->file.plte) 
                if (chunk.offset > ctx->plte_offset) {
                  __retres = SPNG_ECHUNK_POS;
                  goto return_label;
                }
              if (ctx->file.iccp) {
                __retres = SPNG_EDUP_ICCP;
                goto return_label;
              }
              if (! chunk.length) {
                __retres = SPNG_ECHUNK_SIZE;
                goto return_label;
              }
              continue;
            }
          }
          else {
            if (ctx->file.plte) 
              if (chunk.offset > ctx->plte_offset) {
                __retres = SPNG_ECHUNK_POS;
                goto return_label;
              }
            if (ctx->file.gama) {
              __retres = SPNG_EDUP_GAMA;
              goto return_label;
            }
            if (chunk.length != (uint32_t)4) {
              __retres = SPNG_ECHUNK_SIZE;
              goto return_label;
            }
            ctx->gama = read_u32((void const *)data);
            if (! ctx->gama) {
              __retres = SPNG_EGAMA;
              goto return_label;
            }
            if (ctx->gama > png_u32max) {
              __retres = SPNG_EGAMA;
              goto return_label;
            }
            ctx->file.gama = (unsigned int)1;
            ctx->stored.gama = (unsigned int)1;
          }
        }
        else {
          int tmp_7;
          if (ctx->file.plte) 
            if (chunk.offset > ctx->plte_offset) {
              __retres = SPNG_ECHUNK_POS;
              goto return_label;
            }
          if (ctx->file.chrm) {
            __retres = SPNG_EDUP_CHRM;
            goto return_label;
          }
          if (chunk.length != (uint32_t)32) {
            __retres = SPNG_ECHUNK_SIZE;
            goto return_label;
          }
          ctx->chrm_int.white_point_x = read_u32((void const *)data);
          ctx->chrm_int.white_point_y = read_u32((void const *)(data + 4));
          ctx->chrm_int.red_x = read_u32((void const *)(data + 8));
          ctx->chrm_int.red_y = read_u32((void const *)(data + 12));
          ctx->chrm_int.green_x = read_u32((void const *)(data + 16));
          ctx->chrm_int.green_y = read_u32((void const *)(data + 20));
          ctx->chrm_int.blue_x = read_u32((void const *)(data + 24));
          ctx->chrm_int.blue_y = read_u32((void const *)(data + 28));
          tmp_7 = check_chrm_int((struct spng_chrm_int const *)(& ctx->chrm_int));
          if (tmp_7) {
            __retres = SPNG_ECHRM;
            goto return_label;
          }
          ctx->file.chrm = (unsigned int)1;
          ctx->stored.chrm = (unsigned int)1;
        }
      }
    }
  }
  __retres = ret;
  return_label: return __retres;
}

static int read_chunks_after_idat(spng_ctx *ctx)
{
  int __retres;
  int ret;
  struct spng_chunk chunk;
  unsigned char const *data;
  struct spng_chunk_bitfield stored;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  int discard = 0;
  int prev_was_idat = 1;
  memcpy((void *)(& stored),(void const *)(& ctx->stored),
         sizeof(struct spng_chunk_bitfield));
  memcpy((void *)(& chunk),(void const *)(& ctx->last_idat),
         sizeof(struct spng_chunk));
  while (1) {
    ret = read_header(ctx,& discard);
    if (ret) break;
    {
      int tmp_1;
      int tmp_2;
      int tmp_20;
      if (discard) memcpy((void *)(& ctx->stored),(void const *)(& stored),
                          sizeof(struct spng_chunk_bitfield));
      memcpy((void *)(& stored),(void const *)(& ctx->stored),
             sizeof(struct spng_chunk_bitfield));
      memcpy((void *)(& chunk),(void const *)(& ctx->current_chunk),
             sizeof(struct spng_chunk));
      tmp_1 = is_critical_chunk(& chunk);
      if (tmp_1) {
        int tmp_0;
        tmp_0 = memcmp((void const *)(chunk.type),(void const *)(type_iend),
                       (size_t)4);
        if (tmp_0) {
          int tmp;
          tmp = memcmp((void const *)(chunk.type),(void const *)(type_idat),
                       (size_t)4);
          if (tmp) {
            __retres = SPNG_ECHUNK_POS;
            goto return_label;
          }
          else 
            if (prev_was_idat) {
              ret = discard_chunk_bytes(ctx,chunk.length);
              if (ret) {
                __retres = ret;
                goto return_label;
              }
              continue;
            }
            else {
              __retres = SPNG_ECHUNK_POS;
              goto return_label;
            }
        }
        else {
          if (chunk.length) {
            __retres = SPNG_ECHUNK_CRC;
            goto return_label;
          }
          ret = read_and_check_crc(ctx);
          if (ret == - SPNG_CRC_DISCARD) ret = 0;
          __retres = ret;
          goto return_label;
        }
      }
      tmp_2 = chunk_fits_in_cache(ctx,& ctx->chunk_cache_usage);
      if (! tmp_2) {
        ret = discard_chunk_bytes(ctx,chunk.length);
        if (ret) {
          __retres = ret;
          goto return_label;
        }
        continue;
      }
      ret = read_chunk_bytes(ctx,chunk.length);
      if (ret) {
        __retres = ret;
        goto return_label;
      }
      data = ctx->data;
      prev_was_idat = 0;
      tmp_20 = memcmp((void const *)(chunk.type),(void const *)(type_chrm),
                      (size_t)4);
      if (tmp_20) {
        int tmp_19;
        tmp_19 = memcmp((void const *)(chunk.type),(void const *)(type_gama),
                        (size_t)4);
        if (tmp_19) {
          int tmp_18;
          tmp_18 = memcmp((void const *)(chunk.type),
                          (void const *)(type_iccp),(size_t)4);
          if (tmp_18) {
            int tmp_17;
            tmp_17 = memcmp((void const *)(chunk.type),
                            (void const *)(type_sbit),(size_t)4);
            if (tmp_17) {
              int tmp_16;
              tmp_16 = memcmp((void const *)(chunk.type),
                              (void const *)(type_srgb),(size_t)4);
              if (tmp_16) {
                int tmp_15;
                tmp_15 = memcmp((void const *)(chunk.type),
                                (void const *)(type_bkgd),(size_t)4);
                if (tmp_15) {
                  int tmp_14;
                  tmp_14 = memcmp((void const *)(chunk.type),
                                  (void const *)(type_hist),(size_t)4);
                  if (tmp_14) {
                    int tmp_13;
                    tmp_13 = memcmp((void const *)(chunk.type),
                                    (void const *)(type_trns),(size_t)4);
                    if (tmp_13) {
                      int tmp_12;
                      tmp_12 = memcmp((void const *)(chunk.type),
                                      (void const *)(type_phys),(size_t)4);
                      if (tmp_12) {
                        int tmp_11;
                        tmp_11 = memcmp((void const *)(chunk.type),
                                        (void const *)(type_splt),(size_t)4);
                        if (tmp_11) {
                          int tmp_10;
                          tmp_10 = memcmp((void const *)(chunk.type),
                                          (void const *)(type_offs),
                                          (size_t)4);
                          if (tmp_10) {
                            int tmp_9;
                            tmp_9 = memcmp((void const *)(chunk.type),
                                           (void const *)(type_time),
                                           (size_t)4);
                            if (tmp_9) {
                              int tmp_8;
                              tmp_8 = memcmp((void const *)(chunk.type),
                                             (void const *)(type_exif),
                                             (size_t)4);
                              if (tmp_8) {
                                int tmp_5;
                                tmp_5 = memcmp((void const *)(chunk.type),
                                               (void const *)(type_text),
                                               (size_t)4);
                                if (tmp_5) {
                                  int tmp_6;
                                  tmp_6 = memcmp((void const *)(chunk.type),
                                                 (void const *)(type_ztxt),
                                                 (size_t)4);
                                  if (tmp_6) {
                                    int tmp_7;
                                    tmp_7 = memcmp((void const *)(chunk.type),
                                                   (void const *)(type_itxt),
                                                   (size_t)4);
                                    if (! tmp_7) {
                                      _LOR:
                                      {
                                        ctx->file.text = (unsigned int)1;
                                        continue;
                                      }
                                    }
                                  }
                                  else goto _LOR;
                                }
                                else goto _LOR;
                              }
                              else {
                                struct spng_exif exif;
                                int tmp_4;
                                if (ctx->file.exif) {
                                  __retres = SPNG_EDUP_EXIF;
                                  goto return_label;
                                }
                                ctx->file.exif = (unsigned int)1;
                                if (! chunk.length) {
                                  __retres = SPNG_EEXIF;
                                  goto return_label;
                                }
                                exif.data = (char *)spng__malloc(ctx,
                                                                 chunk.length);
                                if (exif.data == (char *)0) {
                                  __retres = SPNG_EMEM;
                                  goto return_label;
                                }
                                memcpy((void *)exif.data,(void const *)data,
                                       chunk.length);
                                exif.length = chunk.length;
                                tmp_4 = check_exif((struct spng_exif const *)(& exif));
                                if (tmp_4) {
                                  spng__free(ctx,(void *)exif.data);
                                  __retres = SPNG_EEXIF;
                                  goto return_label;
                                }
                                if (! ctx->user.exif) memcpy((void *)(& ctx->exif),
                                                             (void const *)(& exif),
                                                             sizeof(struct spng_exif));
                                else spng__free(ctx,(void *)exif.data);
                                ctx->stored.exif = (unsigned int)1;
                              }
                            }
                            else {
                              struct spng_time time;
                              int tmp_3;
                              if (ctx->file.time) {
                                __retres = SPNG_EDUP_TIME;
                                goto return_label;
                              }
                              if (chunk.length != (uint32_t)7) {
                                __retres = SPNG_ECHUNK_SIZE;
                                goto return_label;
                              }
                              time.year = read_u16((void const *)data);
                              memcpy((void *)(& time.month),
                                     (void const *)(data + 2),(size_t)1);
                              memcpy((void *)(& time.day),
                                     (void const *)(data + 3),(size_t)1);
                              memcpy((void *)(& time.hour),
                                     (void const *)(data + 4),(size_t)1);
                              memcpy((void *)(& time.minute),
                                     (void const *)(data + 5),(size_t)1);
                              memcpy((void *)(& time.second),
                                     (void const *)(data + 6),(size_t)1);
                              tmp_3 = check_time((struct spng_time const *)(& time));
                              if (tmp_3) {
                                __retres = SPNG_ETIME;
                                goto return_label;
                              }
                              ctx->file.time = (unsigned int)1;
                              if (! ctx->user.time) memcpy((void *)(& ctx->time),
                                                           (void const *)(& time),
                                                           sizeof(struct spng_time));
                              ctx->stored.time = (unsigned int)1;
                            }
                          }
                          else {
                            __retres = SPNG_ECHUNK_POS;
                            goto return_label;
                          }
                        }
                        else {
                          __retres = SPNG_ECHUNK_POS;
                          goto return_label;
                        }
                      }
                      else {
                        __retres = SPNG_ECHUNK_POS;
                        goto return_label;
                      }
                    }
                    else {
                      __retres = SPNG_ECHUNK_POS;
                      goto return_label;
                    }
                  }
                  else {
                    __retres = SPNG_ECHUNK_POS;
                    goto return_label;
                  }
                }
                else {
                  __retres = SPNG_ECHUNK_POS;
                  goto return_label;
                }
              }
              else {
                __retres = SPNG_ECHUNK_POS;
                goto return_label;
              }
            }
            else {
              __retres = SPNG_ECHUNK_POS;
              goto return_label;
            }
          }
          else {
            __retres = SPNG_ECHUNK_POS;
            goto return_label;
          }
        }
        else {
          __retres = SPNG_ECHUNK_POS;
          goto return_label;
        }
      }
      else {
        __retres = SPNG_ECHUNK_POS;
        goto return_label;
      }
    }
  }
  __retres = ret;
  return_label: return __retres;
}

static int calculate_subimages(struct spng_subimage sub[7],
                               size_t *widest_scanline,
                               struct spng_ihdr *ihdr, unsigned int channels)
{
  int __retres;
  size_t scanline_width;
  int i;
  if (sub == (struct spng_subimage *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (ihdr == (struct spng_ihdr *)0) {
      __retres = 1;
      goto return_label;
    }
  if ((int)ihdr->interlace_method == 1) {
    (sub + 0)->width = (ihdr->width + (uint32_t)7) >> 3;
    (sub + 0)->height = (ihdr->height + (uint32_t)7) >> 3;
    (sub + 1)->width = (ihdr->width + (uint32_t)3) >> 3;
    (sub + 1)->height = (ihdr->height + (uint32_t)7) >> 3;
    (sub + 2)->width = (ihdr->width + (uint32_t)3) >> 2;
    (sub + 2)->height = (ihdr->height + (uint32_t)3) >> 3;
    (sub + 3)->width = (ihdr->width + (uint32_t)1) >> 2;
    (sub + 3)->height = (ihdr->height + (uint32_t)3) >> 2;
    (sub + 4)->width = (ihdr->width + (uint32_t)1) >> 1;
    (sub + 4)->height = (ihdr->height + (uint32_t)1) >> 2;
    (sub + 5)->width = ihdr->width >> 1;
    (sub + 5)->height = (ihdr->height + (uint32_t)1) >> 1;
    (sub + 6)->width = ihdr->width;
    (sub + 6)->height = ihdr->height >> 1;
  }
  else {
    (sub + 0)->width = ihdr->width;
    (sub + 0)->height = ihdr->height;
  }
  size_t widest = (size_t)0;
  i = 0;
  while (i < 7) {
    if ((sub + i)->width == (uint32_t)0) goto __Cont;
    else 
      if ((sub + i)->height == (uint32_t)0) goto __Cont;
    scanline_width = channels * (unsigned int)ihdr->bit_depth;
    if (scanline_width > 4294967295U / ihdr->width) {
      __retres = SPNG_EOVERFLOW;
      goto return_label;
    }
    scanline_width *= (sub + i)->width;
    scanline_width += (size_t)8;
    if (scanline_width < (size_t)8) {
      __retres = SPNG_EOVERFLOW;
      goto return_label;
    }
    if (scanline_width % (unsigned int)8 != (unsigned int)0) {
      scanline_width += (size_t)8;
      if (scanline_width < (size_t)8) {
        __retres = SPNG_EOVERFLOW;
        goto return_label;
      }
      scanline_width -= scanline_width % (unsigned int)8;
    }
    scanline_width /= (size_t)8;
    (sub + i)->scanline_width = scanline_width;
    if (widest < scanline_width) widest = scanline_width;
    __Cont: i ++;
  }
  *widest_scanline = widest;
  __retres = 0;
  return_label: return __retres;
}

static int get_ancillary(spng_ctx *ctx)
{
  int ret = read_chunks_before_idat(ctx);
  if (ret) ctx->valid_state = (unsigned int)0;
  return ret;
}

static int get_ancillary2(spng_ctx *ctx)
{
  int __retres;
  int tmp;
  if (ctx->data == (unsigned char const *)0) {
    ctx->encode_only = (unsigned int)1;
    __retres = 0;
    goto return_label;
  }
  tmp = get_ancillary(ctx);
  __retres = tmp;
  goto return_label;
  return_label: return __retres;
}

int spng_decode_image(spng_ctx *ctx, unsigned char *out, size_t out_size,
                      int fmt, int flags)
{
  int __retres;
  int ret;
  size_t out_size_required;
  size_t out_width;
  uint8_t bytes_per_pixel;
  z_stream stream;
  int tmp;
  int pass;
  uint32_t i;
  uint32_t k;
  uint32_t scanline_idx;
  uint32_t width;
  uint8_t r_8;
  uint8_t g_8;
  uint8_t b_8;
  uint8_t a_8;
  uint8_t gray_8;
  uint16_t r_16;
  uint16_t g_16;
  uint16_t b_16;
  uint16_t a_16;
  uint16_t gray_16;
  unsigned char *pixel;
  struct spng_subimage sub[7];
  size_t scanline_width;
  struct spng_sbit sb;
  struct spng_plte_entry16 plte[256];
  unsigned char trns_px[8];
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  if (out == (unsigned char *)0) {
    __retres = 1;
    goto return_label;
  }
  ret = spng_decoded_image_size(ctx,fmt,& out_size_required);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  if (out_size < out_size_required) {
    __retres = SPNG_EBUFSIZ;
    goto return_label;
  }
  out_width = out_size_required / ctx->ihdr.height;
  uint8_t channels = (uint8_t)1;
  if ((int)ctx->ihdr.color_type == SPNG_COLOR_TYPE_TRUECOLOR) channels = (uint8_t)3;
  else 
    if ((int)ctx->ihdr.color_type == SPNG_COLOR_TYPE_GRAYSCALE_ALPHA) 
      channels = (uint8_t)2;
    else 
      if ((int)ctx->ihdr.color_type == SPNG_COLOR_TYPE_TRUECOLOR_ALPHA) 
        channels = (uint8_t)4;
  if ((int)ctx->ihdr.bit_depth < 8) bytes_per_pixel = (uint8_t)1;
  else bytes_per_pixel = (uint8_t)((int)channels * ((int)ctx->ihdr.bit_depth / 8));
  stream.zalloc = & spng__zalloc;
  stream.zfree = & spng__zfree;
  stream.opaque = (void *)ctx;
  tmp = inflateInit(& stream);
  if (tmp != 0) {
    __retres = SPNG_EZLIB;
    goto return_label;
  }
  int apply_trns = 0;
  if (flags & SPNG_DECODE_USE_TRNS) 
    if (ctx->stored.trns) apply_trns = 1;
  int apply_gamma = 0;
  if (flags & SPNG_DECODE_USE_GAMA) 
    if (ctx->stored.gama) apply_gamma = 1;
  int use_sbit = 0;
  if (flags & SPNG_DECODE_USE_SBIT) 
    if (ctx->stored.sbit) use_sbit = 1;
  int indexed = 0;
  if ((int)ctx->ihdr.color_type == SPNG_COLOR_TYPE_INDEXED) indexed = 1;
  int do_scaling = 1;
  if (indexed) do_scaling = 0;
  int interlaced = 0;
  if (ctx->ihdr.interlace_method) interlaced = 1;
  uint8_t filter = (uint8_t)0;
  uint8_t next_filter = (uint8_t)0;
  r_8 = (uint8_t)0;
  g_8 = (uint8_t)0;
  b_8 = (uint8_t)0;
  a_8 = (uint8_t)0;
  gray_8 = (uint8_t)0;
  r_16 = (uint16_t)0;
  g_16 = (uint16_t)0;
  b_16 = (uint16_t)0;
  a_16 = (uint16_t)0;
  gray_16 = (uint16_t)0;
  uint8_t const samples_per_byte = (uint8_t)(8 / (int)ctx->ihdr.bit_depth);
  uint8_t const mask =
    (uint8_t)((int)((uint16_t)(1 << (int)ctx->ihdr.bit_depth)) - 1);
  uint8_t const initial_shift = (uint8_t)(8 - (int)ctx->ihdr.bit_depth);
  size_t pixel_size = (size_t)4;
  size_t pixel_offset = (size_t)0;
  unsigned int depth_target = (unsigned int)8;
  unsigned int processing_depth = (unsigned int)ctx->ihdr.bit_depth;
  if (indexed) processing_depth = (unsigned int)8;
  if (fmt == SPNG_FMT_RGBA16) {
    depth_target = (unsigned int)16;
    pixel_size = (size_t)8;
  }
  memset((void *)(sub),0,sizeof(struct spng_subimage) * (unsigned int)7);
  ret = calculate_subimages(sub,& scanline_width,& ctx->ihdr,
                            (unsigned int)channels);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  unsigned char *row = (unsigned char *)0;
  unsigned char *scanline = spng__malloc(ctx,scanline_width);
  unsigned char *prev_scanline = spng__malloc(ctx,scanline_width);
  if (interlaced) row = (unsigned char *)spng__malloc(ctx,out_width);
  else row = out;
  if (scanline == (unsigned char *)0) goto _LOR;
  else 
    if (prev_scanline == (unsigned char *)0) goto _LOR;
    else 
      if (row == (unsigned char *)0) {
        _LOR: {
                ret = SPNG_EMEM;
                goto decode_err;
              }
      }
  uint16_t *gamma_lut = (uint16_t *)0;
  if (apply_gamma) {
    float max;
    uint32_t lut_entries;
    int tmp_4;
    float file_gamma = (float)ctx->gama / 100000.0f;
    if (fmt == SPNG_FMT_RGBA8) {
      lut_entries = (uint32_t)256;
      max = 255.0f;
      gamma_lut = ctx->gamma_lut8;
    }
    else {
      lut_entries = (uint32_t)65536;
      max = 65535.0f;
      ctx->gamma_lut = (uint16_t *)spng__malloc(ctx,
                                                lut_entries * sizeof(uint16_t));
      if (ctx->gamma_lut == (uint16_t *)0) {
        ret = SPNG_EMEM;
        goto decode_err;
      }
      gamma_lut = ctx->gamma_lut;
    }
    float screen_gamma = 2.2f;
    float exponent = file_gamma * screen_gamma;
    if (sizeof(exponent) == sizeof(float)) tmp_4 = __fc_fpclassifyf(exponent);
    else tmp_4 = __fc_fpclassify((double)exponent);
    if (2 == tmp_4) {
      ret = SPNG_EGAMA;
      goto decode_err;
    }
    exponent = 1.0f / exponent;
    i = (uint32_t)0;
    while (i < lut_entries) {
      {
        double tmp_5;
        double tmp_6;
        tmp_5 = pow((double)((float)i / max),(double)exponent);
        float c = (float)(tmp_5 * (double)max);
        tmp_6 = fmin((double)c,(double)max);
        c = (float)tmp_6;
        *(gamma_lut + i) = (uint16_t)c;
      }
      i ++;
    }
  }
  sb.red_bits = (uint8_t)processing_depth;
  sb.green_bits = (uint8_t)processing_depth;
  sb.blue_bits = (uint8_t)processing_depth;
  sb.alpha_bits = (uint8_t)processing_depth;
  sb.grayscale_bits = (uint8_t)processing_depth;
  if (use_sbit) 
    if ((int)ctx->ihdr.color_type == 0) {
      sb.grayscale_bits = ctx->sbit.grayscale_bits;
      sb.alpha_bits = ctx->ihdr.bit_depth;
    }
    else 
      if ((int)ctx->ihdr.color_type == 2) goto _LOR_0;
      else 
        if ((int)ctx->ihdr.color_type == 3) {
          _LOR_0:
          {
            sb.red_bits = ctx->sbit.red_bits;
            sb.green_bits = ctx->sbit.green_bits;
            sb.blue_bits = ctx->sbit.blue_bits;
            sb.alpha_bits = ctx->ihdr.bit_depth;
          }
        }
        else 
          if ((int)ctx->ihdr.color_type == 4) {
            sb.grayscale_bits = ctx->sbit.grayscale_bits;
            sb.alpha_bits = ctx->sbit.alpha_bits;
          }
          else {
            sb.red_bits = ctx->sbit.red_bits;
            sb.green_bits = ctx->sbit.green_bits;
            sb.blue_bits = ctx->sbit.blue_bits;
            sb.alpha_bits = ctx->sbit.alpha_bits;
          }
  if ((int)ctx->ihdr.bit_depth == 16) 
    if (fmt == SPNG_FMT_RGBA8) {
      sb.red_bits = (uint8_t)((int)sb.red_bits - 8);
      sb.green_bits = (uint8_t)((int)sb.green_bits - 8);
      sb.blue_bits = (uint8_t)((int)sb.blue_bits - 8);
      sb.alpha_bits = (uint8_t)((int)sb.alpha_bits - 8);
      sb.grayscale_bits = (uint8_t)((int)sb.grayscale_bits - 8);
      processing_depth = (unsigned int)8;
    }
  if (! depth_target) goto _LOR_1;
  else 
    if (depth_target > (unsigned int)16) goto _LOR_1;
    else 
      if (! processing_depth) goto _LOR_1;
      else 
        if (processing_depth > (unsigned int)16) goto _LOR_1;
        else 
          if (! sb.grayscale_bits) goto _LOR_1;
          else 
            if ((unsigned int)sb.grayscale_bits > processing_depth) goto _LOR_1;
            else 
              if (! sb.alpha_bits) goto _LOR_1;
              else 
                if ((unsigned int)sb.alpha_bits > processing_depth) goto _LOR_1;
                else 
                  if (! sb.red_bits) goto _LOR_1;
                  else 
                    if ((unsigned int)sb.red_bits > processing_depth) 
                      goto _LOR_1;
                    else 
                      if (! sb.green_bits) goto _LOR_1;
                      else 
                        if ((unsigned int)sb.green_bits > processing_depth) 
                          goto _LOR_1;
                        else 
                          if (! sb.blue_bits) goto _LOR_1;
                          else 
                            if ((unsigned int)sb.blue_bits > processing_depth) {
                              _LOR_1: {
                                        ret = SPNG_ESBIT;
                                        goto decode_err;
                                      }
                            }
  if ((int)sb.red_bits == (int)sb.green_bits) 
    if ((int)sb.green_bits == (int)sb.blue_bits) 
      if ((int)sb.blue_bits == (int)sb.alpha_bits) 
        if ((unsigned int)sb.alpha_bits == processing_depth) 
          if (processing_depth == depth_target) do_scaling = 0;
  if (indexed) {
    i = (uint32_t)0;
    /*@ loop unroll 256; */
    while (i < (uint32_t)256) {
      if (apply_trns) 
        if (i < ctx->trns.n_type3_entries) ctx->plte.entries[i].alpha = ctx->trns.type3_alpha[i];
        else ctx->plte.entries[i].alpha = (uint8_t)255;
      else ctx->plte.entries[i].alpha = (uint8_t)255;
      plte[i].red = sample_to_target((uint16_t)ctx->plte.entries[i].red,
                                     (unsigned int)8,
                                     (unsigned int)sb.red_bits,depth_target);
      plte[i].green = sample_to_target((uint16_t)ctx->plte.entries[i].green,
                                       (unsigned int)8,
                                       (unsigned int)sb.green_bits,
                                       depth_target);
      plte[i].blue = sample_to_target((uint16_t)ctx->plte.entries[i].blue,
                                      (unsigned int)8,
                                      (unsigned int)sb.blue_bits,
                                      depth_target);
      plte[i].alpha = sample_to_target((uint16_t)ctx->plte.entries[i].alpha,
                                       (unsigned int)8,
                                       (unsigned int)sb.alpha_bits,
                                       depth_target);
      if (apply_gamma) {
        plte[i].red = *(gamma_lut + plte[i].red);
        plte[i].green = *(gamma_lut + plte[i].green);
        plte[i].blue = *(gamma_lut + plte[i].blue);
      }
      i ++;
    }
    apply_trns = 0;
    apply_gamma = 0;
  }
  if (apply_trns) 
    if ((int)ctx->ihdr.color_type == SPNG_COLOR_TYPE_TRUECOLOR) 
      if ((int)ctx->ihdr.bit_depth == 16) {
        memcpy((void *)(trns_px),(void const *)(& ctx->trns.red),(size_t)2);
        memcpy((void *)(& trns_px[2]),(void const *)(& ctx->trns.green),
               (size_t)2);
        memcpy((void *)(& trns_px[4]),(void const *)(& ctx->trns.blue),
               (size_t)2);
      }
      else {
        trns_px[0] = (unsigned char)ctx->trns.red;
        trns_px[1] = (unsigned char)ctx->trns.green;
        trns_px[2] = (unsigned char)ctx->trns.blue;
      }
  stream.avail_in = (unsigned int)0;
  stream.next_in = ctx->data;
  pass = 0;
  while (pass < 7) {
    if (sub[pass].width == (uint32_t)0) goto __Cont;
    else 
      if (sub[pass].height == (uint32_t)0) goto __Cont;
    scanline_width = sub[pass].scanline_width;
    memset((void *)prev_scanline,0,scanline_width);
    ret = read_scanline_bytes(ctx,& stream,& filter,(size_t)1);
    if (ret) goto decode_err;
    scanline_idx = (uint32_t)0;
    while (scanline_idx < sub[pass].height) {
      {
        if (scanline_idx == sub[pass].height - (uint32_t)1) ret = read_scanline_bytes
                                                            (ctx,& stream,
                                                             scanline,
                                                             scanline_width - (size_t)1);
        else ret = read_scanline_bytes(ctx,& stream,scanline,scanline_width);
        if (ret) goto decode_err;
        memcpy((void *)(& next_filter),
               (void const *)((scanline + scanline_width) - 1),(size_t)1);
        ret = defilter_scanline((unsigned char const *)prev_scanline,
                                scanline,scanline_width - (size_t)1,
                                (unsigned int)bytes_per_pixel,
                                (unsigned int)filter);
        if (ret) goto decode_err;
        filter = next_filter;
        pixel_offset = (size_t)0;
        width = sub[pass].width;
        uint8_t shift_amount = initial_shift;
        k = (uint32_t)0;
        while (k < width) {
          pixel = row + pixel_offset;
          pixel_offset += pixel_size;
          if ((int)ctx->ihdr.color_type == SPNG_COLOR_TYPE_TRUECOLOR) 
            if ((int)ctx->ihdr.bit_depth == 16) {
              r_16 = read_u16((void const *)(scanline + k * (uint32_t)6));
              g_16 = read_u16((void const *)((scanline + k * (uint32_t)6) + 2));
              b_16 = read_u16((void const *)((scanline + k * (uint32_t)6) + 4));
              a_16 = (uint16_t)65535;
            }
            else {
              if (fmt == SPNG_FMT_RGBA8) {
                memcpy((void *)pixel,
                       (void const *)(scanline + k * (uint32_t)3),(size_t)3);
                *(pixel + 3) = (unsigned char)255;
                goto __Cont_0;
              }
              memcpy((void *)(& r_8),
                     (void const *)(scanline + k * (uint32_t)3),(size_t)1);
              memcpy((void *)(& g_8),
                     (void const *)((scanline + k * (uint32_t)3) + 1),
                     (size_t)1);
              memcpy((void *)(& b_8),
                     (void const *)((scanline + k * (uint32_t)3) + 2),
                     (size_t)1);
              a_8 = (uint8_t)255;
            }
          else 
            if ((int)ctx->ihdr.color_type == SPNG_COLOR_TYPE_INDEXED) {
              uint8_t entry = (uint8_t)0;
              if ((int)ctx->ihdr.bit_depth == 8) memcpy((void *)(& entry),
                                                        (void const *)(
                                                        scanline + k),
                                                        (size_t)1);
              else {
                memcpy((void *)(& entry),
                       (void const *)(scanline + k / (uint32_t)samples_per_byte),
                       (size_t)1);
                if ((int)shift_amount > 8) shift_amount = initial_shift;
                entry = (uint8_t)(((int)entry >> (int)shift_amount) & (int)mask);
                shift_amount = (uint8_t)((int)shift_amount - (int)ctx->ihdr.bit_depth);
              }
              if (fmt == SPNG_FMT_RGBA8) {
                *(pixel + 0) = (unsigned char)plte[entry].red;
                *(pixel + 1) = (unsigned char)plte[entry].green;
                *(pixel + 2) = (unsigned char)plte[entry].blue;
                *(pixel + 3) = (unsigned char)plte[entry].alpha;
                goto __Cont_0;
              }
              else {
                r_16 = plte[entry].red;
                g_16 = plte[entry].green;
                b_16 = plte[entry].blue;
                a_16 = plte[entry].alpha;
                memcpy((void *)pixel,(void const *)(& r_16),(size_t)2);
                memcpy((void *)(pixel + 2),(void const *)(& g_16),(size_t)2);
                memcpy((void *)(pixel + 4),(void const *)(& b_16),(size_t)2);
                memcpy((void *)(pixel + 6),(void const *)(& a_16),(size_t)2);
                goto __Cont_0;
              }
            }
            else 
              if ((int)ctx->ihdr.color_type == SPNG_COLOR_TYPE_TRUECOLOR_ALPHA) 
                if ((int)ctx->ihdr.bit_depth == 16) {
                  r_16 = read_u16((void const *)(scanline + k * (uint32_t)8));
                  g_16 = read_u16((void const *)((scanline + k * (uint32_t)8) + 2));
                  b_16 = read_u16((void const *)((scanline + k * (uint32_t)8) + 4));
                  a_16 = read_u16((void const *)((scanline + k * (uint32_t)8) + 6));
                }
                else {
                  if (fmt == SPNG_FMT_RGBA8) {
                    memcpy((void *)row,(void const *)scanline,
                           scanline_width - (size_t)1);
                    break;
                  }
                  memcpy((void *)(& r_8),
                         (void const *)(scanline + k * (uint32_t)4),
                         (size_t)1);
                  memcpy((void *)(& g_8),
                         (void const *)((scanline + k * (uint32_t)4) + 1),
                         (size_t)1);
                  memcpy((void *)(& b_8),
                         (void const *)((scanline + k * (uint32_t)4) + 2),
                         (size_t)1);
                  memcpy((void *)(& a_8),
                         (void const *)((scanline + k * (uint32_t)4) + 3),
                         (size_t)1);
                }
              else 
                if ((int)ctx->ihdr.color_type == SPNG_COLOR_TYPE_GRAYSCALE) 
                  if ((int)ctx->ihdr.bit_depth == 16) {
                    gray_16 = read_u16((void const *)(scanline + k * (uint32_t)2));
                    if (apply_trns) 
                      if ((int)ctx->trns.gray == (int)gray_16) a_16 = (uint16_t)0;
                      else a_16 = (uint16_t)65535;
                    else a_16 = (uint16_t)65535;
                    r_16 = gray_16;
                    g_16 = gray_16;
                    b_16 = gray_16;
                  }
                  else {
                    memcpy((void *)(& gray_8),
                           (void const *)(scanline + k / (uint32_t)samples_per_byte),
                           (size_t)1);
                    if ((int)shift_amount > 8) shift_amount = initial_shift;
                    gray_8 = (uint8_t)(((int)gray_8 >> (int)shift_amount) & (int)mask);
                    shift_amount = (uint8_t)((int)shift_amount - (int)ctx->ihdr.bit_depth);
                    if (apply_trns) 
                      if ((int)ctx->trns.gray == (int)gray_8) a_8 = (uint8_t)0;
                      else a_8 = (uint8_t)255;
                    else a_8 = (uint8_t)255;
                    r_8 = gray_8;
                    g_8 = gray_8;
                    b_8 = gray_8;
                  }
                else 
                  if ((int)ctx->ihdr.color_type == SPNG_COLOR_TYPE_GRAYSCALE_ALPHA) 
                    if ((int)ctx->ihdr.bit_depth == 16) {
                      gray_16 = read_u16((void const *)(scanline + k * (uint32_t)4));
                      a_16 = read_u16((void const *)((scanline + k * (uint32_t)4) + 2));
                      r_16 = gray_16;
                      g_16 = gray_16;
                      b_16 = gray_16;
                    }
                    else {
                      memcpy((void *)(& gray_8),
                             (void const *)(scanline + k * (uint32_t)2),
                             (size_t)1);
                      memcpy((void *)(& a_8),
                             (void const *)((scanline + k * (uint32_t)2) + 1),
                             (size_t)1);
                      r_8 = gray_8;
                      g_8 = gray_8;
                      b_8 = gray_8;
                    }
          if (fmt == SPNG_FMT_RGBA8) {
            if ((int)ctx->ihdr.bit_depth == 16) {
              r_8 = (uint8_t)((int)r_16 >> 8);
              g_8 = (uint8_t)((int)g_16 >> 8);
              b_8 = (uint8_t)((int)b_16 >> 8);
              a_8 = (uint8_t)((int)a_16 >> 8);
            }
            memcpy((void *)pixel,(void const *)(& r_8),(size_t)1);
            memcpy((void *)(pixel + 1),(void const *)(& g_8),(size_t)1);
            memcpy((void *)(pixel + 2),(void const *)(& b_8),(size_t)1);
            memcpy((void *)(pixel + 3),(void const *)(& a_8),(size_t)1);
          }
          else 
            if (fmt == SPNG_FMT_RGBA16) {
              if ((int)ctx->ihdr.bit_depth != 16) {
                r_16 = (uint16_t)r_8;
                g_16 = (uint16_t)g_8;
                b_16 = (uint16_t)b_8;
                a_16 = (uint16_t)a_8;
              }
              memcpy((void *)pixel,(void const *)(& r_16),(size_t)2);
              memcpy((void *)(pixel + 2),(void const *)(& g_16),(size_t)2);
              memcpy((void *)(pixel + 4),(void const *)(& b_16),(size_t)2);
              memcpy((void *)(pixel + 6),(void const *)(& a_16),(size_t)2);
            }
          __Cont_0: k ++;
        }
        if (apply_trns) trns_row(row,(unsigned char const *)scanline,
                                 (unsigned char const *)(trns_px),width,fmt,
                                 (unsigned int)ctx->ihdr.color_type,
                                 (unsigned int)ctx->ihdr.bit_depth);
        if (do_scaling) scale_row(row,width,fmt,processing_depth,& sb);
        if (apply_gamma) gamma_correct_row(row,width,fmt,
                                           (uint16_t const *)gamma_lut);
        void *t = (void *)prev_scanline;
        prev_scanline = scanline;
        scanline = (unsigned char *)t;
        if (interlaced) {
          unsigned int const adam7_x_start[7] =
            {(unsigned int)0,
             (unsigned int)4,
             (unsigned int)0,
             (unsigned int)2,
             (unsigned int)0,
             (unsigned int)1,
             (unsigned int)0};
          unsigned int const adam7_y_start[7] =
            {(unsigned int)0,
             (unsigned int)0,
             (unsigned int)4,
             (unsigned int)0,
             (unsigned int)2,
             (unsigned int)0,
             (unsigned int)1};
          unsigned int const adam7_x_delta[7] =
            {(unsigned int)8,
             (unsigned int)8,
             (unsigned int)4,
             (unsigned int)4,
             (unsigned int)2,
             (unsigned int)2,
             (unsigned int)1};
          unsigned int const adam7_y_delta[7] =
            {(unsigned int)8,
             (unsigned int)8,
             (unsigned int)8,
             (unsigned int)4,
             (unsigned int)4,
             (unsigned int)2,
             (unsigned int)2};
          k = (uint32_t)0;
          while (k < width) {
            {
              size_t ioffset =
                (((adam7_y_start[pass] + scanline_idx * adam7_y_delta[pass]) * ctx->ihdr.width + adam7_x_start[pass]) + 
                 k * adam7_x_delta[pass]) * pixel_size;
              memcpy((void *)(out + ioffset),
                     (void const *)(row + k * pixel_size),pixel_size);
            }
            k ++;
          }
        }
        else 
          if (scanline_idx != sub[pass].height - (uint32_t)1) row += out_width;
      }
      scanline_idx ++;
    }
    __Cont: pass ++;
  }
  if (ctx->cur_chunk_bytes_left) ret = discard_chunk_bytes(ctx,
                                                           ctx->cur_chunk_bytes_left);
  decode_err: inflateEnd(& stream);
  if (interlaced) spng__free(ctx,(void *)row);
  spng__free(ctx,(void *)scanline);
  spng__free(ctx,(void *)prev_scanline);
  if (ret) {
    ctx->valid_state = (unsigned int)0;
    __retres = ret;
    goto return_label;
  }
  memcpy((void *)(& ctx->last_idat),(void const *)(& ctx->current_chunk),
         sizeof(struct spng_chunk));
  ret = read_chunks_after_idat(ctx);
  if (ret) ctx->valid_state = (unsigned int)0;
  __retres = ret;
  return_label: return __retres;
}

spng_ctx *spng_ctx_new(int flags)
{
  spng_ctx *__retres;
  spng_ctx *tmp;
  if (flags) {
    __retres = (spng_ctx *)0;
    goto return_label;
  }
  struct spng_alloc alloc =
    {.malloc_fn = (spng_malloc_fn *)0,
     .realloc_fn = (spng_realloc_fn *)0,
     .calloc_fn = (spng_calloc_fn *)0,
     .free_fn = (spng_free_fn *)0};
  alloc.malloc_fn = & malloc;
  alloc.realloc_fn = & realloc;
  alloc.calloc_fn = & calloc;
  alloc.free_fn = & free;
  tmp = spng_ctx_new2(& alloc,flags);
  __retres = tmp;
  return_label: return __retres;
}

spng_ctx *spng_ctx_new2(struct spng_alloc *alloc, int flags)
{
  spng_ctx *__retres;
  spng_ctx *tmp;
  if (alloc == (struct spng_alloc *)0) {
    __retres = (spng_ctx *)0;
    goto return_label;
  }
  if (flags) {
    __retres = (spng_ctx *)0;
    goto return_label;
  }
  if (alloc->malloc_fn == (spng_malloc_fn *)0) {
    __retres = (spng_ctx *)0;
    goto return_label;
  }
  if (alloc->realloc_fn == (spng_realloc_fn *)0) {
    __retres = (spng_ctx *)0;
    goto return_label;
  }
  if (alloc->calloc_fn == (spng_calloc_fn *)0) {
    __retres = (spng_ctx *)0;
    goto return_label;
  }
  if (alloc->free_fn == (spng_free_fn *)0) {
    __retres = (spng_ctx *)0;
    goto return_label;
  }
  tmp = (spng_ctx *)(*(alloc->calloc_fn))((size_t)1,sizeof(spng_ctx));
  spng_ctx *ctx = tmp;
  if (ctx == (spng_ctx *)0) {
    __retres = (spng_ctx *)0;
    goto return_label;
  }
  memcpy((void *)(& ctx->alloc),(void const *)alloc,
         sizeof(struct spng_alloc));
  ctx->max_chunk_size = png_u32max;
  ctx->chunk_cache_limit = 4294967295U;
  ctx->valid_state = (unsigned int)1;
  __retres = ctx;
  return_label: return __retres;
}

void spng_ctx_free(spng_ctx *ctx)
{
  if (ctx == (spng_ctx *)0) goto return_label;
  if (ctx->streaming) 
    if (ctx->stream_buf != (unsigned char *)0) spng__free(ctx,
                                                          (void *)ctx->stream_buf);
  if (ctx->exif.data != (char *)0) 
    if (! ctx->user.exif) spng__free(ctx,(void *)ctx->exif.data);
  if (ctx->iccp.profile != (char *)0) 
    if (! ctx->user.iccp) spng__free(ctx,(void *)ctx->iccp.profile);
  if (ctx->gamma_lut != (uint16_t *)0) spng__free(ctx,(void *)ctx->gamma_lut);
  if (ctx->splt_list != (struct spng_splt *)0) 
    if (! ctx->user.splt) {
      uint32_t i;
      i = (uint32_t)0;
      while (i < ctx->n_splt) {
        if ((ctx->splt_list + i)->entries != (struct spng_splt_entry *)0) 
          spng__free(ctx,(void *)(ctx->splt_list + i)->entries);
        i ++;
      }
      spng__free(ctx,(void *)ctx->splt_list);
    }
  if (ctx->text_list != (struct spng_text *)0) 
    if (! ctx->user.text) {
      uint32_t i_0;
      i_0 = (uint32_t)0;
      while (i_0 < ctx->n_text) {
        if ((ctx->text_list + i_0)->text != (char *)0) spng__free(ctx,
                                                                  (void *)(
                                                                  ctx->text_list + i_0)->text);
        if ((ctx->text_list + i_0)->language_tag != (char *)0) spng__free
                                                               (ctx,
                                                                (void *)(
                                                                ctx->text_list + i_0)->language_tag);
        if ((ctx->text_list + i_0)->translated_keyword != (char *)0) 
          spng__free(ctx,(void *)(ctx->text_list + i_0)->translated_keyword);
        i_0 ++;
      }
      spng__free(ctx,(void *)ctx->text_list);
    }
  spng_free_fn *free_func = ctx->alloc.free_fn;
  memset((void *)ctx,0,sizeof(spng_ctx));
  (*free_func)((void *)ctx);
  return_label: return;
}

static int buffer_read_fn(spng_ctx *ctx, void *user, void *data, size_t n)
{
  int __retres;
  if (n > ctx->bytes_left) {
    __retres = SPNG_IO_EOF;
    goto return_label;
  }
  ctx->data += ctx->last_read_size;
  ctx->last_read_size = n;
  ctx->bytes_left -= n;
  __retres = 0;
  return_label: return __retres;
}

int spng_set_png_buffer(spng_ctx *ctx, void const *buf, size_t size)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (buf == (void const *)0) {
      __retres = 1;
      goto return_label;
    }
  if (! ctx->valid_state) {
    __retres = SPNG_EBADSTATE;
    goto return_label;
  }
  if (ctx->encode_only) {
    __retres = SPNG_ENCODE_ONLY;
    goto return_label;
  }
  if (ctx->data != (unsigned char const *)0) {
    __retres = SPNG_EBUF_SET;
    goto return_label;
  }
  ctx->data = (unsigned char const *)buf;
  ctx->png_buf = (unsigned char const *)buf;
  ctx->data_size = size;
  ctx->bytes_left = size;
  ctx->read_fn = & buffer_read_fn;
  __retres = 0;
  return_label: return __retres;
}

int spng_set_png_stream(spng_ctx *ctx, spng_read_fn *read_func, void *user)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (read_func == (spng_read_fn *)0) {
      __retres = 1;
      goto return_label;
    }
  if (! ctx->valid_state) {
    __retres = SPNG_EBADSTATE;
    goto return_label;
  }
  if (ctx->encode_only) {
    __retres = SPNG_ENCODE_ONLY;
    goto return_label;
  }
  if (ctx->stream_buf != (unsigned char *)0) {
    __retres = SPNG_EBUF_SET;
    goto return_label;
  }
  ctx->stream_buf = (unsigned char *)spng__malloc(ctx,(size_t)8192);
  if (ctx->stream_buf == (unsigned char *)0) {
    __retres = SPNG_EMEM;
    goto return_label;
  }
  ctx->data = (unsigned char const *)ctx->stream_buf;
  ctx->data_size = (size_t)8192;
  ctx->read_fn = read_func;
  ctx->read_user_ptr = user;
  ctx->streaming = (unsigned int)1;
  __retres = 0;
  return_label: return __retres;
}

int spng_set_image_limits(spng_ctx *ctx, uint32_t width, uint32_t height)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  if (width > png_u32max) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (height > png_u32max) {
      __retres = 1;
      goto return_label;
    }
  ctx->max_width = width;
  ctx->max_height = height;
  __retres = 0;
  return_label: return __retres;
}

int spng_get_image_limits(spng_ctx *ctx, uint32_t *width, uint32_t *height)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (width == (uint32_t *)0) {
      __retres = 1;
      goto return_label;
    }
    else 
      if (height == (uint32_t *)0) {
        __retres = 1;
        goto return_label;
      }
  *width = ctx->max_width;
  *height = ctx->max_height;
  __retres = 0;
  return_label: return __retres;
}

int spng_set_chunk_limits(spng_ctx *ctx, size_t chunk_size,
                          size_t cache_limit)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (chunk_size > png_u32max) {
      __retres = 1;
      goto return_label;
    }
  ctx->max_chunk_size = chunk_size;
  ctx->chunk_cache_limit = cache_limit;
  __retres = 0;
  return_label: return __retres;
}

int spng_get_chunk_limits(spng_ctx *ctx, size_t *chunk_size,
                          size_t *cache_limit)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (chunk_size == (size_t *)0) {
      __retres = 1;
      goto return_label;
    }
    else 
      if (cache_limit == (size_t *)0) {
        __retres = 1;
        goto return_label;
      }
  *chunk_size = ctx->max_chunk_size;
  *cache_limit = ctx->chunk_cache_limit;
  __retres = 0;
  return_label: return __retres;
}

int spng_set_crc_action(spng_ctx *ctx, int critical, int ancillary)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  if (critical > 2) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (critical < 0) {
      __retres = 1;
      goto return_label;
    }
  if (ancillary > 2) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (ancillary < 0) {
      __retres = 1;
      goto return_label;
    }
  if (critical == SPNG_CRC_DISCARD) {
    __retres = 1;
    goto return_label;
  }
  ctx->crc_action_critical = critical;
  ctx->crc_action_ancillary = ancillary;
  __retres = 0;
  return_label: return __retres;
}

int spng_decoded_image_size(spng_ctx *ctx, int fmt, size_t *out)
{
  int __retres;
  size_t res;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (out == (size_t *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  if (fmt == SPNG_FMT_RGBA8) {
    if ((unsigned int)4 > 4294967295U / ctx->ihdr.width) {
      __retres = SPNG_EOVERFLOW;
      goto return_label;
    }
    res = (uint32_t)4 * ctx->ihdr.width;
    if (res > 4294967295U / ctx->ihdr.height) {
      __retres = SPNG_EOVERFLOW;
      goto return_label;
    }
    res *= ctx->ihdr.height;
  }
  else 
    if (fmt == SPNG_FMT_RGBA16) {
      if ((unsigned int)8 > 4294967295U / ctx->ihdr.width) {
        __retres = SPNG_EOVERFLOW;
        goto return_label;
      }
      res = (uint32_t)8 * ctx->ihdr.width;
      if (res > 4294967295U / ctx->ihdr.height) {
        __retres = SPNG_EOVERFLOW;
        goto return_label;
      }
      res *= ctx->ihdr.height;
    }
    else {
      __retres = SPNG_EFMT;
      goto return_label;
    }
  *out = res;
  __retres = 0;
  return_label: return __retres;
}

int spng_get_ihdr(spng_ctx *ctx, struct spng_ihdr *ihdr)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (ihdr == (struct spng_ihdr *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  memcpy((void *)ihdr,(void const *)(& ctx->ihdr),sizeof(struct spng_ihdr));
  __retres = 0;
  return_label: return __retres;
}

int spng_get_plte(spng_ctx *ctx, struct spng_plte *plte)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (plte == (struct spng_plte *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  if (! ctx->stored.plte) {
    __retres = SPNG_ECHUNKAVAIL;
    goto return_label;
  }
  memcpy((void *)plte,(void const *)(& ctx->plte),sizeof(struct spng_plte));
  __retres = 0;
  return_label: return __retres;
}

int spng_get_trns(spng_ctx *ctx, struct spng_trns *trns)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (trns == (struct spng_trns *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  if (! ctx->stored.trns) {
    __retres = SPNG_ECHUNKAVAIL;
    goto return_label;
  }
  memcpy((void *)trns,(void const *)(& ctx->trns),sizeof(struct spng_trns));
  __retres = 0;
  return_label: return __retres;
}

int spng_get_chrm(spng_ctx *ctx, struct spng_chrm *chrm)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (chrm == (struct spng_chrm *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  if (! ctx->stored.chrm) {
    __retres = SPNG_ECHUNKAVAIL;
    goto return_label;
  }
  chrm->white_point_x = (double)ctx->chrm_int.white_point_x / 100000.0;
  chrm->white_point_y = (double)ctx->chrm_int.white_point_y / 100000.0;
  chrm->red_x = (double)ctx->chrm_int.red_x / 100000.0;
  chrm->red_y = (double)ctx->chrm_int.red_y / 100000.0;
  chrm->blue_y = (double)ctx->chrm_int.blue_y / 100000.0;
  chrm->blue_x = (double)ctx->chrm_int.blue_x / 100000.0;
  chrm->green_x = (double)ctx->chrm_int.green_x / 100000.0;
  chrm->green_y = (double)ctx->chrm_int.green_y / 100000.0;
  __retres = 0;
  return_label: return __retres;
}

int spng_get_chrm_int(spng_ctx *ctx, struct spng_chrm_int *chrm)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (chrm == (struct spng_chrm_int *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  if (! ctx->stored.chrm) {
    __retres = SPNG_ECHUNKAVAIL;
    goto return_label;
  }
  memcpy((void *)chrm,(void const *)(& ctx->chrm_int),
         sizeof(struct spng_chrm_int));
  __retres = 0;
  return_label: return __retres;
}

int spng_get_gama(spng_ctx *ctx, double *gamma)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (gamma == (double *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  if (! ctx->stored.gama) {
    __retres = SPNG_ECHUNKAVAIL;
    goto return_label;
  }
  *gamma = (double)ctx->gama / 100000.0;
  __retres = 0;
  return_label: return __retres;
}

int spng_get_iccp(spng_ctx *ctx, struct spng_iccp *iccp)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (iccp == (struct spng_iccp *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  if (! ctx->stored.iccp) {
    __retres = SPNG_ECHUNKAVAIL;
    goto return_label;
  }
  memcpy((void *)iccp,(void const *)(& ctx->iccp),sizeof(struct spng_iccp));
  __retres = 0;
  return_label: return __retres;
}

int spng_get_sbit(spng_ctx *ctx, struct spng_sbit *sbit)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (sbit == (struct spng_sbit *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  if (! ctx->stored.sbit) {
    __retres = SPNG_ECHUNKAVAIL;
    goto return_label;
  }
  memcpy((void *)sbit,(void const *)(& ctx->sbit),sizeof(struct spng_sbit));
  __retres = 0;
  return_label: return __retres;
}

int spng_get_srgb(spng_ctx *ctx, uint8_t *rendering_intent)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (rendering_intent == (uint8_t *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  if (! ctx->stored.srgb) {
    __retres = SPNG_ECHUNKAVAIL;
    goto return_label;
  }
  *rendering_intent = ctx->srgb_rendering_intent;
  __retres = 0;
  return_label: return __retres;
}

int spng_get_text(spng_ctx *ctx, struct spng_text *text, uint32_t *n_text)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (n_text == (uint32_t *)0) {
      __retres = 1;
      goto return_label;
    }
  if (text == (struct spng_text *)0) {
    *n_text = ctx->n_text;
    __retres = 0;
    goto return_label;
  }
  int ret = get_ancillary(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  if (*n_text < ctx->n_text) {
    __retres = 1;
    goto return_label;
  }
  if (! ctx->stored.text) {
    __retres = SPNG_ECHUNKAVAIL;
    goto return_label;
  }
  memcpy((void *)text,(void const *)(& ctx->text_list),
         ctx->n_text * sizeof(struct spng_text));
  __retres = ret;
  return_label: return __retres;
}

int spng_get_bkgd(spng_ctx *ctx, struct spng_bkgd *bkgd)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (bkgd == (struct spng_bkgd *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  if (! ctx->stored.bkgd) {
    __retres = SPNG_ECHUNKAVAIL;
    goto return_label;
  }
  memcpy((void *)bkgd,(void const *)(& ctx->bkgd),sizeof(struct spng_bkgd));
  __retres = 0;
  return_label: return __retres;
}

int spng_get_hist(spng_ctx *ctx, struct spng_hist *hist)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (hist == (struct spng_hist *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  if (! ctx->stored.hist) {
    __retres = SPNG_ECHUNKAVAIL;
    goto return_label;
  }
  memcpy((void *)hist,(void const *)(& ctx->hist),sizeof(struct spng_hist));
  __retres = 0;
  return_label: return __retres;
}

int spng_get_phys(spng_ctx *ctx, struct spng_phys *phys)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (phys == (struct spng_phys *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  if (! ctx->stored.phys) {
    __retres = SPNG_ECHUNKAVAIL;
    goto return_label;
  }
  memcpy((void *)phys,(void const *)(& ctx->phys),sizeof(struct spng_phys));
  __retres = 0;
  return_label: return __retres;
}

int spng_get_splt(spng_ctx *ctx, struct spng_splt *splt, uint32_t *n_splt)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (n_splt == (uint32_t *)0) {
      __retres = 1;
      goto return_label;
    }
  if (splt == (struct spng_splt *)0) {
    *n_splt = ctx->n_splt;
    __retres = 0;
    goto return_label;
  }
  int ret = get_ancillary(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  if (*n_splt < ctx->n_splt) {
    __retres = 1;
    goto return_label;
  }
  if (! ctx->stored.splt) {
    __retres = SPNG_ECHUNKAVAIL;
    goto return_label;
  }
  memcpy((void *)splt,(void const *)(& ctx->splt_list),
         ctx->n_splt * sizeof(struct spng_splt));
  __retres = 0;
  return_label: return __retres;
}

int spng_get_time(spng_ctx *ctx, struct spng_time *time)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (time == (struct spng_time *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  if (! ctx->stored.time) {
    __retres = SPNG_ECHUNKAVAIL;
    goto return_label;
  }
  memcpy((void *)time,(void const *)(& ctx->time),sizeof(struct spng_time));
  __retres = 0;
  return_label: return __retres;
}

int spng_get_offs(spng_ctx *ctx, struct spng_offs *offs)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (offs == (struct spng_offs *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  if (! ctx->stored.offs) {
    __retres = SPNG_ECHUNKAVAIL;
    goto return_label;
  }
  memcpy((void *)offs,(void const *)(& ctx->offs),sizeof(struct spng_offs));
  __retres = 0;
  return_label: return __retres;
}

int spng_get_exif(spng_ctx *ctx, struct spng_exif *exif)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (exif == (struct spng_exif *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  if (! ctx->stored.exif) {
    __retres = SPNG_ECHUNKAVAIL;
    goto return_label;
  }
  memcpy((void *)exif,(void const *)(& ctx->exif),sizeof(struct spng_exif));
  __retres = 0;
  return_label: return __retres;
}

int spng_set_ihdr(spng_ctx *ctx, struct spng_ihdr *ihdr)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (ihdr == (struct spng_ihdr *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary2(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  if (ctx->stored.ihdr) {
    __retres = 1;
    goto return_label;
  }
  ret = check_ihdr((struct spng_ihdr const *)ihdr,ctx->max_width,
                   ctx->max_height);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  memcpy((void *)(& ctx->ihdr),(void const *)ihdr,sizeof(struct spng_ihdr));
  ctx->stored.ihdr = (unsigned int)1;
  ctx->user.ihdr = (unsigned int)1;
  __retres = 0;
  return_label: return __retres;
}

int spng_set_plte(spng_ctx *ctx, struct spng_plte *plte)
{
  int __retres;
  int tmp_0;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (plte == (struct spng_plte *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary2(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  if (! ctx->stored.ihdr) {
    __retres = 1;
    goto return_label;
  }
  tmp_0 = check_plte((struct spng_plte const *)plte,
                     (struct spng_ihdr const *)(& ctx->ihdr));
  if (tmp_0) {
    __retres = 1;
    goto return_label;
  }
  memcpy((void *)(& ctx->plte),(void const *)plte,sizeof(struct spng_plte));
  ctx->stored.plte = (unsigned int)1;
  ctx->user.plte = (unsigned int)1;
  __retres = 0;
  return_label: return __retres;
}

int spng_set_trns(spng_ctx *ctx, struct spng_trns *trns)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (trns == (struct spng_trns *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary2(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  if (! ctx->stored.ihdr) {
    __retres = 1;
    goto return_label;
  }
  uint16_t mask = (uint16_t)(~ 0);
  if ((int)ctx->ihdr.bit_depth < 16) mask = (uint16_t)((1 << (int)ctx->ihdr.bit_depth) - 1);
  if ((int)ctx->ihdr.color_type == 0) trns->gray = (uint16_t)((int)trns->gray & (int)mask);
  else 
    if ((int)ctx->ihdr.color_type == 2) {
      trns->red = (uint16_t)((int)trns->red & (int)mask);
      trns->green = (uint16_t)((int)trns->green & (int)mask);
      trns->blue = (uint16_t)((int)trns->blue & (int)mask);
    }
    else 
      if ((int)ctx->ihdr.color_type == 3) {
        if (! ctx->stored.plte) {
          __retres = SPNG_ETRNS_NO_PLTE;
          goto return_label;
        }
      }
      else {
        __retres = SPNG_ETRNS_COLOR_TYPE;
        goto return_label;
      }
  memcpy((void *)(& ctx->trns),(void const *)trns,sizeof(struct spng_trns));
  ctx->stored.trns = (unsigned int)1;
  ctx->user.trns = (unsigned int)1;
  __retres = 0;
  return_label: return __retres;
}

int spng_set_chrm(spng_ctx *ctx, struct spng_chrm *chrm)
{
  int __retres;
  struct spng_chrm_int chrm_int;
  int tmp_0;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (chrm == (struct spng_chrm *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary2(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  chrm_int.white_point_x = (uint32_t)(chrm->white_point_x * 100000.0);
  chrm_int.white_point_y = (uint32_t)(chrm->white_point_y * 100000.0);
  chrm_int.red_x = (uint32_t)(chrm->red_x * 100000.0);
  chrm_int.red_y = (uint32_t)(chrm->red_y * 100000.0);
  chrm_int.green_x = (uint32_t)(chrm->green_x * 100000.0);
  chrm_int.green_y = (uint32_t)(chrm->green_y * 100000.0);
  chrm_int.blue_x = (uint32_t)(chrm->blue_x * 100000.0);
  chrm_int.blue_y = (uint32_t)(chrm->blue_y * 100000.0);
  tmp_0 = check_chrm_int((struct spng_chrm_int const *)(& chrm_int));
  if (tmp_0) {
    __retres = SPNG_ECHRM;
    goto return_label;
  }
  memcpy((void *)(& ctx->chrm_int),(void const *)(& chrm_int),
         sizeof(struct spng_chrm_int));
  ctx->stored.chrm = (unsigned int)1;
  ctx->user.chrm = (unsigned int)1;
  __retres = 0;
  return_label: return __retres;
}

int spng_set_chrm_int(spng_ctx *ctx, struct spng_chrm_int *chrm_int)
{
  int __retres;
  int tmp_0;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (chrm_int == (struct spng_chrm_int *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary2(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  tmp_0 = check_chrm_int((struct spng_chrm_int const *)chrm_int);
  if (tmp_0) {
    __retres = SPNG_ECHRM;
    goto return_label;
  }
  memcpy((void *)(& ctx->chrm_int),(void const *)chrm_int,
         sizeof(struct spng_chrm_int));
  ctx->stored.chrm = (unsigned int)1;
  ctx->user.chrm = (unsigned int)1;
  __retres = 0;
  return_label: return __retres;
}

int spng_set_gama(spng_ctx *ctx, double gamma)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (ctx == (spng_ctx *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary2(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  uint32_t gama = (uint32_t)(gamma * 100000.0);
  if (! gama) {
    __retres = 1;
    goto return_label;
  }
  if (gama > png_u32max) {
    __retres = 1;
    goto return_label;
  }
  ctx->gama = gama;
  ctx->stored.gama = (unsigned int)1;
  ctx->user.gama = (unsigned int)1;
  __retres = 0;
  return_label: return __retres;
}

int spng_set_iccp(spng_ctx *ctx, struct spng_iccp *iccp)
{
  int __retres;
  int tmp_0;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (iccp == (struct spng_iccp *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary2(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  tmp_0 = check_png_keyword((char const *)(iccp->profile_name));
  if (tmp_0) {
    __retres = SPNG_EICCP_NAME;
    goto return_label;
  }
  if (! iccp->profile_len) {
    __retres = 1;
    goto return_label;
  }
  if (ctx->iccp.profile) 
    if (! ctx->user.iccp) spng__free(ctx,(void *)ctx->iccp.profile);
  memcpy((void *)(& ctx->iccp),(void const *)iccp,sizeof(struct spng_iccp));
  ctx->stored.iccp = (unsigned int)1;
  ctx->user.iccp = (unsigned int)1;
  __retres = 0;
  return_label: return __retres;
}

int spng_set_sbit(spng_ctx *ctx, struct spng_sbit *sbit)
{
  int __retres;
  int tmp_0;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (sbit == (struct spng_sbit *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary2(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  tmp_0 = check_sbit((struct spng_sbit const *)sbit,
                     (struct spng_ihdr const *)(& ctx->ihdr));
  if (tmp_0) {
    __retres = 1;
    goto return_label;
  }
  if (! ctx->stored.ihdr) {
    __retres = 1;
    goto return_label;
  }
  memcpy((void *)(& ctx->sbit),(void const *)sbit,sizeof(struct spng_sbit));
  ctx->stored.sbit = (unsigned int)1;
  ctx->user.sbit = (unsigned int)1;
  __retres = 0;
  return_label: return __retres;
}

int spng_set_srgb(spng_ctx *ctx, uint8_t rendering_intent)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (ctx == (spng_ctx *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary2(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  if ((int)rendering_intent > 3) {
    __retres = 1;
    goto return_label;
  }
  ctx->srgb_rendering_intent = rendering_intent;
  ctx->stored.srgb = (unsigned int)1;
  ctx->user.srgb = (unsigned int)1;
  __retres = 0;
  return_label: return __retres;
}

int spng_set_text(spng_ctx *ctx, struct spng_text *text, uint32_t n_text)
{
  int __retres;
  uint32_t i;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (text == (struct spng_text *)0) {
      __retres = 1;
      goto return_label;
    }
    else 
      if (! n_text) {
        __retres = 1;
        goto return_label;
      }
  int ret = get_ancillary2(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  i = (uint32_t)0;
  while (i < n_text) {
    {
      int tmp_0;
      tmp_0 = check_png_keyword((char const *)((text + i)->keyword));
      if (tmp_0) {
        __retres = SPNG_ETEXT_KEYWORD;
        goto return_label;
      }
      if (! (text + i)->length) {
        __retres = 1;
        goto return_label;
      }
      if ((text + i)->text == (char *)0) {
        __retres = 1;
        goto return_label;
      }
      if ((text + i)->type == SPNG_TEXT) {
        int tmp_1;
        tmp_1 = check_png_text((char const *)(text + i)->text,
                               (text + i)->length);
        if (tmp_1) {
          __retres = 1;
          goto return_label;
        }
      }
      else 
        if ((text + i)->type == SPNG_ZTXT) {
          int tmp_2;
          tmp_2 = check_png_text((char const *)(text + i)->text,
                                 (text + i)->length);
          if (tmp_2) {
            __retres = 1;
            goto return_label;
          }
          if ((int)(text + i)->compression_method != 0) {
            __retres = 1;
            goto return_label;
          }
        }
        else 
          if ((text + i)->type == SPNG_ITXT) {
            if ((int)(text + i)->compression_flag > 1) {
              __retres = 1;
              goto return_label;
            }
            if ((int)(text + i)->compression_method != 0) {
              __retres = 1;
              goto return_label;
            }
            if ((text + i)->language_tag == (char *)0) {
              __retres = SPNG_EITXT_LANG_TAG;
              goto return_label;
            }
            if ((text + i)->translated_keyword == (char *)0) {
              __retres = SPNG_EITXT_TRANSLATED_KEY;
              goto return_label;
            }
          }
          else {
            __retres = 1;
            goto return_label;
          }
    }
    i ++;
  }
  if (ctx->text_list != (struct spng_text *)0) 
    if (! ctx->user.text) {
      i = (uint32_t)0;
      while (i < ctx->n_text) {
        if ((ctx->text_list + i)->text != (char *)0) spng__free(ctx,
                                                                (void *)(
                                                                ctx->text_list + i)->text);
        if ((ctx->text_list + i)->language_tag != (char *)0) spng__free
                                                             (ctx,
                                                              (void *)(
                                                              ctx->text_list + i)->language_tag);
        if ((ctx->text_list + i)->translated_keyword != (char *)0) spng__free
                                                                   (ctx,
                                                                    (void *)(
                                                                    ctx->text_list + i)->translated_keyword);
        i ++;
      }
      spng__free(ctx,(void *)ctx->text_list);
    }
  ctx->text_list = text;
  ctx->n_text = n_text;
  ctx->stored.text = (unsigned int)1;
  ctx->user.text = (unsigned int)1;
  __retres = 0;
  return_label: return __retres;
}

int spng_set_bkgd(spng_ctx *ctx, struct spng_bkgd *bkgd)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (bkgd == (struct spng_bkgd *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary2(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  if (! ctx->stored.ihdr) {
    __retres = 1;
    goto return_label;
  }
  uint16_t mask = (uint16_t)(~ 0);
  if ((int)ctx->ihdr.bit_depth < 16) mask = (uint16_t)((1 << (int)ctx->ihdr.bit_depth) - 1);
  if ((int)ctx->ihdr.color_type == 0) goto _LOR_0;
  else 
    if ((int)ctx->ihdr.color_type == 4) _LOR_0:
                                        bkgd->gray = (uint16_t)((int)bkgd->gray & (int)mask);
    else 
      if ((int)ctx->ihdr.color_type == 2) goto _LOR;
      else 
        if ((int)ctx->ihdr.color_type == 6) {
          _LOR:
          {
            bkgd->red = (uint16_t)((int)bkgd->red & (int)mask);
            bkgd->green = (uint16_t)((int)bkgd->green & (int)mask);
            bkgd->blue = (uint16_t)((int)bkgd->blue & (int)mask);
          }
        }
        else 
          if ((int)ctx->ihdr.color_type == 3) {
            if (! ctx->stored.bkgd) {
              __retres = SPNG_EBKGD_NO_PLTE;
              goto return_label;
            }
            if ((uint32_t)bkgd->plte_index >= ctx->plte.n_entries) {
              __retres = SPNG_EBKGD_PLTE_IDX;
              goto return_label;
            }
          }
  memcpy((void *)(& ctx->bkgd),(void const *)bkgd,sizeof(struct spng_bkgd));
  ctx->stored.bkgd = (unsigned int)1;
  ctx->user.bkgd = (unsigned int)1;
  __retres = 0;
  return_label: return __retres;
}

int spng_set_hist(spng_ctx *ctx, struct spng_hist *hist)
{
  int __retres;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (hist == (struct spng_hist *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary2(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  if (! ctx->stored.plte) {
    __retres = SPNG_EHIST_NO_PLTE;
    goto return_label;
  }
  memcpy((void *)(& ctx->hist),(void const *)hist,sizeof(struct spng_hist));
  ctx->stored.hist = (unsigned int)1;
  ctx->user.hist = (unsigned int)1;
  __retres = 0;
  return_label: return __retres;
}

int spng_set_phys(spng_ctx *ctx, struct spng_phys *phys)
{
  int __retres;
  int tmp_0;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (phys == (struct spng_phys *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary2(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  tmp_0 = check_phys((struct spng_phys const *)phys);
  if (tmp_0) {
    __retres = SPNG_EPHYS;
    goto return_label;
  }
  memcpy((void *)(& ctx->phys),(void const *)phys,sizeof(struct spng_phys));
  ctx->stored.phys = (unsigned int)1;
  ctx->user.phys = (unsigned int)1;
  __retres = 0;
  return_label: return __retres;
}

int spng_set_splt(spng_ctx *ctx, struct spng_splt *splt, uint32_t n_splt)
{
  int __retres;
  uint32_t i;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (splt == (struct spng_splt *)0) {
      __retres = 1;
      goto return_label;
    }
    else 
      if (! n_splt) {
        __retres = 1;
        goto return_label;
      }
  int ret = get_ancillary2(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  i = (uint32_t)0;
  while (i < n_splt) {
    {
      int tmp_0;
      tmp_0 = check_png_keyword((char const *)((splt + i)->name));
      if (tmp_0) {
        __retres = SPNG_ESPLT_NAME;
        goto return_label;
      }
      if (! ((int)(splt + i)->sample_depth == 8)) 
        if (! ((int)(splt + i)->sample_depth == 16)) {
          __retres = SPNG_ESPLT_DEPTH;
          goto return_label;
        }
    }
    i ++;
  }
  if (ctx->stored.splt) 
    if (! ctx->user.splt) {
      i = (uint32_t)0;
      while (i < ctx->n_splt) {
        if ((ctx->splt_list + i)->entries != (struct spng_splt_entry *)0) 
          spng__free(ctx,(void *)(ctx->splt_list + i)->entries);
        i ++;
      }
      spng__free(ctx,(void *)ctx->splt_list);
    }
  ctx->splt_list = splt;
  ctx->n_splt = n_splt;
  ctx->stored.splt = (unsigned int)1;
  ctx->user.splt = (unsigned int)1;
  __retres = 0;
  return_label: return __retres;
}

int spng_set_time(spng_ctx *ctx, struct spng_time *time)
{
  int __retres;
  int tmp_0;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (time == (struct spng_time *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary2(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  tmp_0 = check_time((struct spng_time const *)time);
  if (tmp_0) {
    __retres = SPNG_ETIME;
    goto return_label;
  }
  memcpy((void *)(& ctx->time),(void const *)time,sizeof(struct spng_time));
  ctx->stored.time = (unsigned int)1;
  ctx->user.time = (unsigned int)1;
  __retres = 0;
  return_label: return __retres;
}

int spng_set_offs(spng_ctx *ctx, struct spng_offs *offs)
{
  int __retres;
  int tmp_0;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (offs == (struct spng_offs *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary2(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  tmp_0 = check_offs((struct spng_offs const *)offs);
  if (tmp_0) {
    __retres = SPNG_EOFFS;
    goto return_label;
  }
  memcpy((void *)(& ctx->offs),(void const *)offs,sizeof(struct spng_offs));
  ctx->stored.offs = (unsigned int)1;
  ctx->user.offs = (unsigned int)1;
  __retres = 0;
  return_label: return __retres;
}

int spng_set_exif(spng_ctx *ctx, struct spng_exif *exif)
{
  int __retres;
  int tmp_0;
  if (ctx == (spng_ctx *)0) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (exif == (struct spng_exif *)0) {
      __retres = 1;
      goto return_label;
    }
  int ret = get_ancillary2(ctx);
  if (ret) {
    __retres = ret;
    goto return_label;
  }
  tmp_0 = check_exif((struct spng_exif const *)exif);
  if (tmp_0) {
    __retres = SPNG_EEXIF;
    goto return_label;
  }
  if (ctx->exif.data != (char *)0) 
    if (! ctx->user.exif) spng__free(ctx,(void *)ctx->exif.data);
  memcpy((void *)(& ctx->exif),(void const *)exif,sizeof(struct spng_exif));
  ctx->stored.exif = (unsigned int)1;
  ctx->user.exif = (unsigned int)1;
  __retres = 0;
  return_label: return __retres;
}

char const *spng_strerror(int err)
{
  char const *__retres;
  switch (err) {
    case SPNG_IO_EOF: __retres = "end of stream";
    goto return_label;
    case SPNG_IO_ERROR: __retres = "stream error";
    goto return_label;
    case SPNG_OK: __retres = "success";
    goto return_label;
    case SPNG_EINVAL: __retres = "invalid argument";
    goto return_label;
    case SPNG_EMEM: __retres = "out of memory";
    goto return_label;
    case SPNG_EOVERFLOW: __retres = "arithmetic overflow";
    goto return_label;
    case SPNG_ESIGNATURE: __retres = "invalid signature";
    goto return_label;
    case SPNG_EWIDTH: __retres = "invalid image width";
    goto return_label;
    case SPNG_EHEIGHT: __retres = "invalid image height";
    goto return_label;
    case SPNG_EUSER_WIDTH: __retres = "image width exceeds user limit";
    goto return_label;
    case SPNG_EUSER_HEIGHT: __retres = "image height exceeds user limit";
    goto return_label;
    case SPNG_EBIT_DEPTH: __retres = "invalid bit depth";
    goto return_label;
    case SPNG_ECOLOR_TYPE: __retres = "invalid color type";
    goto return_label;
    case SPNG_ECOMPRESSION_METHOD: __retres = "invalid compression method";
    goto return_label;
    case SPNG_EFILTER_METHOD: __retres = "invalid filter method";
    goto return_label;
    case SPNG_EINTERLACE_METHOD: __retres = "invalid interlace method";
    goto return_label;
    case SPNG_EIHDR_SIZE: __retres = "invalid IHDR chunk size";
    goto return_label;
    case SPNG_ENOIHDR: __retres = "missing IHDR chunk";
    goto return_label;
    case SPNG_ECHUNK_POS: __retres = "invalid chunk position";
    goto return_label;
    case SPNG_ECHUNK_SIZE: __retres = "invalid chunk length";
    goto return_label;
    case SPNG_ECHUNK_CRC: __retres = "invalid chunk checksum";
    goto return_label;
    case SPNG_ECHUNK_TYPE: __retres = "invalid chunk type";
    goto return_label;
    case SPNG_ECHUNK_UNKNOWN_CRITICAL: __retres = "unknown critical chunk";
    goto return_label;
    case SPNG_EDUP_PLTE: __retres = "duplicate PLTE chunk";
    goto return_label;
    case SPNG_EDUP_CHRM: __retres = "duplicate cHRM chunk";
    goto return_label;
    case SPNG_EDUP_GAMA: __retres = "duplicate gAMA chunk";
    goto return_label;
    case SPNG_EDUP_ICCP: __retres = "duplicate iCCP chunk";
    goto return_label;
    case SPNG_EDUP_SBIT: __retres = "duplicate sBIT chunk";
    goto return_label;
    case SPNG_EDUP_SRGB: __retres = "duplicate sRGB chunk";
    goto return_label;
    case SPNG_EDUP_BKGD: __retres = "duplicate bKGD chunk";
    goto return_label;
    case SPNG_EDUP_HIST: __retres = "duplicate hIST chunk";
    goto return_label;
    case SPNG_EDUP_TRNS: __retres = "duplicate tRNS chunk";
    goto return_label;
    case SPNG_EDUP_PHYS: __retres = "duplicate pHYs chunk";
    goto return_label;
    case SPNG_EDUP_TIME: __retres = "duplicate tIME chunk";
    goto return_label;
    case SPNG_EDUP_OFFS: __retres = "duplicate oFFs chunk";
    goto return_label;
    case SPNG_EDUP_EXIF: __retres = "duplicate eXIf chunk";
    goto return_label;
    case SPNG_ECHRM: __retres = "invalid cHRM chunk";
    goto return_label;
    case SPNG_EPLTE_IDX: __retres = "invalid palette (PLTE) index";
    goto return_label;
    case SPNG_ETRNS_COLOR_TYPE:
    __retres = "tRNS chunk with incompatible color type";
    goto return_label;
    case SPNG_ETRNS_NO_PLTE:
    __retres = "missing palette (PLTE) for tRNS chunk";
    goto return_label;
    case SPNG_EGAMA: __retres = "invalid gAMA chunk";
    goto return_label;
    case SPNG_EICCP_NAME: __retres = "invalid iCCP profile name";
    goto return_label;
    case SPNG_EICCP_COMPRESSION_METHOD:
    __retres = "invalid iCCP compression method";
    goto return_label;
    case SPNG_ESBIT: __retres = "invalid sBIT chunk";
    goto return_label;
    case SPNG_ESRGB: __retres = "invalid sRGB chunk";
    goto return_label;
    case SPNG_ETEXT: __retres = "invalid tEXt chunk";
    goto return_label;
    case SPNG_ETEXT_KEYWORD: __retres = "invalid tEXt keyword";
    goto return_label;
    case SPNG_EZTXT: __retres = "invalid zTXt chunk";
    goto return_label;
    case SPNG_EZTXT_COMPRESSION_METHOD:
    __retres = "invalid zTXt compression method";
    goto return_label;
    case SPNG_EITXT: __retres = "invalid iTXt chunk";
    goto return_label;
    case SPNG_EITXT_COMPRESSION_FLAG:
    __retres = "invalid iTXt compression flag";
    goto return_label;
    case SPNG_EITXT_COMPRESSION_METHOD:
    __retres = "invalid iTXt compression method";
    goto return_label;
    case SPNG_EITXT_LANG_TAG: __retres = "invalid iTXt language tag";
    goto return_label;
    case SPNG_EITXT_TRANSLATED_KEY: __retres = "invalid iTXt translated key";
    goto return_label;
    case SPNG_EBKGD_NO_PLTE: __retres = "missing palette for bKGD chunk";
    goto return_label;
    case SPNG_EBKGD_PLTE_IDX:
    __retres = "invalid palette index for bKGD chunk";
    goto return_label;
    case SPNG_EHIST_NO_PLTE: __retres = "missing palette for hIST chunk";
    goto return_label;
    case SPNG_EPHYS: __retres = "invalid pHYs chunk";
    goto return_label;
    case SPNG_ESPLT_NAME: __retres = "invalid suggested palette name";
    goto return_label;
    case SPNG_ESPLT_DUP_NAME:
    __retres = "duplicate suggested palette (sPLT) name";
    goto return_label;
    case SPNG_ESPLT_DEPTH:
    __retres = "invalid suggested palette (sPLT) sample depth";
    goto return_label;
    case SPNG_ETIME: __retres = "invalid tIME chunk";
    goto return_label;
    case SPNG_EOFFS: __retres = "invalid oFFs chunk";
    goto return_label;
    case SPNG_EEXIF: __retres = "invalid eXIf chunk";
    goto return_label;
    case SPNG_EIDAT_TOO_SHORT: __retres = "IDAT stream too short";
    goto return_label;
    case SPNG_EIDAT_STREAM: __retres = "IDAT stream error";
    goto return_label;
    case SPNG_EZLIB: __retres = "zlib error";
    goto return_label;
    case SPNG_EFILTER: __retres = "invalid scanline filter";
    goto return_label;
    case SPNG_EBUFSIZ: __retres = "output buffer too small";
    goto return_label;
    case SPNG_EIO: __retres = "i/o error";
    goto return_label;
    case SPNG_EOF: __retres = "end of file";
    goto return_label;
    case SPNG_EBUF_SET: __retres = "buffer already set";
    goto return_label;
    case SPNG_EBADSTATE: __retres = "non-recoverable state";
    goto return_label;
    case SPNG_EFMT: __retres = "invalid format";
    goto return_label;
    case SPNG_EFLAGS: __retres = "invalid flags";
    goto return_label;
    case SPNG_ECHUNKAVAIL: __retres = "chunk not available";
    goto return_label;
    case SPNG_ENCODE_ONLY: __retres = "encode only context";
    goto return_label;
    default: __retres = "unknown error";
    goto return_label;
  }
  return_label: return __retres;
}

char const *spng_version_string(void)
{
  char const *__retres;
  __retres = "0.5.1";
  return __retres;
}


