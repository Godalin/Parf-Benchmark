/* Generated by Frama-C */
#include "errno.h"
#include "inttypes.h"
#include "math.c"
#include "math.h"
#include "stdint.h"
typedef uint8_t bool_t;
struct AdMsg {
   uint8_t len ;
   uint8_t const *data ;
};
struct adc_buf {
   uint16_t sum ;
   uint16_t values[0x20] ;
   uint8_t head ;
};
typedef int16_t pprz_t;
struct inter_mcu_msg {
   int16_t channels[9] ;
   uint8_t ppm_cpt ;
   uint8_t status ;
   uint8_t nb_err ;
   uint8_t vsupply ;
};
struct point {
   float x ;
   float y ;
   float a ;
};
__inline static void timer_enable_int(unsigned char ints)
{
  *((uint8_t volatile *)(0x37 + 0x20)) = ints;
  return;
}

uint16_t ad7714_sample;
uint8_t ad7714_sample_read;
void ad7714_init(void);

void ad7714_on_spi_it(void);

void ad7714_on_it(void);

uint8_t volatile spi_cur_slave;

uint8_t spi_nb_ovrn;

void spi_init(void);

uint8_t const ad7714_setup_data[6] =
  {(uint8_t)((2 << 4) + (4 << 0)),
   (uint8_t)0xA7,
   (uint8_t)((3 << 4) + (4 << 0)),
   (uint8_t)0xD0,
   (uint8_t)((1 << 4) + (4 << 0)),
   (uint8_t)((1 << 5) + (7 << 2))};
struct AdMsg const ad7714_setup =
  {.len = (uint8_t)6, .data = ad7714_setup_data};
uint8_t const ad7714_read_data[3] =
  {(uint8_t)(((5 << 4) + (1 << 3)) + (4 << 0)), (uint8_t)0x00, (uint8_t)0xAA};
struct AdMsg const ad7714_read =
  {.len = (uint8_t)3, .data = ad7714_read_data};
uint8_t const ad7714_select_channel_data[2] =
  {(uint8_t)((1 << 4) + (4 << 0)), (uint8_t)((0 << 5) + (7 << 2))};
struct AdMsg const ad7714_select_channel =
  {.len = (uint8_t)2, .data = ad7714_select_channel_data};
static struct AdMsg *msg;
static uint8_t idx;
void ad7714_start_transmitting(struct AdMsg const *amsg)
{
  {
    uint8_t foo;
    *((uint8_t volatile *)(0x0D + 0x20)) = (uint8_t)((((((1 << 6) | (1 << 4)) | (
                                                        1 << 1)) | (1 << 3)) | (
                                                      1 << 2)) | (1 << 0));
    if ((int)*((uint8_t volatile *)(0x0E + 0x20)) & (1 << 7)) foo = *((uint8_t volatile *)(
                                                              0x0F + 0x20));
    *((uint8_t volatile *)(0x0D + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                     0x0D + 0x20)) | (
                                                     1 << 7));
  }
  spi_cur_slave = (uint8_t)2;
  *((uint8_t volatile *)(0x03 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                   0x03 + 0x20)) & ~ (
                                                   1 << 7));
  msg = (struct AdMsg *)amsg;
  *((uint8_t volatile *)(0x0F + 0x20)) = *(msg->data + 0);
  idx = (uint8_t)0;
  return;
}

void ad7714_on_spi_it(void)
{
  uint8_t spi_read = *((uint8_t volatile *)(0x0F + 0x20));
  if ((void *)msg == (void *)(& ad7714_read)) 
    if ((int)idx == 1) ad7714_sample = (uint16_t)((int)spi_read << 8);
    else 
      if ((int)idx == 2) {
        ad7714_sample = (uint16_t)((int)ad7714_sample + (int)spi_read);
        ad7714_sample_read = (uint8_t)(! 0);
      }
  idx = (uint8_t)((int)idx + 1);
  if ((int)idx < (int)msg->len) *((uint8_t volatile *)(0x0F + 0x20)) = *(
                                msg->data + idx);
  else {
    spi_cur_slave = (uint8_t)0;
    *((uint8_t volatile *)(0x03 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                     0x03 + 0x20)) | (
                                                     1 << 7));
    *((uint8_t volatile *)(0x0D + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                     0x0D + 0x20)) & ~ (
                                                     1 << 7));
    *((uint8_t volatile *)(0x0D + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                     0x0D + 0x20)) & ~ (
                                                     1 << 6));
  }
  return;
}

uint8_t ad7714_status = (uint8_t)0;
void ad7714_on_it(void)
{
  if ((int)ad7714_status == 0) ad7714_start_transmitting(& ad7714_setup);
  else 
    if ((int)ad7714_status == 1) ad7714_start_transmitting(& ad7714_select_channel);
    else ad7714_start_transmitting(& ad7714_read);
  ad7714_status = (uint8_t)((int)ad7714_status + 1);
  return;
}

void ad7714_init(void)
{
  *((uint8_t volatile *)(0x3A + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                   0x3A + 0x20)) & ~ (
                                                   1 << 4));
  *((uint8_t volatile *)(0x3A + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                   0x3A + 0x20)) | (1 << 5));
  *((uint8_t volatile *)(0x39 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                   0x39 + 0x20)) | (1 << 6));
  return;
}

void __vector_7(void) __attribute__((__signal__));

void __vector_7(void) __attribute__((__signal__));
void __vector_7(void)
{
  ad7714_on_it();
  return;
}

__inline static void timer_enable_int_0(unsigned char ints)
{
  *((uint8_t volatile *)(0x37 + 0x20)) = ints;
  return;
}

uint16_t adc_samples[8];
void adc_init(void);

void adc_buf_channel(uint8_t adc_channel, struct adc_buf *s);

static struct adc_buf *buffers[8];
void adc_buf_channel(uint8_t adc_channel, struct adc_buf *s)
{
  buffers[adc_channel] = s;
  return;
}

void adc_init(void)
{
  uint8_t i;
  *((uint8_t volatile *)0x62) = (uint8_t)0x00;
  *((uint8_t volatile *)0x61) = (uint8_t)0x00;
  *((uint8_t volatile *)(0x07 + 0x20)) = (uint8_t)(1 << 6);
  *((uint8_t volatile *)(0x08 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                   0x08 + 0x20)) | (1 << 7));
  *((uint8_t volatile *)(0x06 + 0x20)) = (uint8_t)((((0 | 0x07) | (1 << 7)) | (
                                                    1 << 3)) | (1 << 6));
  i = (uint8_t)0;
  while ((int)i < 8) {
    buffers[i] = (struct adc_buf *)0;
    i = (uint8_t)((int)i + 1);
  }
  return;
}

void __vector_21(void) __attribute__((__signal__));

void __vector_21(void) __attribute__((__signal__));
void __vector_21(void)
{
  uint8_t adc_input =
    (uint8_t)((int)*((uint8_t volatile *)(0x07 + 0x20)) & 0x7);
  struct adc_buf *buf = buffers[adc_input];
  uint16_t adc_value = *((uint16_t volatile *)(0x04 + 0x20));
  adc_samples[adc_input] = adc_value;
  if (buf) {
    uint8_t new_head = (uint8_t)((int)buf->head + 1);
    if ((int)new_head >= 0x20) new_head = (uint8_t)0;
    buf->sum = (uint16_t)((int)buf->sum - (int)buf->values[new_head]);
    buf->values[new_head] = adc_value;
    buf->sum = (uint16_t)((int)buf->sum + (int)adc_value);
    buf->head = new_head;
  }
  adc_input = (uint8_t)((int)adc_input + 1);
  if ((int)adc_input >= 8) adc_input = (uint8_t)0;
  *((uint8_t volatile *)(0x07 + 0x20)) = (uint8_t)((int)adc_input | (1 << 6));
  *((uint8_t volatile *)(0x06 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                   0x06 + 0x20)) | (1 << 6));
  return;
}

double pp_sin(double x);

double pp_sqrt(double n);

double pp_atan2(double x, double y);

float estimator_x;
float estimator_y;
float estimator_z;
float estimator_phi;
float estimator_psi;
float estimator_theta;
float estimator_x_dot;
float estimator_y_dot;
float estimator_z_dot;
float estimator_phi_dot;
float estimator_psi_dot;
uint16_t estimator_flight_time;
float estimator_t;
float volatile estimator_hspeed_mod;
float estimator_hspeed_dir;
void estimator_init(void);

void estimator_update_state_infrared(void);

void estimator_update_state_gps(void);

void estimator_propagate_state(void);

float estimator_rad_of_ir;
float estimator_ir;
float estimator_rad;
uint8_t volatile gps_mode;

float gps_ftow;

float gps_falt;

float gps_fspeed;

float gps_fclimb;

float gps_fcourse;

int32_t gps_utm_east;

int32_t gps_utm_north;

float gps_east;

float gps_north;

void gps_init(void);

void parse_gps_msg(void);

uint8_t volatile gps_msg_received;

bool_t gps_pos_available;

uint8_t gps_nb_ovrn;

int32_t const utm_east0;

int32_t const utm_north0;

float desired_roll;

float max_roll;

float desired_pitch;

float roll_pgain;

float pitch_pgain;

float pitch_of_roll;

void roll_pitch_pid_run(void);

float course_pgain;

float desired_course;

void course_pid_run(void);

float const climb_pgain;

float const climb_igain;

float climb_sum_err;

float desired_climb;

float pre_climb;

int16_t desired_gaz;

int16_t desired_aileron;

int16_t desired_elevator;

float pitch_of_vz_pgain;

float pitch_of_vz;

void climb_pid_run(void);

void altitude_pid_run(void);

int16_t ir_roll;

int16_t ir_pitch;

float ir_rad_of_ir;

int16_t ir_contrast;

int16_t ir_roll_neutral;

int16_t ir_pitch_neutral;

void ir_init(void);

void ir_update(void);

void ir_gain_calib(void);

uint8_t pprz_mode;

uint8_t ir_estim_mode;

uint8_t fatal_error_nb;

uint8_t inflight_calib_mode;

uint8_t vertical_mode;

bool_t auto_pitch;

uint8_t lateral_mode;

uint8_t vsupply;

bool_t rc_event_1;

bool_t rc_event_2;

float slider_1_val;

float slider_2_val;

bool_t launch;

void periodic_task(void);

void radio_control_task(void);

void send_gps_pos(void);

void send_radIR(void);

void send_takeOff(void);

void stabilisation_task(void);

float estimator_theta_dot;
void estimator_init(void)
{
  estimator_x = (float)0.;
  estimator_y = (float)0.;
  estimator_z = (float)0.;
  estimator_phi = (float)0.;
  estimator_psi = (float)0.;
  estimator_theta = (float)0;
  estimator_hspeed_mod = (float)0.;
  estimator_hspeed_dir = (float)0.;
  estimator_z_dot = (float)0.;
  estimator_phi_dot = (float)0.;
  estimator_psi_dot = (float)0.;
  estimator_theta_dot = (float)0.;
  estimator_flight_time = (uint16_t)0;
  estimator_rad_of_ir = ir_rad_of_ir;
  return;
}

void estimator_update_state_infrared(void)
{
  float tmp;
  if ((int)ir_estim_mode == 1) 
    if (! 0) tmp = estimator_rad_of_ir; else tmp = ir_rad_of_ir;
  else tmp = ir_rad_of_ir;
  float rad_of_ir = tmp;
  estimator_phi = rad_of_ir * (float)ir_roll;
  estimator_theta = rad_of_ir * (float)ir_pitch;
  return;
}

static float estimator_update_ir_estim_last_hspeed_dir;
static float estimator_update_ir_estim_last_t;
void estimator_update_ir_estim(void);

static bool_t estimator_update_ir_estim_initialized = (bool_t)0;
static float estimator_update_ir_estim_sum_xy;
static float estimator_update_ir_estim_sum_xx;
void estimator_update_ir_estim(void)
{
  float absphi;
  float init_ir2;
  if (estimator_update_ir_estim_initialized) {
    float dt = gps_ftow - estimator_update_ir_estim_last_t;
    if ((double)dt > 0.1) {
      float phi =
        estimator_hspeed_dir - estimator_update_ir_estim_last_hspeed_dir;
      while ((double)phi > 0x1.921fb54442d18p1) phi = (float)((double)phi - 
                                                              (double)2 * 0x1.921fb54442d18p1);
      while ((double)phi < - 0x1.921fb54442d18p1) phi = (float)((double)phi + 
                                                                (double)2 * 0x1.921fb54442d18p1);
      phi = (float)(((double)(phi / dt) * 10.) / 9.81);
      while ((double)phi > 0x1.921fb54442d18p1) phi = (float)((double)phi - 
                                                              (double)2 * 0x1.921fb54442d18p1);
      while ((double)phi < - 0x1.921fb54442d18p1) phi = (float)((double)phi + 
                                                                (double)2 * 0x1.921fb54442d18p1);
      estimator_ir = (float)ir_roll;
      estimator_rad = phi;
      if ((double)phi < 0.) absphi = - phi; else absphi = phi;
      if ((double)absphi < 1.0) 
        if ((double)absphi > 0.05) 
          if (- ((int)ir_contrast) / 2 < (int)ir_roll) 
            if ((int)ir_roll < (int)ir_contrast / 2) {
              estimator_update_ir_estim_sum_xy = (float)((double)(estimator_rad * estimator_ir) + 
                                                         0.999 * (double)estimator_update_ir_estim_sum_xy);
              estimator_update_ir_estim_sum_xx = (float)((double)(estimator_ir * estimator_ir) + 
                                                         0.999 * (double)estimator_update_ir_estim_sum_xx);
              estimator_rad_of_ir = estimator_update_ir_estim_sum_xy / estimator_update_ir_estim_sum_xx;
            }
    }
  }
  else {
    estimator_update_ir_estim_initialized = (bool_t)(! 0);
    init_ir2 = (float)ir_contrast;
    init_ir2 *= init_ir2;
    estimator_update_ir_estim_sum_xy = (float)((100. * (double)estimator_rad_of_ir) * (double)init_ir2);
    estimator_update_ir_estim_sum_xx = (float)(100. * (double)init_ir2);
  }
  estimator_update_ir_estim_last_hspeed_dir = estimator_hspeed_dir;
  estimator_update_ir_estim_last_t = gps_ftow;
  return;
}

void estimator_update_state_gps(void)
{
  if ((int)gps_mode == 3) {
    estimator_x = gps_east;
    estimator_y = gps_north;
    estimator_z = gps_falt;
    estimator_hspeed_mod = gps_fspeed;
    estimator_hspeed_dir = gps_fcourse;
    estimator_z_dot = gps_fclimb;
    if (estimator_flight_time) estimator_update_ir_estim();
  }
  return;
}

void estimator_propagate_state(void)
{
  return;
}

__inline static void timer_enable_int_1(unsigned char ints)
{
  *((uint8_t volatile *)(0x37 + 0x20)) = ints;
  return;
}

void uart0_init(void);

void uart1_init(void);

void uart0_print_string(uint8_t const *s);

void uart0_print_hex(uint8_t const c);

void uart0_transmit(unsigned char data);

void uart1_transmit(unsigned char data);

uint8_t volatile gps_mode;
float gps_ftow;
float gps_falt;
float gps_fspeed;
float gps_fclimb;
float gps_fcourse;
int32_t gps_utm_east;
int32_t gps_utm_north;
float gps_east;
float gps_north;
uint8_t volatile gps_msg_received;
bool_t gps_pos_available;
uint8_t gps_nb_ovrn;
int32_t const utm_east0 = 605530;
int32_t const utm_north0 = 5797350;
static uint8_t ubx_msg_buf[255];
static uint8_t volatile ubx_status;
static uint16_t ubx_len;
static uint8_t ubx_msg_idx;
static uint8_t volatile ck_a_0;
static uint8_t volatile ck_b_0;
static uint8_t volatile ubx_id;
static uint8_t volatile ubx_class;
void gps_init(void)
{
  uart1_init();
  ubx_status = (uint8_t)0;
  return;
}

static void parse_ubx(uint8_t c);

void parse_gps_msg(void)
{
  uint8_t c = *((uint8_t volatile *)0x9C);
  parse_ubx(c);
  if ((int)ubx_class == 0x01) 
    if ((int)ubx_id == 0x08) {
      gps_utm_east = *((int32_t *)(& ubx_msg_buf[4]));
      gps_utm_north = *((int32_t *)(& ubx_msg_buf[8]));
      gps_falt = (float)((double)((float)*((int32_t *)(& ubx_msg_buf[12]))) / 100.);
    }
    else 
      if ((int)ubx_id == 0x03) gps_mode = ubx_msg_buf[4];
      else 
        if ((int)ubx_id == 0x12) {
          gps_fspeed = (float)((double)((float)*((uint32_t *)(& ubx_msg_buf[20]))) / 1e2);
          gps_fclimb = (float)((double)((float)*((int32_t *)(& ubx_msg_buf[12]))) / - 1e2);
          gps_fcourse = (float)((((double)((float)*((int32_t *)(& ubx_msg_buf[24]))) / 1e5) / 180.) * 3.1415927);
          gps_ftow = (float)((double)((float)*((uint32_t *)(& ubx_msg_buf[0]))) / 1e3);
          gps_east = (float)(gps_utm_east / 100 - 605530);
          gps_north = (float)(gps_utm_north / 100 - 5797350);
          gps_pos_available = (bool_t)(! 0);
        }
  return;
}

static void parse_ubx(uint8_t c)
{
  if ((int)ubx_status < 7) {
    ck_a_0 = (uint8_t)((int)ck_a_0 + (int)c);
    ck_b_0 = (uint8_t)((int)ck_b_0 + (int)ck_a_0);
  }
  if ((int)ubx_status == 0) {
    if ((int)c == 0xB5) ubx_status = (uint8_t)((int)ubx_status + 1);
  }
  else 
    if ((int)ubx_status == 1) {
      if ((int)c != 0x62) goto error;
      ck_a_0 = (uint8_t)0;
      ck_b_0 = (uint8_t)0;
      ubx_status = (uint8_t)((int)ubx_status + 1);
    }
    else 
      if ((int)ubx_status == 2) {
        if (gps_msg_received) {
          gps_nb_ovrn = (uint8_t)((int)gps_nb_ovrn + 1);
          goto error;
        }
        ubx_class = c;
        ubx_status = (uint8_t)((int)ubx_status + 1);
      }
      else 
        if ((int)ubx_status == 3) {
          ubx_id = c;
          ubx_status = (uint8_t)((int)ubx_status + 1);
        }
        else 
          if ((int)ubx_status == 4) {
            ubx_len = (uint16_t)c;
            ubx_status = (uint8_t)((int)ubx_status + 1);
          }
          else 
            if ((int)ubx_status == 5) {
              ubx_len = (uint16_t)((int)ubx_len | ((int)c << 8));
              if ((int)ubx_len > 255) goto error;
              ubx_msg_idx = (uint8_t)0;
              ubx_status = (uint8_t)((int)ubx_status + 1);
            }
            else 
              if ((int)ubx_status == 6) {
                ubx_msg_buf[ubx_msg_idx] = c;
                ubx_msg_idx = (uint8_t)((int)ubx_msg_idx + 1);
                if ((int)ubx_msg_idx >= (int)ubx_len) ubx_status = (uint8_t)(
                                                      (int)ubx_status + 1);
              }
              else 
                if ((int)ubx_status == 7) {
                  if ((int)c != (int)ck_a_0) goto error;
                  ubx_status = (uint8_t)((int)ubx_status + 1);
                }
                else 
                  if ((int)ubx_status == 8) {
                    if ((int)c != (int)ck_b_0) goto error;
                    gps_msg_received = (uint8_t)(! 0);
                    goto error;
                  }
  goto return_label;
  error: ubx_status = (uint8_t)0;
  return_label: return;
}

void __vector_30(void) __attribute__((__signal__));

void __vector_30(void) __attribute__((__signal__));
void __vector_30(void)
{
  uint8_t c = *((uint8_t volatile *)0x9C);
  parse_ubx(c);
  return;
}

void link_fbw_init(void);

void link_fbw_send(void);

void link_fbw_on_spi_it(void);

uint8_t volatile link_fbw_nb_err;

uint8_t link_fbw_fbw_nb_err;

struct inter_mcu_msg volatile from_fbw;

struct inter_mcu_msg volatile to_fbw;

uint8_t volatile link_fbw_receive_complete;

uint8_t volatile link_fbw_receive_valid;

void inflight_calib(bool_t mode_changed);

uint8_t nav_stage;

uint8_t nav_block;

float dist2_to_wp;

float dist2_to_home;

int32_t const nav_east0;

int32_t const nav_north0;

uint8_t const nb_waypoint;

struct point waypoints[7 + 1];

float desired_altitude;

float desired_x;

float desired_y;

uint16_t nav_desired_gaz;

float nav_pitch;

float rc_pitch;

bool_t too_far_from_home;

uint16_t stage_time;

uint16_t block_time;

float stage_time_ds;

float nav_desired_roll;

void nav_update(void);

void nav_home(void);

void nav_init(void);

uint8_t inflight_calib_mode = (uint8_t)0;
static int16_t slider1_init;
static int16_t slider2_init;
static int16_t inflight_calib_ir_pitch_neutral_init;
static int16_t inflight_calib_ir_roll_neutral_init;
static float inflight_calib_course_pgain_init;
static float inflight_calib_max_roll_init;
void inflight_calib(bool_t mode_changed)
{
  if ((int)pprz_mode == 1) {
    if ((int)inflight_calib_mode == 2) {
      if (mode_changed) {
        inflight_calib_ir_pitch_neutral_init = ir_pitch_neutral;
        slider1_init = from_fbw.channels[5];
      }
      ir_pitch_neutral = (int16_t)((int)inflight_calib_ir_pitch_neutral_init + (int)((int16_t)(
                                   ((double)((float)((int)from_fbw.channels[5] - (int)slider1_init)) * 60.000000) / (double)((float)(
                                   600 * 16)))));
      slider_1_val = (float)ir_pitch_neutral;
    }
    if ((int)inflight_calib_mode == 2) {
      if (mode_changed) {
        inflight_calib_ir_roll_neutral_init = ir_roll_neutral;
        slider2_init = from_fbw.channels[6];
      }
      ir_roll_neutral = (int16_t)((int)inflight_calib_ir_roll_neutral_init + (int)((int16_t)(
                                  ((double)((float)((int)from_fbw.channels[6] - (int)slider2_init)) * - 60.000000) / (double)((float)(
                                  600 * 16)))));
      slider_2_val = (float)ir_roll_neutral;
    }
  }
  if ((int)pprz_mode == 2) {
    if ((int)inflight_calib_mode == 2) {
      if (mode_changed) {
        inflight_calib_course_pgain_init = course_pgain;
        slider1_init = from_fbw.channels[5];
      }
      course_pgain = (float)((double)inflight_calib_course_pgain_init + 
                             ((double)((float)((int)from_fbw.channels[5] - (int)slider1_init)) * 0.100000) / (double)((float)(
                             600 * 16)));
      slider_1_val = course_pgain;
    }
    if ((int)inflight_calib_mode == 2) {
      if (mode_changed) {
        inflight_calib_max_roll_init = max_roll;
        slider2_init = from_fbw.channels[6];
      }
      max_roll = (float)((double)inflight_calib_max_roll_init + ((double)((float)(
                                                                 (int)from_fbw.channels[6] - (int)slider2_init)) * - 0.200000) / (double)((float)(
                                                                600 * 16)));
      slider_2_val = max_roll;
    }
  }
  return;
}

int16_t ir_roll;
int16_t ir_pitch;
int16_t ir_contrast = (int16_t)200;
int16_t ir_roll_neutral = (int16_t)(-915);
int16_t ir_pitch_neutral = (int16_t)110;
float ir_rad_of_ir = (float)(0.75 / (double)200);
static struct adc_buf buf_ir1;
static struct adc_buf buf_ir2;
void ir_init(void)
{
  ir_rad_of_ir = (float)(0.75 / (double)200);
  adc_buf_channel((uint8_t)1,& buf_ir1);
  adc_buf_channel((uint8_t)2,& buf_ir2);
  return;
}

void ir_update(void)
{
  int16_t x1_mean = (int16_t)((int)buf_ir1.sum / 0x20);
  int16_t x2_mean = (int16_t)((int)buf_ir2.sum / 0x20);
  ir_roll = (int16_t)((-1 * (int)x1_mean + -1 * (int)x2_mean) - (int)ir_roll_neutral);
  ir_pitch = (int16_t)((-1 * (int)x1_mean + 1 * (int)x2_mean) - (int)ir_pitch_neutral);
  return;
}

void ir_gain_calib(void)
{
  ir_contrast = (int16_t)(- ((int)ir_pitch));
  ir_rad_of_ir = (float)(0.75 / (double)ir_contrast);
  return;
}

__inline static void timer_enable_int_2(unsigned char ints)
{
  *((uint8_t volatile *)(0x37 + 0x20)) = ints;
  return;
}

uint8_t volatile link_fbw_nb_err;
uint8_t link_fbw_fbw_nb_err;
struct inter_mcu_msg volatile from_fbw;
struct inter_mcu_msg volatile to_fbw;
uint8_t volatile link_fbw_receive_complete = (uint8_t)(! 0);
uint8_t volatile link_fbw_receive_valid = (uint8_t)0;
static uint8_t idx_buf;
static uint8_t xor_in;
static uint8_t xor_out;
void link_fbw_init(void)
{
  uint8_t tmp = link_fbw_nb_err;
  link_fbw_receive_complete = (uint8_t)0;
  return;
}

void link_fbw_send(void)
{
  if ((int)spi_cur_slave != 0) {
    spi_nb_ovrn = (uint8_t)((int)spi_nb_ovrn + 1);
    goto return_label;
  }
  {
    uint8_t foo;
    *((uint8_t volatile *)(0x0D + 0x20)) = (uint8_t)(((1 << 6) | (1 << 4)) | (
                                                     1 << 0));
    if ((int)*((uint8_t volatile *)(0x0E + 0x20)) & (1 << 7)) foo = *((uint8_t volatile *)(
                                                              0x0F + 0x20));
    *((uint8_t volatile *)(0x0D + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                     0x0D + 0x20)) | (
                                                     1 << 7));
  }
  spi_cur_slave = (uint8_t)1;
  *((uint8_t volatile *)(0x18 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                   0x18 + 0x20)) & ~ (
                                                   1 << 0));
  idx_buf = (uint8_t)0;
  xor_in = (uint8_t)0;
  xor_out = *((uint8_t *)(& to_fbw) + idx_buf);
  *((uint8_t volatile *)(0x0F + 0x20)) = xor_out;
  link_fbw_receive_valid = (uint8_t)0;
  return_label: return;
}

void link_fbw_on_spi_it(void)
{
  *((uint16_t volatile *)(0x2A + 0x20)) = (uint16_t)((int)*((uint16_t volatile *)(
                                                     0x2C + 0x20)) + 200);
  *((uint8_t volatile *)(0x36 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                   0x36 + 0x20)) | (1 << 4));
  *((uint8_t volatile *)(0x37 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                   0x37 + 0x20)) | (1 << 4));
  return;
}

void __vector_12(void) __attribute__((__signal__));

void __vector_12(void) __attribute__((__signal__));
void __vector_12(void)
{
  uint8_t tmp;
  *((uint8_t volatile *)(0x37 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                   0x37 + 0x20)) & ~ (
                                                   1 << 4));
  idx_buf = (uint8_t)((int)idx_buf + 1);
  if ((unsigned int)idx_buf == sizeof(struct inter_mcu_msg) + (unsigned int)1) {
    tmp = *((uint8_t volatile *)(0x0F + 0x20));
    if ((int)tmp == (int)xor_in) {
      link_fbw_receive_valid = (uint8_t)(! 0);
      link_fbw_fbw_nb_err = from_fbw.nb_err;
    }
    else link_fbw_nb_err = (uint8_t)((int)link_fbw_nb_err + 1);
    link_fbw_receive_complete = (uint8_t)(! 0);
    spi_cur_slave = (uint8_t)0;
    *((uint8_t volatile *)(0x18 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                     0x18 + 0x20)) | (
                                                     1 << 0));
    *((uint8_t volatile *)(0x0D + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                     0x0D + 0x20)) & ~ (
                                                     1 << 7));
    *((uint8_t volatile *)(0x0D + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                     0x0D + 0x20)) & ~ (
                                                     1 << 6));
    goto return_label;
  }
  if ((unsigned int)idx_buf < (sizeof(struct inter_mcu_msg) + (unsigned int)1) - (unsigned int)1) {
    tmp = *((uint8_t *)(& to_fbw) + idx_buf);
    *((uint8_t volatile *)(0x0F + 0x20)) = tmp;
    xor_out = (uint8_t)((int)xor_out ^ (int)tmp);
  }
  else *((uint8_t volatile *)(0x0F + 0x20)) = xor_out;
  tmp = *((uint8_t volatile *)(0x0F + 0x20));
  *((uint8_t *)(& from_fbw) + ((int)idx_buf - 1)) = tmp;
  xor_in = (uint8_t)((int)xor_in ^ (int)tmp);
  return_label: return;
}

__inline static void timer_init(void)
{
  *((uint8_t volatile *)(0x2F + 0x20)) = (uint8_t)0x00;
  *((uint8_t volatile *)(0x2E + 0x20)) = (uint8_t)0x01;
  *((uint8_t volatile *)(0x25 + 0x20)) = (uint8_t)0x05;
  return;
}

__inline static uint16_t timer_now(void)
{
  uint16_t __retres;
  __retres = *((uint16_t volatile *)(0x2C + 0x20));
  return __retres;
}

__inline static uint16_t timer_now_non_atomic(void)
{
  uint16_t __retres;
  __retres = (uint16_t)*((uint8_t volatile *)(0x2C + 0x20));
  return __retres;
}

__inline static bool_t timer_periodic(void)
{
  bool_t __retres;
  if (! ((int)*((uint8_t volatile *)(0x36 + 0x20)) & (1 << 6))) {
    __retres = (bool_t)0;
    goto return_label;
  }
  *((uint8_t volatile *)(0x36 + 0x20)) = (uint8_t)(1 << 6);
  __retres = (bool_t)(! 0);
  return_label: return __retres;
}

void modem_init(void);

uint8_t modem_nb_ovrn;

uint8_t tx_head;

uint8_t volatile tx_tail;

uint8_t tx_buf[255];

uint8_t tx_byte;

uint8_t tx_byte_idx;

uint8_t ck_a;

uint8_t ck_b;

uint8_t vsupply;
bool_t rc_event_1;
bool_t rc_event_2;
float slider_1_val;
float slider_2_val;
uint8_t fatal_error_nb = (uint8_t)0;
static uint16_t const version = (uint16_t)1;
static uint16_t cputime = (uint16_t)0;
uint8_t pprz_mode = (uint8_t)0;
uint8_t vertical_mode = (uint8_t)0;
uint8_t lateral_mode = (uint8_t)0;
uint8_t ir_estim_mode = (uint8_t)1;
bool_t auto_pitch = (bool_t)0;
static uint8_t mcu1_status;
static uint8_t mcu1_ppm_cpt;
static bool_t low_battery = (bool_t)0;
bool_t launch = (bool_t)0;
static uint8_t boot = (uint8_t)(! 0);
static uint8_t count;
__inline static void ground_calibrate__fc_inline(void);

static uint8_t ground_calibrate_calib_status = (uint8_t)0;
__inline static void ground_calibrate__fc_inline(void)
{
  if ((int)ground_calibrate_calib_status == 0) {
    if ((int)cputime < 10) 
      if ((int)pprz_mode == 1) {
        ground_calibrate_calib_status = (uint8_t)1;
        {
          int tmp;
          if ((int)tx_head >= (int)tx_tail) tmp = 4 < 255 - ((int)tx_head - (int)tx_tail);
          else tmp = 4 < (int)tx_tail - (int)tx_head;
          if (tmp) {
            tx_buf[tx_head] = (uint8_t)0x05;
            tx_head = (uint8_t)((int)tx_head + 1);
            if ((int)tx_head >= 255) tx_head = (uint8_t)0;
            tx_buf[tx_head] = (uint8_t)2;
            tx_head = (uint8_t)((int)tx_head + 1);
            if ((int)tx_head >= 255) tx_head = (uint8_t)0;
            ck_a = (uint8_t)2;
            ck_b = (uint8_t)2;
            tx_buf[tx_head] = ck_a;
            tx_head = (uint8_t)((int)tx_head + 1);
            if ((int)tx_head >= 255) tx_head = (uint8_t)0;
            tx_buf[tx_head] = ck_b;
            tx_head = (uint8_t)((int)tx_head + 1);
            if ((int)tx_head >= 255) tx_head = (uint8_t)0;
            if (! ((int)*((uint8_t volatile *)(0x39 + 0x20)) & (1 << 4))) {
              tx_byte = tx_buf[tx_tail];
              tx_byte_idx = (uint8_t)0;
              tx_tail = (uint8_t)((int)tx_tail + 1);
              if ((int)tx_tail >= 255) tx_tail = (uint8_t)0;
              *((uint8_t volatile *)(0x38 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                               0x38 + 0x20)) | (
                                                               1 << 0));
              *((uint8_t volatile *)(0x39 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                               0x39 + 0x20)) | (
                                                               1 << 4));
            }
          }
          else modem_nb_ovrn = (uint8_t)((int)modem_nb_ovrn + 1);
        }
      }
  }
  else 
    if ((int)ground_calibrate_calib_status == 1) 
      if ((int)from_fbw.channels[1] < - (600 * 16) / 2) goto _LOR;
      else 
        if ((int)from_fbw.channels[1] > 200 * 16) {
          _LOR:
          {
            ir_gain_calib();
            estimator_rad_of_ir = ir_rad_of_ir;
            {
              int tmp_0;
              if ((int)tx_head >= (int)tx_tail) tmp_0 = 20 < 255 - ((int)tx_head - (int)tx_tail);
              else tmp_0 = 20 < (int)tx_tail - (int)tx_head;
              if (tmp_0) {
                tx_buf[tx_head] = (uint8_t)0x05;
                tx_head = (uint8_t)((int)tx_head + 1);
                if ((int)tx_head >= 255) tx_head = (uint8_t)0;
                tx_buf[tx_head] = (uint8_t)5;
                tx_head = (uint8_t)((int)tx_head + 1);
                if ((int)tx_head >= 255) tx_head = (uint8_t)0;
                ck_a = (uint8_t)5;
                ck_b = (uint8_t)5;
                tx_buf[tx_head] = *((uint8_t *)(& estimator_ir));
                ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_ir)));
                ck_b = (uint8_t)((int)ck_b + (int)ck_a);
                tx_head = (uint8_t)((int)tx_head + 1);
                if ((int)tx_head >= 255) tx_head = (uint8_t)0;
                tx_buf[tx_head] = *((uint8_t *)(& estimator_ir) + 1);
                ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_ir) + 1));
                ck_b = (uint8_t)((int)ck_b + (int)ck_a);
                tx_head = (uint8_t)((int)tx_head + 1);
                if ((int)tx_head >= 255) tx_head = (uint8_t)0;
                tx_buf[tx_head] = *((uint8_t *)(& estimator_ir) + 2);
                ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_ir) + 2));
                ck_b = (uint8_t)((int)ck_b + (int)ck_a);
                tx_head = (uint8_t)((int)tx_head + 1);
                if ((int)tx_head >= 255) tx_head = (uint8_t)0;
                tx_buf[tx_head] = *((uint8_t *)(& estimator_ir) + 3);
                ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_ir) + 3));
                ck_b = (uint8_t)((int)ck_b + (int)ck_a);
                tx_head = (uint8_t)((int)tx_head + 1);
                if ((int)tx_head >= 255) tx_head = (uint8_t)0;
                tx_buf[tx_head] = *((uint8_t *)(& estimator_rad));
                ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_rad)));
                ck_b = (uint8_t)((int)ck_b + (int)ck_a);
                tx_head = (uint8_t)((int)tx_head + 1);
                if ((int)tx_head >= 255) tx_head = (uint8_t)0;
                tx_buf[tx_head] = *((uint8_t *)(& estimator_rad) + 1);
                ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_rad) + 1));
                ck_b = (uint8_t)((int)ck_b + (int)ck_a);
                tx_head = (uint8_t)((int)tx_head + 1);
                if ((int)tx_head >= 255) tx_head = (uint8_t)0;
                tx_buf[tx_head] = *((uint8_t *)(& estimator_rad) + 2);
                ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_rad) + 2));
                ck_b = (uint8_t)((int)ck_b + (int)ck_a);
                tx_head = (uint8_t)((int)tx_head + 1);
                if ((int)tx_head >= 255) tx_head = (uint8_t)0;
                tx_buf[tx_head] = *((uint8_t *)(& estimator_rad) + 3);
                ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_rad) + 3));
                ck_b = (uint8_t)((int)ck_b + (int)ck_a);
                tx_head = (uint8_t)((int)tx_head + 1);
                if ((int)tx_head >= 255) tx_head = (uint8_t)0;
                tx_buf[tx_head] = *((uint8_t *)(& estimator_rad_of_ir));
                ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_rad_of_ir)));
                ck_b = (uint8_t)((int)ck_b + (int)ck_a);
                tx_head = (uint8_t)((int)tx_head + 1);
                if ((int)tx_head >= 255) tx_head = (uint8_t)0;
                tx_buf[tx_head] = *((uint8_t *)(& estimator_rad_of_ir) + 1);
                ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_rad_of_ir) + 1));
                ck_b = (uint8_t)((int)ck_b + (int)ck_a);
                tx_head = (uint8_t)((int)tx_head + 1);
                if ((int)tx_head >= 255) tx_head = (uint8_t)0;
                tx_buf[tx_head] = *((uint8_t *)(& estimator_rad_of_ir) + 2);
                ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_rad_of_ir) + 2));
                ck_b = (uint8_t)((int)ck_b + (int)ck_a);
                tx_head = (uint8_t)((int)tx_head + 1);
                if ((int)tx_head >= 255) tx_head = (uint8_t)0;
                tx_buf[tx_head] = *((uint8_t *)(& estimator_rad_of_ir) + 3);
                ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_rad_of_ir) + 3));
                ck_b = (uint8_t)((int)ck_b + (int)ck_a);
                tx_head = (uint8_t)((int)tx_head + 1);
                if ((int)tx_head >= 255) tx_head = (uint8_t)0;
                tx_buf[tx_head] = *((uint8_t *)(& ir_roll_neutral));
                ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& ir_roll_neutral)));
                ck_b = (uint8_t)((int)ck_b + (int)ck_a);
                tx_head = (uint8_t)((int)tx_head + 1);
                if ((int)tx_head >= 255) tx_head = (uint8_t)0;
                tx_buf[tx_head] = *((uint8_t *)(& ir_roll_neutral) + 1);
                ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& ir_roll_neutral) + 1));
                ck_b = (uint8_t)((int)ck_b + (int)ck_a);
                tx_head = (uint8_t)((int)tx_head + 1);
                if ((int)tx_head >= 255) tx_head = (uint8_t)0;
                tx_buf[tx_head] = *((uint8_t *)(& ir_pitch_neutral));
                ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& ir_pitch_neutral)));
                ck_b = (uint8_t)((int)ck_b + (int)ck_a);
                tx_head = (uint8_t)((int)tx_head + 1);
                if ((int)tx_head >= 255) tx_head = (uint8_t)0;
                tx_buf[tx_head] = *((uint8_t *)(& ir_pitch_neutral) + 1);
                ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& ir_pitch_neutral) + 1));
                ck_b = (uint8_t)((int)ck_b + (int)ck_a);
                tx_head = (uint8_t)((int)tx_head + 1);
                if ((int)tx_head >= 255) tx_head = (uint8_t)0;
                tx_buf[tx_head] = ck_a;
                tx_head = (uint8_t)((int)tx_head + 1);
                if ((int)tx_head >= 255) tx_head = (uint8_t)0;
                tx_buf[tx_head] = ck_b;
                tx_head = (uint8_t)((int)tx_head + 1);
                if ((int)tx_head >= 255) tx_head = (uint8_t)0;
                if (! ((int)*((uint8_t volatile *)(0x39 + 0x20)) & (1 << 4))) {
                  tx_byte = tx_buf[tx_tail];
                  tx_byte_idx = (uint8_t)0;
                  tx_tail = (uint8_t)((int)tx_tail + 1);
                  if ((int)tx_tail >= 255) tx_tail = (uint8_t)0;
                  *((uint8_t volatile *)(0x38 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                                   0x38 + 0x20)) | (
                                                                   1 << 0));
                  *((uint8_t volatile *)(0x39 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                                   0x39 + 0x20)) | (
                                                                   1 << 4));
                }
              }
              else modem_nb_ovrn = (uint8_t)((int)modem_nb_ovrn + 1);
            }
            ground_calibrate_calib_status = (uint8_t)2;
            {
              int tmp_1;
              if ((int)tx_head >= (int)tx_tail) tmp_1 = 6 < 255 - ((int)tx_head - (int)tx_tail);
              else tmp_1 = 6 < (int)tx_tail - (int)tx_head;
              if (tmp_1) {
                tx_buf[tx_head] = (uint8_t)0x05;
                tx_head = (uint8_t)((int)tx_head + 1);
                if ((int)tx_head >= 255) tx_head = (uint8_t)0;
                tx_buf[tx_head] = (uint8_t)3;
                tx_head = (uint8_t)((int)tx_head + 1);
                if ((int)tx_head >= 255) tx_head = (uint8_t)0;
                ck_a = (uint8_t)3;
                ck_b = (uint8_t)3;
                tx_buf[tx_head] = *((uint8_t *)(& ir_contrast));
                ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& ir_contrast)));
                ck_b = (uint8_t)((int)ck_b + (int)ck_a);
                tx_head = (uint8_t)((int)tx_head + 1);
                if ((int)tx_head >= 255) tx_head = (uint8_t)0;
                tx_buf[tx_head] = *((uint8_t *)(& ir_contrast) + 1);
                ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& ir_contrast) + 1));
                ck_b = (uint8_t)((int)ck_b + (int)ck_a);
                tx_head = (uint8_t)((int)tx_head + 1);
                if ((int)tx_head >= 255) tx_head = (uint8_t)0;
                tx_buf[tx_head] = ck_a;
                tx_head = (uint8_t)((int)tx_head + 1);
                if ((int)tx_head >= 255) tx_head = (uint8_t)0;
                tx_buf[tx_head] = ck_b;
                tx_head = (uint8_t)((int)tx_head + 1);
                if ((int)tx_head >= 255) tx_head = (uint8_t)0;
                if (! ((int)*((uint8_t volatile *)(0x39 + 0x20)) & (1 << 4))) {
                  tx_byte = tx_buf[tx_tail];
                  tx_byte_idx = (uint8_t)0;
                  tx_tail = (uint8_t)((int)tx_tail + 1);
                  if ((int)tx_tail >= 255) tx_tail = (uint8_t)0;
                  *((uint8_t volatile *)(0x38 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                                   0x38 + 0x20)) | (
                                                                   1 << 0));
                  *((uint8_t volatile *)(0x39 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                                   0x39 + 0x20)) | (
                                                                   1 << 4));
                }
              }
              else modem_nb_ovrn = (uint8_t)((int)modem_nb_ovrn + 1);
            }
          }
        }
  return;
}

__inline static uint8_t pprz_mode_update__fc_inline(void)
{
  uint8_t __retres;
  if ((int)pprz_mode != 3) goto _LOR;
  else {
    int tmp_1;
    if (rc_event_1) {
      rc_event_1 = (bool_t)0;
      tmp_1 = ! 0;
    }
    else tmp_1 = 0;
    if (tmp_1) {
      _LOR:
      {
        int tmp_0;
        if ((int)from_fbw.channels[4] > 200 * 16) tmp_0 = 2;
        else {
          int tmp;
          if ((int)from_fbw.channels[4] > - (600 * 16) / 2) tmp = 1;
          else tmp = 0;
          tmp_0 = tmp;
        }
        uint8_t new_mode = (uint8_t)tmp_0;
        if ((int)pprz_mode != (int)new_mode) {
          pprz_mode = new_mode;
          __retres = (uint8_t)(! 0);
          goto return_label;
        }
        __retres = (uint8_t)0;
        goto return_label;
      }
    }
    else {
      __retres = (uint8_t)0;
      goto return_label;
    }
  }
  return_label: return __retres;
}

__inline static uint8_t ir_estim_mode_update__fc_inline(void)
{
  uint8_t __retres;
  {
    int tmp;
    if ((int)from_fbw.channels[7] < 200 * 16) tmp = 0; else tmp = 1;
    uint8_t new_mode = (uint8_t)tmp;
    if ((int)ir_estim_mode != (int)new_mode) {
      ir_estim_mode = new_mode;
      __retres = (uint8_t)(! 0);
      goto return_label;
    }
    __retres = (uint8_t)0;
    goto return_label;
  }
  return_label: return __retres;
}

__inline static uint8_t mcu1_status_update__fc_inline(void)
{
  uint8_t __retres;
  uint8_t new_mode = from_fbw.status;
  if ((int)mcu1_status != (int)new_mode) {
    bool_t changed =
      (bool_t)(((int)mcu1_status & 0x3) != ((int)new_mode & 0x3));
    mcu1_status = new_mode;
    __retres = changed;
    goto return_label;
  }
  __retres = (uint8_t)0;
  return_label: return __retres;
}

__inline static void events_update(void);

static uint16_t events_update_event1_cpt = (uint16_t)0;
static uint16_t events_update_event2_cpt = (uint16_t)0;
__inline static void events_update(void)
{
  if ((int)inflight_calib_mode == 0) {
    if ((int)from_fbw.channels[5] > (int)(0.75 * (double)(600 * 16))) {
      if ((int)events_update_event1_cpt < 20) {
        events_update_event1_cpt = (uint16_t)((int)events_update_event1_cpt + 1);
        if ((int)events_update_event1_cpt == 20) rc_event_1 = (bool_t)(! 0);
      }
    }
    else goto _LAND;
  }
  else {
    _LAND:
    {
      events_update_event1_cpt = (uint16_t)0;
      rc_event_1 = (bool_t)0;
    }
  }
  if ((int)inflight_calib_mode == 0) {
    if ((int)from_fbw.channels[5] < (int)(- 0.75 * (double)(600 * 16))) {
      if ((int)events_update_event2_cpt < 20) {
        events_update_event2_cpt = (uint16_t)((int)events_update_event2_cpt + 1);
        if ((int)events_update_event2_cpt == 20) rc_event_2 = (bool_t)(! 0);
      }
    }
    else goto _LAND_0;
  }
  else {
    _LAND_0:
    {
      events_update_event2_cpt = (uint16_t)0;
      rc_event_2 = (bool_t)0;
    }
  }
  return;
}

__inline static void copy_from_to_fbw__fc_inline(void)
{
  to_fbw.channels[3] = from_fbw.channels[3];
  to_fbw.status = (uint8_t)0;
  return;
}

void send_boot(void)
{
  if (boot) {
    {
      int tmp;
      if ((int)tx_head >= (int)tx_tail) tmp = 6 < 255 - ((int)tx_head - (int)tx_tail);
      else tmp = 6 < (int)tx_tail - (int)tx_head;
      if (tmp) {
        tx_buf[tx_head] = (uint8_t)0x05;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = (uint8_t)1;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        ck_a = (uint8_t)1;
        ck_b = (uint8_t)1;
        tx_buf[tx_head] = *((uint8_t *)(& version));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& version)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& version) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& version) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = ck_a;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = ck_b;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        if (! ((int)*((uint8_t volatile *)(0x39 + 0x20)) & (1 << 4))) {
          tx_byte = tx_buf[tx_tail];
          tx_byte_idx = (uint8_t)0;
          tx_tail = (uint8_t)((int)tx_tail + 1);
          if ((int)tx_tail >= 255) tx_tail = (uint8_t)0;
          *((uint8_t volatile *)(0x38 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                           0x38 + 0x20)) | (
                                                           1 << 0));
          *((uint8_t volatile *)(0x39 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                           0x39 + 0x20)) | (
                                                           1 << 4));
        }
      }
      else modem_nb_ovrn = (uint8_t)((int)modem_nb_ovrn + 1);
    }
    {
      int tmp_0;
      if ((int)tx_head >= (int)tx_tail) tmp_0 = 20 < 255 - ((int)tx_head - (int)tx_tail);
      else tmp_0 = 20 < (int)tx_tail - (int)tx_head;
      if (tmp_0) {
        tx_buf[tx_head] = (uint8_t)0x05;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = (uint8_t)5;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        ck_a = (uint8_t)5;
        ck_b = (uint8_t)5;
        tx_buf[tx_head] = *((uint8_t *)(& estimator_ir));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_ir)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& estimator_ir) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_ir) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& estimator_ir) + 2);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_ir) + 2));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& estimator_ir) + 3);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_ir) + 3));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& estimator_rad));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_rad)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& estimator_rad) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_rad) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& estimator_rad) + 2);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_rad) + 2));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& estimator_rad) + 3);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_rad) + 3));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& estimator_rad_of_ir));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_rad_of_ir)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& estimator_rad_of_ir) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_rad_of_ir) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& estimator_rad_of_ir) + 2);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_rad_of_ir) + 2));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& estimator_rad_of_ir) + 3);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_rad_of_ir) + 3));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& ir_roll_neutral));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& ir_roll_neutral)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& ir_roll_neutral) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& ir_roll_neutral) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& ir_pitch_neutral));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& ir_pitch_neutral)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& ir_pitch_neutral) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& ir_pitch_neutral) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = ck_a;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = ck_b;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        if (! ((int)*((uint8_t volatile *)(0x39 + 0x20)) & (1 << 4))) {
          tx_byte = tx_buf[tx_tail];
          tx_byte_idx = (uint8_t)0;
          tx_tail = (uint8_t)((int)tx_tail + 1);
          if ((int)tx_tail >= 255) tx_tail = (uint8_t)0;
          *((uint8_t volatile *)(0x38 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                           0x38 + 0x20)) | (
                                                           1 << 0));
          *((uint8_t volatile *)(0x39 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                           0x39 + 0x20)) | (
                                                           1 << 4));
        }
      }
      else modem_nb_ovrn = (uint8_t)((int)modem_nb_ovrn + 1);
    }
    boot = (uint8_t)0;
  }
  return;
}

void send_attitude(void)
{
  if (! boot) {
    count = (uint8_t)((int)count + 1);
    if ((int)count == 250) count = (uint8_t)0;
    if ((int)count % 5 == 0) {
      int tmp;
      if ((int)tx_head >= (int)tx_tail) tmp = 16 < 255 - ((int)tx_head - (int)tx_tail);
      else tmp = 16 < (int)tx_tail - (int)tx_head;
      if (tmp) {
        tx_buf[tx_head] = (uint8_t)0x05;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = (uint8_t)6;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        ck_a = (uint8_t)6;
        ck_b = (uint8_t)6;
        tx_buf[tx_head] = *((uint8_t *)(& estimator_phi));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_phi)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& estimator_phi) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_phi) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& estimator_phi) + 2);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_phi) + 2));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& estimator_phi) + 3);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_phi) + 3));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& estimator_psi));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_psi)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& estimator_psi) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_psi) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& estimator_psi) + 2);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_psi) + 2));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& estimator_psi) + 3);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_psi) + 3));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& estimator_theta));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_theta)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& estimator_theta) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_theta) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& estimator_theta) + 2);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_theta) + 2));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& estimator_theta) + 3);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_theta) + 3));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = ck_a;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = ck_b;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        if (! ((int)*((uint8_t volatile *)(0x39 + 0x20)) & (1 << 4))) {
          tx_byte = tx_buf[tx_tail];
          tx_byte_idx = (uint8_t)0;
          tx_tail = (uint8_t)((int)tx_tail + 1);
          if ((int)tx_tail >= 255) tx_tail = (uint8_t)0;
          *((uint8_t volatile *)(0x38 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                           0x38 + 0x20)) | (
                                                           1 << 0));
          *((uint8_t volatile *)(0x39 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                           0x39 + 0x20)) | (
                                                           1 << 4));
        }
      }
      else modem_nb_ovrn = (uint8_t)((int)modem_nb_ovrn + 1);
    }
  }
  return;
}

void send_adc(void)
{
  if (! boot) 
    if ((int)count % 5 == 1) {
      int tmp;
      if ((int)tx_head >= (int)tx_tail) tmp = 8 < 255 - ((int)tx_head - (int)tx_tail);
      else tmp = 8 < (int)tx_tail - (int)tx_head;
      if (tmp) {
        tx_buf[tx_head] = (uint8_t)0x05;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = (uint8_t)7;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        ck_a = (uint8_t)7;
        ck_b = (uint8_t)7;
        tx_buf[tx_head] = *((uint8_t *)(& ir_roll));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& ir_roll)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& ir_roll) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& ir_roll) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& ir_pitch));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& ir_pitch)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& ir_pitch) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& ir_pitch) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = ck_a;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = ck_b;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        if (! ((int)*((uint8_t volatile *)(0x39 + 0x20)) & (1 << 4))) {
          tx_byte = tx_buf[tx_tail];
          tx_byte_idx = (uint8_t)0;
          tx_tail = (uint8_t)((int)tx_tail + 1);
          if ((int)tx_tail >= 255) tx_tail = (uint8_t)0;
          *((uint8_t volatile *)(0x38 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                           0x38 + 0x20)) | (
                                                           1 << 0));
          *((uint8_t volatile *)(0x39 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                           0x39 + 0x20)) | (
                                                           1 << 4));
        }
      }
      else modem_nb_ovrn = (uint8_t)((int)modem_nb_ovrn + 1);
    }
  return;
}

void send_settings(void)
{
  if (! boot) 
    if ((int)count % 5 == 2) 
      if ((int)inflight_calib_mode != 0) {
        int tmp;
        if ((int)tx_head >= (int)tx_tail) tmp = 13 < 255 - ((int)tx_head - (int)tx_tail);
        else tmp = 13 < (int)tx_tail - (int)tx_head;
        if (tmp) {
          tx_buf[tx_head] = (uint8_t)0x05;
          tx_head = (uint8_t)((int)tx_head + 1);
          if ((int)tx_head >= 255) tx_head = (uint8_t)0;
          tx_buf[tx_head] = (uint8_t)17;
          tx_head = (uint8_t)((int)tx_head + 1);
          if ((int)tx_head >= 255) tx_head = (uint8_t)0;
          ck_a = (uint8_t)17;
          ck_b = (uint8_t)17;
          tx_buf[tx_head] = inflight_calib_mode;
          ck_a = (uint8_t)((int)ck_a + (int)inflight_calib_mode);
          ck_b = (uint8_t)((int)ck_b + (int)ck_a);
          tx_head = (uint8_t)((int)tx_head + 1);
          if ((int)tx_head >= 255) tx_head = (uint8_t)0;
          tx_buf[tx_head] = *((uint8_t *)(& slider_1_val));
          ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& slider_1_val)));
          ck_b = (uint8_t)((int)ck_b + (int)ck_a);
          tx_head = (uint8_t)((int)tx_head + 1);
          if ((int)tx_head >= 255) tx_head = (uint8_t)0;
          tx_buf[tx_head] = *((uint8_t *)(& slider_1_val) + 1);
          ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& slider_1_val) + 1));
          ck_b = (uint8_t)((int)ck_b + (int)ck_a);
          tx_head = (uint8_t)((int)tx_head + 1);
          if ((int)tx_head >= 255) tx_head = (uint8_t)0;
          tx_buf[tx_head] = *((uint8_t *)(& slider_1_val) + 2);
          ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& slider_1_val) + 2));
          ck_b = (uint8_t)((int)ck_b + (int)ck_a);
          tx_head = (uint8_t)((int)tx_head + 1);
          if ((int)tx_head >= 255) tx_head = (uint8_t)0;
          tx_buf[tx_head] = *((uint8_t *)(& slider_1_val) + 3);
          ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& slider_1_val) + 3));
          ck_b = (uint8_t)((int)ck_b + (int)ck_a);
          tx_head = (uint8_t)((int)tx_head + 1);
          if ((int)tx_head >= 255) tx_head = (uint8_t)0;
          tx_buf[tx_head] = *((uint8_t *)(& slider_2_val));
          ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& slider_2_val)));
          ck_b = (uint8_t)((int)ck_b + (int)ck_a);
          tx_head = (uint8_t)((int)tx_head + 1);
          if ((int)tx_head >= 255) tx_head = (uint8_t)0;
          tx_buf[tx_head] = *((uint8_t *)(& slider_2_val) + 1);
          ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& slider_2_val) + 1));
          ck_b = (uint8_t)((int)ck_b + (int)ck_a);
          tx_head = (uint8_t)((int)tx_head + 1);
          if ((int)tx_head >= 255) tx_head = (uint8_t)0;
          tx_buf[tx_head] = *((uint8_t *)(& slider_2_val) + 2);
          ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& slider_2_val) + 2));
          ck_b = (uint8_t)((int)ck_b + (int)ck_a);
          tx_head = (uint8_t)((int)tx_head + 1);
          if ((int)tx_head >= 255) tx_head = (uint8_t)0;
          tx_buf[tx_head] = *((uint8_t *)(& slider_2_val) + 3);
          ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& slider_2_val) + 3));
          ck_b = (uint8_t)((int)ck_b + (int)ck_a);
          tx_head = (uint8_t)((int)tx_head + 1);
          if ((int)tx_head >= 255) tx_head = (uint8_t)0;
          tx_buf[tx_head] = ck_a;
          tx_head = (uint8_t)((int)tx_head + 1);
          if ((int)tx_head >= 255) tx_head = (uint8_t)0;
          tx_buf[tx_head] = ck_b;
          tx_head = (uint8_t)((int)tx_head + 1);
          if ((int)tx_head >= 255) tx_head = (uint8_t)0;
          if (! ((int)*((uint8_t volatile *)(0x39 + 0x20)) & (1 << 4))) {
            tx_byte = tx_buf[tx_tail];
            tx_byte_idx = (uint8_t)0;
            tx_tail = (uint8_t)((int)tx_tail + 1);
            if ((int)tx_tail >= 255) tx_tail = (uint8_t)0;
            *((uint8_t volatile *)(0x38 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                             0x38 + 0x20)) | (
                                                             1 << 0));
            *((uint8_t volatile *)(0x39 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                             0x39 + 0x20)) | (
                                                             1 << 4));
          }
        }
        else modem_nb_ovrn = (uint8_t)((int)modem_nb_ovrn + 1);
      }
  return;
}

void send_desired(void)
{
  if (! boot) 
    if ((int)count % 10 == 3) {
      int tmp;
      if ((int)tx_head >= (int)tx_tail) tmp = 24 < 255 - ((int)tx_head - (int)tx_tail);
      else tmp = 24 < (int)tx_tail - (int)tx_head;
      if (tmp) {
        tx_buf[tx_head] = (uint8_t)0x05;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = (uint8_t)18;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        ck_a = (uint8_t)18;
        ck_b = (uint8_t)18;
        tx_buf[tx_head] = *((uint8_t *)(& desired_roll));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_roll)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& desired_roll) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_roll) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& desired_roll) + 2);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_roll) + 2));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& desired_roll) + 3);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_roll) + 3));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& desired_pitch));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_pitch)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& desired_pitch) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_pitch) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& desired_pitch) + 2);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_pitch) + 2));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& desired_pitch) + 3);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_pitch) + 3));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& desired_x));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_x)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& desired_x) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_x) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& desired_x) + 2);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_x) + 2));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& desired_x) + 3);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_x) + 3));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& desired_y));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_y)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& desired_y) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_y) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& desired_y) + 2);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_y) + 2));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& desired_y) + 3);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_y) + 3));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& desired_altitude));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_altitude)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& desired_altitude) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_altitude) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& desired_altitude) + 2);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_altitude) + 2));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& desired_altitude) + 3);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_altitude) + 3));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = ck_a;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = ck_b;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        if (! ((int)*((uint8_t volatile *)(0x39 + 0x20)) & (1 << 4))) {
          tx_byte = tx_buf[tx_tail];
          tx_byte_idx = (uint8_t)0;
          tx_tail = (uint8_t)((int)tx_tail + 1);
          if ((int)tx_tail >= 255) tx_tail = (uint8_t)0;
          *((uint8_t volatile *)(0x38 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                           0x38 + 0x20)) | (
                                                           1 << 0));
          *((uint8_t volatile *)(0x39 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                           0x39 + 0x20)) | (
                                                           1 << 4));
        }
      }
      else modem_nb_ovrn = (uint8_t)((int)modem_nb_ovrn + 1);
    }
  return;
}

void send_bat(void)
{
  if (! boot) 
    if ((int)count % 20 == 8) {
      int tmp;
      if ((int)tx_head >= (int)tx_tail) tmp = 12 < 255 - ((int)tx_head - (int)tx_tail);
      else tmp = 12 < (int)tx_tail - (int)tx_head;
      if (tmp) {
        tx_buf[tx_head] = (uint8_t)0x05;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = (uint8_t)12;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        ck_a = (uint8_t)12;
        ck_b = (uint8_t)12;
        tx_buf[tx_head] = vsupply;
        ck_a = (uint8_t)((int)ck_a + (int)vsupply);
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& estimator_flight_time));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_flight_time)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& estimator_flight_time) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_flight_time) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = low_battery;
        ck_a = (uint8_t)((int)ck_a + (int)low_battery);
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& block_time));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& block_time)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& block_time) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& block_time) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& stage_time));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& stage_time)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& stage_time) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& stage_time) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = ck_a;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = ck_b;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        if (! ((int)*((uint8_t volatile *)(0x39 + 0x20)) & (1 << 4))) {
          tx_byte = tx_buf[tx_tail];
          tx_byte_idx = (uint8_t)0;
          tx_tail = (uint8_t)((int)tx_tail + 1);
          if ((int)tx_tail >= 255) tx_tail = (uint8_t)0;
          *((uint8_t volatile *)(0x38 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                           0x38 + 0x20)) | (
                                                           1 << 0));
          *((uint8_t volatile *)(0x39 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                           0x39 + 0x20)) | (
                                                           1 << 4));
        }
      }
      else modem_nb_ovrn = (uint8_t)((int)modem_nb_ovrn + 1);
    }
  return;
}

void send_climb(void)
{
  if (! boot) 
    if ((int)count % 20 == 18) {
      int tmp;
      if ((int)tx_head >= (int)tx_tail) tmp = 18 < 255 - ((int)tx_head - (int)tx_tail);
      else tmp = 18 < (int)tx_tail - (int)tx_head;
      if (tmp) {
        tx_buf[tx_head] = (uint8_t)0x05;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = (uint8_t)14;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        ck_a = (uint8_t)14;
        ck_b = (uint8_t)14;
        tx_buf[tx_head] = *((uint8_t *)(& desired_gaz));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_gaz)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& desired_gaz) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_gaz) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& desired_climb));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_climb)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& desired_climb) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_climb) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& desired_climb) + 2);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_climb) + 2));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& desired_climb) + 3);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_climb) + 3));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& climb_sum_err));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& climb_sum_err)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& climb_sum_err) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& climb_sum_err) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& climb_sum_err) + 2);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& climb_sum_err) + 2));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& climb_sum_err) + 3);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& climb_sum_err) + 3));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& climb_pgain));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& climb_pgain)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& climb_pgain) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& climb_pgain) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& climb_pgain) + 2);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& climb_pgain) + 2));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& climb_pgain) + 3);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& climb_pgain) + 3));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = ck_a;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = ck_b;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        if (! ((int)*((uint8_t volatile *)(0x39 + 0x20)) & (1 << 4))) {
          tx_byte = tx_buf[tx_tail];
          tx_byte_idx = (uint8_t)0;
          tx_tail = (uint8_t)((int)tx_tail + 1);
          if ((int)tx_tail >= 255) tx_tail = (uint8_t)0;
          *((uint8_t volatile *)(0x38 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                           0x38 + 0x20)) | (
                                                           1 << 0));
          *((uint8_t volatile *)(0x39 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                           0x39 + 0x20)) | (
                                                           1 << 4));
        }
      }
      else modem_nb_ovrn = (uint8_t)((int)modem_nb_ovrn + 1);
    }
  return;
}

void send_mode(void)
{
  if (! boot) 
    if ((int)count % 50 == 9) {
      int tmp;
      if ((int)tx_head >= (int)tx_tail) tmp = 9 < 255 - ((int)tx_head - (int)tx_tail);
      else tmp = 9 < (int)tx_tail - (int)tx_head;
      if (tmp) {
        tx_buf[tx_head] = (uint8_t)0x05;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = (uint8_t)11;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        ck_a = (uint8_t)11;
        ck_b = (uint8_t)11;
        tx_buf[tx_head] = pprz_mode;
        ck_a = (uint8_t)((int)ck_a + (int)pprz_mode);
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = vertical_mode;
        ck_a = (uint8_t)((int)ck_a + (int)vertical_mode);
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = inflight_calib_mode;
        ck_a = (uint8_t)((int)ck_a + (int)inflight_calib_mode);
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = mcu1_status;
        ck_a = (uint8_t)((int)ck_a + (int)mcu1_status);
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = ir_estim_mode;
        ck_a = (uint8_t)((int)ck_a + (int)ir_estim_mode);
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = ck_a;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = ck_b;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        if (! ((int)*((uint8_t volatile *)(0x39 + 0x20)) & (1 << 4))) {
          tx_byte = tx_buf[tx_tail];
          tx_byte_idx = (uint8_t)0;
          tx_tail = (uint8_t)((int)tx_tail + 1);
          if ((int)tx_tail >= 255) tx_tail = (uint8_t)0;
          *((uint8_t volatile *)(0x38 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                           0x38 + 0x20)) | (
                                                           1 << 0));
          *((uint8_t volatile *)(0x39 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                           0x39 + 0x20)) | (
                                                           1 << 4));
        }
      }
      else modem_nb_ovrn = (uint8_t)((int)modem_nb_ovrn + 1);
    }
  return;
}

void send_debug(void)
{
  if (! boot) 
    if ((int)count % 50 == 29) {
      int tmp;
      if ((int)tx_head >= (int)tx_tail) tmp = 9 < 255 - ((int)tx_head - (int)tx_tail);
      else tmp = 9 < (int)tx_tail - (int)tx_head;
      if (tmp) {
        tx_buf[tx_head] = (uint8_t)0x05;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = (uint8_t)13;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        ck_a = (uint8_t)13;
        ck_b = (uint8_t)13;
        tx_buf[tx_head] = *((uint8_t *)(& link_fbw_nb_err));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& link_fbw_nb_err)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = link_fbw_fbw_nb_err;
        ck_a = (uint8_t)((int)ck_a + (int)link_fbw_fbw_nb_err);
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = modem_nb_ovrn;
        ck_a = (uint8_t)((int)ck_a + (int)modem_nb_ovrn);
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = gps_nb_ovrn;
        ck_a = (uint8_t)((int)ck_a + (int)gps_nb_ovrn);
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = mcu1_ppm_cpt;
        ck_a = (uint8_t)((int)ck_a + (int)mcu1_ppm_cpt);
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = ck_a;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = ck_b;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        if (! ((int)*((uint8_t volatile *)(0x39 + 0x20)) & (1 << 4))) {
          tx_byte = tx_buf[tx_tail];
          tx_byte_idx = (uint8_t)0;
          tx_tail = (uint8_t)((int)tx_tail + 1);
          if ((int)tx_tail >= 255) tx_tail = (uint8_t)0;
          *((uint8_t volatile *)(0x38 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                           0x38 + 0x20)) | (
                                                           1 << 0));
          *((uint8_t volatile *)(0x39 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                           0x39 + 0x20)) | (
                                                           1 << 4));
        }
      }
      else modem_nb_ovrn = (uint8_t)((int)modem_nb_ovrn + 1);
    }
  return;
}

void send_nav_ref(void)
{
  if (! boot) 
    if ((int)count % 100 == 49) {
      int tmp;
      if ((int)tx_head >= (int)tx_tail) tmp = 12 < 255 - ((int)tx_head - (int)tx_tail);
      else tmp = 12 < (int)tx_tail - (int)tx_head;
      if (tmp) {
        tx_buf[tx_head] = (uint8_t)0x05;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = (uint8_t)9;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        ck_a = (uint8_t)9;
        ck_b = (uint8_t)9;
        tx_buf[tx_head] = *((uint8_t *)(& utm_east0));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& utm_east0)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& utm_east0) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& utm_east0) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& utm_east0) + 2);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& utm_east0) + 2));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& utm_east0) + 3);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& utm_east0) + 3));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& utm_north0));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& utm_north0)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& utm_north0) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& utm_north0) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& utm_north0) + 2);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& utm_north0) + 2));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& utm_north0) + 3);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& utm_north0) + 3));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = ck_a;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = ck_b;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        if (! ((int)*((uint8_t volatile *)(0x39 + 0x20)) & (1 << 4))) {
          tx_byte = tx_buf[tx_tail];
          tx_byte_idx = (uint8_t)0;
          tx_tail = (uint8_t)((int)tx_tail + 1);
          if ((int)tx_tail >= 255) tx_tail = (uint8_t)0;
          *((uint8_t volatile *)(0x38 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                           0x38 + 0x20)) | (
                                                           1 << 0));
          *((uint8_t volatile *)(0x39 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                           0x39 + 0x20)) | (
                                                           1 << 4));
        }
      }
      else modem_nb_ovrn = (uint8_t)((int)modem_nb_ovrn + 1);
    }
  return;
}

__inline static uint8_t inflight_calib_mode_update__fc_inline(void)
{
  uint8_t __retres;
  {
    int tmp_0;
    if ((int)from_fbw.channels[8] < - (600 * 16) / 2) tmp_0 = 2;
    else {
      int tmp;
      if ((int)from_fbw.channels[8] < 200 * 16) tmp = 0; else tmp = 1;
      tmp_0 = tmp;
    }
    uint8_t new_mode = (uint8_t)tmp_0;
    if ((int)inflight_calib_mode != (int)new_mode) {
      inflight_calib_mode = new_mode;
      __retres = (uint8_t)(! 0);
      goto return_label;
    }
    __retres = (uint8_t)0;
    goto return_label;
  }
  return_label: return __retres;
}

void radio_control_task(void)
{
  bool_t calib_mode_changed;
  if (link_fbw_receive_valid) {
    uint8_t tmp_2;
    uint8_t mode_changed = (uint8_t)0;
    copy_from_to_fbw__fc_inline();
    if ((int)from_fbw.status & (1 << 1)) {
      if ((int)pprz_mode == 1) goto _LOR;
      else 
        if ((int)pprz_mode == 0) goto _LOR; else goto _LAND;
    }
    else {
      _LAND: ;
      if (too_far_from_home) {
        _LOR: {
                pprz_mode = (uint8_t)3;
                mode_changed = (uint8_t)(! 0);
              }
      }
    }
    if ((int)from_fbw.status & (1 << 2)) {
      uint8_t tmp_0;
      int tmp_1;
      bool_t pprz_mode_changed = pprz_mode_update__fc_inline();
      mode_changed = (uint8_t)((int)mode_changed | (int)pprz_mode_changed);
      tmp_0 = ir_estim_mode_update__fc_inline();
      mode_changed = (uint8_t)((int)mode_changed | (int)tmp_0);
      calib_mode_changed = inflight_calib_mode_update__fc_inline();
      if (calib_mode_changed) tmp_1 = 1;
      else 
        if (pprz_mode_changed) tmp_1 = 1; else tmp_1 = 0;
      inflight_calib((bool_t)tmp_1);
      mode_changed = (uint8_t)((int)mode_changed | (int)calib_mode_changed);
    }
    tmp_2 = mcu1_status_update__fc_inline();
    mode_changed = (uint8_t)((int)mode_changed | (int)tmp_2);
    if (mode_changed) {
      int tmp_3;
      if ((int)tx_head >= (int)tx_tail) tmp_3 = 9 < 255 - ((int)tx_head - (int)tx_tail);
      else tmp_3 = 9 < (int)tx_tail - (int)tx_head;
      if (tmp_3) {
        tx_buf[tx_head] = (uint8_t)0x05;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = (uint8_t)11;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        ck_a = (uint8_t)11;
        ck_b = (uint8_t)11;
        tx_buf[tx_head] = pprz_mode;
        ck_a = (uint8_t)((int)ck_a + (int)pprz_mode);
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = vertical_mode;
        ck_a = (uint8_t)((int)ck_a + (int)vertical_mode);
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = inflight_calib_mode;
        ck_a = (uint8_t)((int)ck_a + (int)inflight_calib_mode);
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = mcu1_status;
        ck_a = (uint8_t)((int)ck_a + (int)mcu1_status);
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = ir_estim_mode;
        ck_a = (uint8_t)((int)ck_a + (int)ir_estim_mode);
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = ck_a;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = ck_b;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        if (! ((int)*((uint8_t volatile *)(0x39 + 0x20)) & (1 << 4))) {
          tx_byte = tx_buf[tx_tail];
          tx_byte_idx = (uint8_t)0;
          tx_tail = (uint8_t)((int)tx_tail + 1);
          if ((int)tx_tail >= 255) tx_tail = (uint8_t)0;
          *((uint8_t volatile *)(0x38 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                           0x38 + 0x20)) | (
                                                           1 << 0));
          *((uint8_t volatile *)(0x39 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                           0x39 + 0x20)) | (
                                                           1 << 4));
        }
      }
      else modem_nb_ovrn = (uint8_t)((int)modem_nb_ovrn + 1);
    }
    if ((int)pprz_mode == 1) {
      desired_roll = (float)((double)((float)from_fbw.channels[1] / (float)(
                                      600 * 16)) * - 0.6 + 0.);
      desired_pitch = (float)((double)((float)from_fbw.channels[2] / (float)(
                                       600 * 16)) * 0.5 + 0.);
    }
    if ((int)pprz_mode == 0) goto _LOR_0;
    else 
      if ((int)pprz_mode == 1) _LOR_0: desired_gaz = from_fbw.channels[0];
    mcu1_ppm_cpt = from_fbw.ppm_cpt;
    vsupply = from_fbw.vsupply;
    events_update();
    if (! estimator_flight_time) {
      ground_calibrate__fc_inline();
      if ((int)pprz_mode == 2) 
        if ((int)from_fbw.channels[0] > (int)((pprz_t)((double)(600 * 16) * 0.9))) 
          launch = (bool_t)(! 0);
    }
  }
  return;
}

void navigation_update(void)
{
  lateral_mode = (uint8_t)3;
  if ((int)pprz_mode == 3) nav_home(); else nav_update();
  return;
}

void send_nav_values(void)
{
  {
    int tmp;
    if ((int)tx_head >= (int)tx_tail) tmp = 30 < 255 - ((int)tx_head - (int)tx_tail);
    else tmp = 30 < (int)tx_tail - (int)tx_head;
    if (tmp) {
      tx_buf[tx_head] = (uint8_t)0x05;
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = (uint8_t)10;
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      ck_a = (uint8_t)10;
      ck_b = (uint8_t)10;
      tx_buf[tx_head] = nav_block;
      ck_a = (uint8_t)((int)ck_a + (int)nav_block);
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = nav_stage;
      ck_a = (uint8_t)((int)ck_a + (int)nav_stage);
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& estimator_x));
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_x)));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& estimator_x) + 1);
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_x) + 1));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& estimator_x) + 2);
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_x) + 2));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& estimator_x) + 3);
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_x) + 3));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& estimator_y));
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_y)));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& estimator_y) + 1);
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_y) + 1));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& estimator_y) + 2);
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_y) + 2));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& estimator_y) + 3);
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_y) + 3));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& desired_course));
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_course)));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& desired_course) + 1);
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_course) + 1));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& desired_course) + 2);
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_course) + 2));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& desired_course) + 3);
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& desired_course) + 3));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& dist2_to_wp));
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& dist2_to_wp)));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& dist2_to_wp) + 1);
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& dist2_to_wp) + 1));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& dist2_to_wp) + 2);
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& dist2_to_wp) + 2));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& dist2_to_wp) + 3);
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& dist2_to_wp) + 3));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& course_pgain));
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& course_pgain)));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& course_pgain) + 1);
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& course_pgain) + 1));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& course_pgain) + 2);
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& course_pgain) + 2));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& course_pgain) + 3);
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& course_pgain) + 3));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& dist2_to_home));
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& dist2_to_home)));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& dist2_to_home) + 1);
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& dist2_to_home) + 1));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& dist2_to_home) + 2);
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& dist2_to_home) + 2));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& dist2_to_home) + 3);
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& dist2_to_home) + 3));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = ck_a;
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = ck_b;
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      if (! ((int)*((uint8_t volatile *)(0x39 + 0x20)) & (1 << 4))) {
        tx_byte = tx_buf[tx_tail];
        tx_byte_idx = (uint8_t)0;
        tx_tail = (uint8_t)((int)tx_tail + 1);
        if ((int)tx_tail >= 255) tx_tail = (uint8_t)0;
        *((uint8_t volatile *)(0x38 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                         0x38 + 0x20)) | (
                                                         1 << 0));
        *((uint8_t volatile *)(0x39 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                         0x39 + 0x20)) | (
                                                         1 << 4));
      }
    }
    else modem_nb_ovrn = (uint8_t)((int)modem_nb_ovrn + 1);
  }
  return;
}

void course_run(void)
{
  if ((int)pprz_mode == 2) goto _LOR;
  else 
    if ((int)pprz_mode == 3) {
      _LOR:
      {
        if ((int)lateral_mode >= 3) course_pid_run();
        desired_roll = nav_desired_roll;
      }
    }
  return;
}

void altitude_control_task(void)
{
  if ((int)pprz_mode == 2) goto _LOR;
  else 
    if ((int)pprz_mode == 3) 
      _LOR: if ((int)vertical_mode == 3) altitude_pid_run();
  return;
}

void climb_control_task(void)
{
  if ((int)pprz_mode == 2) goto _LOR;
  else 
    if ((int)pprz_mode == 3) {
      _LOR:
      {
        if ((int)vertical_mode >= 2) climb_pid_run();
        if ((int)vertical_mode == 1) desired_gaz = (int16_t)nav_desired_gaz;
        if (low_battery) desired_gaz = (int16_t)0.;
        else 
          if (! estimator_flight_time) 
            if (! launch) desired_gaz = (int16_t)0.;
      }
    }
  return;
}

static uint8_t _20Hz = (uint8_t)0;
static uint8_t _1Hz = (uint8_t)0;
static uint8_t periodic_task__10Hz = (uint8_t)0;
static uint8_t periodic_task__4Hz = (uint8_t)0;
static uint8_t periodic_task_t = (uint8_t)0;
static uint8_t periodic_task_odd;
void periodic_task(void)
{
  estimator_t = (float)((double)estimator_t + ((256. * 1024.) / (double)16) / 1000000.);
  _20Hz = (uint8_t)((int)_20Hz + 1);
  if ((int)_20Hz >= 3) _20Hz = (uint8_t)0;
  periodic_task__10Hz = (uint8_t)((int)periodic_task__10Hz + 1);
  if ((int)periodic_task__10Hz >= 6) periodic_task__10Hz = (uint8_t)0;
  periodic_task__4Hz = (uint8_t)((int)periodic_task__4Hz + 1);
  if ((int)periodic_task__4Hz >= 15) periodic_task__4Hz = (uint8_t)0;
  _1Hz = (uint8_t)((int)_1Hz + 1);
  if ((int)_1Hz >= 61) _1Hz = (uint8_t)0;
  if (! periodic_task__10Hz) stage_time_ds = (float)((double)stage_time_ds + .1);
  if (! _1Hz) {
    if (estimator_flight_time) estimator_flight_time = (uint16_t)((int)estimator_flight_time + 1);
    cputime = (uint16_t)((int)cputime + 1);
    stage_time_ds = (float)((int16_t)((double)stage_time_ds + .5));
    stage_time = (uint16_t)((int)stage_time + 1);
    block_time = (uint16_t)((int)block_time + 1);
    if ((int)vsupply < 93) periodic_task_t = (uint8_t)((int)periodic_task_t + 1);
    else periodic_task_t = (uint8_t)0;
    low_battery = (bool_t)((int)low_battery | ((int)periodic_task_t >= 5));
  }
  if ((int)periodic_task__4Hz == 0) {
    estimator_propagate_state();
    navigation_update();
    send_nav_values();
    course_run();
    altitude_control_task();
    climb_control_task();
  }
  if (! ((int)_20Hz == 0)) 
    if ((int)_20Hz == 1) {
      periodic_task_odd = (uint8_t)((int)periodic_task_odd + 1);
      if ((int)periodic_task_odd & 0x01) {
        send_boot();
        send_attitude();
        send_adc();
        send_settings();
        send_desired();
        send_bat();
        send_climb();
        send_mode();
        send_debug();
        send_nav_ref();
      }
    }
    else 
      if ((int)_20Hz == 2) {
        stabilisation_task();
        link_fbw_send();
      }
      else fatal_error_nb = (uint8_t)((int)fatal_error_nb + 1);
  return;
}

void stabilisation_task(void)
{
  ir_update();
  estimator_update_state_infrared();
  roll_pitch_pid_run();
  to_fbw.channels[0] = desired_gaz;
  to_fbw.channels[1] = desired_aileron;
  to_fbw.channels[2] = desired_elevator;
  if (((double)(600 * 16) / 0.75) * (double)(- estimator_phi) < (double)(- (
      600 * 16))) to_fbw.channels[5] = (int16_t)(- (600 * 16));
  else {
    double tmp;
    if (((double)(600 * 16) / 0.75) * (double)(- estimator_phi) > (double)(
        600 * 16)) tmp = (double)(600 * 16);
    else tmp = ((double)(600 * 16) / 0.75) * (double)(- estimator_phi);
    to_fbw.channels[5] = (int16_t)tmp;
  }
  return;
}

void send_gps_pos(void)
{
  gps_msg_received = (uint8_t)0;
  if (gps_pos_available) {
    {
      int tmp;
      if ((int)tx_head >= (int)tx_tail) tmp = 33 < 255 - ((int)tx_head - (int)tx_tail);
      else tmp = 33 < (int)tx_tail - (int)tx_head;
      if (tmp) {
        tx_buf[tx_head] = (uint8_t)0x05;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = (uint8_t)8;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        ck_a = (uint8_t)8;
        ck_b = (uint8_t)8;
        tx_buf[tx_head] = *((uint8_t *)(& gps_mode));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& gps_mode)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& gps_utm_east));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& gps_utm_east)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& gps_utm_east) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& gps_utm_east) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& gps_utm_east) + 2);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& gps_utm_east) + 2));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& gps_utm_east) + 3);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& gps_utm_east) + 3));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& gps_utm_north));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& gps_utm_north)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& gps_utm_north) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& gps_utm_north) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& gps_utm_north) + 2);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& gps_utm_north) + 2));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& gps_utm_north) + 3);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& gps_utm_north) + 3));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& gps_fcourse));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& gps_fcourse)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& gps_fcourse) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& gps_fcourse) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& gps_fcourse) + 2);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& gps_fcourse) + 2));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& gps_fcourse) + 3);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& gps_fcourse) + 3));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& gps_falt));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& gps_falt)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& gps_falt) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& gps_falt) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& gps_falt) + 2);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& gps_falt) + 2));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& gps_falt) + 3);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& gps_falt) + 3));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& gps_fspeed));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& gps_fspeed)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& gps_fspeed) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& gps_fspeed) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& gps_fspeed) + 2);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& gps_fspeed) + 2));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& gps_fspeed) + 3);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& gps_fspeed) + 3));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& gps_fclimb));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& gps_fclimb)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& gps_fclimb) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& gps_fclimb) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& gps_fclimb) + 2);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& gps_fclimb) + 2));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& gps_fclimb) + 3);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& gps_fclimb) + 3));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& gps_ftow));
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& gps_ftow)));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& gps_ftow) + 1);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& gps_ftow) + 1));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& gps_ftow) + 2);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& gps_ftow) + 2));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = *((uint8_t *)(& gps_ftow) + 3);
        ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& gps_ftow) + 3));
        ck_b = (uint8_t)((int)ck_b + (int)ck_a);
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = ck_a;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        tx_buf[tx_head] = ck_b;
        tx_head = (uint8_t)((int)tx_head + 1);
        if ((int)tx_head >= 255) tx_head = (uint8_t)0;
        if (! ((int)*((uint8_t volatile *)(0x39 + 0x20)) & (1 << 4))) {
          tx_byte = tx_buf[tx_tail];
          tx_byte_idx = (uint8_t)0;
          tx_tail = (uint8_t)((int)tx_tail + 1);
          if ((int)tx_tail >= 255) tx_tail = (uint8_t)0;
          *((uint8_t volatile *)(0x38 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                           0x38 + 0x20)) | (
                                                           1 << 0));
          *((uint8_t volatile *)(0x39 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                           0x39 + 0x20)) | (
                                                           1 << 4));
        }
      }
      else modem_nb_ovrn = (uint8_t)((int)modem_nb_ovrn + 1);
    }
    estimator_update_state_gps();
  }
  return;
}

void send_radIR(void)
{
  if (gps_pos_available) {
    int tmp;
    if ((int)tx_head >= (int)tx_tail) tmp = 20 < 255 - ((int)tx_head - (int)tx_tail);
    else tmp = 20 < (int)tx_tail - (int)tx_head;
    if (tmp) {
      tx_buf[tx_head] = (uint8_t)0x05;
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = (uint8_t)5;
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      ck_a = (uint8_t)5;
      ck_b = (uint8_t)5;
      tx_buf[tx_head] = *((uint8_t *)(& estimator_ir));
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_ir)));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& estimator_ir) + 1);
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_ir) + 1));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& estimator_ir) + 2);
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_ir) + 2));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& estimator_ir) + 3);
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_ir) + 3));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& estimator_rad));
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_rad)));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& estimator_rad) + 1);
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_rad) + 1));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& estimator_rad) + 2);
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_rad) + 2));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& estimator_rad) + 3);
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_rad) + 3));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& estimator_rad_of_ir));
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_rad_of_ir)));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& estimator_rad_of_ir) + 1);
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_rad_of_ir) + 1));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& estimator_rad_of_ir) + 2);
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_rad_of_ir) + 2));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& estimator_rad_of_ir) + 3);
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& estimator_rad_of_ir) + 3));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& ir_roll_neutral));
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& ir_roll_neutral)));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& ir_roll_neutral) + 1);
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& ir_roll_neutral) + 1));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& ir_pitch_neutral));
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& ir_pitch_neutral)));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = *((uint8_t *)(& ir_pitch_neutral) + 1);
      ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& ir_pitch_neutral) + 1));
      ck_b = (uint8_t)((int)ck_b + (int)ck_a);
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = ck_a;
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      tx_buf[tx_head] = ck_b;
      tx_head = (uint8_t)((int)tx_head + 1);
      if ((int)tx_head >= 255) tx_head = (uint8_t)0;
      if (! ((int)*((uint8_t volatile *)(0x39 + 0x20)) & (1 << 4))) {
        tx_byte = tx_buf[tx_tail];
        tx_byte_idx = (uint8_t)0;
        tx_tail = (uint8_t)((int)tx_tail + 1);
        if ((int)tx_tail >= 255) tx_tail = (uint8_t)0;
        *((uint8_t volatile *)(0x38 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                         0x38 + 0x20)) | (
                                                         1 << 0));
        *((uint8_t volatile *)(0x39 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                         0x39 + 0x20)) | (
                                                         1 << 4));
      }
    }
    else modem_nb_ovrn = (uint8_t)((int)modem_nb_ovrn + 1);
  }
  return;
}

void send_takeOff(void)
{
  if (gps_pos_available) {
    if (! estimator_flight_time) 
      if ((double)estimator_hspeed_mod > 5.) {
        estimator_flight_time = (uint16_t)1;
        launch = (bool_t)(! 0);
        {
          int tmp;
          if ((int)tx_head >= (int)tx_tail) tmp = 6 < 255 - ((int)tx_head - (int)tx_tail);
          else tmp = 6 < (int)tx_tail - (int)tx_head;
          if (tmp) {
            tx_buf[tx_head] = (uint8_t)0x05;
            tx_head = (uint8_t)((int)tx_head + 1);
            if ((int)tx_head >= 255) tx_head = (uint8_t)0;
            tx_buf[tx_head] = (uint8_t)4;
            tx_head = (uint8_t)((int)tx_head + 1);
            if ((int)tx_head >= 255) tx_head = (uint8_t)0;
            ck_a = (uint8_t)4;
            ck_b = (uint8_t)4;
            tx_buf[tx_head] = *((uint8_t *)(& cputime));
            ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& cputime)));
            ck_b = (uint8_t)((int)ck_b + (int)ck_a);
            tx_head = (uint8_t)((int)tx_head + 1);
            if ((int)tx_head >= 255) tx_head = (uint8_t)0;
            tx_buf[tx_head] = *((uint8_t *)(& cputime) + 1);
            ck_a = (uint8_t)((int)ck_a + (int)*((uint8_t *)(& cputime) + 1));
            ck_b = (uint8_t)((int)ck_b + (int)ck_a);
            tx_head = (uint8_t)((int)tx_head + 1);
            if ((int)tx_head >= 255) tx_head = (uint8_t)0;
            tx_buf[tx_head] = ck_a;
            tx_head = (uint8_t)((int)tx_head + 1);
            if ((int)tx_head >= 255) tx_head = (uint8_t)0;
            tx_buf[tx_head] = ck_b;
            tx_head = (uint8_t)((int)tx_head + 1);
            if ((int)tx_head >= 255) tx_head = (uint8_t)0;
            if (! ((int)*((uint8_t volatile *)(0x39 + 0x20)) & (1 << 4))) {
              tx_byte = tx_buf[tx_tail];
              tx_byte_idx = (uint8_t)0;
              tx_tail = (uint8_t)((int)tx_tail + 1);
              if ((int)tx_tail >= 255) tx_tail = (uint8_t)0;
              *((uint8_t volatile *)(0x38 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                               0x38 + 0x20)) | (
                                                               1 << 0));
              *((uint8_t volatile *)(0x39 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                               0x39 + 0x20)) | (
                                                               1 << 4));
            }
          }
          else modem_nb_ovrn = (uint8_t)((int)modem_nb_ovrn + 1);
        }
      }
    gps_pos_available = (bool_t)0;
  }
  return;
}

__inline static void timer_enable_int_3(unsigned char ints)
{
  *((uint8_t volatile *)(0x37 + 0x20)) = ints;
  return;
}

__inline static void timer_init_0(void)
{
  *((uint8_t volatile *)(0x2F + 0x20)) = (uint8_t)0x00;
  *((uint8_t volatile *)(0x2E + 0x20)) = (uint8_t)0x01;
  *((uint8_t volatile *)(0x25 + 0x20)) = (uint8_t)0x05;
  return;
}

__inline static uint16_t timer_now_0(void)
{
  uint16_t __retres;
  __retres = *((uint16_t volatile *)(0x2C + 0x20));
  return __retres;
}

__inline static uint16_t timer_now_non_atomic_0(void)
{
  uint16_t __retres;
  __retres = (uint16_t)*((uint8_t volatile *)(0x2C + 0x20));
  return __retres;
}

__inline static bool_t timer_periodic_0(void)
{
  bool_t __retres;
  if (! ((int)*((uint8_t volatile *)(0x36 + 0x20)) & (1 << 6))) {
    __retres = (bool_t)0;
    goto return_label;
  }
  *((uint8_t volatile *)(0x36 + 0x20)) = (uint8_t)(1 << 6);
  __retres = (bool_t)(! 0);
  return_label: return __retres;
}

int main(void)
{
  int __retres;
  uint8_t init_cpt;
  timer_init_0();
  modem_init();
  adc_init();
  spi_init();
  link_fbw_init();
  gps_init();
  nav_init();
  ir_init();
  estimator_init();
  init_cpt = (uint8_t)30;
  while (init_cpt) {
    bool_t tmp;
    tmp = timer_periodic_0();
    if (tmp) init_cpt = (uint8_t)((int)init_cpt - 1);
  }
  while (1) {
    {
      bool_t tmp_0;
      tmp_0 = timer_periodic_0();
      if (tmp_0) periodic_task();
      if (gps_msg_received) {
        parse_gps_msg();
        send_gps_pos();
        send_radIR();
        send_takeOff();
      }
      if (link_fbw_receive_complete) {
        link_fbw_receive_complete = (uint8_t)0;
        radio_control_task();
      }
    }
  }
  __retres = 0;
  return __retres;
}

__inline static void timer_enable_int_4(unsigned char ints)
{
  *((uint8_t volatile *)(0x37 + 0x20)) = ints;
  return;
}

uint8_t modem_nb_ovrn;
uint8_t tx_head;
uint8_t volatile tx_tail;
uint8_t tx_buf[255];
uint8_t tx_byte;
uint8_t tx_byte_idx;
uint8_t ck_a;
uint8_t ck_b;
void modem_init(void)
{
  *((uint8_t volatile *)(0x17 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                   0x17 + 0x20)) | (1 << 4));
  *((uint8_t volatile *)(0x31 + 0x20)) = (uint8_t)1;
  *((uint8_t volatile *)(0x33 + 0x20)) = (uint8_t)(((1 << 3) | (1 << 4)) | (
                                                   1 << 0));
  *((uint8_t volatile *)(0x11 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                   0x11 + 0x20)) | ((
                                                                    1 << 7) | (
                                                                    1 << 6)));
  *((uint8_t volatile *)(0x12 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                   0x12 + 0x20)) | (1 << 6));
  *((uint8_t volatile *)(0x12 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                   0x12 + 0x20)) & ~ (
                                                   1 << 7));
  *((uint8_t volatile *)(0x3A + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                   0x3A + 0x20)) | (1 << 1));
  return;
}

void __vector_5(void) __attribute__((__signal__));

void __vector_5(void) __attribute__((__signal__));
void __vector_5(void)
{
  if ((int)tx_byte_idx == 0) *((uint8_t volatile *)(0x12 + 0x20)) = (uint8_t)(
                             (int)*((uint8_t volatile *)(0x12 + 0x20)) & ~ (
                             1 << 6));
  else 
    if ((int)tx_byte_idx < 9) {
      if ((int)tx_byte & 0x01) *((uint8_t volatile *)(0x12 + 0x20)) = (uint8_t)(
                               (int)*((uint8_t volatile *)(0x12 + 0x20)) | (
                               1 << 6));
      else *((uint8_t volatile *)(0x12 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                            0x12 + 0x20)) & ~ (
                                                            1 << 6));
      tx_byte = (uint8_t)((int)tx_byte >> 1);
    }
    else *((uint8_t volatile *)(0x12 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                          0x12 + 0x20)) | (
                                                          1 << 6));
  tx_byte_idx = (uint8_t)((int)tx_byte_idx + 1);
  if ((int)tx_byte_idx >= 10) 
    if ((int)tx_head == (int)tx_tail) *((uint8_t volatile *)(0x39 + 0x20)) = (uint8_t)(
                                      (int)*((uint8_t volatile *)(0x39 + 0x20)) & ~ (
                                      1 << 4));
    else {
      tx_byte = tx_buf[tx_tail];
      tx_byte_idx = (uint8_t)0;
      tx_tail = (uint8_t)((int)tx_tail + 1);
      if ((int)tx_tail >= 255) tx_tail = (uint8_t)0;
    }
  return;
}

uint8_t nav_stage;
uint8_t nav_block;
float dist2_to_wp;
float dist2_to_home;
float desired_x;
float desired_y;
uint16_t nav_desired_gaz;
float rc_pitch;
bool_t too_far_from_home;
uint16_t stage_time;
uint16_t block_time;
float stage_time_ds;
float nav_desired_roll;
uint8_t excpt_stage;
static float last_x;
static float last_y;
static uint8_t last_wp;
static bool_t approaching(uint8_t wp);

static void fly_to_xy(float x, float y);

static void fly_to(uint8_t wp);

static void route_to(uint8_t _last_wp, uint8_t wp);

static float qdr;
static float auto_nav_carrot_x;
static float auto_nav_carrot_y;
__inline static void auto_nav(void)
{
  if ((int)nav_block == 0) {
    if ((int)nav_stage == 0) {
      label_while_1: nav_stage = (uint8_t)0;
      if (! (! estimator_flight_time)) goto label_endwhile_2;
      else {
        nav_stage = (uint8_t)((int)nav_stage + 1);
        last_x = estimator_x;
        last_y = estimator_y;
        stage_time = (uint16_t)0;
        stage_time_ds = (float)0.0;
        goto return_label;
      }
    }
    else 
      if ((int)nav_stage == 1) goto label_while_1;
      else 
        if ((int)nav_stage == 2) {
          label_endwhile_2: nav_stage = (uint8_t)2;
          if ((int)estimator_flight_time > 8) {
            nav_stage = (uint8_t)((int)nav_stage + 1);
            last_x = estimator_x;
            last_y = estimator_y;
            stage_time = (uint16_t)0;
            stage_time_ds = (float)0.0;
            goto return_label;
          }
          else {
            desired_course = (float)((270.0 / 180.) * 0x1.921fb54442d18p1);
            auto_pitch = (bool_t)0;
            nav_pitch = (float)0.150000;
            vertical_mode = (uint8_t)1;
            if (0.800000 * (double)(600 * 16) < (double)0) nav_desired_gaz = (uint16_t)0;
            else {
              double tmp;
              if (0.800000 * (double)(600 * 16) > (double)(600 * 16)) 
                tmp = (double)(600 * 16);
              else tmp = 0.800000 * (double)(600 * 16);
              nav_desired_gaz = (uint16_t)tmp;
            }
          }
          goto return_label;
        }
        else 
          if ((int)nav_stage == 3) {
            nav_stage = (uint8_t)3;
            if ((double)estimator_z > 150.) {
              nav_stage = (uint8_t)((int)nav_stage + 1);
              last_x = estimator_x;
              last_y = estimator_y;
              stage_time = (uint16_t)0;
              stage_time_ds = (float)0.0;
              goto return_label;
            }
            else {
              desired_course = (float)((270.0 / 180.) * 0x1.921fb54442d18p1);
              auto_pitch = (bool_t)0;
              nav_pitch = (float)0.000000;
              vertical_mode = (uint8_t)2;
              desired_climb = (float)8.000000;
            }
            goto return_label;
          }
          else 
            if ((int)nav_stage == 4) {
              nav_block = (uint8_t)((int)nav_block + 1);
              nav_stage = (uint8_t)0;
              block_time = (uint16_t)0;
              last_x = estimator_x;
              last_y = estimator_y;
              stage_time = (uint16_t)0;
              stage_time_ds = (float)0.0;
              goto return_label;
            }
  }
  else 
    if ((int)nav_block == 1) {
      int tmp_0;
      nav_block = (uint8_t)1;
      if (rc_event_1) {
        rc_event_1 = (bool_t)0;
        tmp_0 = ! 0;
      }
      else tmp_0 = 0;
      if (tmp_0) {
        nav_block = (uint8_t)2;
        nav_stage = (uint8_t)0;
        block_time = (uint16_t)0;
        last_x = estimator_x;
        last_y = estimator_y;
        stage_time = (uint16_t)0;
        stage_time_ds = (float)0.0;
        goto return_label;
      }
      if ((int)nav_stage == 0) {
        label_while_3:
        if (! (! 0)) goto label_endwhile_4;
        else {
          nav_stage = (uint8_t)((int)nav_stage + 1);
          last_x = estimator_x;
          last_y = estimator_y;
          stage_time = (uint16_t)0;
          stage_time_ds = (float)0.0;
          goto return_label;
        }
      }
      else 
        if ((int)nav_stage == 1) {
          bool_t tmp_1;
          nav_stage = (uint8_t)1;
          tmp_1 = approaching((uint8_t)1);
          if (tmp_1) {
            last_wp = (uint8_t)1;
            nav_stage = (uint8_t)((int)nav_stage + 1);
            last_x = estimator_x;
            last_y = estimator_y;
            stage_time = (uint16_t)0;
            stage_time_ds = (float)0.0;
            goto return_label;
          }
          else {
            fly_to((uint8_t)1);
            auto_pitch = (bool_t)0;
            nav_pitch = (float)0.000000;
            vertical_mode = (uint8_t)3;
            desired_altitude = waypoints[1].a;
            pre_climb = (float)0.;
          }
          goto return_label;
        }
        else 
          if ((int)nav_stage == 2) {
            bool_t tmp_2;
            nav_stage = (uint8_t)2;
            tmp_2 = approaching((uint8_t)4);
            if (tmp_2) {
              last_wp = (uint8_t)4;
              nav_stage = (uint8_t)((int)nav_stage + 1);
              last_x = estimator_x;
              last_y = estimator_y;
              stage_time = (uint16_t)0;
              stage_time_ds = (float)0.0;
              goto return_label;
            }
            else {
              fly_to((uint8_t)4);
              auto_pitch = (bool_t)0;
              nav_pitch = (float)0.000000;
              vertical_mode = (uint8_t)3;
              desired_altitude = waypoints[4].a;
              pre_climb = (float)0.;
            }
            goto return_label;
          }
          else 
            if ((int)nav_stage == 3) {
              nav_stage = (uint8_t)3;
              goto label_while_3;
            }
            else 
              if ((int)nav_stage == 4) {
                label_endwhile_4: nav_stage = (uint8_t)4;
                nav_block = (uint8_t)((int)nav_block + 1);
                nav_stage = (uint8_t)0;
                block_time = (uint16_t)0;
                last_x = estimator_x;
                last_y = estimator_y;
                stage_time = (uint16_t)0;
                stage_time_ds = (float)0.0;
                goto return_label;
              }
    }
    else 
      if ((int)nav_block == 2) {
        int tmp_3;
        nav_block = (uint8_t)2;
        if (rc_event_1) {
          rc_event_1 = (bool_t)0;
          tmp_3 = ! 0;
        }
        else tmp_3 = 0;
        if (tmp_3) {
          nav_block = (uint8_t)3;
          nav_stage = (uint8_t)0;
          block_time = (uint16_t)0;
          last_x = estimator_x;
          last_y = estimator_y;
          stage_time = (uint16_t)0;
          stage_time_ds = (float)0.0;
          goto return_label;
        }
        if ((int)nav_stage == 0) {
          label_while_5: nav_stage = (uint8_t)0;
          if (! (! 0)) goto label_endwhile_6;
          else {
            nav_stage = (uint8_t)((int)nav_stage + 1);
            last_x = estimator_x;
            last_y = estimator_y;
            stage_time = (uint16_t)0;
            stage_time_ds = (float)0.0;
            goto return_label;
          }
        }
        else 
          if ((int)nav_stage == 1) {
            bool_t tmp_4;
            nav_stage = (uint8_t)1;
            tmp_4 = approaching((uint8_t)6);
            if (tmp_4) {
              last_wp = (uint8_t)6;
              nav_stage = (uint8_t)((int)nav_stage + 1);
              last_x = estimator_x;
              last_y = estimator_y;
              stage_time = (uint16_t)0;
              stage_time_ds = (float)0.0;
              goto return_label;
            }
            else {
              fly_to((uint8_t)6);
              auto_pitch = (bool_t)0;
              nav_pitch = (float)0.000000;
              vertical_mode = (uint8_t)3;
              desired_altitude = waypoints[6].a;
              pre_climb = (float)0.;
            }
            goto return_label;
          }
          else 
            if ((int)nav_stage == 2) {
              bool_t tmp_5;
              nav_stage = (uint8_t)2;
              tmp_5 = approaching((uint8_t)1);
              if (tmp_5) {
                last_wp = (uint8_t)1;
                nav_stage = (uint8_t)((int)nav_stage + 1);
                last_x = estimator_x;
                last_y = estimator_y;
                stage_time = (uint16_t)0;
                stage_time_ds = (float)0.0;
                goto return_label;
              }
              else {
                fly_to((uint8_t)1);
                auto_pitch = (bool_t)0;
                nav_pitch = (float)0.000000;
                vertical_mode = (uint8_t)3;
                desired_altitude = waypoints[1].a;
                pre_climb = (float)0.;
              }
              goto return_label;
            }
            else 
              if ((int)nav_stage == 3) {
                bool_t tmp_6;
                nav_stage = (uint8_t)3;
                tmp_6 = approaching((uint8_t)2);
                if (tmp_6) {
                  last_wp = (uint8_t)2;
                  nav_stage = (uint8_t)((int)nav_stage + 1);
                  last_x = estimator_x;
                  last_y = estimator_y;
                  stage_time = (uint16_t)0;
                  stage_time_ds = (float)0.0;
                  goto return_label;
                }
                else {
                  route_to(last_wp,(uint8_t)2);
                  auto_pitch = (bool_t)0;
                  nav_pitch = (float)0.000000;
                  vertical_mode = (uint8_t)3;
                  desired_altitude = waypoints[2].a;
                  pre_climb = (float)0.;
                }
                goto return_label;
              }
              else 
                if ((int)nav_stage == 4) {
                  bool_t tmp_7;
                  nav_stage = (uint8_t)4;
                  tmp_7 = approaching((uint8_t)3);
                  if (tmp_7) {
                    last_wp = (uint8_t)3;
                    nav_stage = (uint8_t)((int)nav_stage + 1);
                    last_x = estimator_x;
                    last_y = estimator_y;
                    stage_time = (uint16_t)0;
                    stage_time_ds = (float)0.0;
                    goto return_label;
                  }
                  else {
                    fly_to((uint8_t)3);
                    auto_pitch = (bool_t)0;
                    nav_pitch = (float)0.000000;
                    vertical_mode = (uint8_t)3;
                    desired_altitude = waypoints[3].a;
                    pre_climb = (float)0.;
                  }
                  goto return_label;
                }
                else 
                  if ((int)nav_stage == 5) {
                    bool_t tmp_8;
                    nav_stage = (uint8_t)5;
                    tmp_8 = approaching((uint8_t)4);
                    if (tmp_8) {
                      last_wp = (uint8_t)4;
                      nav_stage = (uint8_t)((int)nav_stage + 1);
                      last_x = estimator_x;
                      last_y = estimator_y;
                      stage_time = (uint16_t)0;
                      stage_time_ds = (float)0.0;
                      goto return_label;
                    }
                    else {
                      fly_to((uint8_t)4);
                      auto_pitch = (bool_t)0;
                      nav_pitch = (float)0.000000;
                      vertical_mode = (uint8_t)3;
                      desired_altitude = waypoints[4].a;
                      pre_climb = (float)0.;
                    }
                    goto return_label;
                  }
                  else 
                    if ((int)nav_stage == 6) {
                      bool_t tmp_9;
                      nav_stage = (uint8_t)6;
                      tmp_9 = approaching((uint8_t)5);
                      if (tmp_9) {
                        last_wp = (uint8_t)5;
                        nav_stage = (uint8_t)((int)nav_stage + 1);
                        last_x = estimator_x;
                        last_y = estimator_y;
                        stage_time = (uint16_t)0;
                        stage_time_ds = (float)0.0;
                        goto return_label;
                      }
                      else {
                        route_to(last_wp,(uint8_t)5);
                        auto_pitch = (bool_t)0;
                        nav_pitch = (float)0.000000;
                        vertical_mode = (uint8_t)3;
                        desired_altitude = waypoints[5].a;
                        pre_climb = (float)0.;
                      }
                      goto return_label;
                    }
                    else 
                      if ((int)nav_stage == 7) {
                        nav_stage = (uint8_t)7;
                        goto label_while_5;
                      }
                      else 
                        if ((int)nav_stage == 8) {
                          label_endwhile_6: nav_stage = (uint8_t)8;
                          nav_block = (uint8_t)((int)nav_block + 1);
                          nav_stage = (uint8_t)0;
                          block_time = (uint16_t)0;
                          last_x = estimator_x;
                          last_y = estimator_y;
                          stage_time = (uint16_t)0;
                          stage_time_ds = (float)0.0;
                          goto return_label;
                        }
      }
      else 
        if ((int)nav_block == 3) {
          int tmp_10;
          nav_block = (uint8_t)3;
          if (rc_event_1) {
            rc_event_1 = (bool_t)0;
            tmp_10 = ! 0;
          }
          else tmp_10 = 0;
          if (tmp_10) {
            nav_block = (uint8_t)4;
            nav_stage = (uint8_t)0;
            block_time = (uint16_t)0;
            last_x = estimator_x;
            last_y = estimator_y;
            stage_time = (uint16_t)0;
            stage_time_ds = (float)0.0;
            goto return_label;
          }
          if ((int)nav_stage == 0) {
            nav_stage = (uint8_t)0;
            {
              int16_t pitch;
              int16_t roll;
              if ((int)pprz_mode == 2) {
                int16_t yaw = from_fbw.channels[3];
                if ((int)yaw > (int)((int16_t)((double)(600 * 16) * 0.05))) 
                  goto _LOR;
                else 
                  if ((int)yaw < - ((int)((int16_t)((double)(600 * 16) * 0.05)))) {
                    _LOR:
                    {
                      auto_nav_carrot_x = (float)((double)auto_nav_carrot_x + (
                                                  (double)((float)yaw / (float)(
                                                           600 * 16)) * - 20. + (double)0));
                      if ((double)auto_nav_carrot_x <= 250.) auto_nav_carrot_x = auto_nav_carrot_x;
                      else auto_nav_carrot_x = (float)250.;
                      if ((double)auto_nav_carrot_x >= - 250.) auto_nav_carrot_x = auto_nav_carrot_x;
                      else auto_nav_carrot_x = (float)(- 250.);
                    }
                  }
                pitch = from_fbw.channels[2];
                if ((int)pitch > (int)((int16_t)((double)(600 * 16) * 0.05))) 
                  goto _LOR_0;
                else 
                  if ((int)pitch < - ((int)((int16_t)((double)(600 * 16) * 0.05)))) {
                    _LOR_0:
                    {
                      auto_nav_carrot_y = (float)((double)auto_nav_carrot_y + (
                                                  (double)((float)pitch / (float)(
                                                           600 * 16)) * - 20. + (double)0));
                      if ((double)auto_nav_carrot_y <= 250.) auto_nav_carrot_y = auto_nav_carrot_y;
                      else auto_nav_carrot_y = (float)250.;
                      if ((double)auto_nav_carrot_y >= - 250.) auto_nav_carrot_y = auto_nav_carrot_y;
                      else auto_nav_carrot_y = (float)(- 250.);
                    }
                  }
                vertical_mode = (uint8_t)3;
                roll = from_fbw.channels[1];
                if ((int)roll > (int)((int16_t)((double)(600 * 16) * 0.05))) 
                  goto _LOR_1;
                else 
                  if ((int)roll < - ((int)((int16_t)((double)(600 * 16) * 0.05)))) {
                    _LOR_1:
                    {
                      desired_altitude = (float)((double)desired_altitude + (
                                                 (double)((float)roll / (float)(
                                                          600 * 16)) * - 1.0 + (double)0));
                      if ((double)desired_altitude >= 50. + 125.) desired_altitude = desired_altitude;
                      else desired_altitude = (float)(50. + 125.);
                      if ((double)desired_altitude <= 150. + 125.) desired_altitude = desired_altitude;
                      else desired_altitude = (float)(150. + 125.);
                    }
                  }
              }
              {
                double tmp_12;
                float tmp_11;
                double tmp_13;
                double tmp_14;
                int tmp_15;
                double tmp_16;
                int tmp_17;
                if ((double)estimator_hspeed_mod < 0.) tmp_11 = - estimator_hspeed_mod;
                else tmp_11 = estimator_hspeed_mod;
                if ((double)tmp_11 < 0.1) tmp_12 = 0.1;
                else tmp_12 = (double)estimator_hspeed_mod;
                float speed_for_radius = (float)tmp_12;
                tmp_13 = pp_atan2((double)(estimator_y - auto_nav_carrot_y),
                                  (double)(estimator_x - auto_nav_carrot_x));
                float alpha_0 = (float)tmp_13;
                float alpha_carrot =
                  (float)((double)alpha_0 + 5. / (double)((float)(-50) * speed_for_radius));
                tmp_14 = pp_sin((double)alpha_carrot);
                if ((double)50 < 0.) tmp_15 = -50; else tmp_15 = 50;
                ;
                tmp_16 = pp_sin((double)alpha_carrot + 1.57079632679489661923);
                if ((double)50 < 0.) tmp_17 = -50; else tmp_17 = 50;
                ;
                fly_to_xy((float)((double)auto_nav_carrot_x + tmp_16 * (double)tmp_17),
                          (float)((double)auto_nav_carrot_y + tmp_14 * (double)tmp_15));
                qdr = (float)(((0x1.921fb54442d18p1 / (double)2 - (double)alpha_carrot) / 0x1.921fb54442d18p1) * 180.);
                while (qdr < (float)0) qdr += (float)360;
                while (qdr >= (float)360) qdr -= (float)360;
              }
            }
            goto return_label;
          }
          else 
            if ((int)nav_stage == 1) {
              nav_stage = (uint8_t)1;
              nav_block = (uint8_t)((int)nav_block + 1);
              nav_stage = (uint8_t)0;
              block_time = (uint16_t)0;
              last_x = estimator_x;
              last_y = estimator_y;
              stage_time = (uint16_t)0;
              stage_time_ds = (float)0.0;
              goto return_label;
            }
        }
        else 
          if ((int)nav_block == 4) {
            int tmp_18;
            nav_block = (uint8_t)4;
            if (rc_event_1) {
              rc_event_1 = (bool_t)0;
              tmp_18 = ! 0;
            }
            else tmp_18 = 0;
            if (tmp_18) {
              nav_block = (uint8_t)5;
              nav_stage = (uint8_t)0;
              block_time = (uint16_t)0;
              last_x = estimator_x;
              last_y = estimator_y;
              stage_time = (uint16_t)0;
              stage_time_ds = (float)0.0;
              goto return_label;
            }
            if ((int)nav_stage == 0) {
              nav_stage = (uint8_t)0;
              auto_pitch = (bool_t)0;
              nav_pitch = (float)0.000000;
              vertical_mode = (uint8_t)3;
              desired_altitude = waypoints[0].a;
              pre_climb = (float)0.;
              {
                double tmp_20;
                float tmp_19;
                double tmp_21;
                double tmp_22;
                int tmp_23;
                double tmp_24;
                int tmp_25;
                if ((double)estimator_hspeed_mod < 0.) tmp_19 = - estimator_hspeed_mod;
                else tmp_19 = estimator_hspeed_mod;
                if ((double)tmp_19 < 0.1) tmp_20 = 0.1;
                else tmp_20 = (double)estimator_hspeed_mod;
                float speed_for_radius_0 = (float)tmp_20;
                tmp_21 = pp_atan2((double)(estimator_y - waypoints[0].y),
                                  (double)(estimator_x - waypoints[0].x));
                float alpha_1 = (float)tmp_21;
                float alpha_carrot_0 =
                  (float)((double)alpha_1 + 5. / (double)((float)(-150) * speed_for_radius_0));
                tmp_22 = pp_sin((double)alpha_carrot_0);
                if ((double)150 < 0.) tmp_23 = -150; else tmp_23 = 150;
                ;
                tmp_24 = pp_sin((double)alpha_carrot_0 + 1.57079632679489661923);
                if ((double)150 < 0.) tmp_25 = -150; else tmp_25 = 150;
                ;
                fly_to_xy((float)((double)waypoints[0].x + tmp_24 * (double)tmp_25),
                          (float)((double)waypoints[0].y + tmp_22 * (double)tmp_23));
                qdr = (float)(((0x1.921fb54442d18p1 / (double)2 - (double)alpha_carrot_0) / 0x1.921fb54442d18p1) * 180.);
                while (qdr < (float)0) qdr += (float)360;
                while (qdr >= (float)360) qdr -= (float)360;
              }
              goto return_label;
            }
            else 
              if ((int)nav_stage == 1) {
                nav_stage = (uint8_t)1;
                nav_block = (uint8_t)((int)nav_block + 1);
                nav_stage = (uint8_t)0;
                block_time = (uint16_t)0;
                last_x = estimator_x;
                last_y = estimator_y;
                stage_time = (uint16_t)0;
                stage_time_ds = (float)0.0;
                goto return_label;
              }
          }
          else 
            if ((int)nav_block == 5) {
              int tmp_26;
              nav_block = (uint8_t)5;
              if (rc_event_1) {
                rc_event_1 = (bool_t)0;
                tmp_26 = ! 0;
              }
              else tmp_26 = 0;
              if (tmp_26) {
                nav_block = (uint8_t)1;
                nav_stage = (uint8_t)0;
                block_time = (uint16_t)0;
                last_x = estimator_x;
                last_y = estimator_y;
                stage_time = (uint16_t)0;
                stage_time_ds = (float)0.0;
                goto return_label;
              }
              if ((int)nav_stage == 0) {
                label_while_7: nav_stage = (uint8_t)0;
                if (! (! 0)) goto label_endwhile_8;
                else {
                  nav_stage = (uint8_t)((int)nav_stage + 1);
                  last_x = estimator_x;
                  last_y = estimator_y;
                  stage_time = (uint16_t)0;
                  stage_time_ds = (float)0.0;
                  goto return_label;
                }
              }
              else 
                if ((int)nav_stage == 1) {
                  int tmp_34;
                  nav_stage = (uint8_t)1;
                  auto_pitch = (bool_t)0;
                  nav_pitch = (float)0.000000;
                  vertical_mode = (uint8_t)3;
                  desired_altitude = waypoints[1].a;
                  pre_climb = (float)0.;
                  {
                    double tmp_28;
                    float tmp_27;
                    double tmp_29;
                    double tmp_30;
                    int tmp_31;
                    double tmp_32;
                    int tmp_33;
                    if ((double)estimator_hspeed_mod < 0.) tmp_27 = - estimator_hspeed_mod;
                    else tmp_27 = estimator_hspeed_mod;
                    if ((double)tmp_27 < 0.1) tmp_28 = 0.1;
                    else tmp_28 = (double)estimator_hspeed_mod;
                    float speed_for_radius_1 = (float)tmp_28;
                    tmp_29 = pp_atan2((double)(estimator_y - waypoints[1].y),
                                      (double)(estimator_x - waypoints[1].x));
                    float alpha_2 = (float)tmp_29;
                    float alpha_carrot_1 =
                      (float)((double)alpha_2 + 5. / (double)((float)(-100) * speed_for_radius_1));
                    tmp_30 = pp_sin((double)alpha_carrot_1);
                    if ((double)100 < 0.) tmp_31 = -100; else tmp_31 = 100;
                    ;
                    tmp_32 = pp_sin((double)alpha_carrot_1 + 1.57079632679489661923);
                    if ((double)100 < 0.) tmp_33 = -100; else tmp_33 = 100;
                    ;
                    fly_to_xy((float)((double)waypoints[1].x + tmp_32 * (double)tmp_33),
                              (float)((double)waypoints[1].y + tmp_30 * (double)tmp_31));
                    qdr = (float)(((0x1.921fb54442d18p1 / (double)2 - (double)alpha_carrot_1) / 0x1.921fb54442d18p1) * 180.);
                    while (qdr < (float)0) qdr += (float)360;
                    while (qdr >= (float)360) qdr -= (float)360;
                  }
                  if (0 <= 350) tmp_34 = 0; else tmp_34 = 350;
                  ;
                  if ((float)tmp_34 < qdr) 
                    if (qdr < (float)(0 + 10)) {
                      nav_stage = (uint8_t)((int)nav_stage + 1);
                      last_x = estimator_x;
                      last_y = estimator_y;
                      stage_time = (uint16_t)0;
                      stage_time_ds = (float)0.0;
                      goto return_label;
                    }
                  goto return_label;
                }
                else 
                  if ((int)nav_stage == 2) {
                    int tmp_42;
                    nav_stage = (uint8_t)2;
                    auto_pitch = (bool_t)0;
                    nav_pitch = (float)0.000000;
                    vertical_mode = (uint8_t)3;
                    desired_altitude = waypoints[4].a;
                    pre_climb = (float)0.;
                    {
                      double tmp_36;
                      float tmp_35;
                      double tmp_37;
                      double tmp_38;
                      int tmp_39;
                      double tmp_40;
                      int tmp_41;
                      if ((double)estimator_hspeed_mod < 0.) tmp_35 = - estimator_hspeed_mod;
                      else tmp_35 = estimator_hspeed_mod;
                      if ((double)tmp_35 < 0.1) tmp_36 = 0.1;
                      else tmp_36 = (double)estimator_hspeed_mod;
                      float speed_for_radius_2 = (float)tmp_36;
                      tmp_37 = pp_atan2((double)(estimator_y - waypoints[4].y),
                                        (double)(estimator_x - waypoints[4].x));
                      float alpha_3 = (float)tmp_37;
                      float alpha_carrot_2 =
                        (float)((double)alpha_3 + 5. / (double)((float)(-100) * speed_for_radius_2));
                      tmp_38 = pp_sin((double)alpha_carrot_2);
                      if ((double)100 < 0.) tmp_39 = -100; else tmp_39 = 100;
                      ;
                      tmp_40 = pp_sin((double)alpha_carrot_2 + 1.57079632679489661923);
                      if ((double)100 < 0.) tmp_41 = -100; else tmp_41 = 100;
                      ;
                      fly_to_xy((float)((double)waypoints[4].x + tmp_40 * (double)tmp_41),
                                (float)((double)waypoints[4].y + tmp_38 * (double)tmp_39));
                      qdr = (float)(((0x1.921fb54442d18p1 / (double)2 - (double)alpha_carrot_2) / 0x1.921fb54442d18p1) * 180.);
                      while (qdr < (float)0) qdr += (float)360;
                      while (qdr >= (float)360) qdr -= (float)360;
                    }
                    if (180 <= 350) tmp_42 = 180; else tmp_42 = 350;
                    ;
                    if ((float)tmp_42 < qdr) 
                      if (qdr < (float)(180 + 10)) {
                        nav_stage = (uint8_t)((int)nav_stage + 1);
                        last_x = estimator_x;
                        last_y = estimator_y;
                        stage_time = (uint16_t)0;
                        stage_time_ds = (float)0.0;
                        goto return_label;
                      }
                    goto return_label;
                  }
                  else 
                    if ((int)nav_stage == 3) {
                      nav_stage = (uint8_t)3;
                      goto label_while_7;
                    }
                    else 
                      if ((int)nav_stage == 4) {
                        label_endwhile_8: nav_stage = (uint8_t)4;
                        nav_block = (uint8_t)((int)nav_block + 1);
                        nav_stage = (uint8_t)0;
                        block_time = (uint16_t)0;
                        last_x = estimator_x;
                        last_y = estimator_y;
                        stage_time = (uint16_t)0;
                        stage_time_ds = (float)0.0;
                        goto return_label;
                      }
            }
  return_label: return;
}

int32_t const nav_east0 = 605530;
int32_t const nav_north0 = 5797350;
float desired_altitude = (float)(125. + 50.);
float nav_pitch = (float)0.;
uint8_t const nb_waypoint = (uint8_t)7;
struct point waypoints[7 + 1] =
  {{.x = (float)0.0, .y = (float)0.0, .a = (float)200},
   {.x = (float)0.0, .y = (float)0.0, .a = (float)200},
   {.x = (float)115.0, .y = (float)(- 75.0), .a = (float)200},
   {.x = (float)156.7, .y = (float)(- 41.7), .a = (float)200},
   {.x = (float)115.0, .y = (float)0.0, .a = (float)200},
   {.x = (float)0.0, .y = (float)(- 75.0), .a = (float)200},
   {.x = (float)(- 51.7), .y = (float)(- 36.7), .a = (float)200}};
static float carrot;
static bool_t approaching(uint8_t wp)
{
  bool_t __retres;
  float scal_prod;
  float pw_x = waypoints[wp].x - estimator_x;
  float pw_y = waypoints[wp].y - estimator_y;
  dist2_to_wp = pw_x * pw_x + pw_y * pw_y;
  carrot = (float)(5. * (double)estimator_hspeed_mod);
  if (carrot < (float)40) carrot = (float)40; else carrot = carrot;
  if (dist2_to_wp < carrot * carrot) {
    __retres = (bool_t)(! 0);
    goto return_label;
  }
  scal_prod = (waypoints[wp].x - last_x) * pw_x + (waypoints[wp].y - last_y) * pw_y;
  __retres = (bool_t)(scal_prod < (float)0);
  return_label: return __retres;
}

static void fly_to_xy(float x, float y)
{
  double tmp;
  desired_x = x;
  desired_y = y;
  tmp = pp_atan2((double)(y - estimator_y),(double)(x - estimator_x));
  desired_course = (float)(0x1.921fb54442d18p1 / 2. - tmp);
  return;
}

static void fly_to(uint8_t wp)
{
  fly_to_xy(waypoints[wp].x,waypoints[wp].y);
  return;
}

static float alpha;
static float leg;
static void route_to(uint8_t _last_wp, uint8_t wp)
{
  double tmp;
  double tmp_0;
  float last_wp_x = waypoints[_last_wp].x;
  float last_wp_y = waypoints[_last_wp].y;
  float leg_x = waypoints[wp].x - last_wp_x;
  float leg_y = waypoints[wp].y - last_wp_y;
  float leg2 = leg_x * leg_x + leg_y * leg_y;
  alpha = ((estimator_x - last_wp_x) * leg_x + (estimator_y - last_wp_y) * leg_y) / leg2;
  if ((double)alpha >= 0.) alpha = alpha; else alpha = (float)0.;
  tmp = pp_sqrt((double)leg2);
  leg = (float)tmp;
  if ((double)(carrot / leg) >= 0.) tmp_0 = (double)(carrot / leg);
  else tmp_0 = 0.;
  alpha = (float)((double)alpha + tmp_0);
  if (1. <= (double)alpha) alpha = (float)1.; else alpha = alpha;
  fly_to_xy(last_wp_x + alpha * leg_x,last_wp_y + alpha * leg_y);
  return;
}

__inline static void compute_dist2_to_home(void)
{
  float ph_x = waypoints[0].x - estimator_x;
  float ph_y = waypoints[0].y - estimator_y;
  dist2_to_home = ph_x * ph_x + ph_y * ph_y;
  too_far_from_home = (bool_t)((double)dist2_to_home > 500. * 500.);
  return;
}

void nav_home(void)
{
  {
    double tmp_0;
    float tmp;
    double tmp_1;
    double tmp_2;
    int tmp_3;
    double tmp_4;
    int tmp_5;
    if ((double)estimator_hspeed_mod < 0.) tmp = - estimator_hspeed_mod;
    else tmp = estimator_hspeed_mod;
    if ((double)tmp < 0.1) tmp_0 = 0.1;
    else tmp_0 = (double)estimator_hspeed_mod;
    float speed_for_radius = (float)tmp_0;
    tmp_1 = pp_atan2((double)(estimator_y - waypoints[0].y),
                     (double)(estimator_x - waypoints[0].x));
    float alpha_0 = (float)tmp_1;
    float alpha_carrot =
      (float)((double)alpha_0 + 5. / (double)((float)(-50) * speed_for_radius));
    tmp_2 = pp_sin((double)alpha_carrot);
    if ((double)50 < 0.) tmp_3 = -50; else tmp_3 = 50;
    ;
    tmp_4 = pp_sin((double)alpha_carrot + 1.57079632679489661923);
    if ((double)50 < 0.) tmp_5 = -50; else tmp_5 = 50;
    ;
    fly_to_xy((float)((double)waypoints[0].x + tmp_4 * (double)tmp_5),
              (float)((double)waypoints[0].y + tmp_2 * (double)tmp_3));
    qdr = (float)(((0x1.921fb54442d18p1 / (double)2 - (double)alpha_carrot) / 0x1.921fb54442d18p1) * 180.);
    while (qdr < (float)0) qdr += (float)360;
    while (qdr >= (float)360) qdr -= (float)360;
  }
  nav_pitch = (float)0.;
  vertical_mode = (uint8_t)3;
  desired_altitude = (float)(125. + (double)50);
  compute_dist2_to_home();
  dist2_to_wp = dist2_to_home;
  return;
}

void nav_update(void)
{
  compute_dist2_to_home();
  auto_nav();
  return;
}

void nav_init(void)
{
  nav_block = (uint8_t)0;
  nav_stage = (uint8_t)0;
  return;
}

int16_t desired_gaz;
int16_t desired_aileron;
int16_t desired_elevator;
float desired_roll = (float)0.;
float desired_pitch = (float)0.;
float roll_pgain = (float)10000.;
float pitch_pgain = (float)15000.;
float pitch_of_roll = (float)0.0;
float pitch_of_vz_pgain = (float)0.05;
float pitch_of_vz = (float)0.;
void roll_pitch_pid_run(void)
{
  float tmp_0;
  float err = estimator_phi - desired_roll;
  if (roll_pgain * err < (float)(- (600 * 16))) desired_aileron = (int16_t)(- (
                                                600 * 16));
  else {
    float tmp;
    if (roll_pgain * err > (float)(600 * 16)) tmp = (float)(600 * 16);
    else tmp = roll_pgain * err;
    desired_aileron = (int16_t)tmp;
  }
  if ((double)pitch_of_roll < 0.) pitch_of_roll = (float)0.;
  if ((double)estimator_phi < 0.) tmp_0 = - estimator_phi;
  else tmp_0 = estimator_phi;
  err = - ((estimator_theta - desired_pitch) - pitch_of_roll * tmp_0);
  if (pitch_pgain * err < (float)(- (600 * 16))) desired_elevator = (int16_t)(- (
                                                 600 * 16));
  else {
    float tmp_1;
    if (pitch_pgain * err > (float)(600 * 16)) tmp_1 = (float)(600 * 16);
    else tmp_1 = pitch_pgain * err;
    desired_elevator = (int16_t)tmp_1;
  }
  return;
}

float course_pgain = (float)(- 0.2);
float desired_course = (float)0.;
float max_roll = (float)0.35;
void course_pid_run(void)
{
  float err = estimator_hspeed_dir - desired_course;
  while ((double)err > 0x1.921fb54442d18p1) err = (float)((double)err - 
                                                          (double)2 * 0x1.921fb54442d18p1);
  while ((double)err < - 0x1.921fb54442d18p1) err = (float)((double)err + 
                                                            (double)2 * 0x1.921fb54442d18p1);
  nav_desired_roll = course_pgain * err;
  if (nav_desired_roll > max_roll) nav_desired_roll = max_roll;
  else 
    if (nav_desired_roll < - max_roll) nav_desired_roll = - max_roll;
  return;
}

float const climb_pgain = (float)(- 0.03);
float const climb_igain = (float)0.1;
float desired_climb = (float)0.;
float pre_climb = (float)0.;
float climb_sum_err = (float)0;
float climb_pitch_pgain = (float)(- 0.1);
float climb_pitch_igain = (float)0.025;
float climb_pitch_sum_err = (float)0.;
float max_pitch = (float)0.35;
float min_pitch = (float)(- 0.35);
void climb_pid_run(void)
{
  float fgaz;
  float err = estimator_z_dot - desired_climb;
  if (auto_pitch) {
    desired_gaz = (int16_t)nav_desired_gaz;
    desired_pitch = climb_pitch_pgain * (err + climb_pitch_igain * climb_pitch_sum_err);
    if (desired_pitch > max_pitch) desired_pitch = max_pitch;
    if (desired_pitch < min_pitch) desired_pitch = min_pitch;
    climb_pitch_sum_err += err;
    if (climb_pitch_sum_err > (float)100) climb_pitch_sum_err = (float)100;
    if (climb_pitch_sum_err < (float)(-100)) climb_pitch_sum_err = (float)(-100);
  }
  else {
    if (desired_climb > (float)0) pitch_of_vz = desired_climb * pitch_of_vz_pgain;
    else pitch_of_vz = (float)0.;
    fgaz = (float)(((double)(climb_pgain * (err + climb_igain * climb_sum_err)) + 0.31) + 
                   0.2 * (double)desired_climb);
    climb_sum_err += err;
    if (climb_sum_err > (float)100) climb_sum_err = (float)100;
    if (climb_sum_err < (float)(-100)) climb_sum_err = (float)(-100);
    if (fgaz * (float)(600 * 16) < (float)0) desired_gaz = (int16_t)0;
    else {
      float tmp;
      if (fgaz * (float)(600 * 16) > (float)(600 * 16)) tmp = (float)(
                                                        600 * 16);
      else tmp = fgaz * (float)(600 * 16);
      desired_gaz = (int16_t)tmp;
    }
    desired_pitch = nav_pitch + pitch_of_vz;
  }
  return;
}

float altitude_pgain = (float)(- 0.025);
void altitude_pid_run(void)
{
  float err = estimator_z - desired_altitude;
  desired_climb = pre_climb + altitude_pgain * err;
  if ((double)desired_climb < - 1.) desired_climb = (float)(- 1.);
  if ((double)desired_climb > 1.) desired_climb = (float)1.;
  return;
}

__inline static void timer_enable_int_5(unsigned char ints)
{
  *((uint8_t volatile *)(0x37 + 0x20)) = ints;
  return;
}

uint8_t volatile spi_cur_slave;
uint8_t spi_nb_ovrn;
void spi_init(void)
{
  *((uint8_t volatile *)(0x17 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                   0x17 + 0x20)) | ((
                                                                    1 << 2) | (
                                                                    1 << 1)));
  *((uint8_t volatile *)(0x17 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                   0x17 + 0x20)) | (1 << 0));
  spi_cur_slave = (uint8_t)0;
  *((uint8_t volatile *)(0x18 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                   0x18 + 0x20)) | (1 << 0));
  *((uint8_t volatile *)(0x02 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                   0x02 + 0x20)) | (1 << 7));
  spi_cur_slave = (uint8_t)0;
  *((uint8_t volatile *)(0x03 + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                   0x03 + 0x20)) | (1 << 7));
  spi_cur_slave = (uint8_t)0;
  return;
}

void __vector_17(void) __attribute__((__signal__));

void __vector_17(void) __attribute__((__signal__));
void __vector_17(void)
{
  if ((int)spi_cur_slave == 1) link_fbw_on_spi_it();
  else fatal_error_nb = (uint8_t)((int)fatal_error_nb + 1);
  return;
}

__inline static void timer_enable_int_6(unsigned char ints)
{
  *((uint8_t volatile *)(0x37 + 0x20)) = ints;
  return;
}

static uint8_t tx_head0;
static uint8_t volatile tx_tail0;
static uint8_t tx_buf0[256];
static uint8_t tx_head1;
static uint8_t volatile tx_tail1;
static uint8_t tx_buf1[256];
void uart0_transmit(unsigned char data)
{
  if ((int)*((uint8_t volatile *)(0x0A + 0x20)) & (1 << 6)) {
    if ((int)tx_tail0 == (int)tx_head0 + 1) goto return_label;
    tx_buf0[tx_head0] = data;
    tx_head0 = (uint8_t)((int)tx_head0 + 1);
  }
  else {
    *((uint8_t volatile *)(0x0C + 0x20)) = data;
    *((uint8_t volatile *)(0x0A + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                     0x0A + 0x20)) | (
                                                     1 << 6));
  }
  return_label: return;
}

void uart1_transmit(unsigned char data)
{
  if ((int)*((uint8_t volatile *)0x9A) & (1 << 6)) {
    if ((int)tx_tail1 == (int)tx_head1 + 1) goto return_label;
    tx_buf1[tx_head1] = data;
    tx_head1 = (uint8_t)((int)tx_head1 + 1);
  }
  else {
    *((uint8_t volatile *)0x9C) = data;
    *((uint8_t volatile *)0x9A) = (uint8_t)((int)*((uint8_t volatile *)0x9A) | (
                                            1 << 6));
  }
  return_label: return;
}

void uart0_print_string(uint8_t const *s)
{
  uint8_t i = (uint8_t)0;
  while (*(s + i)) {
    uart0_transmit(*(s + i));
    i = (uint8_t)((int)i + 1);
  }
  return;
}

void uart0_print_hex(uint8_t const c)
{
  uint8_t const hex[16] =
    {(uint8_t)'0',
     (uint8_t)'1',
     (uint8_t)'2',
     (uint8_t)'3',
     (uint8_t)'4',
     (uint8_t)'5',
     (uint8_t)'6',
     (uint8_t)'7',
     (uint8_t)'8',
     (uint8_t)'9',
     (uint8_t)'A',
     (uint8_t)'B',
     (uint8_t)'C',
     (uint8_t)'D',
     (uint8_t)'E',
     (uint8_t)'F'};
  uint8_t high = (uint8_t)(((int)c & 0xF0) >> 4);
  uint8_t low = (uint8_t)((int)c & 0x0F);
  uart0_transmit(hex[high]);
  uart0_transmit(hex[low]);
  return;
}

void __vector_20(void) __attribute__((__signal__));

void __vector_20(void) __attribute__((__signal__));
void __vector_20(void)
{
  if ((int)tx_head0 == (int)tx_tail0) *((uint8_t volatile *)(0x0A + 0x20)) = (uint8_t)(
                                      (int)*((uint8_t volatile *)(0x0A + 0x20)) & ~ (
                                      1 << 6));
  else {
    *((uint8_t volatile *)(0x0C + 0x20)) = tx_buf0[tx_tail0];
    tx_tail0 = (uint8_t)((int)tx_tail0 + 1);
  }
  return;
}

void __vector_32(void) __attribute__((__signal__));

void __vector_32(void) __attribute__((__signal__));
void __vector_32(void)
{
  if ((int)tx_head1 == (int)tx_tail1) *((uint8_t volatile *)0x9A) = (uint8_t)(
                                      (int)*((uint8_t volatile *)0x9A) & ~ (
                                      1 << 6));
  else {
    *((uint8_t volatile *)0x9C) = tx_buf1[tx_tail1];
    tx_tail1 = (uint8_t)((int)tx_tail1 + 1);
  }
  return;
}

void uart0_init(void)
{
  *((uint8_t volatile *)0x90) = (uint8_t)0;
  *((uint8_t volatile *)(0x09 + 0x20)) = (uint8_t)25;
  *((uint8_t volatile *)(0x0B + 0x20)) = (uint8_t)0;
  *((uint8_t volatile *)(0x0A + 0x20)) = (uint8_t)((1 << 4) | (1 << 3));
  *((uint8_t volatile *)0x95) = (uint8_t)((1 << 2) | (1 << 1));
  *((uint8_t volatile *)(0x0A + 0x20)) = (uint8_t)((int)*((uint8_t volatile *)(
                                                   0x0A + 0x20)) | (1 << 7));
  return;
}

void uart1_init(void)
{
  *((uint8_t volatile *)0x98) = (uint8_t)0;
  *((uint8_t volatile *)0x99) = (uint8_t)25;
  *((uint8_t volatile *)0x9B) = (uint8_t)0;
  *((uint8_t volatile *)0x9A) = (uint8_t)((1 << 4) | (1 << 3));
  *((uint8_t volatile *)0x9D) = (uint8_t)((1 << 2) | (1 << 1));
  *((uint8_t volatile *)0x9A) = (uint8_t)((int)*((uint8_t volatile *)0x9A) | (
                                          1 << 7));
  return;
}

double pp_atan2(double x, double y)
{
  double __retres;
  double tmp;
  double angle;
  double r;
  double coeff_1 = 0x1.921fb54442d18p1 / (double)4;
  double coeff_2 = (double)3 * coeff_1;
  if (y < 0.) tmp = - y; else tmp = y;
  double abs_y = tmp + 1e-10;
  if (x > (double)0) {
    r = (x - abs_y) / (x + abs_y);
    angle = coeff_1 - coeff_1 * r;
  }
  else {
    r = (x + abs_y) / (abs_y - x);
    angle = coeff_2 - coeff_1 * r;
  }
  if (y < (double)0) {
    __retres = - angle;
    goto return_label;
  }
  else {
    __retres = angle;
    goto return_label;
  }
  return_label: return __retres;
}

/*@ requires \is_finite(x);
    assigns \result;
    assigns \result \from x; */
double pp_sin(double x)
{
  double xi;
  double y;
  double q;
  double q2;
  int sign;
  double tmp;
  xi = x;
  sign = 1;
  while (xi < - 1.57079632679489661923) xi += 6.28318530717958647692;
  while (xi > 4.71238898038468985769) xi -= 6.28318530717958647692;
  if (xi > 1.57079632679489661923) {
    xi -= 3.141592653589793238462643;
    sign = -1;
  }
  q = xi / 1.57079632679;
  q2 = q * q;
  y = ((((.00015148419 * q2 - .00467376557) * q2 + .07968967928) * q2 - .64596371106) * q2 + 1.57079631847) * q;
  if (sign < 0) tmp = - y; else tmp = y;
  return tmp;
}

double pp_sqrt(double n)
{
  double __retres;
  float x;
  float m;
  int i;
  int e;
  double tmp;
  m = frexpf((float)n,& e);
  tmp = ldexp((double)m,e / 2);
  x = (float)tmp;
  i = 0;
  /*@ loop unroll 5; */
  while (i < 5) {
    x = (float)(((double)x + n / (double)x) / (double)2);
    i ++;
  }
  __retres = (double)x;
  return __retres;
}


