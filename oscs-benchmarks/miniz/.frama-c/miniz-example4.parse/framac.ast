/* Generated by Frama-C */
#include "__fc_builtin.h"
#include "assert.h"
#include "errno.h"
#include "signal.h"
#include "stdarg.h"
#include "stddef.h"
#include "stdint.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "strings.h"
#include "time.h"
typedef unsigned long mz_ulong;
enum __anonenum_1 {
    MZ_DEFAULT_STRATEGY = 0,
    MZ_FILTERED = 1,
    MZ_HUFFMAN_ONLY = 2,
    MZ_RLE = 3,
    MZ_FIXED = 4
};
enum __anonenum_2 {
    MZ_NO_COMPRESSION = 0,
    MZ_BEST_SPEED = 1,
    MZ_BEST_COMPRESSION = 9,
    MZ_UBER_COMPRESSION = 10,
    MZ_DEFAULT_LEVEL = 6,
    MZ_DEFAULT_COMPRESSION = -1
};
enum __anonenum_3 {
    MZ_NO_FLUSH = 0,
    MZ_PARTIAL_FLUSH = 1,
    MZ_SYNC_FLUSH = 2,
    MZ_FULL_FLUSH = 3,
    MZ_FINISH = 4,
    MZ_BLOCK = 5
};
enum __anonenum_4 {
    MZ_OK = 0,
    MZ_STREAM_END = 1,
    MZ_NEED_DICT = 2,
    MZ_ERRNO = -1,
    MZ_STREAM_ERROR = -2,
    MZ_DATA_ERROR = -3,
    MZ_MEM_ERROR = -4,
    MZ_BUF_ERROR = -5,
    MZ_VERSION_ERROR = -6,
    MZ_PARAM_ERROR = -10000
};
struct mz_internal_state;
struct mz_stream_s {
   unsigned char const *next_in ;
   unsigned int avail_in ;
   mz_ulong total_in ;
   unsigned char *next_out ;
   unsigned int avail_out ;
   mz_ulong total_out ;
   char *msg ;
   struct mz_internal_state *state ;
   void *(*zalloc)(void *opaque, size_t items, size_t size) ;
   void (*zfree)(void *opaque, void *address) ;
   void *opaque ;
   int data_type ;
   mz_ulong adler ;
   mz_ulong reserved ;
};
typedef struct mz_stream_s mz_stream;
typedef mz_stream *mz_streamp;
typedef unsigned char mz_uint8;
typedef short mz_int16;
typedef unsigned short mz_uint16;
typedef unsigned int mz_uint32;
typedef unsigned int mz_uint;
typedef uint64_t mz_uint64;
typedef int mz_bool;
enum __anonenum_6 {
    TDEFL_WRITE_ZLIB_HEADER = 0x01000,
    TDEFL_COMPUTE_ADLER32 = 0x02000,
    TDEFL_GREEDY_PARSING_FLAG = 0x04000,
    TDEFL_NONDETERMINISTIC_PARSING_FLAG = 0x08000,
    TDEFL_RLE_MATCHES = 0x10000,
    TDEFL_FILTER_MATCHES = 0x20000,
    TDEFL_FORCE_ALL_STATIC_BLOCKS = 0x40000,
    TDEFL_FORCE_ALL_RAW_BLOCKS = 0x80000
};
enum __anonenum_7 {
    TDEFL_MAX_HUFF_TABLES = 3,
    TDEFL_MAX_HUFF_SYMBOLS_0 = 288,
    TDEFL_MAX_HUFF_SYMBOLS_1 = 32,
    TDEFL_MAX_HUFF_SYMBOLS_2 = 19,
    TDEFL_LZ_DICT_SIZE = 32768,
    TDEFL_LZ_DICT_SIZE_MASK = TDEFL_LZ_DICT_SIZE - 1,
    TDEFL_MIN_MATCH_LEN = 3,
    TDEFL_MAX_MATCH_LEN = 258
};
enum __anonenum_8 {
    TDEFL_LZ_CODE_BUF_SIZE = 64 * 1024,
    TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13) / 10,
    TDEFL_MAX_HUFF_SYMBOLS = 288,
    TDEFL_LZ_HASH_BITS = 15,
    TDEFL_LEVEL1_HASH_SIZE_MASK = 4095,
    TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3,
    TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS
};
enum __anonenum_tdefl_status_9 {
    TDEFL_STATUS_BAD_PARAM = -2,
    TDEFL_STATUS_PUT_BUF_FAILED = -1,
    TDEFL_STATUS_OKAY = 0,
    TDEFL_STATUS_DONE = 1
};
typedef enum __anonenum_tdefl_status_9 tdefl_status;
enum __anonenum_tdefl_flush_10 {
    TDEFL_NO_FLUSH = 0,
    TDEFL_SYNC_FLUSH = 2,
    TDEFL_FULL_FLUSH = 3,
    TDEFL_FINISH = 4
};
typedef enum __anonenum_tdefl_flush_10 tdefl_flush;
struct __anonstruct_tdefl_compressor_11 {
   mz_bool (*m_pPut_buf_func)(void const *pBuf, int len, void *pUser) ;
   void *m_pPut_buf_user ;
   mz_uint m_flags ;
   mz_uint m_max_probes[2] ;
   int m_greedy_parsing ;
   mz_uint m_adler32 ;
   mz_uint m_lookahead_pos ;
   mz_uint m_lookahead_size ;
   mz_uint m_dict_size ;
   mz_uint8 *m_pLZ_code_buf ;
   mz_uint8 *m_pLZ_flags ;
   mz_uint8 *m_pOutput_buf ;
   mz_uint8 *m_pOutput_buf_end ;
   mz_uint m_num_flags_left ;
   mz_uint m_total_lz_bytes ;
   mz_uint m_lz_code_buf_dict_pos ;
   mz_uint m_bits_in ;
   mz_uint m_bit_buffer ;
   mz_uint m_saved_match_dist ;
   mz_uint m_saved_match_len ;
   mz_uint m_saved_lit ;
   mz_uint m_output_flush_ofs ;
   mz_uint m_output_flush_remaining ;
   mz_uint m_finished ;
   mz_uint m_block_index ;
   mz_uint m_wants_to_finish ;
   tdefl_status m_prev_return_status ;
   void const *m_pIn_buf ;
   void *m_pOut_buf ;
   size_t *m_pIn_buf_size ;
   size_t *m_pOut_buf_size ;
   tdefl_flush m_flush ;
   mz_uint8 const *m_pSrc ;
   size_t m_src_buf_left ;
   size_t m_out_buf_ofs ;
   mz_uint8 m_dict[(TDEFL_LZ_DICT_SIZE + TDEFL_MAX_MATCH_LEN) - 1] ;
   mz_uint16 m_huff_count[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS] ;
   mz_uint16 m_huff_codes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS] ;
   mz_uint8 m_huff_code_sizes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS] ;
   mz_uint8 m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE] ;
   mz_uint16 m_next[TDEFL_LZ_DICT_SIZE] ;
   mz_uint16 m_hash[TDEFL_LZ_HASH_SIZE] ;
   mz_uint8 m_output_buf[TDEFL_OUT_BUF_SIZE] ;
};
typedef struct __anonstruct_tdefl_compressor_11 tdefl_compressor;
enum __anonenum_12 {
    TINFL_FLAG_PARSE_ZLIB_HEADER = 1,
    TINFL_FLAG_HAS_MORE_INPUT = 2,
    TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF = 4,
    TINFL_FLAG_COMPUTE_ADLER32 = 8
};
struct tinfl_decompressor_tag;
typedef struct tinfl_decompressor_tag tinfl_decompressor;
enum __anonenum_tinfl_status_13 {
    TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS = -4,
    TINFL_STATUS_BAD_PARAM = -3,
    TINFL_STATUS_ADLER32_MISMATCH = -2,
    TINFL_STATUS_FAILED = -1,
    TINFL_STATUS_DONE = 0,
    TINFL_STATUS_NEEDS_MORE_INPUT = 1,
    TINFL_STATUS_HAS_MORE_OUTPUT = 2
};
typedef enum __anonenum_tinfl_status_13 tinfl_status;
enum __anonenum_14 {
    TINFL_MAX_HUFF_TABLES = 3,
    TINFL_MAX_HUFF_SYMBOLS_0 = 288,
    TINFL_MAX_HUFF_SYMBOLS_1 = 32,
    TINFL_MAX_HUFF_SYMBOLS_2 = 19,
    TINFL_FAST_LOOKUP_BITS = 10,
    TINFL_FAST_LOOKUP_SIZE = 1 << TINFL_FAST_LOOKUP_BITS
};
struct __anonstruct_tinfl_huff_table_15 {
   mz_uint8 m_code_size[TINFL_MAX_HUFF_SYMBOLS_0] ;
   mz_int16 m_look_up[TINFL_FAST_LOOKUP_SIZE] ;
   mz_int16 m_tree[TINFL_MAX_HUFF_SYMBOLS_0 * 2] ;
};
typedef struct __anonstruct_tinfl_huff_table_15 tinfl_huff_table;
typedef mz_uint64 tinfl_bit_buf_t;
struct tinfl_decompressor_tag {
   mz_uint32 m_state ;
   mz_uint32 m_num_bits ;
   mz_uint32 m_zhdr0 ;
   mz_uint32 m_zhdr1 ;
   mz_uint32 m_z_adler32 ;
   mz_uint32 m_final ;
   mz_uint32 m_type ;
   mz_uint32 m_check_adler32 ;
   mz_uint32 m_dist ;
   mz_uint32 m_counter ;
   mz_uint32 m_num_extra ;
   mz_uint32 m_table_sizes[TINFL_MAX_HUFF_TABLES] ;
   tinfl_bit_buf_t m_bit_buf ;
   size_t m_dist_from_out_buf_start ;
   tinfl_huff_table m_tables[TINFL_MAX_HUFF_TABLES] ;
   mz_uint8 m_raw_header[4] ;
   mz_uint8 m_len_codes[(TINFL_MAX_HUFF_SYMBOLS_0 + TINFL_MAX_HUFF_SYMBOLS_1) + 137] ;
};
typedef unsigned char uint8;
typedef unsigned int uint;
struct __anonstruct_inflate_state_24 {
   tinfl_decompressor m_decomp ;
   mz_uint m_dict_ofs ;
   mz_uint m_dict_avail ;
   mz_uint m_first_call ;
   mz_uint m_has_flushed ;
   int m_window_bits ;
   mz_uint8 m_dict[32768] ;
   tinfl_status m_last_status ;
};
typedef struct __anonstruct_inflate_state_24 inflate_state;
struct __anonstruct_s_error_descs_25 {
   int m_err ;
   char const *m_pDesc ;
};
int main(int argc, char **argv);

int eva_main(void)
{
  char argv0[256];
  char argv1[256];
  char argv2[256];
  char argv3[256];
  char argv4[256];
  int tmp_0;
  int argc = Frama_C_interval(0,5);
  char *argv[6] = {argv0, argv1, argv2, argv3, argv4, (char *)0};
  {
    int i = 0;
    /*@ loop unroll 5; */
    while (i < 5) {
      Frama_C_make_unknown(argv[i],(size_t)255);
      *(argv[i] + 255) = (char)0;
      i ++;
    }
  }
  tmp_0 = main(argc,argv);
  return tmp_0;
}

void __attribute__((__visibility__("default"))) mz_free(void *p);

mz_ulong __attribute__((__visibility__("default"))) mz_adler32(mz_ulong adler,
                                                               unsigned char const *ptr,
                                                               size_t buf_len);

mz_ulong __attribute__((__visibility__("default"))) mz_crc32(mz_ulong crc,
                                                             unsigned char const *ptr,
                                                             size_t buf_len);

char const __attribute__((__visibility__("default"))) *mz_version(void);

int __attribute__((__visibility__("default"))) mz_deflateInit(mz_streamp pStream,
                                                              int level);

int __attribute__((__visibility__("default"))) mz_deflateInit2(mz_streamp pStream,
                                                               int level,
                                                               int method,
                                                               int window_bits,
                                                               int mem_level,
                                                               int strategy);

int __attribute__((__visibility__("default"))) mz_deflateReset(mz_streamp pStream);

int __attribute__((__visibility__("default"))) mz_deflate(mz_streamp pStream,
                                                          int flush);

int __attribute__((__visibility__("default"))) mz_deflateEnd(mz_streamp pStream);

mz_ulong __attribute__((__visibility__("default"))) mz_deflateBound(mz_streamp pStream,
                                                                    mz_ulong source_len);

int __attribute__((__visibility__("default"))) mz_compress(unsigned char *pDest,
                                                           mz_ulong *pDest_len,
                                                           unsigned char const *pSource,
                                                           mz_ulong source_len);

int __attribute__((__visibility__("default"))) mz_compress2(unsigned char *pDest,
                                                            mz_ulong *pDest_len,
                                                            unsigned char const *pSource,
                                                            mz_ulong source_len,
                                                            int level);

mz_ulong __attribute__((__visibility__("default"))) mz_compressBound(
                                                                    mz_ulong source_len);

int __attribute__((__visibility__("default"))) mz_inflateInit(mz_streamp pStream);

int __attribute__((__visibility__("default"))) mz_inflateInit2(mz_streamp pStream,
                                                               int window_bits);

int __attribute__((__visibility__("default"))) mz_inflateReset(mz_streamp pStream);

int __attribute__((__visibility__("default"))) mz_inflate(mz_streamp pStream,
                                                          int flush);

int __attribute__((__visibility__("default"))) mz_inflateEnd(mz_streamp pStream);

int __attribute__((__visibility__("default"))) mz_uncompress(unsigned char *pDest,
                                                             mz_ulong *pDest_len,
                                                             unsigned char const *pSource,
                                                             mz_ulong source_len);

int __attribute__((__visibility__("default"))) mz_uncompress2(unsigned char *pDest,
                                                              mz_ulong *pDest_len,
                                                              unsigned char const *pSource,
                                                              mz_ulong *pSource_len);

char const __attribute__((__visibility__("default"))) *mz_error(int err);

void __attribute__((__visibility__("default"))) *miniz_def_alloc_func
(void *opaque, size_t items, size_t size);

void __attribute__((__visibility__("default"))) miniz_def_free_func(void *opaque,
                                                                    void *address);

void __attribute__((__visibility__("default"))) *miniz_def_realloc_func
(void *opaque, void *address, size_t items, size_t size);

tdefl_status __attribute__((__visibility__("default"))) tdefl_init(tdefl_compressor *d,
                                                                   mz_bool (*pPut_buf_func)
                                                                   (void const *pBuf,
                                                                    int len,
                                                                    void *pUser),
                                                                   void *pPut_buf_user,
                                                                   int flags);

tdefl_status __attribute__((__visibility__("default"))) tdefl_compress
(tdefl_compressor *d, void const *pIn_buf, size_t *pIn_buf_size,
 void *pOut_buf, size_t *pOut_buf_size, tdefl_flush flush);

mz_uint32 __attribute__((__visibility__("default"))) tdefl_get_adler32
(tdefl_compressor *d);

mz_uint __attribute__((__visibility__("default"))) tdefl_create_comp_flags_from_zip_params
(int level, int window_bits, int strategy);

void __attribute__((__visibility__("default"))) *tinfl_decompress_mem_to_heap
(void const *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags);

size_t __attribute__((__visibility__("default"))) tinfl_decompress_mem_to_mem
(void *pOut_buf, size_t out_buf_len, void const *pSrc_buf,
 size_t src_buf_len, int flags);

int __attribute__((__visibility__("default"))) tinfl_decompress_mem_to_callback
(void const *pIn_buf, size_t *pIn_buf_size,
 int (*pPut_buf_func)(void const *pBuf, int len, void *pUser),
 void *pPut_buf_user, int flags);

tinfl_decompressor __attribute__((__visibility__("default"))) *tinfl_decompressor_alloc
(void);

void __attribute__((__visibility__("default"))) tinfl_decompressor_free
(tinfl_decompressor *pDecomp);

tinfl_status __attribute__((__visibility__("default"))) tinfl_decompress
(tinfl_decompressor *r, mz_uint8 const *pIn_buf_next, size_t *pIn_buf_size,
 mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size,
 mz_uint32 const decomp_flags);

static int tinfl_put_buf_func(void const *pBuf, int len, void *pUser)
{
  int __retres;
  size_t tmp;
  tmp = fwrite(pBuf,(size_t)1,(size_t)len,(FILE *)pUser);
  ;
  __retres = len == (int)tmp;
  return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_1(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_2(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_3(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_4(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_5(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_6(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_7(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_8(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_9(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_10(char const * restrict format, unsigned int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_11(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_12(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_13(char const * restrict format, unsigned int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_14(char const * restrict format, unsigned int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_15(char const * restrict format);

int main(int argc, char **argv)
{
  int __retres;
  int status;
  FILE *pInfile;
  FILE *pOutfile;
  uint infile_size;
  uint outfile_size;
  size_t in_buf_size;
  uint8 *pCmp_data;
  long file_loc;
  size_t tmp_0;
  long tmp_1;
  int tmp_2;
  if (argc != 3) {
    printf("Usage: example4 infile outfile\n"); /* printf_va_1 */
    printf("Decompresses zlib stream in file infile to file outfile.\n"); /* printf_va_2 */
    printf("Input file must be able to fit entirely in memory.\n"); /* printf_va_3 */
    printf("example3 can be used to create compressed zlib streams.\n"); /* printf_va_4 */
    __retres = 1;
    goto return_label;
  }
  pInfile = fopen((char const *)*(argv + 1),"rb");
  if (! pInfile) {
    printf("Failed opening input file!\n"); /* printf_va_5 */
    __retres = 1;
    goto return_label;
  }
  fseek(pInfile,(long)0,2);
  file_loc = ftell(pInfile);
  fseek(pInfile,(long)0,0);
  if (file_loc < (long)0) goto _LOR;
  else 
    if (file_loc > (long)2147483647) {
      _LOR:
      {
        printf("File is too large to be processed by this example.\n"); /* printf_va_6 */
        __retres = 1;
        goto return_label;
      }
    }
  infile_size = (uint)file_loc;
  pCmp_data = (uint8 *)malloc((size_t)infile_size);
  if (! pCmp_data) {
    printf("Out of memory!\n"); /* printf_va_7 */
    __retres = 1;
    goto return_label;
  }
  tmp_0 = fread((void *)pCmp_data,(size_t)1,(size_t)infile_size,pInfile);
  ;
  if (tmp_0 != (size_t)infile_size) {
    printf("Failed reading input file!\n"); /* printf_va_8 */
    __retres = 1;
    goto return_label;
  }
  pOutfile = fopen((char const *)*(argv + 2),"wb");
  if (! pOutfile) {
    printf("Failed opening output file!\n"); /* printf_va_9 */
    __retres = 1;
    goto return_label;
  }
  printf("Input file size: %u\n",infile_size); /* printf_va_10 */
  in_buf_size = (size_t)infile_size;
  status = (int)tinfl_decompress_mem_to_callback((void const *)pCmp_data,
                                                 & in_buf_size,
                                                 & tinfl_put_buf_func,
                                                 (void *)pOutfile,
                                                 TINFL_FLAG_PARSE_ZLIB_HEADER);
  if (! status) {
    printf("tinfl_decompress_mem_to_callback() failed with status %i!\n",
           status); /* printf_va_11 */
    __retres = 1;
    goto return_label;
  }
  tmp_1 = ftell(pOutfile);
  outfile_size = (uint)tmp_1;
  fclose(pInfile);
  tmp_2 = fclose(pOutfile);
  if (-1 == tmp_2) {
    printf("Failed writing to output file!\n"); /* printf_va_12 */
    __retres = 1;
    goto return_label;
  }
  printf("Total input bytes: %u\n",(uint)in_buf_size); /* printf_va_13 */
  printf("Total output bytes: %u\n",outfile_size); /* printf_va_14 */
  printf("Success.\n"); /* printf_va_15 */
  __retres = 0;
  return_label: return __retres;
}

mz_ulong __attribute__((__visibility__("default"))) mz_adler32(mz_ulong adler,
                                                               unsigned char const *ptr,
                                                               size_t buf_len)
{
  mz_ulong __attribute__((__visibility__("default"))) __retres;
  mz_uint32 i;
  mz_uint32 s1 = (mz_uint32)(adler & (unsigned long)0xffff);
  mz_uint32 s2 = (mz_uint32)(adler >> 16);
  size_t block_len = buf_len % (unsigned long)5552;
  if (! ptr) {
    __retres = (mz_ulong __attribute__((__visibility__("default"))))1;
    goto return_label;
  }
  while (buf_len) {
    i = (mz_uint32)0;
    while ((size_t)(i + (mz_uint32)7) < block_len) {
      s1 += (mz_uint32)*(ptr + 0);
      s2 += s1;
      s1 += (mz_uint32)*(ptr + 1);
      s2 += s1;
      s1 += (mz_uint32)*(ptr + 2);
      s2 += s1;
      s1 += (mz_uint32)*(ptr + 3);
      s2 += s1;
      s1 += (mz_uint32)*(ptr + 4);
      s2 += s1;
      s1 += (mz_uint32)*(ptr + 5);
      s2 += s1;
      s1 += (mz_uint32)*(ptr + 6);
      s2 += s1;
      s1 += (mz_uint32)*(ptr + 7);
      s2 += s1;
      i += (mz_uint32)8;
      ptr += 8;
    }
    while ((size_t)i < block_len) {
      unsigned char const *tmp;
      tmp = ptr;
      ptr ++;
      s1 += (mz_uint32)*tmp;
      s2 += s1;
      i ++;
    }
    s1 %= 65521U;
    s2 %= 65521U;
    buf_len -= block_len;
    block_len = (size_t)5552;
  }
  __retres = (mz_ulong __attribute__((__visibility__("default"))))((s2 << 16) + s1);
  return_label: return __retres;
}

static mz_uint32 const mz_crc32_s_crc_table[256] =
  {(mz_uint32)0x00000000,
   (mz_uint32)0x77073096,
   0xEE0E612C,
   0x990951BA,
   (mz_uint32)0x076DC419,
   (mz_uint32)0x706AF48F,
   0xE963A535,
   0x9E6495A3,
   (mz_uint32)0x0EDB8832,
   (mz_uint32)0x79DCB8A4,
   0xE0D5E91E,
   0x97D2D988,
   (mz_uint32)0x09B64C2B,
   (mz_uint32)0x7EB17CBD,
   0xE7B82D07,
   0x90BF1D91,
   (mz_uint32)0x1DB71064,
   (mz_uint32)0x6AB020F2,
   0xF3B97148,
   0x84BE41DE,
   (mz_uint32)0x1ADAD47D,
   (mz_uint32)0x6DDDE4EB,
   0xF4D4B551,
   0x83D385C7,
   (mz_uint32)0x136C9856,
   (mz_uint32)0x646BA8C0,
   0xFD62F97A,
   0x8A65C9EC,
   (mz_uint32)0x14015C4F,
   (mz_uint32)0x63066CD9,
   0xFA0F3D63,
   0x8D080DF5,
   (mz_uint32)0x3B6E20C8,
   (mz_uint32)0x4C69105E,
   0xD56041E4,
   0xA2677172,
   (mz_uint32)0x3C03E4D1,
   (mz_uint32)0x4B04D447,
   0xD20D85FD,
   0xA50AB56B,
   (mz_uint32)0x35B5A8FA,
   (mz_uint32)0x42B2986C,
   0xDBBBC9D6,
   0xACBCF940,
   (mz_uint32)0x32D86CE3,
   (mz_uint32)0x45DF5C75,
   0xDCD60DCF,
   0xABD13D59,
   (mz_uint32)0x26D930AC,
   (mz_uint32)0x51DE003A,
   0xC8D75180,
   0xBFD06116,
   (mz_uint32)0x21B4F4B5,
   (mz_uint32)0x56B3C423,
   0xCFBA9599,
   0xB8BDA50F,
   (mz_uint32)0x2802B89E,
   (mz_uint32)0x5F058808,
   0xC60CD9B2,
   0xB10BE924,
   (mz_uint32)0x2F6F7C87,
   (mz_uint32)0x58684C11,
   0xC1611DAB,
   0xB6662D3D,
   (mz_uint32)0x76DC4190,
   (mz_uint32)0x01DB7106,
   0x98D220BC,
   0xEFD5102A,
   (mz_uint32)0x71B18589,
   (mz_uint32)0x06B6B51F,
   0x9FBFE4A5,
   0xE8B8D433,
   (mz_uint32)0x7807C9A2,
   (mz_uint32)0x0F00F934,
   0x9609A88E,
   0xE10E9818,
   (mz_uint32)0x7F6A0DBB,
   (mz_uint32)0x086D3D2D,
   0x91646C97,
   0xE6635C01,
   (mz_uint32)0x6B6B51F4,
   (mz_uint32)0x1C6C6162,
   0x856530D8,
   0xF262004E,
   (mz_uint32)0x6C0695ED,
   (mz_uint32)0x1B01A57B,
   0x8208F4C1,
   0xF50FC457,
   (mz_uint32)0x65B0D9C6,
   (mz_uint32)0x12B7E950,
   0x8BBEB8EA,
   0xFCB9887C,
   (mz_uint32)0x62DD1DDF,
   (mz_uint32)0x15DA2D49,
   0x8CD37CF3,
   0xFBD44C65,
   (mz_uint32)0x4DB26158,
   (mz_uint32)0x3AB551CE,
   0xA3BC0074,
   0xD4BB30E2,
   (mz_uint32)0x4ADFA541,
   (mz_uint32)0x3DD895D7,
   0xA4D1C46D,
   0xD3D6F4FB,
   (mz_uint32)0x4369E96A,
   (mz_uint32)0x346ED9FC,
   0xAD678846,
   0xDA60B8D0,
   (mz_uint32)0x44042D73,
   (mz_uint32)0x33031DE5,
   0xAA0A4C5F,
   0xDD0D7CC9,
   (mz_uint32)0x5005713C,
   (mz_uint32)0x270241AA,
   0xBE0B1010,
   0xC90C2086,
   (mz_uint32)0x5768B525,
   (mz_uint32)0x206F85B3,
   0xB966D409,
   0xCE61E49F,
   (mz_uint32)0x5EDEF90E,
   (mz_uint32)0x29D9C998,
   0xB0D09822,
   0xC7D7A8B4,
   (mz_uint32)0x59B33D17,
   (mz_uint32)0x2EB40D81,
   0xB7BD5C3B,
   0xC0BA6CAD,
   0xEDB88320,
   0x9ABFB3B6,
   (mz_uint32)0x03B6E20C,
   (mz_uint32)0x74B1D29A,
   0xEAD54739,
   0x9DD277AF,
   (mz_uint32)0x04DB2615,
   (mz_uint32)0x73DC1683,
   0xE3630B12,
   0x94643B84,
   (mz_uint32)0x0D6D6A3E,
   (mz_uint32)0x7A6A5AA8,
   0xE40ECF0B,
   0x9309FF9D,
   (mz_uint32)0x0A00AE27,
   (mz_uint32)0x7D079EB1,
   0xF00F9344,
   0x8708A3D2,
   (mz_uint32)0x1E01F268,
   (mz_uint32)0x6906C2FE,
   0xF762575D,
   0x806567CB,
   (mz_uint32)0x196C3671,
   (mz_uint32)0x6E6B06E7,
   0xFED41B76,
   0x89D32BE0,
   (mz_uint32)0x10DA7A5A,
   (mz_uint32)0x67DD4ACC,
   0xF9B9DF6F,
   0x8EBEEFF9,
   (mz_uint32)0x17B7BE43,
   (mz_uint32)0x60B08ED5,
   0xD6D6A3E8,
   0xA1D1937E,
   (mz_uint32)0x38D8C2C4,
   (mz_uint32)0x4FDFF252,
   0xD1BB67F1,
   0xA6BC5767,
   (mz_uint32)0x3FB506DD,
   (mz_uint32)0x48B2364B,
   0xD80D2BDA,
   0xAF0A1B4C,
   (mz_uint32)0x36034AF6,
   (mz_uint32)0x41047A60,
   0xDF60EFC3,
   0xA867DF55,
   (mz_uint32)0x316E8EEF,
   (mz_uint32)0x4669BE79,
   0xCB61B38C,
   0xBC66831A,
   (mz_uint32)0x256FD2A0,
   (mz_uint32)0x5268E236,
   0xCC0C7795,
   0xBB0B4703,
   (mz_uint32)0x220216B9,
   (mz_uint32)0x5505262F,
   0xC5BA3BBE,
   0xB2BD0B28,
   (mz_uint32)0x2BB45A92,
   (mz_uint32)0x5CB36A04,
   0xC2D7FFA7,
   0xB5D0CF31,
   (mz_uint32)0x2CD99E8B,
   (mz_uint32)0x5BDEAE1D,
   0x9B64C2B0,
   0xEC63F226,
   (mz_uint32)0x756AA39C,
   (mz_uint32)0x026D930A,
   0x9C0906A9,
   0xEB0E363F,
   (mz_uint32)0x72076785,
   (mz_uint32)0x05005713,
   0x95BF4A82,
   0xE2B87A14,
   (mz_uint32)0x7BB12BAE,
   (mz_uint32)0x0CB61B38,
   0x92D28E9B,
   0xE5D5BE0D,
   (mz_uint32)0x7CDCEFB7,
   (mz_uint32)0x0BDBDF21,
   0x86D3D2D4,
   0xF1D4E242,
   (mz_uint32)0x68DDB3F8,
   (mz_uint32)0x1FDA836E,
   0x81BE16CD,
   0xF6B9265B,
   (mz_uint32)0x6FB077E1,
   (mz_uint32)0x18B74777,
   0x88085AE6,
   0xFF0F6A70,
   (mz_uint32)0x66063BCA,
   (mz_uint32)0x11010B5C,
   0x8F659EFF,
   0xF862AE69,
   (mz_uint32)0x616BFFD3,
   (mz_uint32)0x166CCF45,
   0xA00AE278,
   0xD70DD2EE,
   (mz_uint32)0x4E048354,
   (mz_uint32)0x3903B3C2,
   0xA7672661,
   0xD06016F7,
   (mz_uint32)0x4969474D,
   (mz_uint32)0x3E6E77DB,
   0xAED16A4A,
   0xD9D65ADC,
   (mz_uint32)0x40DF0B66,
   (mz_uint32)0x37D83BF0,
   0xA9BCAE53,
   0xDEBB9EC5,
   (mz_uint32)0x47B2CF7F,
   (mz_uint32)0x30B5FFE9,
   0xBDBDF21C,
   0xCABAC28A,
   (mz_uint32)0x53B39330,
   (mz_uint32)0x24B4A3A6,
   0xBAD03605,
   0xCDD70693,
   (mz_uint32)0x54DE5729,
   (mz_uint32)0x23D967BF,
   0xB3667A2E,
   0xC4614AB8,
   (mz_uint32)0x5D681B02,
   (mz_uint32)0x2A6F2B94,
   0xB40BBE37,
   0xC30C8EA1,
   (mz_uint32)0x5A05DF1B,
   (mz_uint32)0x2D02EF8D};
mz_ulong __attribute__((__visibility__("default"))) mz_crc32(mz_ulong crc,
                                                             unsigned char const *ptr,
                                                             size_t buf_len)
{
  mz_ulong __attribute__((__visibility__("default"))) __retres;
  mz_uint32 mz_crc32_0 = (mz_uint32)crc ^ 0xFFFFFFFF;
  mz_uint8 const *pByte_buf = ptr;
  while (buf_len >= (size_t)4) {
    mz_crc32_0 = (mz_crc32_0 >> 8) ^ mz_crc32_s_crc_table[(mz_crc32_0 ^ (unsigned int)*(
                                                           pByte_buf + 0)) & (unsigned int)0xFF];
    mz_crc32_0 = (mz_crc32_0 >> 8) ^ mz_crc32_s_crc_table[(mz_crc32_0 ^ (unsigned int)*(
                                                           pByte_buf + 1)) & (unsigned int)0xFF];
    mz_crc32_0 = (mz_crc32_0 >> 8) ^ mz_crc32_s_crc_table[(mz_crc32_0 ^ (unsigned int)*(
                                                           pByte_buf + 2)) & (unsigned int)0xFF];
    mz_crc32_0 = (mz_crc32_0 >> 8) ^ mz_crc32_s_crc_table[(mz_crc32_0 ^ (unsigned int)*(
                                                           pByte_buf + 3)) & (unsigned int)0xFF];
    pByte_buf += 4;
    buf_len -= (size_t)4;
  }
  while (buf_len) {
    mz_crc32_0 = (mz_crc32_0 >> 8) ^ mz_crc32_s_crc_table[(mz_crc32_0 ^ (unsigned int)*(
                                                           pByte_buf + 0)) & (unsigned int)0xFF];
    pByte_buf ++;
    buf_len --;
  }
  __retres = (mz_ulong __attribute__((__visibility__("default"))))(~ mz_crc32_0);
  return __retres;
}

void __attribute__((__visibility__("default"))) mz_free(void *p)
{
  free(p);
  return;
}

void __attribute__((__visibility__("default"))) *miniz_def_alloc_func
(void *opaque, size_t items, size_t size)
{
  void __attribute__((__visibility__("default"))) *tmp;
  tmp = (void __attribute__((__visibility__("default"))) *)malloc(items * size);
  return tmp;
}

void __attribute__((__visibility__("default"))) miniz_def_free_func(void *opaque,
                                                                    void *address)
{
  free(address);
  return;
}

void __attribute__((__visibility__("default"))) *miniz_def_realloc_func
(void *opaque, void *address, size_t items, size_t size)
{
  void __attribute__((__visibility__("default"))) *tmp;
  tmp = (void __attribute__((__visibility__("default"))) *)realloc(address,
                                                                   items * size);
  return tmp;
}

char const __attribute__((__visibility__("default"))) *mz_version(void)
{
  char const __attribute__((__visibility__("default"))) *__retres;
  __retres = (char const __attribute__((__visibility__("default"))) *)"10.1.0";
  return __retres;
}

int __attribute__((__visibility__("default"))) mz_deflateInit(mz_streamp pStream,
                                                              int level)
{
  int __attribute__((__visibility__("default"))) tmp;
  tmp = mz_deflateInit2(pStream,level,8,15,9,MZ_DEFAULT_STRATEGY);
  return tmp;
}

int __attribute__((__visibility__("default"))) mz_deflateInit2(mz_streamp pStream,
                                                               int level,
                                                               int method,
                                                               int window_bits,
                                                               int mem_level,
                                                               int strategy)
{
  int __attribute__((__visibility__("default"))) __retres;
  tdefl_compressor *pComp;
  mz_uint __attribute__((__visibility__("default"))) tmp;
  tdefl_status __attribute__((__visibility__("default"))) tmp_1;
  tmp = tdefl_create_comp_flags_from_zip_params(level,window_bits,strategy);
  mz_uint comp_flags =
    (mz_uint)((unsigned int __attribute__((__visibility__("default"))))TDEFL_COMPUTE_ADLER32 | tmp);
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  if (method != 8) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
    goto return_label;
  }
  else 
    if (mem_level < 1) {
      __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
      goto return_label;
    }
    else 
      if (mem_level > 9) {
        __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
        goto return_label;
      }
      else 
        if (window_bits != 15) 
          if (- window_bits != 15) {
            __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
            goto return_label;
          }
  pStream->data_type = 0;
  pStream->adler = (mz_ulong)1;
  pStream->msg = (char *)0;
  pStream->reserved = (mz_ulong)0;
  pStream->total_in = (mz_ulong)0;
  pStream->total_out = (mz_ulong)0;
  if (! pStream->zalloc) pStream->zalloc = (void *(*)(void *opaque,
                                                      size_t items,
                                                      size_t size))(& miniz_def_alloc_func);
  if (! pStream->zfree) pStream->zfree = (void (*)(void *opaque,
                                                   void *address))(& miniz_def_free_func);
  pComp = (tdefl_compressor *)(*(pStream->zalloc))(pStream->opaque,(size_t)1,
                                                   sizeof(tdefl_compressor));
  if (! pComp) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_MEM_ERROR;
    goto return_label;
  }
  pStream->state = (struct mz_internal_state *)pComp;
  tmp_1 = tdefl_init(pComp,
                     (mz_bool (*)(void const *pBuf, int len, void *pUser))0,
                     (void *)0,(int)comp_flags);
  if (tmp_1 != (int __attribute__((__visibility__("default"))))TDEFL_STATUS_OKAY) {
    mz_deflateEnd(pStream);
    __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
    goto return_label;
  }
  __retres = (int __attribute__((__visibility__("default"))))MZ_OK;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_deflateReset(mz_streamp pStream)
{
  int __attribute__((__visibility__("default"))) __retres;
  mz_ulong tmp;
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  else 
    if (! pStream->state) {
      __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
      goto return_label;
    }
    else 
      if (! pStream->zalloc) {
        __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
        goto return_label;
      }
      else 
        if (! pStream->zfree) {
          __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
          goto return_label;
        }
  tmp = (mz_ulong)0;
  pStream->total_out = tmp;
  pStream->total_in = tmp;
  tdefl_init((tdefl_compressor *)pStream->state,
             (mz_bool (*)(void const *pBuf, int len, void *pUser))0,
             (void *)0,(int)((tdefl_compressor *)pStream->state)->m_flags);
  __retres = (int __attribute__((__visibility__("default"))))MZ_OK;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_deflate(mz_streamp pStream,
                                                          int flush)
{
  int __attribute__((__visibility__("default"))) __retres;
  size_t in_bytes;
  size_t out_bytes;
  mz_ulong orig_total_in;
  mz_ulong orig_total_out;
  int mz_status = MZ_OK;
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  else 
    if (! pStream->state) {
      __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
      goto return_label;
    }
    else 
      if (flush < 0) {
        __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
        goto return_label;
      }
      else 
        if (flush > MZ_FINISH) {
          __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
          goto return_label;
        }
        else 
          if (! pStream->next_out) {
            __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
            goto return_label;
          }
  if (! pStream->avail_out) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_BUF_ERROR;
    goto return_label;
  }
  if (flush == MZ_PARTIAL_FLUSH) flush = MZ_SYNC_FLUSH;
  if (((tdefl_compressor *)pStream->state)->m_prev_return_status == TDEFL_STATUS_DONE) {
    int tmp;
    if (flush == MZ_FINISH) tmp = MZ_STREAM_END; else tmp = MZ_BUF_ERROR;
    __retres = (int __attribute__((__visibility__("default"))))tmp;
    goto return_label;
  }
  orig_total_in = pStream->total_in;
  orig_total_out = pStream->total_out;
  while (1) {
    tdefl_status defl_status;
    tdefl_status __attribute__((__visibility__("default"))) tmp_0;
    mz_uint32 __attribute__((__visibility__("default"))) tmp_1;
    in_bytes = (size_t)pStream->avail_in;
    out_bytes = (size_t)pStream->avail_out;
    tmp_0 = tdefl_compress((tdefl_compressor *)pStream->state,
                           (void const *)pStream->next_in,& in_bytes,
                           (void *)pStream->next_out,& out_bytes,
                           (tdefl_flush)flush);
    defl_status = (tdefl_status)tmp_0;
    pStream->next_in += (mz_uint)in_bytes;
    pStream->avail_in -= (mz_uint)in_bytes;
    pStream->total_in += (mz_ulong)((mz_uint)in_bytes);
    tmp_1 = tdefl_get_adler32((tdefl_compressor *)pStream->state);
    pStream->adler = (mz_ulong)tmp_1;
    pStream->next_out += (mz_uint)out_bytes;
    pStream->avail_out -= (mz_uint)out_bytes;
    pStream->total_out += (mz_ulong)((mz_uint)out_bytes);
    if (defl_status < 0) {
      mz_status = MZ_STREAM_ERROR;
      break;
    }
    else 
      if (defl_status == TDEFL_STATUS_DONE) {
        mz_status = MZ_STREAM_END;
        break;
      }
      else 
        if (! pStream->avail_out) break;
        else 
          if (! pStream->avail_in) 
            if (flush != MZ_FINISH) {
              if (flush) break;
              else 
                if (pStream->total_in != orig_total_in) break;
                else 
                  if (pStream->total_out != orig_total_out) break;
              __retres = (int __attribute__((__visibility__("default"))))MZ_BUF_ERROR;
              goto return_label;
            }
  }
  __retres = (int __attribute__((__visibility__("default"))))mz_status;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_deflateEnd(mz_streamp pStream)
{
  int __attribute__((__visibility__("default"))) __retres;
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  if (pStream->state) {
    (*(pStream->zfree))(pStream->opaque,(void *)pStream->state);
    pStream->state = (struct mz_internal_state *)0;
  }
  __retres = (int __attribute__((__visibility__("default"))))MZ_OK;
  return_label: return __retres;
}

mz_ulong __attribute__((__visibility__("default"))) mz_deflateBound(mz_streamp pStream,
                                                                    mz_ulong source_len)
{
  mz_ulong __attribute__((__visibility__("default"))) __retres;
  mz_ulong tmp;
  if ((mz_ulong)128 + (source_len * (mz_ulong)110) / (mz_ulong)100 > 
      ((mz_ulong)128 + source_len) + (source_len / (mz_ulong)(31 * 1024) + (mz_ulong)1) * (mz_ulong)5) 
    tmp = (mz_ulong)128 + (source_len * (mz_ulong)110) / (mz_ulong)100;
  else tmp = ((mz_ulong)128 + source_len) + (source_len / (mz_ulong)(
                                             31 * 1024) + (mz_ulong)1) * (mz_ulong)5;
  __retres = (mz_ulong __attribute__((__visibility__("default"))))tmp;
  return __retres;
}

int __attribute__((__visibility__("default"))) mz_compress2(unsigned char *pDest,
                                                            mz_ulong *pDest_len,
                                                            unsigned char const *pSource,
                                                            mz_ulong source_len,
                                                            int level)
{
  int __attribute__((__visibility__("default"))) __retres;
  int status;
  mz_stream stream;
  int __attribute__((__visibility__("default"))) tmp_0;
  memset((void *)(& stream),0,sizeof(stream));
  if ((source_len | *pDest_len) > (unsigned long)0xFFFFFFFFU) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
    goto return_label;
  }
  stream.next_in = pSource;
  stream.avail_in = (mz_uint32)source_len;
  stream.next_out = pDest;
  stream.avail_out = (mz_uint32)*pDest_len;
  status = (int)mz_deflateInit(& stream,level);
  if (status != MZ_OK) {
    __retres = (int __attribute__((__visibility__("default"))))status;
    goto return_label;
  }
  status = (int)mz_deflate(& stream,MZ_FINISH);
  if (status != MZ_STREAM_END) {
    int tmp;
    mz_deflateEnd(& stream);
    if (status == MZ_OK) tmp = MZ_BUF_ERROR; else tmp = status;
    __retres = (int __attribute__((__visibility__("default"))))tmp;
    goto return_label;
  }
  *pDest_len = stream.total_out;
  tmp_0 = mz_deflateEnd(& stream);
  __retres = tmp_0;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_compress(unsigned char *pDest,
                                                           mz_ulong *pDest_len,
                                                           unsigned char const *pSource,
                                                           mz_ulong source_len)
{
  int __attribute__((__visibility__("default"))) tmp;
  tmp = mz_compress2(pDest,pDest_len,pSource,source_len,
                     MZ_DEFAULT_COMPRESSION);
  return tmp;
}

mz_ulong __attribute__((__visibility__("default"))) mz_compressBound(
                                                                    mz_ulong source_len)
{
  mz_ulong __attribute__((__visibility__("default"))) tmp;
  tmp = mz_deflateBound((mz_streamp)0,source_len);
  return tmp;
}

int __attribute__((__visibility__("default"))) mz_inflateInit2(mz_streamp pStream,
                                                               int window_bits)
{
  int __attribute__((__visibility__("default"))) __retres;
  inflate_state *pDecomp;
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  if (window_bits != 15) 
    if (- window_bits != 15) {
      __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
      goto return_label;
    }
  pStream->data_type = 0;
  pStream->adler = (mz_ulong)0;
  pStream->msg = (char *)0;
  pStream->total_in = (mz_ulong)0;
  pStream->total_out = (mz_ulong)0;
  pStream->reserved = (mz_ulong)0;
  if (! pStream->zalloc) pStream->zalloc = (void *(*)(void *opaque,
                                                      size_t items,
                                                      size_t size))(& miniz_def_alloc_func);
  if (! pStream->zfree) pStream->zfree = (void (*)(void *opaque,
                                                   void *address))(& miniz_def_free_func);
  pDecomp = (inflate_state *)(*(pStream->zalloc))(pStream->opaque,(size_t)1,
                                                  sizeof(inflate_state));
  if (! pDecomp) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_MEM_ERROR;
    goto return_label;
  }
  pStream->state = (struct mz_internal_state *)pDecomp;
  pDecomp->m_decomp.m_state = (mz_uint32)0;
  pDecomp->m_decomp.m_num_bits = (mz_uint32)0;
  pDecomp->m_decomp.m_bit_buf = (tinfl_bit_buf_t)0;
  pDecomp->m_decomp.m_dist = (mz_uint32)0;
  pDecomp->m_decomp.m_counter = (mz_uint32)0;
  pDecomp->m_decomp.m_num_extra = (mz_uint32)0;
  pDecomp->m_decomp.m_dist_from_out_buf_start = (size_t)0;
  pDecomp->m_dict_ofs = (mz_uint)0;
  pDecomp->m_dict_avail = (mz_uint)0;
  pDecomp->m_last_status = TINFL_STATUS_NEEDS_MORE_INPUT;
  pDecomp->m_first_call = (mz_uint)1;
  pDecomp->m_has_flushed = (mz_uint)0;
  pDecomp->m_window_bits = window_bits;
  __retres = (int __attribute__((__visibility__("default"))))MZ_OK;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_inflateInit(mz_streamp pStream)
{
  int __attribute__((__visibility__("default"))) tmp;
  tmp = mz_inflateInit2(pStream,15);
  return tmp;
}

int __attribute__((__visibility__("default"))) mz_inflateReset(mz_streamp pStream)
{
  int __attribute__((__visibility__("default"))) __retres;
  inflate_state *pDecomp;
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  pStream->data_type = 0;
  pStream->adler = (mz_ulong)0;
  pStream->msg = (char *)0;
  pStream->total_in = (mz_ulong)0;
  pStream->total_out = (mz_ulong)0;
  pStream->reserved = (mz_ulong)0;
  pDecomp = (inflate_state *)pStream->state;
  pDecomp->m_decomp.m_state = (mz_uint32)0;
  pDecomp->m_decomp.m_num_bits = (mz_uint32)0;
  pDecomp->m_decomp.m_bit_buf = (tinfl_bit_buf_t)0;
  pDecomp->m_decomp.m_dist = (mz_uint32)0;
  pDecomp->m_decomp.m_counter = (mz_uint32)0;
  pDecomp->m_decomp.m_num_extra = (mz_uint32)0;
  pDecomp->m_decomp.m_dist_from_out_buf_start = (size_t)0;
  pDecomp->m_dict_ofs = (mz_uint)0;
  pDecomp->m_dict_avail = (mz_uint)0;
  pDecomp->m_last_status = TINFL_STATUS_NEEDS_MORE_INPUT;
  pDecomp->m_first_call = (mz_uint)1;
  pDecomp->m_has_flushed = (mz_uint)0;
  __retres = (int __attribute__((__visibility__("default"))))MZ_OK;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_inflate(mz_streamp pStream,
                                                          int flush)
{
  int __attribute__((__visibility__("default"))) __retres;
  inflate_state *pState;
  mz_uint n;
  mz_uint first_call;
  size_t in_bytes;
  size_t out_bytes;
  size_t orig_avail_in;
  tinfl_status status;
  int tmp_3;
  mz_uint decomp_flags = (mz_uint)TINFL_FLAG_COMPUTE_ADLER32;
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  else 
    if (! pStream->state) {
      __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
      goto return_label;
    }
  if (flush == MZ_PARTIAL_FLUSH) flush = MZ_SYNC_FLUSH;
  if (flush) 
    if (flush != MZ_SYNC_FLUSH) 
      if (flush != MZ_FINISH) {
        __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
        goto return_label;
      }
  pState = (inflate_state *)pStream->state;
  if (pState->m_window_bits > 0) decomp_flags |= (unsigned int)TINFL_FLAG_PARSE_ZLIB_HEADER;
  orig_avail_in = (size_t)pStream->avail_in;
  first_call = pState->m_first_call;
  pState->m_first_call = (mz_uint)0;
  if (pState->m_last_status < 0) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_DATA_ERROR;
    goto return_label;
  }
  if (pState->m_has_flushed) 
    if (flush != MZ_FINISH) {
      __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
      goto return_label;
    }
  pState->m_has_flushed |= (unsigned int)(flush == MZ_FINISH);
  if (flush == MZ_FINISH) 
    if (first_call) {
      tinfl_status __attribute__((__visibility__("default"))) tmp;
      decomp_flags |= (unsigned int)TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF;
      in_bytes = (size_t)pStream->avail_in;
      out_bytes = (size_t)pStream->avail_out;
      tmp = tinfl_decompress(& pState->m_decomp,pStream->next_in,& in_bytes,
                             pStream->next_out,pStream->next_out,& out_bytes,
                             decomp_flags);
      status = (tinfl_status)tmp;
      pState->m_last_status = status;
      pStream->next_in += (mz_uint)in_bytes;
      pStream->avail_in -= (mz_uint)in_bytes;
      pStream->total_in += (mz_ulong)((mz_uint)in_bytes);
      pStream->adler = (mz_ulong)pState->m_decomp.m_check_adler32;
      pStream->next_out += (mz_uint)out_bytes;
      pStream->avail_out -= (mz_uint)out_bytes;
      pStream->total_out += (mz_ulong)((mz_uint)out_bytes);
      if (status < 0) {
        __retres = (int __attribute__((__visibility__("default"))))MZ_DATA_ERROR;
        goto return_label;
      }
      else 
        if (status != TINFL_STATUS_DONE) {
          pState->m_last_status = TINFL_STATUS_FAILED;
          __retres = (int __attribute__((__visibility__("default"))))MZ_BUF_ERROR;
          goto return_label;
        }
      __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_END;
      goto return_label;
    }
  if (flush != MZ_FINISH) decomp_flags |= (unsigned int)TINFL_FLAG_HAS_MORE_INPUT;
  if (pState->m_dict_avail) {
    int tmp_0;
    if (pState->m_dict_avail < pStream->avail_out) n = pState->m_dict_avail;
    else n = pStream->avail_out;
    memcpy((void *)pStream->next_out,
           (void const *)(& pState->m_dict[pState->m_dict_ofs]),(size_t)n);
    pStream->next_out += n;
    pStream->avail_out -= n;
    pStream->total_out += (mz_ulong)n;
    pState->m_dict_avail -= n;
    pState->m_dict_ofs = (pState->m_dict_ofs + n) & (unsigned int)(32768 - 1);
    if (pState->m_last_status == TINFL_STATUS_DONE) 
      if (! pState->m_dict_avail) tmp_0 = MZ_STREAM_END; else tmp_0 = MZ_OK;
    else tmp_0 = MZ_OK;
    __retres = (int __attribute__((__visibility__("default"))))tmp_0;
    goto return_label;
  }
  while (1) {
    tinfl_status __attribute__((__visibility__("default"))) tmp_1;
    in_bytes = (size_t)pStream->avail_in;
    out_bytes = (size_t)((mz_uint)32768 - pState->m_dict_ofs);
    tmp_1 = tinfl_decompress(& pState->m_decomp,pStream->next_in,& in_bytes,
                             pState->m_dict,
                             & pState->m_dict[pState->m_dict_ofs],
                             & out_bytes,decomp_flags);
    status = (tinfl_status)tmp_1;
    pState->m_last_status = status;
    pStream->next_in += (mz_uint)in_bytes;
    pStream->avail_in -= (mz_uint)in_bytes;
    pStream->total_in += (mz_ulong)((mz_uint)in_bytes);
    pStream->adler = (mz_ulong)pState->m_decomp.m_check_adler32;
    pState->m_dict_avail = (mz_uint)out_bytes;
    if (pState->m_dict_avail < pStream->avail_out) n = pState->m_dict_avail;
    else n = pStream->avail_out;
    memcpy((void *)pStream->next_out,
           (void const *)(& pState->m_dict[pState->m_dict_ofs]),(size_t)n);
    pStream->next_out += n;
    pStream->avail_out -= n;
    pStream->total_out += (mz_ulong)n;
    pState->m_dict_avail -= n;
    pState->m_dict_ofs = (pState->m_dict_ofs + n) & (unsigned int)(32768 - 1);
    if (status < 0) {
      __retres = (int __attribute__((__visibility__("default"))))MZ_DATA_ERROR;
      goto return_label;
    }
    else 
      if (status == TINFL_STATUS_NEEDS_MORE_INPUT) {
        if (! orig_avail_in) {
          __retres = (int __attribute__((__visibility__("default"))))MZ_BUF_ERROR;
          goto return_label;
        }
        else goto _LAND;
      }
      else {
        _LAND: ;
        if (flush == MZ_FINISH) {
          if (status == TINFL_STATUS_DONE) {
            int tmp_2;
            if (pState->m_dict_avail) tmp_2 = MZ_BUF_ERROR;
            else tmp_2 = MZ_STREAM_END;
            __retres = (int __attribute__((__visibility__("default"))))tmp_2;
            goto return_label;
          }
          else 
            if (! pStream->avail_out) {
              __retres = (int __attribute__((__visibility__("default"))))MZ_BUF_ERROR;
              goto return_label;
            }
        }
        else 
          if (status == TINFL_STATUS_DONE) break;
          else 
            if (! pStream->avail_in) break;
            else 
              if (! pStream->avail_out) break;
              else 
                if (pState->m_dict_avail) break;
      }
  }
  if (status == TINFL_STATUS_DONE) 
    if (! pState->m_dict_avail) tmp_3 = MZ_STREAM_END; else tmp_3 = MZ_OK;
  else tmp_3 = MZ_OK;
  __retres = (int __attribute__((__visibility__("default"))))tmp_3;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_inflateEnd(mz_streamp pStream)
{
  int __attribute__((__visibility__("default"))) __retres;
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  if (pStream->state) {
    (*(pStream->zfree))(pStream->opaque,(void *)pStream->state);
    pStream->state = (struct mz_internal_state *)0;
  }
  __retres = (int __attribute__((__visibility__("default"))))MZ_OK;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_uncompress2(unsigned char *pDest,
                                                              mz_ulong *pDest_len,
                                                              unsigned char const *pSource,
                                                              mz_ulong *pSource_len)
{
  int __attribute__((__visibility__("default"))) __retres;
  mz_stream stream;
  int status;
  int __attribute__((__visibility__("default"))) tmp_0;
  memset((void *)(& stream),0,sizeof(stream));
  if ((*pSource_len | *pDest_len) > (unsigned long)0xFFFFFFFFU) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
    goto return_label;
  }
  stream.next_in = pSource;
  stream.avail_in = (mz_uint32)*pSource_len;
  stream.next_out = pDest;
  stream.avail_out = (mz_uint32)*pDest_len;
  status = (int)mz_inflateInit(& stream);
  if (status != MZ_OK) {
    __retres = (int __attribute__((__visibility__("default"))))status;
    goto return_label;
  }
  status = (int)mz_inflate(& stream,MZ_FINISH);
  *pSource_len -= (mz_ulong)stream.avail_in;
  if (status != MZ_STREAM_END) {
    int tmp;
    mz_inflateEnd(& stream);
    if (status == MZ_BUF_ERROR) 
      if (! stream.avail_in) tmp = MZ_DATA_ERROR; else tmp = status;
    else tmp = status;
    __retres = (int __attribute__((__visibility__("default"))))tmp;
    goto return_label;
  }
  *pDest_len = stream.total_out;
  tmp_0 = mz_inflateEnd(& stream);
  __retres = tmp_0;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_uncompress(unsigned char *pDest,
                                                             mz_ulong *pDest_len,
                                                             unsigned char const *pSource,
                                                             mz_ulong source_len)
{
  int __attribute__((__visibility__("default"))) tmp;
  tmp = mz_uncompress2(pDest,pDest_len,pSource,& source_len);
  return tmp;
}

static struct __anonstruct_s_error_descs_25 mz_error_s_error_descs[10] =
  {{.m_err = MZ_OK, .m_pDesc = ""},
   {.m_err = MZ_STREAM_END, .m_pDesc = "stream end"},
   {.m_err = MZ_NEED_DICT, .m_pDesc = "need dictionary"},
   {.m_err = MZ_ERRNO, .m_pDesc = "file error"},
   {.m_err = MZ_STREAM_ERROR, .m_pDesc = "stream error"},
   {.m_err = MZ_DATA_ERROR, .m_pDesc = "data error"},
   {.m_err = MZ_MEM_ERROR, .m_pDesc = "out of memory"},
   {.m_err = MZ_BUF_ERROR, .m_pDesc = "buf error"},
   {.m_err = MZ_VERSION_ERROR, .m_pDesc = "version error"},
   {.m_err = MZ_PARAM_ERROR, .m_pDesc = "parameter error"}};
char const __attribute__((__visibility__("default"))) *mz_error(int err)
{
  char const __attribute__((__visibility__("default"))) *__retres;
  mz_uint i;
  i = (mz_uint)0;
  while ((unsigned long)i < sizeof(mz_error_s_error_descs) / sizeof(mz_error_s_error_descs[0])) {
    if (mz_error_s_error_descs[i].m_err == err) {
      __retres = (char const __attribute__((__visibility__("default"))) *)mz_error_s_error_descs[i].m_pDesc;
      goto return_label;
    }
    i ++;
  }
  __retres = (char const __attribute__((__visibility__("default"))) *)0;
  return_label: return __retres;
}

static int const tinfl_decompress_s_length_base[31] =
  {3,
   4,
   5,
   6,
   7,
   8,
   9,
   10,
   11,
   13,
   15,
   17,
   19,
   23,
   27,
   31,
   35,
   43,
   51,
   59,
   67,
   83,
   99,
   115,
   131,
   163,
   195,
   227,
   258,
   0,
   0};
static int const tinfl_decompress_s_length_extra[31] =
  {0,
   0,
   0,
   0,
   0,
   0,
   0,
   0,
   1,
   1,
   1,
   1,
   2,
   2,
   2,
   2,
   3,
   3,
   3,
   3,
   4,
   4,
   4,
   4,
   5,
   5,
   5,
   5,
   0,
   0,
   0};
static int const tinfl_decompress_s_dist_base[32] =
  {1,
   2,
   3,
   4,
   5,
   7,
   9,
   13,
   17,
   25,
   33,
   49,
   65,
   97,
   129,
   193,
   257,
   385,
   513,
   769,
   1025,
   1537,
   2049,
   3073,
   4097,
   6145,
   8193,
   12289,
   16385,
   24577,
   0,
   0};
static int const tinfl_decompress_s_dist_extra[32] =
  {0,
   0,
   0,
   0,
   1,
   1,
   2,
   2,
   3,
   3,
   4,
   4,
   5,
   5,
   6,
   6,
   7,
   7,
   8,
   8,
   9,
   9,
   10,
   10,
   11,
   11,
   12,
   12,
   13,
   13};
static mz_uint8 const tinfl_decompress_s_length_dezigzag[19] =
  {(mz_uint8)16,
   (mz_uint8)17,
   (mz_uint8)18,
   (mz_uint8)0,
   (mz_uint8)8,
   (mz_uint8)7,
   (mz_uint8)9,
   (mz_uint8)6,
   (mz_uint8)10,
   (mz_uint8)5,
   (mz_uint8)11,
   (mz_uint8)4,
   (mz_uint8)12,
   (mz_uint8)3,
   (mz_uint8)13,
   (mz_uint8)2,
   (mz_uint8)14,
   (mz_uint8)1,
   (mz_uint8)15};
static int const tinfl_decompress_s_min_table_sizes[3] = {257, 1, 4};
tinfl_status __attribute__((__visibility__("default"))) tinfl_decompress
(tinfl_decompressor *r, mz_uint8 const *pIn_buf_next, size_t *pIn_buf_size,
 mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size,
 mz_uint32 const decomp_flags)
{
  tinfl_status __attribute__((__visibility__("default"))) __retres;
  mz_uint32 num_bits;
  mz_uint32 dist;
  mz_uint32 counter;
  mz_uint32 num_extra;
  tinfl_bit_buf_t bit_buf;
  size_t tmp;
  size_t dist_from_out_buf_start;
  tinfl_status status = TINFL_STATUS_FAILED;
  mz_uint8 const *pIn_buf_cur = pIn_buf_next;
  mz_uint8 const * const pIn_buf_end = pIn_buf_next + *pIn_buf_size;
  mz_uint8 *pOut_buf_cur = pOut_buf_next;
  mz_uint8 * const pOut_buf_end = pOut_buf_next + *pOut_buf_size;
  if (decomp_flags & (unsigned int)TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF) 
    tmp = (size_t)(-1);
  else tmp = ((size_t)(pOut_buf_next - pOut_buf_start) + *pOut_buf_size) - (size_t)1;
  size_t out_buf_size_mask = tmp;
  if ((out_buf_size_mask + (size_t)1) & out_buf_size_mask) goto _LOR;
  else 
    if (pOut_buf_next < pOut_buf_start) {
      _LOR:
      {
        size_t tmp_0;
        tmp_0 = (size_t)0;
        *pOut_buf_size = tmp_0;
        *pIn_buf_size = tmp_0;
        __retres = TINFL_STATUS_BAD_PARAM;
        goto return_label;
      }
    }
  num_bits = r->m_num_bits;
  bit_buf = r->m_bit_buf;
  dist = r->m_dist;
  counter = r->m_counter;
  num_extra = r->m_num_extra;
  dist_from_out_buf_start = r->m_dist_from_out_buf_start;
  switch (r->m_state) {
    mz_uint32 tmp_2;
    mz_uint32 tmp_1;
    mz_uint32 tmp_3;
    case (mz_uint32)0:
    { /* sequence */
      tmp_2 = (mz_uint32)0;
      r->m_zhdr1 = tmp_2;
      tmp_1 = tmp_2;
      r->m_zhdr0 = tmp_1;
      num_extra = tmp_1;
      counter = num_extra;
      dist = counter;
      num_bits = dist;
      bit_buf = (tinfl_bit_buf_t)num_bits;
    }
    tmp_3 = (mz_uint32)1;
    r->m_check_adler32 = tmp_3;
    r->m_z_adler32 = tmp_3;
    if (decomp_flags & (unsigned int)TINFL_FLAG_PARSE_ZLIB_HEADER) {
      int tmp_6;
      {
        mz_uint8 const *tmp_4;
        while (pIn_buf_cur >= pIn_buf_end) {
          if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
            status = TINFL_STATUS_NEEDS_MORE_INPUT;
          else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
          r->m_state = (mz_uint32)1;
          goto common_exit;
          case (mz_uint32)1: ;
        }
        tmp_4 = pIn_buf_cur;
        pIn_buf_cur ++;
        r->m_zhdr0 = (mz_uint32)*tmp_4;
      }
      {
        mz_uint8 const *tmp_5;
        while (pIn_buf_cur >= pIn_buf_end) {
          if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
            status = TINFL_STATUS_NEEDS_MORE_INPUT;
          else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
          r->m_state = (mz_uint32)2;
          goto common_exit;
          case (mz_uint32)2: ;
        }
        tmp_5 = pIn_buf_cur;
        pIn_buf_cur ++;
        r->m_zhdr1 = (mz_uint32)*tmp_5;
      }
      if ((r->m_zhdr0 * (mz_uint32)256 + r->m_zhdr1) % (unsigned int)31 != (unsigned int)0) 
        tmp_6 = 1;
      else 
        if (r->m_zhdr1 & (unsigned int)32) tmp_6 = 1;
        else 
          if ((r->m_zhdr0 & (unsigned int)15) != (unsigned int)8) tmp_6 = 1;
          else tmp_6 = 0;
      counter = (mz_uint32)tmp_6;
      if (! (decomp_flags & (unsigned int)TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)) {
        int tmp_7;
        if (1U << (8U + (r->m_zhdr0 >> 4)) > 32768U) tmp_7 = 1;
        else 
          if (out_buf_size_mask + (size_t)1 < (size_t)(1U << (8U + (r->m_zhdr0 >> 4)))) 
            tmp_7 = 1;
          else tmp_7 = 0;
        counter |= (unsigned int)tmp_7;
      }
      if (counter) 
        while (1) {
          status = TINFL_STATUS_FAILED;
          r->m_state = (mz_uint32)36;
          goto common_exit;
          case (mz_uint32)36: ;
        }
    }
    while (1) {
      if (num_bits < (mz_uint)3) 
        while (1) {
          {
            mz_uint c;
            {
              mz_uint8 const *tmp_8;
              while (pIn_buf_cur >= pIn_buf_end) {
                if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                  status = TINFL_STATUS_NEEDS_MORE_INPUT;
                else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                r->m_state = (mz_uint32)3;
                goto common_exit;
                case (mz_uint32)3: ;
              }
              tmp_8 = pIn_buf_cur;
              pIn_buf_cur ++;
              c = (mz_uint)*tmp_8;
            }
            bit_buf |= (tinfl_bit_buf_t)c << num_bits;
            num_bits += (mz_uint32)8;
          }
          if (! (num_bits < (mz_uint)3)) break;
        }
      r->m_final = (mz_uint32)(bit_buf & (unsigned long)((1 << 3) - 1));
      bit_buf >>= 3;
      num_bits -= (mz_uint32)3;
      r->m_type = r->m_final >> 1;
      if (r->m_type == (mz_uint32)0) {
        if (num_bits < (num_bits & (unsigned int)7)) 
          while (1) {
            {
              mz_uint c_0;
              {
                mz_uint8 const *tmp_9;
                while (pIn_buf_cur >= pIn_buf_end) {
                  if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                    status = TINFL_STATUS_NEEDS_MORE_INPUT;
                  else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                  r->m_state = (mz_uint32)5;
                  goto common_exit;
                  case (mz_uint32)5: ;
                }
                tmp_9 = pIn_buf_cur;
                pIn_buf_cur ++;
                c_0 = (mz_uint)*tmp_9;
              }
              bit_buf |= (tinfl_bit_buf_t)c_0 << num_bits;
              num_bits += (mz_uint32)8;
            }
            if (! (num_bits < (num_bits & (unsigned int)7))) break;
          }
        bit_buf >>= num_bits & (unsigned int)7;
        num_bits -= num_bits & (unsigned int)7;
        counter = (mz_uint32)0;
        while (counter < (mz_uint32)4) {
          if (num_bits) {
            if (num_bits < (mz_uint)8) 
              while (1) {
                {
                  mz_uint c_1;
                  {
                    mz_uint8 const *tmp_10;
                    while (pIn_buf_cur >= pIn_buf_end) {
                      if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                        status = TINFL_STATUS_NEEDS_MORE_INPUT;
                      else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                      r->m_state = (mz_uint32)6;
                      goto common_exit;
                      case (mz_uint32)6: ;
                    }
                    tmp_10 = pIn_buf_cur;
                    pIn_buf_cur ++;
                    c_1 = (mz_uint)*tmp_10;
                  }
                  bit_buf |= (tinfl_bit_buf_t)c_1 << num_bits;
                  num_bits += (mz_uint32)8;
                }
                if (! (num_bits < (mz_uint)8)) break;
              }
            r->m_raw_header[counter] = (mz_uint8)(bit_buf & (unsigned long)(
                                                  (1 << 8) - 1));
            bit_buf >>= 8;
            num_bits -= (mz_uint32)8;
          }
          else {
            mz_uint8 const *tmp_11;
            while (pIn_buf_cur >= pIn_buf_end) {
              if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                status = TINFL_STATUS_NEEDS_MORE_INPUT;
              else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
              r->m_state = (mz_uint32)7;
              goto common_exit;
              case (mz_uint32)7: ;
            }
            tmp_11 = pIn_buf_cur;
            pIn_buf_cur ++;
            r->m_raw_header[counter] = *tmp_11;
          }
          counter ++;
        }
        counter = (mz_uint32)((int)r->m_raw_header[0] | ((int)r->m_raw_header[1] << 8));
        ;
        if (counter != (mz_uint)(0xFFFF ^ ((int)r->m_raw_header[2] | (
                                           (int)r->m_raw_header[3] << 8)))) 
          while (1) {
            status = TINFL_STATUS_FAILED;
            r->m_state = (mz_uint32)39;
            goto common_exit;
            case (mz_uint32)39: ;
          }
        while (1) {
          if (counter) {
            if (! num_bits) break;
          }
          else break;
          {
            mz_uint8 *tmp_13;
            if (num_bits < (mz_uint)8) 
              while (1) {
                {
                  mz_uint c_2;
                  {
                    mz_uint8 const *tmp_12;
                    while (pIn_buf_cur >= pIn_buf_end) {
                      if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                        status = TINFL_STATUS_NEEDS_MORE_INPUT;
                      else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                      r->m_state = (mz_uint32)51;
                      goto common_exit;
                      case (mz_uint32)51: ;
                    }
                    tmp_12 = pIn_buf_cur;
                    pIn_buf_cur ++;
                    c_2 = (mz_uint)*tmp_12;
                  }
                  bit_buf |= (tinfl_bit_buf_t)c_2 << num_bits;
                  num_bits += (mz_uint32)8;
                }
                if (! (num_bits < (mz_uint)8)) break;
              }
            dist = (mz_uint32)(bit_buf & (unsigned long)((1 << 8) - 1));
            bit_buf >>= 8;
            num_bits -= (mz_uint32)8;
            while (pOut_buf_cur >= pOut_buf_end) {
              status = TINFL_STATUS_HAS_MORE_OUTPUT;
              r->m_state = (mz_uint32)52;
              goto common_exit;
              case (mz_uint32)52: ;
            }
            tmp_13 = pOut_buf_cur;
            pOut_buf_cur ++;
            *tmp_13 = (mz_uint8)dist;
            counter --;
          }
        }
        while (counter) {
          size_t n;
          size_t tmp_14;
          while (pOut_buf_cur >= pOut_buf_end) {
            status = TINFL_STATUS_HAS_MORE_OUTPUT;
            r->m_state = (mz_uint32)9;
            goto common_exit;
            case (mz_uint32)9: ;
          }
          while (pIn_buf_cur >= pIn_buf_end) {
            if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
              status = TINFL_STATUS_NEEDS_MORE_INPUT;
            else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
            r->m_state = (mz_uint32)38;
            goto common_exit;
            case (mz_uint32)38: ;
          }
          if ((size_t)(pOut_buf_end - pOut_buf_cur) < (size_t)(pIn_buf_end - pIn_buf_cur)) 
            tmp_14 = (size_t)(pOut_buf_end - pOut_buf_cur);
          else tmp_14 = (size_t)(pIn_buf_end - pIn_buf_cur);
          ;
          if (tmp_14 < (size_t)counter) {
            size_t tmp_15;
            if ((size_t)(pOut_buf_end - pOut_buf_cur) < (size_t)(pIn_buf_end - pIn_buf_cur)) 
              tmp_15 = (size_t)(pOut_buf_end - pOut_buf_cur);
            else tmp_15 = (size_t)(pIn_buf_end - pIn_buf_cur);
            n = tmp_15;
          }
          else n = (size_t)counter;
          memcpy((void *)pOut_buf_cur,(void const *)pIn_buf_cur,n);
          pIn_buf_cur += n;
          pOut_buf_cur += n;
          counter -= (mz_uint)n;
        }
      }
      else 
        if (r->m_type == (mz_uint32)3) 
          while (1) {
            status = TINFL_STATUS_FAILED;
            r->m_state = (mz_uint32)10;
            goto common_exit;
            case (mz_uint32)10: ;
          }
        else {
          if (r->m_type == (mz_uint32)1) {
            mz_uint i;
            mz_uint8 *p = r->m_tables[0].m_code_size;
            r->m_table_sizes[0] = (mz_uint32)288;
            r->m_table_sizes[1] = (mz_uint32)32;
            memset((void *)(r->m_tables[1].m_code_size),5,(size_t)32);
            i = (mz_uint)0;
            while (i <= (mz_uint)143) {
              mz_uint8 *tmp_16;
              tmp_16 = p;
              p ++;
              *tmp_16 = (mz_uint8)8;
              i ++;
            }
            while (i <= (mz_uint)255) {
              mz_uint8 *tmp_17;
              tmp_17 = p;
              p ++;
              *tmp_17 = (mz_uint8)9;
              i ++;
            }
            while (i <= (mz_uint)279) {
              mz_uint8 *tmp_18;
              tmp_18 = p;
              p ++;
              *tmp_18 = (mz_uint8)7;
              i ++;
            }
            while (i <= (mz_uint)287) {
              mz_uint8 *tmp_19;
              tmp_19 = p;
              p ++;
              *tmp_19 = (mz_uint8)8;
              i ++;
            }
          }
          else {
            counter = (mz_uint32)0;
            while (counter < (mz_uint32)3) {
              if (num_bits < (mz_uint)*("\005\005\004" + counter)) 
                while (1) {
                  {
                    mz_uint c_3;
                    {
                      mz_uint8 const *tmp_20;
                      while (pIn_buf_cur >= pIn_buf_end) {
                        if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                          status = TINFL_STATUS_NEEDS_MORE_INPUT;
                        else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                        r->m_state = (mz_uint32)11;
                        goto common_exit;
                        case (mz_uint32)11: ;
                      }
                      tmp_20 = pIn_buf_cur;
                      pIn_buf_cur ++;
                      c_3 = (mz_uint)*tmp_20;
                    }
                    bit_buf |= (tinfl_bit_buf_t)c_3 << num_bits;
                    num_bits += (mz_uint32)8;
                  }
                  if (! (num_bits < (mz_uint)*("\005\005\004" + counter))) 
                    break;
                }
              r->m_table_sizes[counter] = (mz_uint32)(bit_buf & (unsigned long)(
                                                      (1 << (int)*("\005\005\004" + counter)) - 1));
              bit_buf >>= (int)*("\005\005\004" + counter);
              num_bits -= (mz_uint32)*("\005\005\004" + counter);
              r->m_table_sizes[counter] += (mz_uint32)tinfl_decompress_s_min_table_sizes[counter];
              counter ++;
            }
            memset((void *)(& r->m_tables[2].m_code_size),0,
                   sizeof(r->m_tables[2].m_code_size));
            counter = (mz_uint32)0;
            while (counter < r->m_table_sizes[2]) {
              {
                mz_uint s;
                if (num_bits < (mz_uint)3) 
                  while (1) {
                    {
                      mz_uint c_4;
                      {
                        mz_uint8 const *tmp_21;
                        while (pIn_buf_cur >= pIn_buf_end) {
                          if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                            status = TINFL_STATUS_NEEDS_MORE_INPUT;
                          else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                          r->m_state = (mz_uint32)14;
                          goto common_exit;
                          case (mz_uint32)14: ;
                        }
                        tmp_21 = pIn_buf_cur;
                        pIn_buf_cur ++;
                        c_4 = (mz_uint)*tmp_21;
                      }
                      bit_buf |= (tinfl_bit_buf_t)c_4 << num_bits;
                      num_bits += (mz_uint32)8;
                    }
                    if (! (num_bits < (mz_uint)3)) break;
                  }
                s = (mz_uint)(bit_buf & (unsigned long)((1 << 3) - 1));
                bit_buf >>= 3;
                num_bits -= (mz_uint32)3;
                r->m_tables[2].m_code_size[tinfl_decompress_s_length_dezigzag[counter]] = (mz_uint8)s;
              }
              counter ++;
            }
            r->m_table_sizes[2] = (mz_uint32)19;
          }
          while ((int)r->m_type >= 0) {
            {
              int tree_next;
              int tree_cur;
              tinfl_huff_table *pTable;
              mz_uint i_0;
              mz_uint j;
              mz_uint used_syms;
              mz_uint total;
              mz_uint sym_index;
              mz_uint next_code[17];
              mz_uint total_syms[16];
              pTable = & r->m_tables[r->m_type];
              memset((void *)(& total_syms),0,sizeof(total_syms));
              memset((void *)(& pTable->m_look_up),0,
                     sizeof(pTable->m_look_up));
              memset((void *)(& pTable->m_tree),0,sizeof(pTable->m_tree));
              i_0 = (mz_uint)0;
              while (i_0 < r->m_table_sizes[r->m_type]) {
                (total_syms[pTable->m_code_size[i_0]]) ++;
                i_0 ++;
              }
              used_syms = (mz_uint)0;
              total = (mz_uint)0;
              next_code[1] = (mz_uint)0;
              next_code[0] = next_code[1];
              i_0 = (mz_uint)1;
              while (i_0 <= (mz_uint)15) {
                used_syms += total_syms[i_0];
                total = (total + total_syms[i_0]) << 1;
                next_code[i_0 + (mz_uint)1] = total;
                i_0 ++;
              }
              if ((mz_uint)65536 != total) 
                if (used_syms > (mz_uint)1) 
                  while (1) {
                    status = TINFL_STATUS_FAILED;
                    r->m_state = (mz_uint32)35;
                    goto common_exit;
                    case (mz_uint32)35: ;
                  }
              tree_next = -1;
              sym_index = (mz_uint)0;
              while (sym_index < r->m_table_sizes[r->m_type]) {
                {
                  mz_uint l;
                  mz_uint cur_code;
                  mz_uint tmp_22;
                  mz_uint rev_code = (mz_uint)0;
                  mz_uint code_size =
                    (mz_uint)pTable->m_code_size[sym_index];
                  if (! code_size) goto __Cont;
                  tmp_22 = next_code[code_size];
                  (next_code[code_size]) ++;
                  cur_code = tmp_22;
                  l = code_size;
                  while (l > (mz_uint)0) {
                    rev_code = (rev_code << 1) | (cur_code & (unsigned int)1);
                    l --;
                    cur_code >>= 1;
                  }
                  if (code_size <= (mz_uint)TINFL_FAST_LOOKUP_BITS) {
                    mz_int16 k = (mz_int16)((code_size << 9) | sym_index);
                    while (rev_code < (mz_uint)TINFL_FAST_LOOKUP_SIZE) {
                      pTable->m_look_up[rev_code] = k;
                      rev_code += (mz_uint)(1 << code_size);
                    }
                    goto __Cont;
                  }
                  tree_cur = (int)pTable->m_look_up[rev_code & (unsigned int)(
                                                    TINFL_FAST_LOOKUP_SIZE - 1)];
                  if (0 == tree_cur) {
                    pTable->m_look_up[rev_code & (unsigned int)(TINFL_FAST_LOOKUP_SIZE - 1)] = (mz_int16)tree_next;
                    tree_cur = tree_next;
                    tree_next -= 2;
                  }
                  rev_code >>= TINFL_FAST_LOOKUP_BITS - 1;
                  j = code_size;
                  while (j > (mz_uint)(TINFL_FAST_LOOKUP_BITS + 1)) {
                    rev_code >>= 1;
                    tree_cur = (int)((unsigned int)tree_cur - (rev_code & (unsigned int)1));
                    if (! pTable->m_tree[- tree_cur - 1]) {
                      pTable->m_tree[- tree_cur - 1] = (mz_int16)tree_next;
                      tree_cur = tree_next;
                      tree_next -= 2;
                    }
                    else tree_cur = (int)pTable->m_tree[- tree_cur - 1];
                    j --;
                  }
                  rev_code >>= 1;
                  tree_cur = (int)((unsigned int)tree_cur - (rev_code & (unsigned int)1));
                  pTable->m_tree[- tree_cur - 1] = (mz_int16)sym_index;
                }
                __Cont: sym_index ++;
              }
              if (r->m_type == (mz_uint32)2) {
                counter = (mz_uint32)0;
                while (counter < r->m_table_sizes[0] + r->m_table_sizes[1]) {
                  {
                    mz_uint s_0;
                    int tmp_28;
                    {
                      int temp;
                      mz_uint code_len;
                      mz_uint c_5;
                      if (num_bits < (mz_uint32)15) 
                        if (pIn_buf_end - pIn_buf_cur < (long)2) 
                          while (1) {
                            temp = (int)r->m_tables[2].m_look_up[bit_buf & (unsigned long)(
                                                                 TINFL_FAST_LOOKUP_SIZE - 1)];
                            if (temp >= 0) {
                              code_len = (mz_uint)(temp >> 9);
                              if (code_len) 
                                if (num_bits >= code_len) break;
                            }
                            else 
                              if (num_bits > (mz_uint32)TINFL_FAST_LOOKUP_BITS) {
                                code_len = (mz_uint)TINFL_FAST_LOOKUP_BITS;
                                while (1) {
                                  {
                                    mz_uint tmp_23;
                                    tmp_23 = code_len;
                                    code_len ++;
                                    temp = (int)r->m_tables[2].m_tree[
                                    (unsigned long)(~ temp) + ((bit_buf >> tmp_23) & (unsigned long)1)];
                                  }
                                  if (temp < 0) {
                                    if (! (num_bits >= code_len + (mz_uint)1)) 
                                      break;
                                  }
                                  else break;
                                }
                                if (temp >= 0) break;
                              }
                            {
                              mz_uint8 const *tmp_24;
                              while (pIn_buf_cur >= pIn_buf_end) {
                                if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                                  status = TINFL_STATUS_NEEDS_MORE_INPUT;
                                else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                                r->m_state = (mz_uint32)16;
                                goto common_exit;
                                case (mz_uint32)16: ;
                              }
                              tmp_24 = pIn_buf_cur;
                              pIn_buf_cur ++;
                              c_5 = (mz_uint)*tmp_24;
                            }
                            bit_buf |= (tinfl_bit_buf_t)c_5 << num_bits;
                            num_bits += (mz_uint32)8;
                            if (! (num_bits < (mz_uint32)15)) break;
                          }
                        else {
                          bit_buf |= ((tinfl_bit_buf_t)*(pIn_buf_cur + 0) << num_bits) | (
                                     (tinfl_bit_buf_t)*(pIn_buf_cur + 1) << (
                                     num_bits + (mz_uint32)8));
                          pIn_buf_cur += 2;
                          num_bits += (mz_uint32)16;
                        }
                      temp = (int)r->m_tables[2].m_look_up[bit_buf & (unsigned long)(
                                                           TINFL_FAST_LOOKUP_SIZE - 1)];
                      if (temp >= 0) {
                        code_len = (mz_uint)(temp >> 9);
                        temp &= 511;
                      }
                      else {
                        code_len = (mz_uint)TINFL_FAST_LOOKUP_BITS;
                        while (1) {
                          {
                            mz_uint tmp_25;
                            tmp_25 = code_len;
                            code_len ++;
                            temp = (int)r->m_tables[2].m_tree[(unsigned long)(~ temp) + (
                                                              (bit_buf >> tmp_25) & (unsigned long)1)];
                          }
                          if (! (temp < 0)) break;
                        }
                      }
                      dist = (mz_uint32)temp;
                      bit_buf >>= code_len;
                      num_bits -= code_len;
                    }
                    if (dist < (mz_uint32)16) {
                      mz_uint32 tmp_26;
                      tmp_26 = counter;
                      counter ++;
                      r->m_len_codes[tmp_26] = (mz_uint8)dist;
                      goto __Cont_0;
                    }
                    if (dist == (mz_uint32)16) 
                      if (! counter) 
                        while (1) {
                          status = TINFL_STATUS_FAILED;
                          r->m_state = (mz_uint32)17;
                          goto common_exit;
                          case (mz_uint32)17: ;
                        }
                    num_extra = (mz_uint32)*("\002\003\a" + (dist - (mz_uint32)16));
                    if (num_bits < num_extra) 
                      while (1) {
                        {
                          mz_uint c_6;
                          {
                            mz_uint8 const *tmp_27;
                            while (pIn_buf_cur >= pIn_buf_end) {
                              if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                                status = TINFL_STATUS_NEEDS_MORE_INPUT;
                              else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                              r->m_state = (mz_uint32)18;
                              goto common_exit;
                              case (mz_uint32)18: ;
                            }
                            tmp_27 = pIn_buf_cur;
                            pIn_buf_cur ++;
                            c_6 = (mz_uint)*tmp_27;
                          }
                          bit_buf |= (tinfl_bit_buf_t)c_6 << num_bits;
                          num_bits += (mz_uint32)8;
                        }
                        if (! (num_bits < num_extra)) break;
                      }
                    s_0 = (mz_uint)(bit_buf & (unsigned long)((1 << num_extra) - 1));
                    bit_buf >>= num_extra;
                    num_bits -= num_extra;
                    s_0 += (mz_uint)*("\003\003\v" + (dist - (mz_uint32)16));
                    ;
                    if (dist == (mz_uint32)16) tmp_28 = (int)r->m_len_codes[
                                               counter - (mz_uint32)1];
                    else tmp_28 = 0;
                    ;
                    memset((void *)(& r->m_len_codes[counter]),tmp_28,
                           (size_t)s_0);
                    counter += s_0;
                  }
                  __Cont_0: ;
                }
                if (r->m_table_sizes[0] + r->m_table_sizes[1] != counter) 
                  while (1) {
                    status = TINFL_STATUS_FAILED;
                    r->m_state = (mz_uint32)21;
                    goto common_exit;
                    case (mz_uint32)21: ;
                  }
                memcpy((void *)(r->m_tables[0].m_code_size),
                       (void const *)(r->m_len_codes),
                       (size_t)r->m_table_sizes[0]);
                memcpy((void *)(r->m_tables[1].m_code_size),
                       (void const *)(& r->m_len_codes[r->m_table_sizes[0]]),
                       (size_t)r->m_table_sizes[1]);
              }
            }
            (r->m_type) --;
          }
          while (1) {
            {
              mz_uint8 *pSrc;
              mz_uint8 *tmp_43;
              while (1) 
                if (pIn_buf_end - pIn_buf_cur < (long)4) goto _LOR_0;
                else 
                  if (pOut_buf_end - pOut_buf_cur < (long)2) {
                    _LOR_0:
                    {
                      mz_uint8 *tmp_32;
                      {
                        int temp_0;
                        mz_uint code_len_0;
                        mz_uint c_7;
                        if (num_bits < (mz_uint32)15) 
                          if (pIn_buf_end - pIn_buf_cur < (long)2) 
                            while (1) {
                              temp_0 = (int)r->m_tables[0].m_look_up[
                              bit_buf & (unsigned long)(TINFL_FAST_LOOKUP_SIZE - 1)];
                              if (temp_0 >= 0) {
                                code_len_0 = (mz_uint)(temp_0 >> 9);
                                if (code_len_0) 
                                  if (num_bits >= code_len_0) break;
                              }
                              else 
                                if (num_bits > (mz_uint32)TINFL_FAST_LOOKUP_BITS) {
                                  code_len_0 = (mz_uint)TINFL_FAST_LOOKUP_BITS;
                                  while (1) {
                                    {
                                      mz_uint tmp_29;
                                      tmp_29 = code_len_0;
                                      code_len_0 ++;
                                      temp_0 = (int)r->m_tables[0].m_tree[
                                      (unsigned long)(~ temp_0) + ((bit_buf >> tmp_29) & (unsigned long)1)];
                                    }
                                    if (temp_0 < 0) {
                                      if (! (num_bits >= code_len_0 + (mz_uint)1)) 
                                        break;
                                    }
                                    else break;
                                  }
                                  if (temp_0 >= 0) break;
                                }
                              {
                                mz_uint8 const *tmp_30;
                                while (pIn_buf_cur >= pIn_buf_end) {
                                  if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                                    status = TINFL_STATUS_NEEDS_MORE_INPUT;
                                  else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                                  r->m_state = (mz_uint32)23;
                                  goto common_exit;
                                  case (mz_uint32)23: ;
                                }
                                tmp_30 = pIn_buf_cur;
                                pIn_buf_cur ++;
                                c_7 = (mz_uint)*tmp_30;
                              }
                              bit_buf |= (tinfl_bit_buf_t)c_7 << num_bits;
                              num_bits += (mz_uint32)8;
                              if (! (num_bits < (mz_uint32)15)) break;
                            }
                          else {
                            bit_buf |= ((tinfl_bit_buf_t)*(pIn_buf_cur + 0) << num_bits) | (
                                       (tinfl_bit_buf_t)*(pIn_buf_cur + 1) << (
                                       num_bits + (mz_uint32)8));
                            pIn_buf_cur += 2;
                            num_bits += (mz_uint32)16;
                          }
                        temp_0 = (int)r->m_tables[0].m_look_up[bit_buf & (unsigned long)(
                                                               TINFL_FAST_LOOKUP_SIZE - 1)];
                        if (temp_0 >= 0) {
                          code_len_0 = (mz_uint)(temp_0 >> 9);
                          temp_0 &= 511;
                        }
                        else {
                          code_len_0 = (mz_uint)TINFL_FAST_LOOKUP_BITS;
                          while (1) {
                            {
                              mz_uint tmp_31;
                              tmp_31 = code_len_0;
                              code_len_0 ++;
                              temp_0 = (int)r->m_tables[0].m_tree[(unsigned long)(~ temp_0) + (
                                                                  (bit_buf >> tmp_31) & (unsigned long)1)];
                            }
                            if (! (temp_0 < 0)) break;
                          }
                        }
                        counter = (mz_uint32)temp_0;
                        bit_buf >>= code_len_0;
                        num_bits -= code_len_0;
                      }
                      if (counter >= (mz_uint32)256) break;
                      while (pOut_buf_cur >= pOut_buf_end) {
                        status = TINFL_STATUS_HAS_MORE_OUTPUT;
                        r->m_state = (mz_uint32)24;
                        goto common_exit;
                        case (mz_uint32)24: ;
                      }
                      tmp_32 = pOut_buf_cur;
                      pOut_buf_cur ++;
                      *tmp_32 = (mz_uint8)counter;
                    }
                  }
                  else {
                    int sym2;
                    mz_uint code_len_1;
                    if (num_bits < (mz_uint32)30) {
                      bit_buf |= (tinfl_bit_buf_t)*((mz_uint32 const *)pIn_buf_cur) << num_bits;
                      pIn_buf_cur += 4;
                      num_bits += (mz_uint32)32;
                    }
                    sym2 = (int)r->m_tables[0].m_look_up[bit_buf & (unsigned long)(
                                                         TINFL_FAST_LOOKUP_SIZE - 1)];
                    if (sym2 >= 0) code_len_1 = (mz_uint)(sym2 >> 9);
                    else {
                      code_len_1 = (mz_uint)TINFL_FAST_LOOKUP_BITS;
                      while (1) {
                        {
                          mz_uint tmp_33;
                          tmp_33 = code_len_1;
                          code_len_1 ++;
                          sym2 = (int)r->m_tables[0].m_tree[(unsigned long)(~ sym2) + (
                                                            (bit_buf >> tmp_33) & (unsigned long)1)];
                        }
                        if (! (sym2 < 0)) break;
                      }
                    }
                    counter = (mz_uint32)sym2;
                    bit_buf >>= code_len_1;
                    num_bits -= code_len_1;
                    if (counter & (unsigned int)256) break;
                    sym2 = (int)r->m_tables[0].m_look_up[bit_buf & (unsigned long)(
                                                         TINFL_FAST_LOOKUP_SIZE - 1)];
                    if (sym2 >= 0) code_len_1 = (mz_uint)(sym2 >> 9);
                    else {
                      code_len_1 = (mz_uint)TINFL_FAST_LOOKUP_BITS;
                      while (1) {
                        {
                          mz_uint tmp_34;
                          tmp_34 = code_len_1;
                          code_len_1 ++;
                          sym2 = (int)r->m_tables[0].m_tree[(unsigned long)(~ sym2) + (
                                                            (bit_buf >> tmp_34) & (unsigned long)1)];
                        }
                        if (! (sym2 < 0)) break;
                      }
                    }
                    bit_buf >>= code_len_1;
                    num_bits -= code_len_1;
                    *(pOut_buf_cur + 0) = (mz_uint8)counter;
                    if (sym2 & 256) {
                      pOut_buf_cur ++;
                      counter = (mz_uint32)sym2;
                      break;
                    }
                    *(pOut_buf_cur + 1) = (mz_uint8)sym2;
                    pOut_buf_cur += 2;
                  }
              counter &= (unsigned int)511;
              if (counter == (mz_uint32)256) break;
              num_extra = (mz_uint32)tinfl_decompress_s_length_extra[
              counter - (mz_uint32)257];
              counter = (mz_uint32)tinfl_decompress_s_length_base[counter - (mz_uint32)257];
              if (num_extra) {
                mz_uint extra_bits;
                if (num_bits < num_extra) 
                  while (1) {
                    {
                      mz_uint c_8;
                      {
                        mz_uint8 const *tmp_35;
                        while (pIn_buf_cur >= pIn_buf_end) {
                          if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                            status = TINFL_STATUS_NEEDS_MORE_INPUT;
                          else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                          r->m_state = (mz_uint32)25;
                          goto common_exit;
                          case (mz_uint32)25: ;
                        }
                        tmp_35 = pIn_buf_cur;
                        pIn_buf_cur ++;
                        c_8 = (mz_uint)*tmp_35;
                      }
                      bit_buf |= (tinfl_bit_buf_t)c_8 << num_bits;
                      num_bits += (mz_uint32)8;
                    }
                    if (! (num_bits < num_extra)) break;
                  }
                extra_bits = (mz_uint)(bit_buf & (unsigned long)((1 << num_extra) - 1));
                bit_buf >>= num_extra;
                num_bits -= num_extra;
                counter += extra_bits;
              }
              {
                int temp_1;
                mz_uint code_len_2;
                mz_uint c_9;
                if (num_bits < (mz_uint32)15) 
                  if (pIn_buf_end - pIn_buf_cur < (long)2) 
                    while (1) {
                      temp_1 = (int)r->m_tables[1].m_look_up[bit_buf & (unsigned long)(
                                                             TINFL_FAST_LOOKUP_SIZE - 1)];
                      if (temp_1 >= 0) {
                        code_len_2 = (mz_uint)(temp_1 >> 9);
                        if (code_len_2) 
                          if (num_bits >= code_len_2) break;
                      }
                      else 
                        if (num_bits > (mz_uint32)TINFL_FAST_LOOKUP_BITS) {
                          code_len_2 = (mz_uint)TINFL_FAST_LOOKUP_BITS;
                          while (1) {
                            {
                              mz_uint tmp_36;
                              tmp_36 = code_len_2;
                              code_len_2 ++;
                              temp_1 = (int)r->m_tables[1].m_tree[(unsigned long)(~ temp_1) + (
                                                                  (bit_buf >> tmp_36) & (unsigned long)1)];
                            }
                            if (temp_1 < 0) {
                              if (! (num_bits >= code_len_2 + (mz_uint)1)) 
                                break;
                            }
                            else break;
                          }
                          if (temp_1 >= 0) break;
                        }
                      {
                        mz_uint8 const *tmp_37;
                        while (pIn_buf_cur >= pIn_buf_end) {
                          if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                            status = TINFL_STATUS_NEEDS_MORE_INPUT;
                          else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                          r->m_state = (mz_uint32)26;
                          goto common_exit;
                          case (mz_uint32)26: ;
                        }
                        tmp_37 = pIn_buf_cur;
                        pIn_buf_cur ++;
                        c_9 = (mz_uint)*tmp_37;
                      }
                      bit_buf |= (tinfl_bit_buf_t)c_9 << num_bits;
                      num_bits += (mz_uint32)8;
                      if (! (num_bits < (mz_uint32)15)) break;
                    }
                  else {
                    bit_buf |= ((tinfl_bit_buf_t)*(pIn_buf_cur + 0) << num_bits) | (
                               (tinfl_bit_buf_t)*(pIn_buf_cur + 1) << (
                               num_bits + (mz_uint32)8));
                    pIn_buf_cur += 2;
                    num_bits += (mz_uint32)16;
                  }
                temp_1 = (int)r->m_tables[1].m_look_up[bit_buf & (unsigned long)(
                                                       TINFL_FAST_LOOKUP_SIZE - 1)];
                if (temp_1 >= 0) {
                  code_len_2 = (mz_uint)(temp_1 >> 9);
                  temp_1 &= 511;
                }
                else {
                  code_len_2 = (mz_uint)TINFL_FAST_LOOKUP_BITS;
                  while (1) {
                    {
                      mz_uint tmp_38;
                      tmp_38 = code_len_2;
                      code_len_2 ++;
                      temp_1 = (int)r->m_tables[1].m_tree[(unsigned long)(~ temp_1) + (
                                                          (bit_buf >> tmp_38) & (unsigned long)1)];
                    }
                    if (! (temp_1 < 0)) break;
                  }
                }
                dist = (mz_uint32)temp_1;
                bit_buf >>= code_len_2;
                num_bits -= code_len_2;
              }
              num_extra = (mz_uint32)tinfl_decompress_s_dist_extra[dist];
              dist = (mz_uint32)tinfl_decompress_s_dist_base[dist];
              if (num_extra) {
                mz_uint extra_bits_0;
                if (num_bits < num_extra) 
                  while (1) {
                    {
                      mz_uint c_10;
                      {
                        mz_uint8 const *tmp_39;
                        while (pIn_buf_cur >= pIn_buf_end) {
                          if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                            status = TINFL_STATUS_NEEDS_MORE_INPUT;
                          else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                          r->m_state = (mz_uint32)27;
                          goto common_exit;
                          case (mz_uint32)27: ;
                        }
                        tmp_39 = pIn_buf_cur;
                        pIn_buf_cur ++;
                        c_10 = (mz_uint)*tmp_39;
                      }
                      bit_buf |= (tinfl_bit_buf_t)c_10 << num_bits;
                      num_bits += (mz_uint32)8;
                    }
                    if (! (num_bits < num_extra)) break;
                  }
                extra_bits_0 = (mz_uint)(bit_buf & (unsigned long)((1 << num_extra) - 1));
                bit_buf >>= num_extra;
                num_bits -= num_extra;
                dist += extra_bits_0;
              }
              dist_from_out_buf_start = (size_t)(pOut_buf_cur - pOut_buf_start);
              if (dist == (mz_uint32)0) goto _LOR_1;
              else 
                if ((size_t)dist > dist_from_out_buf_start) goto _LOR_1;
                else 
                  if (dist_from_out_buf_start == (size_t)0) {
                    _LOR_1: ;
                    if (decomp_flags & (unsigned int)TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF) 
                      while (1) {
                        status = TINFL_STATUS_FAILED;
                        r->m_state = (mz_uint32)37;
                        goto common_exit;
                        case (mz_uint32)37: ;
                      }
                  }
              pSrc = pOut_buf_start + ((dist_from_out_buf_start - (size_t)dist) & out_buf_size_mask);
              if (pOut_buf_cur > pSrc) tmp_43 = pOut_buf_cur;
              else tmp_43 = pSrc;
              ;
              if (tmp_43 + counter > pOut_buf_end) {
                while (1) {
                  mz_uint32 tmp_42;
                  tmp_42 = counter;
                  counter --;
                  ;
                  if (! tmp_42) break;
                  {
                    mz_uint8 *tmp_40;
                    size_t tmp_41;
                    while (pOut_buf_cur >= pOut_buf_end) {
                      status = TINFL_STATUS_HAS_MORE_OUTPUT;
                      r->m_state = (mz_uint32)53;
                      goto common_exit;
                      case (mz_uint32)53: ;
                    }
                    tmp_40 = pOut_buf_cur;
                    pOut_buf_cur ++;
                    tmp_41 = dist_from_out_buf_start;
                    dist_from_out_buf_start ++;
                    *tmp_40 = *(pOut_buf_start + ((tmp_41 - (size_t)dist) & out_buf_size_mask));
                  }
                }
                goto __Cont_1;
              }
              else 
                if (counter >= (mz_uint32)9) 
                  if (counter <= dist) {
                    mz_uint8 const *pSrc_end =
                      (mz_uint8 const *)(pSrc + (counter & (unsigned int)(~ 7)));
                    while (1) {
                      memcpy((void *)pOut_buf_cur,(void const *)pSrc,
                             sizeof(mz_uint32) * (unsigned long)2);
                      pOut_buf_cur += 8;
                      pSrc += 8;
                      ;
                      if (! ((void *)pSrc < (void *)pSrc_end)) break;
                    }
                    counter &= (unsigned int)7;
                    if (counter < (mz_uint32)3) {
                      if (counter) {
                        *(pOut_buf_cur + 0) = *(pSrc + 0);
                        if (counter > (mz_uint32)1) *(pOut_buf_cur + 1) = *(
                                                    pSrc + 1);
                        pOut_buf_cur += counter;
                      }
                      goto __Cont_1;
                    }
                  }
              while (counter > (mz_uint32)2) {
                *(pOut_buf_cur + 0) = *(pSrc + 0);
                *(pOut_buf_cur + 1) = *(pSrc + 1);
                *(pOut_buf_cur + 2) = *(pSrc + 2);
                pOut_buf_cur += 3;
                pSrc += 3;
                counter -= (mz_uint32)3;
              }
              if (counter > (mz_uint32)0) {
                *(pOut_buf_cur + 0) = *(pSrc + 0);
                if (counter > (mz_uint32)1) *(pOut_buf_cur + 1) = *(pSrc + 1);
                pOut_buf_cur += counter;
              }
            }
            __Cont_1: ;
          }
        }
      if (! (! (r->m_final & (unsigned int)1))) break;
    }
    if (num_bits < (num_bits & (unsigned int)7)) 
      while (1) {
        {
          mz_uint c_11;
          {
            mz_uint8 const *tmp_44;
            while (pIn_buf_cur >= pIn_buf_end) {
              if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                status = TINFL_STATUS_NEEDS_MORE_INPUT;
              else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
              r->m_state = (mz_uint32)32;
              goto common_exit;
              case (mz_uint32)32: ;
            }
            tmp_44 = pIn_buf_cur;
            pIn_buf_cur ++;
            c_11 = (mz_uint)*tmp_44;
          }
          bit_buf |= (tinfl_bit_buf_t)c_11 << num_bits;
          num_bits += (mz_uint32)8;
        }
        if (! (num_bits < (num_bits & (unsigned int)7))) break;
      }
    bit_buf >>= num_bits & (unsigned int)7;
    num_bits -= num_bits & (unsigned int)7;
    while (1) {
      if (pIn_buf_cur > pIn_buf_next) {
        if (! (num_bits >= (mz_uint32)8)) break;
      }
      else break;
      pIn_buf_cur --;
      num_bits -= (mz_uint32)8;
    }
    bit_buf &= ((mz_uint64)1 << num_bits) - (mz_uint64)1;
    __FC_assert(! num_bits != 0,"miniz_tinfl.c",576,"!num_bits");
    if (decomp_flags & (unsigned int)TINFL_FLAG_PARSE_ZLIB_HEADER) {
      counter = (mz_uint32)0;
      while (counter < (mz_uint32)4) {
        {
          mz_uint s_1;
          if (num_bits) {
            if (num_bits < (mz_uint)8) 
              while (1) {
                {
                  mz_uint c_12;
                  {
                    mz_uint8 const *tmp_45;
                    while (pIn_buf_cur >= pIn_buf_end) {
                      if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                        status = TINFL_STATUS_NEEDS_MORE_INPUT;
                      else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                      r->m_state = (mz_uint32)41;
                      goto common_exit;
                      case (mz_uint32)41: ;
                    }
                    tmp_45 = pIn_buf_cur;
                    pIn_buf_cur ++;
                    c_12 = (mz_uint)*tmp_45;
                  }
                  bit_buf |= (tinfl_bit_buf_t)c_12 << num_bits;
                  num_bits += (mz_uint32)8;
                }
                if (! (num_bits < (mz_uint)8)) break;
              }
            s_1 = (mz_uint)(bit_buf & (unsigned long)((1 << 8) - 1));
            bit_buf >>= 8;
            num_bits -= (mz_uint32)8;
          }
          else {
            mz_uint8 const *tmp_46;
            while (pIn_buf_cur >= pIn_buf_end) {
              if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                status = TINFL_STATUS_NEEDS_MORE_INPUT;
              else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
              r->m_state = (mz_uint32)42;
              goto common_exit;
              case (mz_uint32)42: ;
            }
            tmp_46 = pIn_buf_cur;
            pIn_buf_cur ++;
            s_1 = (mz_uint)*tmp_46;
          }
          r->m_z_adler32 = (r->m_z_adler32 << 8) | s_1;
        }
        counter ++;
      }
    }
    while (1) {
      status = TINFL_STATUS_DONE;
      r->m_state = (mz_uint32)34;
      goto common_exit;
      case (mz_uint32)34: ;
    }
  }
  common_exit: ;
  if (status != TINFL_STATUS_NEEDS_MORE_INPUT) 
    if (status != TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS) 
      while (1) {
        if (pIn_buf_cur > pIn_buf_next) {
          if (! (num_bits >= (mz_uint32)8)) break;
        }
        else break;
        pIn_buf_cur --;
        num_bits -= (mz_uint32)8;
      }
  r->m_num_bits = num_bits;
  r->m_bit_buf = bit_buf & (((mz_uint64)1 << num_bits) - (mz_uint64)1);
  r->m_dist = dist;
  r->m_counter = counter;
  r->m_num_extra = num_extra;
  r->m_dist_from_out_buf_start = dist_from_out_buf_start;
  *pIn_buf_size = (size_t)(pIn_buf_cur - pIn_buf_next);
  *pOut_buf_size = (size_t)(pOut_buf_cur - pOut_buf_next);
  if (decomp_flags & (unsigned int)(TINFL_FLAG_PARSE_ZLIB_HEADER | TINFL_FLAG_COMPUTE_ADLER32)) 
    if (status >= 0) {
      mz_uint32 i_1;
      mz_uint8 const *ptr = (mz_uint8 const *)pOut_buf_next;
      size_t buf_len = *pOut_buf_size;
      mz_uint32 s1 = r->m_check_adler32 & (unsigned int)0xffff;
      mz_uint32 s2 = r->m_check_adler32 >> 16;
      size_t block_len = buf_len % (unsigned long)5552;
      while (buf_len) {
        i_1 = (mz_uint32)0;
        while ((size_t)(i_1 + (mz_uint32)7) < block_len) {
          s1 += (mz_uint32)*(ptr + 0);
          s2 += s1;
          s1 += (mz_uint32)*(ptr + 1);
          s2 += s1;
          s1 += (mz_uint32)*(ptr + 2);
          s2 += s1;
          s1 += (mz_uint32)*(ptr + 3);
          s2 += s1;
          s1 += (mz_uint32)*(ptr + 4);
          s2 += s1;
          s1 += (mz_uint32)*(ptr + 5);
          s2 += s1;
          s1 += (mz_uint32)*(ptr + 6);
          s2 += s1;
          s1 += (mz_uint32)*(ptr + 7);
          s2 += s1;
          i_1 += (mz_uint32)8;
          ptr += 8;
        }
        while ((size_t)i_1 < block_len) {
          mz_uint8 const *tmp_47;
          tmp_47 = ptr;
          ptr ++;
          s1 += (mz_uint32)*tmp_47;
          s2 += s1;
          i_1 ++;
        }
        s1 %= 65521U;
        s2 %= 65521U;
        buf_len -= block_len;
        block_len = (size_t)5552;
      }
      r->m_check_adler32 = (s2 << 16) + s1;
      if (status == TINFL_STATUS_DONE) 
        if (decomp_flags & (unsigned int)TINFL_FLAG_PARSE_ZLIB_HEADER) 
          if (r->m_check_adler32 != r->m_z_adler32) status = TINFL_STATUS_ADLER32_MISMATCH;
    }
  __retres = (tinfl_status __attribute__((__visibility__("default"))))status;
  return_label: return __retres;
}

void __attribute__((__visibility__("default"))) *tinfl_decompress_mem_to_heap
(void const *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)
{
  void __attribute__((__visibility__("default"))) *__retres;
  tinfl_decompressor decomp;
  void *pNew_buf;
  void *pBuf = (void *)0;
  size_t src_buf_ofs = (size_t)0;
  size_t out_buf_capacity = (size_t)0;
  *pOut_len = (size_t)0;
  decomp.m_state = (mz_uint32)0;
  decomp.m_num_bits = (mz_uint32)0;
  decomp.m_bit_buf = (tinfl_bit_buf_t)0;
  decomp.m_dist = (mz_uint32)0;
  decomp.m_counter = (mz_uint32)0;
  decomp.m_num_extra = (mz_uint32)0;
  decomp.m_dist_from_out_buf_start = (size_t)0;
  while (1) {
    size_t new_out_buf_capacity;
    tinfl_status __attribute__((__visibility__("default"))) tmp_0;
    mz_uint8 *tmp;
    size_t src_buf_size = src_buf_len - src_buf_ofs;
    size_t dst_buf_size = out_buf_capacity - *pOut_len;
    ;
    if (pBuf) tmp = (mz_uint8 *)pBuf + *pOut_len; else tmp = (mz_uint8 *)0;
    ;
    ;
    tmp_0 = tinfl_decompress(& decomp,
                             (mz_uint8 const *)pSrc_buf + src_buf_ofs,
                             & src_buf_size,(mz_uint8 *)pBuf,tmp,
                             & dst_buf_size,
                             (mz_uint32)((flags & ~ TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF));
    tinfl_status status = (tinfl_status)tmp_0;
    if (status < 0) goto _LOR;
    else 
      if (status == TINFL_STATUS_NEEDS_MORE_INPUT) {
        _LOR:
        {
          free(pBuf);
          *pOut_len = (size_t)0;
          __retres = (void __attribute__((__visibility__("default"))) *)0;
          goto return_label;
        }
      }
    src_buf_ofs += src_buf_size;
    *pOut_len += dst_buf_size;
    if (status == TINFL_STATUS_DONE) break;
    new_out_buf_capacity = out_buf_capacity * (size_t)2;
    if (new_out_buf_capacity < (size_t)128) new_out_buf_capacity = (size_t)128;
    pNew_buf = realloc(pBuf,new_out_buf_capacity);
    if (! pNew_buf) {
      free(pBuf);
      *pOut_len = (size_t)0;
      __retres = (void __attribute__((__visibility__("default"))) *)0;
      goto return_label;
    }
    pBuf = pNew_buf;
    out_buf_capacity = new_out_buf_capacity;
  }
  __retres = (void __attribute__((__visibility__("default"))) *)pBuf;
  return_label: return __retres;
}

size_t __attribute__((__visibility__("default"))) tinfl_decompress_mem_to_mem
(void *pOut_buf, size_t out_buf_len, void const *pSrc_buf,
 size_t src_buf_len, int flags)
{
  size_t __attribute__((__visibility__("default"))) __retres;
  tinfl_decompressor decomp;
  tinfl_status status;
  tinfl_status __attribute__((__visibility__("default"))) tmp;
  size_t tmp_0;
  decomp.m_state = (mz_uint32)0;
  decomp.m_num_bits = (mz_uint32)0;
  decomp.m_bit_buf = (tinfl_bit_buf_t)0;
  decomp.m_dist = (mz_uint32)0;
  decomp.m_counter = (mz_uint32)0;
  decomp.m_num_extra = (mz_uint32)0;
  decomp.m_dist_from_out_buf_start = (size_t)0;
  tmp = tinfl_decompress(& decomp,(mz_uint8 const *)pSrc_buf,& src_buf_len,
                         (mz_uint8 *)pOut_buf,(mz_uint8 *)pOut_buf,
                         & out_buf_len,
                         (mz_uint32)((flags & ~ TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF));
  status = (tinfl_status)tmp;
  if (status != TINFL_STATUS_DONE) tmp_0 = (size_t)(-1);
  else tmp_0 = out_buf_len;
  __retres = (size_t __attribute__((__visibility__("default"))))tmp_0;
  return __retres;
}

int __attribute__((__visibility__("default"))) tinfl_decompress_mem_to_callback
(void const *pIn_buf, size_t *pIn_buf_size,
 int (*pPut_buf_func)(void const *pBuf, int len, void *pUser),
 void *pPut_buf_user, int flags)
{
  int __attribute__((__visibility__("default"))) __retres;
  tinfl_decompressor decomp;
  int result = 0;
  mz_uint8 *pDict = malloc((size_t)32768);
  size_t in_buf_ofs = (size_t)0;
  size_t dict_ofs = (size_t)0;
  if (! pDict) {
    __retres = (int __attribute__((__visibility__("default"))))TINFL_STATUS_FAILED;
    goto return_label;
  }
  decomp.m_state = (mz_uint32)0;
  decomp.m_num_bits = (mz_uint32)0;
  decomp.m_bit_buf = (tinfl_bit_buf_t)0;
  decomp.m_dist = (mz_uint32)0;
  decomp.m_counter = (mz_uint32)0;
  decomp.m_num_extra = (mz_uint32)0;
  decomp.m_dist_from_out_buf_start = (size_t)0;
  while (1) {
    tinfl_status __attribute__((__visibility__("default"))) tmp_0;
    size_t in_buf_size = *pIn_buf_size - in_buf_ofs;
    size_t dst_buf_size = (size_t)32768 - dict_ofs;
    tmp_0 = tinfl_decompress(& decomp,(mz_uint8 const *)pIn_buf + in_buf_ofs,
                             & in_buf_size,pDict,pDict + dict_ofs,
                             & dst_buf_size,
                             (mz_uint32)(flags & ~ (TINFL_FLAG_HAS_MORE_INPUT | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)));
    tinfl_status status = (tinfl_status)tmp_0;
    in_buf_ofs += in_buf_size;
    if (dst_buf_size) {
      int tmp_1;
      tmp_1 = (*pPut_buf_func)((void const *)(pDict + dict_ofs),
                               (int)dst_buf_size,pPut_buf_user);
      if (! tmp_1) break;
    }
    if (status != TINFL_STATUS_HAS_MORE_OUTPUT) {
      result = status == TINFL_STATUS_DONE;
      break;
    }
    dict_ofs = (dict_ofs + dst_buf_size) & (unsigned long)(32768 - 1);
  }
  free((void *)pDict);
  *pIn_buf_size = in_buf_ofs;
  __retres = (int __attribute__((__visibility__("default"))))result;
  return_label: return __retres;
}

tinfl_decompressor __attribute__((__visibility__("default"))) *tinfl_decompressor_alloc
(void)
{
  tinfl_decompressor __attribute__((__visibility__("default"))) *__retres;
  tinfl_decompressor *pDecomp = malloc(sizeof(tinfl_decompressor));
  if (pDecomp) {
    pDecomp->m_state = (mz_uint32)0;
    pDecomp->m_num_bits = (mz_uint32)0;
    pDecomp->m_bit_buf = (tinfl_bit_buf_t)0;
    pDecomp->m_dist = (mz_uint32)0;
    pDecomp->m_counter = (mz_uint32)0;
    pDecomp->m_num_extra = (mz_uint32)0;
    pDecomp->m_dist_from_out_buf_start = (size_t)0;
  }
  __retres = (tinfl_decompressor __attribute__((__visibility__("default"))) *)pDecomp;
  return __retres;
}

void __attribute__((__visibility__("default"))) tinfl_decompressor_free
(tinfl_decompressor *pDecomp)
{
  free((void *)pDecomp);
  return;
}


