/* Generated by Frama-C */
#include "__fc_builtin.h"
#include "assert.h"
#include "errno.h"
#include "signal.h"
#include "stdarg.h"
#include "stdint.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "strings.h"
#include "time.h"
typedef unsigned long mz_ulong;
enum __anonenum_1 {
    MZ_DEFAULT_STRATEGY = 0,
    MZ_FILTERED = 1,
    MZ_HUFFMAN_ONLY = 2,
    MZ_RLE = 3,
    MZ_FIXED = 4
};
enum __anonenum_2 {
    MZ_NO_COMPRESSION = 0,
    MZ_BEST_SPEED = 1,
    MZ_BEST_COMPRESSION = 9,
    MZ_UBER_COMPRESSION = 10,
    MZ_DEFAULT_LEVEL = 6,
    MZ_DEFAULT_COMPRESSION = -1
};
enum __anonenum_3 {
    MZ_NO_FLUSH = 0,
    MZ_PARTIAL_FLUSH = 1,
    MZ_SYNC_FLUSH = 2,
    MZ_FULL_FLUSH = 3,
    MZ_FINISH = 4,
    MZ_BLOCK = 5
};
enum __anonenum_4 {
    MZ_OK = 0,
    MZ_STREAM_END = 1,
    MZ_NEED_DICT = 2,
    MZ_ERRNO = -1,
    MZ_STREAM_ERROR = -2,
    MZ_DATA_ERROR = -3,
    MZ_MEM_ERROR = -4,
    MZ_BUF_ERROR = -5,
    MZ_VERSION_ERROR = -6,
    MZ_PARAM_ERROR = -10000
};
struct mz_internal_state;
struct mz_stream_s {
   unsigned char const *next_in ;
   unsigned int avail_in ;
   mz_ulong total_in ;
   unsigned char *next_out ;
   unsigned int avail_out ;
   mz_ulong total_out ;
   char *msg ;
   struct mz_internal_state *state ;
   void *(*zalloc)(void *opaque, size_t items, size_t size) ;
   void (*zfree)(void *opaque, void *address) ;
   void *opaque ;
   int data_type ;
   mz_ulong adler ;
   mz_ulong reserved ;
};
typedef struct mz_stream_s mz_stream;
typedef mz_stream *mz_streamp;
typedef mz_ulong uLong;
typedef unsigned char mz_uint8;
typedef short mz_int16;
typedef unsigned short mz_uint16;
typedef unsigned int mz_uint32;
typedef unsigned int mz_uint;
typedef uint64_t mz_uint64;
typedef int mz_bool;
enum __anonenum_5 {
    TDEFL_HUFFMAN_ONLY = 0,
    TDEFL_DEFAULT_MAX_PROBES = 128,
    TDEFL_MAX_PROBES_MASK = 0xFFF
};
enum __anonenum_6 {
    TDEFL_WRITE_ZLIB_HEADER = 0x01000,
    TDEFL_COMPUTE_ADLER32 = 0x02000,
    TDEFL_GREEDY_PARSING_FLAG = 0x04000,
    TDEFL_NONDETERMINISTIC_PARSING_FLAG = 0x08000,
    TDEFL_RLE_MATCHES = 0x10000,
    TDEFL_FILTER_MATCHES = 0x20000,
    TDEFL_FORCE_ALL_STATIC_BLOCKS = 0x40000,
    TDEFL_FORCE_ALL_RAW_BLOCKS = 0x80000
};
enum __anonenum_7 {
    TDEFL_MAX_HUFF_TABLES = 3,
    TDEFL_MAX_HUFF_SYMBOLS_0 = 288,
    TDEFL_MAX_HUFF_SYMBOLS_1 = 32,
    TDEFL_MAX_HUFF_SYMBOLS_2 = 19,
    TDEFL_LZ_DICT_SIZE = 32768,
    TDEFL_LZ_DICT_SIZE_MASK = TDEFL_LZ_DICT_SIZE - 1,
    TDEFL_MIN_MATCH_LEN = 3,
    TDEFL_MAX_MATCH_LEN = 258
};
enum __anonenum_8 {
    TDEFL_LZ_CODE_BUF_SIZE = 64 * 1024,
    TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13) / 10,
    TDEFL_MAX_HUFF_SYMBOLS = 288,
    TDEFL_LZ_HASH_BITS = 15,
    TDEFL_LEVEL1_HASH_SIZE_MASK = 4095,
    TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3,
    TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS
};
enum __anonenum_tdefl_status_9 {
    TDEFL_STATUS_BAD_PARAM = -2,
    TDEFL_STATUS_PUT_BUF_FAILED = -1,
    TDEFL_STATUS_OKAY = 0,
    TDEFL_STATUS_DONE = 1
};
typedef enum __anonenum_tdefl_status_9 tdefl_status;
enum __anonenum_tdefl_flush_10 {
    TDEFL_NO_FLUSH = 0,
    TDEFL_SYNC_FLUSH = 2,
    TDEFL_FULL_FLUSH = 3,
    TDEFL_FINISH = 4
};
typedef enum __anonenum_tdefl_flush_10 tdefl_flush;
struct __anonstruct_tdefl_compressor_11 {
   mz_bool (*m_pPut_buf_func)(void const *pBuf, int len, void *pUser) ;
   void *m_pPut_buf_user ;
   mz_uint m_flags ;
   mz_uint m_max_probes[2] ;
   int m_greedy_parsing ;
   mz_uint m_adler32 ;
   mz_uint m_lookahead_pos ;
   mz_uint m_lookahead_size ;
   mz_uint m_dict_size ;
   mz_uint8 *m_pLZ_code_buf ;
   mz_uint8 *m_pLZ_flags ;
   mz_uint8 *m_pOutput_buf ;
   mz_uint8 *m_pOutput_buf_end ;
   mz_uint m_num_flags_left ;
   mz_uint m_total_lz_bytes ;
   mz_uint m_lz_code_buf_dict_pos ;
   mz_uint m_bits_in ;
   mz_uint m_bit_buffer ;
   mz_uint m_saved_match_dist ;
   mz_uint m_saved_match_len ;
   mz_uint m_saved_lit ;
   mz_uint m_output_flush_ofs ;
   mz_uint m_output_flush_remaining ;
   mz_uint m_finished ;
   mz_uint m_block_index ;
   mz_uint m_wants_to_finish ;
   tdefl_status m_prev_return_status ;
   void const *m_pIn_buf ;
   void *m_pOut_buf ;
   size_t *m_pIn_buf_size ;
   size_t *m_pOut_buf_size ;
   tdefl_flush m_flush ;
   mz_uint8 const *m_pSrc ;
   size_t m_src_buf_left ;
   size_t m_out_buf_ofs ;
   mz_uint8 m_dict[(TDEFL_LZ_DICT_SIZE + TDEFL_MAX_MATCH_LEN) - 1] ;
   mz_uint16 m_huff_count[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS] ;
   mz_uint16 m_huff_codes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS] ;
   mz_uint8 m_huff_code_sizes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS] ;
   mz_uint8 m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE] ;
   mz_uint16 m_next[TDEFL_LZ_DICT_SIZE] ;
   mz_uint16 m_hash[TDEFL_LZ_HASH_SIZE] ;
   mz_uint8 m_output_buf[TDEFL_OUT_BUF_SIZE] ;
};
typedef struct __anonstruct_tdefl_compressor_11 tdefl_compressor;
enum __anonenum_12 {
    TINFL_FLAG_PARSE_ZLIB_HEADER = 1,
    TINFL_FLAG_HAS_MORE_INPUT = 2,
    TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF = 4,
    TINFL_FLAG_COMPUTE_ADLER32 = 8
};
struct tinfl_decompressor_tag;
typedef struct tinfl_decompressor_tag tinfl_decompressor;
enum __anonenum_tinfl_status_13 {
    TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS = -4,
    TINFL_STATUS_BAD_PARAM = -3,
    TINFL_STATUS_ADLER32_MISMATCH = -2,
    TINFL_STATUS_FAILED = -1,
    TINFL_STATUS_DONE = 0,
    TINFL_STATUS_NEEDS_MORE_INPUT = 1,
    TINFL_STATUS_HAS_MORE_OUTPUT = 2
};
typedef enum __anonenum_tinfl_status_13 tinfl_status;
enum __anonenum_14 {
    TINFL_MAX_HUFF_TABLES = 3,
    TINFL_MAX_HUFF_SYMBOLS_0 = 288,
    TINFL_MAX_HUFF_SYMBOLS_1 = 32,
    TINFL_MAX_HUFF_SYMBOLS_2 = 19,
    TINFL_FAST_LOOKUP_BITS = 10,
    TINFL_FAST_LOOKUP_SIZE = 1 << TINFL_FAST_LOOKUP_BITS
};
struct __anonstruct_tinfl_huff_table_15 {
   mz_uint8 m_code_size[TINFL_MAX_HUFF_SYMBOLS_0] ;
   mz_int16 m_look_up[TINFL_FAST_LOOKUP_SIZE] ;
   mz_int16 m_tree[TINFL_MAX_HUFF_SYMBOLS_0 * 2] ;
};
typedef struct __anonstruct_tinfl_huff_table_15 tinfl_huff_table;
typedef mz_uint64 tinfl_bit_buf_t;
struct tinfl_decompressor_tag {
   mz_uint32 m_state ;
   mz_uint32 m_num_bits ;
   mz_uint32 m_zhdr0 ;
   mz_uint32 m_zhdr1 ;
   mz_uint32 m_z_adler32 ;
   mz_uint32 m_final ;
   mz_uint32 m_type ;
   mz_uint32 m_check_adler32 ;
   mz_uint32 m_dist ;
   mz_uint32 m_counter ;
   mz_uint32 m_num_extra ;
   mz_uint32 m_table_sizes[TINFL_MAX_HUFF_TABLES] ;
   tinfl_bit_buf_t m_bit_buf ;
   size_t m_dist_from_out_buf_start ;
   tinfl_huff_table m_tables[TINFL_MAX_HUFF_TABLES] ;
   mz_uint8 m_raw_header[4] ;
   mz_uint8 m_len_codes[(TINFL_MAX_HUFF_SYMBOLS_0 + TINFL_MAX_HUFF_SYMBOLS_1) + 137] ;
};
typedef unsigned char uint8;
typedef unsigned int uint;
struct __anonstruct_inflate_state_24 {
   tinfl_decompressor m_decomp ;
   mz_uint m_dict_ofs ;
   mz_uint m_dict_avail ;
   mz_uint m_first_call ;
   mz_uint m_has_flushed ;
   int m_window_bits ;
   mz_uint8 m_dict[32768] ;
   tinfl_status m_last_status ;
};
typedef struct __anonstruct_inflate_state_24 inflate_state;
struct __anonstruct_s_error_descs_25 {
   int m_err ;
   char const *m_pDesc ;
};
struct __anonstruct_tdefl_sym_freq_24 {
   mz_uint16 m_key ;
   mz_uint16 m_sym_index ;
};
typedef struct __anonstruct_tdefl_sym_freq_24 tdefl_sym_freq;
enum __anonenum_25 {
    TDEFL_MAX_SUPPORTED_HUFF_CODESIZE = 32
};
struct __anonstruct_tdefl_output_buffer_26 {
   size_t m_size ;
   size_t m_capacity ;
   mz_uint8 *m_pBuf ;
   mz_bool m_expandable ;
};
typedef struct __anonstruct_tdefl_output_buffer_26 tdefl_output_buffer;
int main(int argc, char **argv);

int eva_main(void)
{
  char argv0[256];
  char argv1[256];
  char argv2[256];
  char argv3[256];
  char argv4[256];
  int tmp_0;
  int argc = Frama_C_interval(0,5);
  char *argv[6] = {argv0, argv1, argv2, argv3, argv4, (char *)0};
  {
    int i = 0;
    /*@ loop unroll 5; */
    while (i < 5) {
      Frama_C_make_unknown(argv[i],(size_t)255);
      *(argv[i] + 255) = (char)0;
      i ++;
    }
  }
  tmp_0 = main(argc,argv);
  return tmp_0;
}

void __attribute__((__visibility__("default"))) mz_free(void *p);

mz_ulong __attribute__((__visibility__("default"))) mz_adler32(mz_ulong adler,
                                                               unsigned char const *ptr,
                                                               size_t buf_len);

mz_ulong __attribute__((__visibility__("default"))) mz_crc32(mz_ulong crc,
                                                             unsigned char const *ptr,
                                                             size_t buf_len);

char const __attribute__((__visibility__("default"))) *mz_version(void);

int __attribute__((__visibility__("default"))) mz_deflateInit(mz_streamp pStream,
                                                              int level);

int __attribute__((__visibility__("default"))) mz_deflateInit2(mz_streamp pStream,
                                                               int level,
                                                               int method,
                                                               int window_bits,
                                                               int mem_level,
                                                               int strategy);

int __attribute__((__visibility__("default"))) mz_deflateReset(mz_streamp pStream);

int __attribute__((__visibility__("default"))) mz_deflate(mz_streamp pStream,
                                                          int flush);

int __attribute__((__visibility__("default"))) mz_deflateEnd(mz_streamp pStream);

mz_ulong __attribute__((__visibility__("default"))) mz_deflateBound(mz_streamp pStream,
                                                                    mz_ulong source_len);

int __attribute__((__visibility__("default"))) mz_compress(unsigned char *pDest,
                                                           mz_ulong *pDest_len,
                                                           unsigned char const *pSource,
                                                           mz_ulong source_len);

int __attribute__((__visibility__("default"))) mz_compress2(unsigned char *pDest,
                                                            mz_ulong *pDest_len,
                                                            unsigned char const *pSource,
                                                            mz_ulong source_len,
                                                            int level);

mz_ulong __attribute__((__visibility__("default"))) mz_compressBound(
                                                                    mz_ulong source_len);

int __attribute__((__visibility__("default"))) mz_inflateInit(mz_streamp pStream);

int __attribute__((__visibility__("default"))) mz_inflateInit2(mz_streamp pStream,
                                                               int window_bits);

int __attribute__((__visibility__("default"))) mz_inflateReset(mz_streamp pStream);

int __attribute__((__visibility__("default"))) mz_inflate(mz_streamp pStream,
                                                          int flush);

int __attribute__((__visibility__("default"))) mz_inflateEnd(mz_streamp pStream);

int __attribute__((__visibility__("default"))) mz_uncompress(unsigned char *pDest,
                                                             mz_ulong *pDest_len,
                                                             unsigned char const *pSource,
                                                             mz_ulong source_len);

int __attribute__((__visibility__("default"))) mz_uncompress2(unsigned char *pDest,
                                                              mz_ulong *pDest_len,
                                                              unsigned char const *pSource,
                                                              mz_ulong *pSource_len);

char const __attribute__((__visibility__("default"))) *mz_error(int err);

void __attribute__((__visibility__("default"))) *miniz_def_alloc_func
(void *opaque, size_t items, size_t size);

void __attribute__((__visibility__("default"))) miniz_def_free_func(void *opaque,
                                                                    void *address);

void __attribute__((__visibility__("default"))) *miniz_def_realloc_func
(void *opaque, void *address, size_t items, size_t size);

void __attribute__((__visibility__("default"))) *tdefl_compress_mem_to_heap
(void const *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags);

size_t __attribute__((__visibility__("default"))) tdefl_compress_mem_to_mem
(void *pOut_buf, size_t out_buf_len, void const *pSrc_buf,
 size_t src_buf_len, int flags);

void __attribute__((__visibility__("default"))) *tdefl_write_image_to_png_file_in_memory_ex
(void const *pImage, int w, int h, int num_chans, size_t *pLen_out,
 mz_uint level, mz_bool flip);

void __attribute__((__visibility__("default"))) *tdefl_write_image_to_png_file_in_memory
(void const *pImage, int w, int h, int num_chans, size_t *pLen_out);

mz_bool __attribute__((__visibility__("default"))) tdefl_compress_mem_to_output
(void const *pBuf, size_t buf_len,
 mz_bool (*pPut_buf_func)(void const *pBuf, int len, void *pUser),
 void *pPut_buf_user, int flags);

tdefl_status __attribute__((__visibility__("default"))) tdefl_init(tdefl_compressor *d,
                                                                   mz_bool (*pPut_buf_func)
                                                                   (void const *pBuf,
                                                                    int len,
                                                                    void *pUser),
                                                                   void *pPut_buf_user,
                                                                   int flags);

tdefl_status __attribute__((__visibility__("default"))) tdefl_compress
(tdefl_compressor *d, void const *pIn_buf, size_t *pIn_buf_size,
 void *pOut_buf, size_t *pOut_buf_size, tdefl_flush flush);

tdefl_status __attribute__((__visibility__("default"))) tdefl_compress_buffer
(tdefl_compressor *d, void const *pIn_buf, size_t in_buf_size,
 tdefl_flush flush);

tdefl_status __attribute__((__visibility__("default"))) tdefl_get_prev_return_status
(tdefl_compressor *d);

mz_uint32 __attribute__((__visibility__("default"))) tdefl_get_adler32
(tdefl_compressor *d);

mz_uint __attribute__((__visibility__("default"))) tdefl_create_comp_flags_from_zip_params
(int level, int window_bits, int strategy);

tdefl_compressor __attribute__((__visibility__("default"))) *tdefl_compressor_alloc
(void);

void __attribute__((__visibility__("default"))) tdefl_compressor_free
(tdefl_compressor *pComp);

void __attribute__((__visibility__("default"))) *tinfl_decompress_mem_to_heap
(void const *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags);

size_t __attribute__((__visibility__("default"))) tinfl_decompress_mem_to_mem
(void *pOut_buf, size_t out_buf_len, void const *pSrc_buf,
 size_t src_buf_len, int flags);

int __attribute__((__visibility__("default"))) tinfl_decompress_mem_to_callback
(void const *pIn_buf, size_t *pIn_buf_size,
 int (*pPut_buf_func)(void const *pBuf, int len, void *pUser),
 void *pPut_buf_user, int flags);

tinfl_decompressor __attribute__((__visibility__("default"))) *tinfl_decompressor_alloc
(void);

void __attribute__((__visibility__("default"))) tinfl_decompressor_free
(tinfl_decompressor *pDecomp);

tinfl_status __attribute__((__visibility__("default"))) tinfl_decompress
(tinfl_decompressor *r, mz_uint8 const *pIn_buf_next, size_t *pIn_buf_size,
 mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size,
 mz_uint32 const decomp_flags);

static char const *s_pStr =
  "Good morning Dr. Chandra. This is Hal. I am ready for my first lesson.Good morning Dr. Chandra. This is Hal. I am ready for my first lesson.Good morning Dr. Chandra. This is Hal. I am ready for my first lesson.Good morning Dr. Chandra. This is Hal. I am ready for my first lesson.Good morning Dr. Chandra. This is Hal. I am ready for my first lesson.Good morning Dr. Chandra. This is Hal. I am ready for my first lesson.Good morning Dr. Chandra. This is Hal. I am ready for my first lesson.";
/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_1(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_2(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_3(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, param0;
 */
int printf_va_4(char const * restrict format, unsigned int param0,
                unsigned int param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, param0;
 */
int printf_va_5(char const * restrict format, unsigned int param0,
                unsigned int param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_6(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, param0;
 */
int printf_va_7(char const * restrict format, unsigned int param0,
                unsigned int param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_8(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_9(char const * restrict format);

int main(int argc, char **argv)
{
  int __retres;
  int cmp_status;
  uint8 *pCmp;
  uint8 *pUncomp;
  uint step = (uint)0;
  uLong src_len = strlen(s_pStr);
  uLong cmp_len = mz_compressBound(src_len);
  uLong uncomp_len = src_len;
  uint total_succeeded = (uint)0;
  printf("miniz.c version: %s\n",(char *)"10.1.0"); /* printf_va_1 */
  while (1) {
    pCmp = (uint8 *)malloc(cmp_len);
    pUncomp = (uint8 *)malloc(src_len);
    if (! pCmp) goto _LOR;
    else 
      if (! pUncomp) {
        _LOR:
        {
          printf("Out of memory!\n"); /* printf_va_2 */
          __retres = 1;
          goto return_label;
        }
      }
    cmp_status = (int)mz_compress(pCmp,& cmp_len,
                                  (unsigned char const *)s_pStr,src_len);
    if (cmp_status != MZ_OK) {
      printf("compress() failed!\n"); /* printf_va_3 */
      free((void *)pCmp);
      free((void *)pUncomp);
      __retres = 1;
      goto return_label;
    }
    printf("Compressed from %u to %u bytes\n",(mz_uint32)src_len,
           (mz_uint32)cmp_len); /* printf_va_4 */
    if (step) {
      int tmp_3;
      tmp_3 = rand();
      uint n = (uint)(1 + tmp_3 % 3);
      while (1) {
        uint tmp_6;
        tmp_6 = n;
        n --;
        ;
        if (! tmp_6) break;
        {
          int tmp_4;
          int tmp_5;
          tmp_4 = rand();
          uint i = (uint)((unsigned long)tmp_4 % cmp_len);
          tmp_5 = rand();
          *(pCmp + i) = (uint8)((int)*(pCmp + i) ^ (tmp_5 & 0xFF));
        }
      }
    }
    cmp_status = (int)mz_uncompress(pUncomp,& uncomp_len,
                                    (unsigned char const *)pCmp,cmp_len);
    total_succeeded += (uint)(cmp_status == MZ_OK);
    if (step) printf("Simple fuzzy test: step %u total_succeeded: %u\n",step,
                     total_succeeded); /* printf_va_5 */
    else {
      if (cmp_status != MZ_OK) {
        printf("uncompress failed!\n"); /* printf_va_6 */
        free((void *)pCmp);
        free((void *)pUncomp);
        __retres = 1;
        goto return_label;
      }
      printf("Decompressed from %u to %u bytes\n",(mz_uint32)cmp_len,
             (mz_uint32)uncomp_len); /* printf_va_7 */
      if (uncomp_len != src_len) goto _LOR_0;
      else {
        int tmp_7;
        tmp_7 = memcmp((void const *)pUncomp,(void const *)s_pStr,src_len);
        if (tmp_7) {
          _LOR_0:
          {
            printf("Decompression failed!\n"); /* printf_va_8 */
            free((void *)pCmp);
            free((void *)pUncomp);
            __retres = 1;
            goto return_label;
          }
        }
      }
    }
    free((void *)pCmp);
    free((void *)pUncomp);
    step ++;
    if (! (argc >= 2)) break;
  }
  printf("Success.\n"); /* printf_va_9 */
  __retres = 0;
  return_label: return __retres;
}

mz_ulong __attribute__((__visibility__("default"))) mz_adler32(mz_ulong adler,
                                                               unsigned char const *ptr,
                                                               size_t buf_len)
{
  mz_ulong __attribute__((__visibility__("default"))) __retres;
  mz_uint32 i;
  mz_uint32 s1 = (mz_uint32)(adler & (unsigned long)0xffff);
  mz_uint32 s2 = (mz_uint32)(adler >> 16);
  size_t block_len = buf_len % (unsigned long)5552;
  if (! ptr) {
    __retres = (mz_ulong __attribute__((__visibility__("default"))))1;
    goto return_label;
  }
  while (buf_len) {
    i = (mz_uint32)0;
    while ((size_t)(i + (mz_uint32)7) < block_len) {
      s1 += (mz_uint32)*(ptr + 0);
      s2 += s1;
      s1 += (mz_uint32)*(ptr + 1);
      s2 += s1;
      s1 += (mz_uint32)*(ptr + 2);
      s2 += s1;
      s1 += (mz_uint32)*(ptr + 3);
      s2 += s1;
      s1 += (mz_uint32)*(ptr + 4);
      s2 += s1;
      s1 += (mz_uint32)*(ptr + 5);
      s2 += s1;
      s1 += (mz_uint32)*(ptr + 6);
      s2 += s1;
      s1 += (mz_uint32)*(ptr + 7);
      s2 += s1;
      i += (mz_uint32)8;
      ptr += 8;
    }
    while ((size_t)i < block_len) {
      unsigned char const *tmp;
      tmp = ptr;
      ptr ++;
      s1 += (mz_uint32)*tmp;
      s2 += s1;
      i ++;
    }
    s1 %= 65521U;
    s2 %= 65521U;
    buf_len -= block_len;
    block_len = (size_t)5552;
  }
  __retres = (mz_ulong __attribute__((__visibility__("default"))))((s2 << 16) + s1);
  return_label: return __retres;
}

static mz_uint32 const mz_crc32_s_crc_table[256] =
  {(mz_uint32)0x00000000,
   (mz_uint32)0x77073096,
   0xEE0E612C,
   0x990951BA,
   (mz_uint32)0x076DC419,
   (mz_uint32)0x706AF48F,
   0xE963A535,
   0x9E6495A3,
   (mz_uint32)0x0EDB8832,
   (mz_uint32)0x79DCB8A4,
   0xE0D5E91E,
   0x97D2D988,
   (mz_uint32)0x09B64C2B,
   (mz_uint32)0x7EB17CBD,
   0xE7B82D07,
   0x90BF1D91,
   (mz_uint32)0x1DB71064,
   (mz_uint32)0x6AB020F2,
   0xF3B97148,
   0x84BE41DE,
   (mz_uint32)0x1ADAD47D,
   (mz_uint32)0x6DDDE4EB,
   0xF4D4B551,
   0x83D385C7,
   (mz_uint32)0x136C9856,
   (mz_uint32)0x646BA8C0,
   0xFD62F97A,
   0x8A65C9EC,
   (mz_uint32)0x14015C4F,
   (mz_uint32)0x63066CD9,
   0xFA0F3D63,
   0x8D080DF5,
   (mz_uint32)0x3B6E20C8,
   (mz_uint32)0x4C69105E,
   0xD56041E4,
   0xA2677172,
   (mz_uint32)0x3C03E4D1,
   (mz_uint32)0x4B04D447,
   0xD20D85FD,
   0xA50AB56B,
   (mz_uint32)0x35B5A8FA,
   (mz_uint32)0x42B2986C,
   0xDBBBC9D6,
   0xACBCF940,
   (mz_uint32)0x32D86CE3,
   (mz_uint32)0x45DF5C75,
   0xDCD60DCF,
   0xABD13D59,
   (mz_uint32)0x26D930AC,
   (mz_uint32)0x51DE003A,
   0xC8D75180,
   0xBFD06116,
   (mz_uint32)0x21B4F4B5,
   (mz_uint32)0x56B3C423,
   0xCFBA9599,
   0xB8BDA50F,
   (mz_uint32)0x2802B89E,
   (mz_uint32)0x5F058808,
   0xC60CD9B2,
   0xB10BE924,
   (mz_uint32)0x2F6F7C87,
   (mz_uint32)0x58684C11,
   0xC1611DAB,
   0xB6662D3D,
   (mz_uint32)0x76DC4190,
   (mz_uint32)0x01DB7106,
   0x98D220BC,
   0xEFD5102A,
   (mz_uint32)0x71B18589,
   (mz_uint32)0x06B6B51F,
   0x9FBFE4A5,
   0xE8B8D433,
   (mz_uint32)0x7807C9A2,
   (mz_uint32)0x0F00F934,
   0x9609A88E,
   0xE10E9818,
   (mz_uint32)0x7F6A0DBB,
   (mz_uint32)0x086D3D2D,
   0x91646C97,
   0xE6635C01,
   (mz_uint32)0x6B6B51F4,
   (mz_uint32)0x1C6C6162,
   0x856530D8,
   0xF262004E,
   (mz_uint32)0x6C0695ED,
   (mz_uint32)0x1B01A57B,
   0x8208F4C1,
   0xF50FC457,
   (mz_uint32)0x65B0D9C6,
   (mz_uint32)0x12B7E950,
   0x8BBEB8EA,
   0xFCB9887C,
   (mz_uint32)0x62DD1DDF,
   (mz_uint32)0x15DA2D49,
   0x8CD37CF3,
   0xFBD44C65,
   (mz_uint32)0x4DB26158,
   (mz_uint32)0x3AB551CE,
   0xA3BC0074,
   0xD4BB30E2,
   (mz_uint32)0x4ADFA541,
   (mz_uint32)0x3DD895D7,
   0xA4D1C46D,
   0xD3D6F4FB,
   (mz_uint32)0x4369E96A,
   (mz_uint32)0x346ED9FC,
   0xAD678846,
   0xDA60B8D0,
   (mz_uint32)0x44042D73,
   (mz_uint32)0x33031DE5,
   0xAA0A4C5F,
   0xDD0D7CC9,
   (mz_uint32)0x5005713C,
   (mz_uint32)0x270241AA,
   0xBE0B1010,
   0xC90C2086,
   (mz_uint32)0x5768B525,
   (mz_uint32)0x206F85B3,
   0xB966D409,
   0xCE61E49F,
   (mz_uint32)0x5EDEF90E,
   (mz_uint32)0x29D9C998,
   0xB0D09822,
   0xC7D7A8B4,
   (mz_uint32)0x59B33D17,
   (mz_uint32)0x2EB40D81,
   0xB7BD5C3B,
   0xC0BA6CAD,
   0xEDB88320,
   0x9ABFB3B6,
   (mz_uint32)0x03B6E20C,
   (mz_uint32)0x74B1D29A,
   0xEAD54739,
   0x9DD277AF,
   (mz_uint32)0x04DB2615,
   (mz_uint32)0x73DC1683,
   0xE3630B12,
   0x94643B84,
   (mz_uint32)0x0D6D6A3E,
   (mz_uint32)0x7A6A5AA8,
   0xE40ECF0B,
   0x9309FF9D,
   (mz_uint32)0x0A00AE27,
   (mz_uint32)0x7D079EB1,
   0xF00F9344,
   0x8708A3D2,
   (mz_uint32)0x1E01F268,
   (mz_uint32)0x6906C2FE,
   0xF762575D,
   0x806567CB,
   (mz_uint32)0x196C3671,
   (mz_uint32)0x6E6B06E7,
   0xFED41B76,
   0x89D32BE0,
   (mz_uint32)0x10DA7A5A,
   (mz_uint32)0x67DD4ACC,
   0xF9B9DF6F,
   0x8EBEEFF9,
   (mz_uint32)0x17B7BE43,
   (mz_uint32)0x60B08ED5,
   0xD6D6A3E8,
   0xA1D1937E,
   (mz_uint32)0x38D8C2C4,
   (mz_uint32)0x4FDFF252,
   0xD1BB67F1,
   0xA6BC5767,
   (mz_uint32)0x3FB506DD,
   (mz_uint32)0x48B2364B,
   0xD80D2BDA,
   0xAF0A1B4C,
   (mz_uint32)0x36034AF6,
   (mz_uint32)0x41047A60,
   0xDF60EFC3,
   0xA867DF55,
   (mz_uint32)0x316E8EEF,
   (mz_uint32)0x4669BE79,
   0xCB61B38C,
   0xBC66831A,
   (mz_uint32)0x256FD2A0,
   (mz_uint32)0x5268E236,
   0xCC0C7795,
   0xBB0B4703,
   (mz_uint32)0x220216B9,
   (mz_uint32)0x5505262F,
   0xC5BA3BBE,
   0xB2BD0B28,
   (mz_uint32)0x2BB45A92,
   (mz_uint32)0x5CB36A04,
   0xC2D7FFA7,
   0xB5D0CF31,
   (mz_uint32)0x2CD99E8B,
   (mz_uint32)0x5BDEAE1D,
   0x9B64C2B0,
   0xEC63F226,
   (mz_uint32)0x756AA39C,
   (mz_uint32)0x026D930A,
   0x9C0906A9,
   0xEB0E363F,
   (mz_uint32)0x72076785,
   (mz_uint32)0x05005713,
   0x95BF4A82,
   0xE2B87A14,
   (mz_uint32)0x7BB12BAE,
   (mz_uint32)0x0CB61B38,
   0x92D28E9B,
   0xE5D5BE0D,
   (mz_uint32)0x7CDCEFB7,
   (mz_uint32)0x0BDBDF21,
   0x86D3D2D4,
   0xF1D4E242,
   (mz_uint32)0x68DDB3F8,
   (mz_uint32)0x1FDA836E,
   0x81BE16CD,
   0xF6B9265B,
   (mz_uint32)0x6FB077E1,
   (mz_uint32)0x18B74777,
   0x88085AE6,
   0xFF0F6A70,
   (mz_uint32)0x66063BCA,
   (mz_uint32)0x11010B5C,
   0x8F659EFF,
   0xF862AE69,
   (mz_uint32)0x616BFFD3,
   (mz_uint32)0x166CCF45,
   0xA00AE278,
   0xD70DD2EE,
   (mz_uint32)0x4E048354,
   (mz_uint32)0x3903B3C2,
   0xA7672661,
   0xD06016F7,
   (mz_uint32)0x4969474D,
   (mz_uint32)0x3E6E77DB,
   0xAED16A4A,
   0xD9D65ADC,
   (mz_uint32)0x40DF0B66,
   (mz_uint32)0x37D83BF0,
   0xA9BCAE53,
   0xDEBB9EC5,
   (mz_uint32)0x47B2CF7F,
   (mz_uint32)0x30B5FFE9,
   0xBDBDF21C,
   0xCABAC28A,
   (mz_uint32)0x53B39330,
   (mz_uint32)0x24B4A3A6,
   0xBAD03605,
   0xCDD70693,
   (mz_uint32)0x54DE5729,
   (mz_uint32)0x23D967BF,
   0xB3667A2E,
   0xC4614AB8,
   (mz_uint32)0x5D681B02,
   (mz_uint32)0x2A6F2B94,
   0xB40BBE37,
   0xC30C8EA1,
   (mz_uint32)0x5A05DF1B,
   (mz_uint32)0x2D02EF8D};
mz_ulong __attribute__((__visibility__("default"))) mz_crc32(mz_ulong crc,
                                                             unsigned char const *ptr,
                                                             size_t buf_len)
{
  mz_ulong __attribute__((__visibility__("default"))) __retres;
  mz_uint32 mz_crc32_0 = (mz_uint32)crc ^ 0xFFFFFFFF;
  mz_uint8 const *pByte_buf = ptr;
  while (buf_len >= (size_t)4) {
    mz_crc32_0 = (mz_crc32_0 >> 8) ^ mz_crc32_s_crc_table[(mz_crc32_0 ^ (unsigned int)*(
                                                           pByte_buf + 0)) & (unsigned int)0xFF];
    mz_crc32_0 = (mz_crc32_0 >> 8) ^ mz_crc32_s_crc_table[(mz_crc32_0 ^ (unsigned int)*(
                                                           pByte_buf + 1)) & (unsigned int)0xFF];
    mz_crc32_0 = (mz_crc32_0 >> 8) ^ mz_crc32_s_crc_table[(mz_crc32_0 ^ (unsigned int)*(
                                                           pByte_buf + 2)) & (unsigned int)0xFF];
    mz_crc32_0 = (mz_crc32_0 >> 8) ^ mz_crc32_s_crc_table[(mz_crc32_0 ^ (unsigned int)*(
                                                           pByte_buf + 3)) & (unsigned int)0xFF];
    pByte_buf += 4;
    buf_len -= (size_t)4;
  }
  while (buf_len) {
    mz_crc32_0 = (mz_crc32_0 >> 8) ^ mz_crc32_s_crc_table[(mz_crc32_0 ^ (unsigned int)*(
                                                           pByte_buf + 0)) & (unsigned int)0xFF];
    pByte_buf ++;
    buf_len --;
  }
  __retres = (mz_ulong __attribute__((__visibility__("default"))))(~ mz_crc32_0);
  return __retres;
}

void __attribute__((__visibility__("default"))) mz_free(void *p)
{
  free(p);
  return;
}

void __attribute__((__visibility__("default"))) *miniz_def_alloc_func
(void *opaque, size_t items, size_t size)
{
  void __attribute__((__visibility__("default"))) *tmp;
  tmp = (void __attribute__((__visibility__("default"))) *)malloc(items * size);
  return tmp;
}

void __attribute__((__visibility__("default"))) miniz_def_free_func(void *opaque,
                                                                    void *address)
{
  free(address);
  return;
}

void __attribute__((__visibility__("default"))) *miniz_def_realloc_func
(void *opaque, void *address, size_t items, size_t size)
{
  void __attribute__((__visibility__("default"))) *tmp;
  tmp = (void __attribute__((__visibility__("default"))) *)realloc(address,
                                                                   items * size);
  return tmp;
}

char const __attribute__((__visibility__("default"))) *mz_version(void)
{
  char const __attribute__((__visibility__("default"))) *__retres;
  __retres = (char const __attribute__((__visibility__("default"))) *)"10.1.0";
  return __retres;
}

int __attribute__((__visibility__("default"))) mz_deflateInit(mz_streamp pStream,
                                                              int level)
{
  int __attribute__((__visibility__("default"))) tmp;
  tmp = mz_deflateInit2(pStream,level,8,15,9,MZ_DEFAULT_STRATEGY);
  return tmp;
}

int __attribute__((__visibility__("default"))) mz_deflateInit2(mz_streamp pStream,
                                                               int level,
                                                               int method,
                                                               int window_bits,
                                                               int mem_level,
                                                               int strategy)
{
  int __attribute__((__visibility__("default"))) __retres;
  tdefl_compressor *pComp;
  mz_uint __attribute__((__visibility__("default"))) tmp;
  tdefl_status __attribute__((__visibility__("default"))) tmp_1;
  tmp = tdefl_create_comp_flags_from_zip_params(level,window_bits,strategy);
  mz_uint comp_flags =
    (mz_uint)((unsigned int __attribute__((__visibility__("default"))))TDEFL_COMPUTE_ADLER32 | tmp);
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  if (method != 8) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
    goto return_label;
  }
  else 
    if (mem_level < 1) {
      __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
      goto return_label;
    }
    else 
      if (mem_level > 9) {
        __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
        goto return_label;
      }
      else 
        if (window_bits != 15) 
          if (- window_bits != 15) {
            __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
            goto return_label;
          }
  pStream->data_type = 0;
  pStream->adler = (mz_ulong)1;
  pStream->msg = (char *)0;
  pStream->reserved = (mz_ulong)0;
  pStream->total_in = (mz_ulong)0;
  pStream->total_out = (mz_ulong)0;
  if (! pStream->zalloc) pStream->zalloc = (void *(*)(void *opaque,
                                                      size_t items,
                                                      size_t size))(& miniz_def_alloc_func);
  if (! pStream->zfree) pStream->zfree = (void (*)(void *opaque,
                                                   void *address))(& miniz_def_free_func);
  pComp = (tdefl_compressor *)(*(pStream->zalloc))(pStream->opaque,(size_t)1,
                                                   sizeof(tdefl_compressor));
  if (! pComp) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_MEM_ERROR;
    goto return_label;
  }
  pStream->state = (struct mz_internal_state *)pComp;
  tmp_1 = tdefl_init(pComp,
                     (mz_bool (*)(void const *pBuf, int len, void *pUser))0,
                     (void *)0,(int)comp_flags);
  if (tmp_1 != (int __attribute__((__visibility__("default"))))TDEFL_STATUS_OKAY) {
    mz_deflateEnd(pStream);
    __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
    goto return_label;
  }
  __retres = (int __attribute__((__visibility__("default"))))MZ_OK;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_deflateReset(mz_streamp pStream)
{
  int __attribute__((__visibility__("default"))) __retres;
  mz_ulong tmp;
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  else 
    if (! pStream->state) {
      __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
      goto return_label;
    }
    else 
      if (! pStream->zalloc) {
        __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
        goto return_label;
      }
      else 
        if (! pStream->zfree) {
          __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
          goto return_label;
        }
  tmp = (mz_ulong)0;
  pStream->total_out = tmp;
  pStream->total_in = tmp;
  tdefl_init((tdefl_compressor *)pStream->state,
             (mz_bool (*)(void const *pBuf, int len, void *pUser))0,
             (void *)0,(int)((tdefl_compressor *)pStream->state)->m_flags);
  __retres = (int __attribute__((__visibility__("default"))))MZ_OK;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_deflate(mz_streamp pStream,
                                                          int flush)
{
  int __attribute__((__visibility__("default"))) __retres;
  size_t in_bytes;
  size_t out_bytes;
  mz_ulong orig_total_in;
  mz_ulong orig_total_out;
  int mz_status = MZ_OK;
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  else 
    if (! pStream->state) {
      __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
      goto return_label;
    }
    else 
      if (flush < 0) {
        __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
        goto return_label;
      }
      else 
        if (flush > MZ_FINISH) {
          __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
          goto return_label;
        }
        else 
          if (! pStream->next_out) {
            __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
            goto return_label;
          }
  if (! pStream->avail_out) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_BUF_ERROR;
    goto return_label;
  }
  if (flush == MZ_PARTIAL_FLUSH) flush = MZ_SYNC_FLUSH;
  if (((tdefl_compressor *)pStream->state)->m_prev_return_status == TDEFL_STATUS_DONE) {
    int tmp;
    if (flush == MZ_FINISH) tmp = MZ_STREAM_END; else tmp = MZ_BUF_ERROR;
    __retres = (int __attribute__((__visibility__("default"))))tmp;
    goto return_label;
  }
  orig_total_in = pStream->total_in;
  orig_total_out = pStream->total_out;
  while (1) {
    tdefl_status defl_status;
    tdefl_status __attribute__((__visibility__("default"))) tmp_0;
    mz_uint32 __attribute__((__visibility__("default"))) tmp_1;
    in_bytes = (size_t)pStream->avail_in;
    out_bytes = (size_t)pStream->avail_out;
    tmp_0 = tdefl_compress((tdefl_compressor *)pStream->state,
                           (void const *)pStream->next_in,& in_bytes,
                           (void *)pStream->next_out,& out_bytes,
                           (tdefl_flush)flush);
    defl_status = (tdefl_status)tmp_0;
    pStream->next_in += (mz_uint)in_bytes;
    pStream->avail_in -= (mz_uint)in_bytes;
    pStream->total_in += (mz_ulong)((mz_uint)in_bytes);
    tmp_1 = tdefl_get_adler32((tdefl_compressor *)pStream->state);
    pStream->adler = (mz_ulong)tmp_1;
    pStream->next_out += (mz_uint)out_bytes;
    pStream->avail_out -= (mz_uint)out_bytes;
    pStream->total_out += (mz_ulong)((mz_uint)out_bytes);
    if (defl_status < 0) {
      mz_status = MZ_STREAM_ERROR;
      break;
    }
    else 
      if (defl_status == TDEFL_STATUS_DONE) {
        mz_status = MZ_STREAM_END;
        break;
      }
      else 
        if (! pStream->avail_out) break;
        else 
          if (! pStream->avail_in) 
            if (flush != MZ_FINISH) {
              if (flush) break;
              else 
                if (pStream->total_in != orig_total_in) break;
                else 
                  if (pStream->total_out != orig_total_out) break;
              __retres = (int __attribute__((__visibility__("default"))))MZ_BUF_ERROR;
              goto return_label;
            }
  }
  __retres = (int __attribute__((__visibility__("default"))))mz_status;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_deflateEnd(mz_streamp pStream)
{
  int __attribute__((__visibility__("default"))) __retres;
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  if (pStream->state) {
    (*(pStream->zfree))(pStream->opaque,(void *)pStream->state);
    pStream->state = (struct mz_internal_state *)0;
  }
  __retres = (int __attribute__((__visibility__("default"))))MZ_OK;
  return_label: return __retres;
}

mz_ulong __attribute__((__visibility__("default"))) mz_deflateBound(mz_streamp pStream,
                                                                    mz_ulong source_len)
{
  mz_ulong __attribute__((__visibility__("default"))) __retres;
  mz_ulong tmp;
  if ((mz_ulong)128 + (source_len * (mz_ulong)110) / (mz_ulong)100 > 
      ((mz_ulong)128 + source_len) + (source_len / (mz_ulong)(31 * 1024) + (mz_ulong)1) * (mz_ulong)5) 
    tmp = (mz_ulong)128 + (source_len * (mz_ulong)110) / (mz_ulong)100;
  else tmp = ((mz_ulong)128 + source_len) + (source_len / (mz_ulong)(
                                             31 * 1024) + (mz_ulong)1) * (mz_ulong)5;
  __retres = (mz_ulong __attribute__((__visibility__("default"))))tmp;
  return __retres;
}

int __attribute__((__visibility__("default"))) mz_compress2(unsigned char *pDest,
                                                            mz_ulong *pDest_len,
                                                            unsigned char const *pSource,
                                                            mz_ulong source_len,
                                                            int level)
{
  int __attribute__((__visibility__("default"))) __retres;
  int status;
  mz_stream stream;
  int __attribute__((__visibility__("default"))) tmp_0;
  memset((void *)(& stream),0,sizeof(stream));
  if ((source_len | *pDest_len) > (unsigned long)0xFFFFFFFFU) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
    goto return_label;
  }
  stream.next_in = pSource;
  stream.avail_in = (mz_uint32)source_len;
  stream.next_out = pDest;
  stream.avail_out = (mz_uint32)*pDest_len;
  status = (int)mz_deflateInit(& stream,level);
  if (status != MZ_OK) {
    __retres = (int __attribute__((__visibility__("default"))))status;
    goto return_label;
  }
  status = (int)mz_deflate(& stream,MZ_FINISH);
  if (status != MZ_STREAM_END) {
    int tmp;
    mz_deflateEnd(& stream);
    if (status == MZ_OK) tmp = MZ_BUF_ERROR; else tmp = status;
    __retres = (int __attribute__((__visibility__("default"))))tmp;
    goto return_label;
  }
  *pDest_len = stream.total_out;
  tmp_0 = mz_deflateEnd(& stream);
  __retres = tmp_0;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_compress(unsigned char *pDest,
                                                           mz_ulong *pDest_len,
                                                           unsigned char const *pSource,
                                                           mz_ulong source_len)
{
  int __attribute__((__visibility__("default"))) tmp;
  tmp = mz_compress2(pDest,pDest_len,pSource,source_len,
                     MZ_DEFAULT_COMPRESSION);
  return tmp;
}

mz_ulong __attribute__((__visibility__("default"))) mz_compressBound(
                                                                    mz_ulong source_len)
{
  mz_ulong __attribute__((__visibility__("default"))) tmp;
  tmp = mz_deflateBound((mz_streamp)0,source_len);
  return tmp;
}

int __attribute__((__visibility__("default"))) mz_inflateInit2(mz_streamp pStream,
                                                               int window_bits)
{
  int __attribute__((__visibility__("default"))) __retres;
  inflate_state *pDecomp;
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  if (window_bits != 15) 
    if (- window_bits != 15) {
      __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
      goto return_label;
    }
  pStream->data_type = 0;
  pStream->adler = (mz_ulong)0;
  pStream->msg = (char *)0;
  pStream->total_in = (mz_ulong)0;
  pStream->total_out = (mz_ulong)0;
  pStream->reserved = (mz_ulong)0;
  if (! pStream->zalloc) pStream->zalloc = (void *(*)(void *opaque,
                                                      size_t items,
                                                      size_t size))(& miniz_def_alloc_func);
  if (! pStream->zfree) pStream->zfree = (void (*)(void *opaque,
                                                   void *address))(& miniz_def_free_func);
  pDecomp = (inflate_state *)(*(pStream->zalloc))(pStream->opaque,(size_t)1,
                                                  sizeof(inflate_state));
  if (! pDecomp) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_MEM_ERROR;
    goto return_label;
  }
  pStream->state = (struct mz_internal_state *)pDecomp;
  pDecomp->m_decomp.m_state = (mz_uint32)0;
  pDecomp->m_decomp.m_num_bits = (mz_uint32)0;
  pDecomp->m_decomp.m_bit_buf = (tinfl_bit_buf_t)0;
  pDecomp->m_decomp.m_dist = (mz_uint32)0;
  pDecomp->m_decomp.m_counter = (mz_uint32)0;
  pDecomp->m_decomp.m_num_extra = (mz_uint32)0;
  pDecomp->m_decomp.m_dist_from_out_buf_start = (size_t)0;
  pDecomp->m_dict_ofs = (mz_uint)0;
  pDecomp->m_dict_avail = (mz_uint)0;
  pDecomp->m_last_status = TINFL_STATUS_NEEDS_MORE_INPUT;
  pDecomp->m_first_call = (mz_uint)1;
  pDecomp->m_has_flushed = (mz_uint)0;
  pDecomp->m_window_bits = window_bits;
  __retres = (int __attribute__((__visibility__("default"))))MZ_OK;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_inflateInit(mz_streamp pStream)
{
  int __attribute__((__visibility__("default"))) tmp;
  tmp = mz_inflateInit2(pStream,15);
  return tmp;
}

int __attribute__((__visibility__("default"))) mz_inflateReset(mz_streamp pStream)
{
  int __attribute__((__visibility__("default"))) __retres;
  inflate_state *pDecomp;
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  pStream->data_type = 0;
  pStream->adler = (mz_ulong)0;
  pStream->msg = (char *)0;
  pStream->total_in = (mz_ulong)0;
  pStream->total_out = (mz_ulong)0;
  pStream->reserved = (mz_ulong)0;
  pDecomp = (inflate_state *)pStream->state;
  pDecomp->m_decomp.m_state = (mz_uint32)0;
  pDecomp->m_decomp.m_num_bits = (mz_uint32)0;
  pDecomp->m_decomp.m_bit_buf = (tinfl_bit_buf_t)0;
  pDecomp->m_decomp.m_dist = (mz_uint32)0;
  pDecomp->m_decomp.m_counter = (mz_uint32)0;
  pDecomp->m_decomp.m_num_extra = (mz_uint32)0;
  pDecomp->m_decomp.m_dist_from_out_buf_start = (size_t)0;
  pDecomp->m_dict_ofs = (mz_uint)0;
  pDecomp->m_dict_avail = (mz_uint)0;
  pDecomp->m_last_status = TINFL_STATUS_NEEDS_MORE_INPUT;
  pDecomp->m_first_call = (mz_uint)1;
  pDecomp->m_has_flushed = (mz_uint)0;
  __retres = (int __attribute__((__visibility__("default"))))MZ_OK;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_inflate(mz_streamp pStream,
                                                          int flush)
{
  int __attribute__((__visibility__("default"))) __retres;
  inflate_state *pState;
  mz_uint n;
  mz_uint first_call;
  size_t in_bytes;
  size_t out_bytes;
  size_t orig_avail_in;
  tinfl_status status;
  int tmp_3;
  mz_uint decomp_flags = (mz_uint)TINFL_FLAG_COMPUTE_ADLER32;
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  else 
    if (! pStream->state) {
      __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
      goto return_label;
    }
  if (flush == MZ_PARTIAL_FLUSH) flush = MZ_SYNC_FLUSH;
  if (flush) 
    if (flush != MZ_SYNC_FLUSH) 
      if (flush != MZ_FINISH) {
        __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
        goto return_label;
      }
  pState = (inflate_state *)pStream->state;
  if (pState->m_window_bits > 0) decomp_flags |= (unsigned int)TINFL_FLAG_PARSE_ZLIB_HEADER;
  orig_avail_in = (size_t)pStream->avail_in;
  first_call = pState->m_first_call;
  pState->m_first_call = (mz_uint)0;
  if (pState->m_last_status < 0) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_DATA_ERROR;
    goto return_label;
  }
  if (pState->m_has_flushed) 
    if (flush != MZ_FINISH) {
      __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
      goto return_label;
    }
  pState->m_has_flushed |= (unsigned int)(flush == MZ_FINISH);
  if (flush == MZ_FINISH) 
    if (first_call) {
      tinfl_status __attribute__((__visibility__("default"))) tmp;
      decomp_flags |= (unsigned int)TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF;
      in_bytes = (size_t)pStream->avail_in;
      out_bytes = (size_t)pStream->avail_out;
      tmp = tinfl_decompress(& pState->m_decomp,pStream->next_in,& in_bytes,
                             pStream->next_out,pStream->next_out,& out_bytes,
                             decomp_flags);
      status = (tinfl_status)tmp;
      pState->m_last_status = status;
      pStream->next_in += (mz_uint)in_bytes;
      pStream->avail_in -= (mz_uint)in_bytes;
      pStream->total_in += (mz_ulong)((mz_uint)in_bytes);
      pStream->adler = (mz_ulong)pState->m_decomp.m_check_adler32;
      pStream->next_out += (mz_uint)out_bytes;
      pStream->avail_out -= (mz_uint)out_bytes;
      pStream->total_out += (mz_ulong)((mz_uint)out_bytes);
      if (status < 0) {
        __retres = (int __attribute__((__visibility__("default"))))MZ_DATA_ERROR;
        goto return_label;
      }
      else 
        if (status != TINFL_STATUS_DONE) {
          pState->m_last_status = TINFL_STATUS_FAILED;
          __retres = (int __attribute__((__visibility__("default"))))MZ_BUF_ERROR;
          goto return_label;
        }
      __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_END;
      goto return_label;
    }
  if (flush != MZ_FINISH) decomp_flags |= (unsigned int)TINFL_FLAG_HAS_MORE_INPUT;
  if (pState->m_dict_avail) {
    int tmp_0;
    if (pState->m_dict_avail < pStream->avail_out) n = pState->m_dict_avail;
    else n = pStream->avail_out;
    memcpy((void *)pStream->next_out,
           (void const *)(& pState->m_dict[pState->m_dict_ofs]),(size_t)n);
    pStream->next_out += n;
    pStream->avail_out -= n;
    pStream->total_out += (mz_ulong)n;
    pState->m_dict_avail -= n;
    pState->m_dict_ofs = (pState->m_dict_ofs + n) & (unsigned int)(32768 - 1);
    if (pState->m_last_status == TINFL_STATUS_DONE) 
      if (! pState->m_dict_avail) tmp_0 = MZ_STREAM_END; else tmp_0 = MZ_OK;
    else tmp_0 = MZ_OK;
    __retres = (int __attribute__((__visibility__("default"))))tmp_0;
    goto return_label;
  }
  while (1) {
    tinfl_status __attribute__((__visibility__("default"))) tmp_1;
    in_bytes = (size_t)pStream->avail_in;
    out_bytes = (size_t)((mz_uint)32768 - pState->m_dict_ofs);
    tmp_1 = tinfl_decompress(& pState->m_decomp,pStream->next_in,& in_bytes,
                             pState->m_dict,
                             & pState->m_dict[pState->m_dict_ofs],
                             & out_bytes,decomp_flags);
    status = (tinfl_status)tmp_1;
    pState->m_last_status = status;
    pStream->next_in += (mz_uint)in_bytes;
    pStream->avail_in -= (mz_uint)in_bytes;
    pStream->total_in += (mz_ulong)((mz_uint)in_bytes);
    pStream->adler = (mz_ulong)pState->m_decomp.m_check_adler32;
    pState->m_dict_avail = (mz_uint)out_bytes;
    if (pState->m_dict_avail < pStream->avail_out) n = pState->m_dict_avail;
    else n = pStream->avail_out;
    memcpy((void *)pStream->next_out,
           (void const *)(& pState->m_dict[pState->m_dict_ofs]),(size_t)n);
    pStream->next_out += n;
    pStream->avail_out -= n;
    pStream->total_out += (mz_ulong)n;
    pState->m_dict_avail -= n;
    pState->m_dict_ofs = (pState->m_dict_ofs + n) & (unsigned int)(32768 - 1);
    if (status < 0) {
      __retres = (int __attribute__((__visibility__("default"))))MZ_DATA_ERROR;
      goto return_label;
    }
    else 
      if (status == TINFL_STATUS_NEEDS_MORE_INPUT) {
        if (! orig_avail_in) {
          __retres = (int __attribute__((__visibility__("default"))))MZ_BUF_ERROR;
          goto return_label;
        }
        else goto _LAND;
      }
      else {
        _LAND: ;
        if (flush == MZ_FINISH) {
          if (status == TINFL_STATUS_DONE) {
            int tmp_2;
            if (pState->m_dict_avail) tmp_2 = MZ_BUF_ERROR;
            else tmp_2 = MZ_STREAM_END;
            __retres = (int __attribute__((__visibility__("default"))))tmp_2;
            goto return_label;
          }
          else 
            if (! pStream->avail_out) {
              __retres = (int __attribute__((__visibility__("default"))))MZ_BUF_ERROR;
              goto return_label;
            }
        }
        else 
          if (status == TINFL_STATUS_DONE) break;
          else 
            if (! pStream->avail_in) break;
            else 
              if (! pStream->avail_out) break;
              else 
                if (pState->m_dict_avail) break;
      }
  }
  if (status == TINFL_STATUS_DONE) 
    if (! pState->m_dict_avail) tmp_3 = MZ_STREAM_END; else tmp_3 = MZ_OK;
  else tmp_3 = MZ_OK;
  __retres = (int __attribute__((__visibility__("default"))))tmp_3;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_inflateEnd(mz_streamp pStream)
{
  int __attribute__((__visibility__("default"))) __retres;
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  if (pStream->state) {
    (*(pStream->zfree))(pStream->opaque,(void *)pStream->state);
    pStream->state = (struct mz_internal_state *)0;
  }
  __retres = (int __attribute__((__visibility__("default"))))MZ_OK;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_uncompress2(unsigned char *pDest,
                                                              mz_ulong *pDest_len,
                                                              unsigned char const *pSource,
                                                              mz_ulong *pSource_len)
{
  int __attribute__((__visibility__("default"))) __retres;
  mz_stream stream;
  int status;
  int __attribute__((__visibility__("default"))) tmp_0;
  memset((void *)(& stream),0,sizeof(stream));
  if ((*pSource_len | *pDest_len) > (unsigned long)0xFFFFFFFFU) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
    goto return_label;
  }
  stream.next_in = pSource;
  stream.avail_in = (mz_uint32)*pSource_len;
  stream.next_out = pDest;
  stream.avail_out = (mz_uint32)*pDest_len;
  status = (int)mz_inflateInit(& stream);
  if (status != MZ_OK) {
    __retres = (int __attribute__((__visibility__("default"))))status;
    goto return_label;
  }
  status = (int)mz_inflate(& stream,MZ_FINISH);
  *pSource_len -= (mz_ulong)stream.avail_in;
  if (status != MZ_STREAM_END) {
    int tmp;
    mz_inflateEnd(& stream);
    if (status == MZ_BUF_ERROR) 
      if (! stream.avail_in) tmp = MZ_DATA_ERROR; else tmp = status;
    else tmp = status;
    __retres = (int __attribute__((__visibility__("default"))))tmp;
    goto return_label;
  }
  *pDest_len = stream.total_out;
  tmp_0 = mz_inflateEnd(& stream);
  __retres = tmp_0;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_uncompress(unsigned char *pDest,
                                                             mz_ulong *pDest_len,
                                                             unsigned char const *pSource,
                                                             mz_ulong source_len)
{
  int __attribute__((__visibility__("default"))) tmp;
  tmp = mz_uncompress2(pDest,pDest_len,pSource,& source_len);
  return tmp;
}

static struct __anonstruct_s_error_descs_25 mz_error_s_error_descs[10] =
  {{.m_err = MZ_OK, .m_pDesc = ""},
   {.m_err = MZ_STREAM_END, .m_pDesc = "stream end"},
   {.m_err = MZ_NEED_DICT, .m_pDesc = "need dictionary"},
   {.m_err = MZ_ERRNO, .m_pDesc = "file error"},
   {.m_err = MZ_STREAM_ERROR, .m_pDesc = "stream error"},
   {.m_err = MZ_DATA_ERROR, .m_pDesc = "data error"},
   {.m_err = MZ_MEM_ERROR, .m_pDesc = "out of memory"},
   {.m_err = MZ_BUF_ERROR, .m_pDesc = "buf error"},
   {.m_err = MZ_VERSION_ERROR, .m_pDesc = "version error"},
   {.m_err = MZ_PARAM_ERROR, .m_pDesc = "parameter error"}};
char const __attribute__((__visibility__("default"))) *mz_error(int err)
{
  char const __attribute__((__visibility__("default"))) *__retres;
  mz_uint i;
  i = (mz_uint)0;
  while ((unsigned long)i < sizeof(mz_error_s_error_descs) / sizeof(mz_error_s_error_descs[0])) {
    if (mz_error_s_error_descs[i].m_err == err) {
      __retres = (char const __attribute__((__visibility__("default"))) *)mz_error_s_error_descs[i].m_pDesc;
      goto return_label;
    }
    i ++;
  }
  __retres = (char const __attribute__((__visibility__("default"))) *)0;
  return_label: return __retres;
}

static mz_uint16 const s_tdefl_len_sym[256] =
  {(mz_uint16)257,
   (mz_uint16)258,
   (mz_uint16)259,
   (mz_uint16)260,
   (mz_uint16)261,
   (mz_uint16)262,
   (mz_uint16)263,
   (mz_uint16)264,
   (mz_uint16)265,
   (mz_uint16)265,
   (mz_uint16)266,
   (mz_uint16)266,
   (mz_uint16)267,
   (mz_uint16)267,
   (mz_uint16)268,
   (mz_uint16)268,
   (mz_uint16)269,
   (mz_uint16)269,
   (mz_uint16)269,
   (mz_uint16)269,
   (mz_uint16)270,
   (mz_uint16)270,
   (mz_uint16)270,
   (mz_uint16)270,
   (mz_uint16)271,
   (mz_uint16)271,
   (mz_uint16)271,
   (mz_uint16)271,
   (mz_uint16)272,
   (mz_uint16)272,
   (mz_uint16)272,
   (mz_uint16)272,
   (mz_uint16)273,
   (mz_uint16)273,
   (mz_uint16)273,
   (mz_uint16)273,
   (mz_uint16)273,
   (mz_uint16)273,
   (mz_uint16)273,
   (mz_uint16)273,
   (mz_uint16)274,
   (mz_uint16)274,
   (mz_uint16)274,
   (mz_uint16)274,
   (mz_uint16)274,
   (mz_uint16)274,
   (mz_uint16)274,
   (mz_uint16)274,
   (mz_uint16)275,
   (mz_uint16)275,
   (mz_uint16)275,
   (mz_uint16)275,
   (mz_uint16)275,
   (mz_uint16)275,
   (mz_uint16)275,
   (mz_uint16)275,
   (mz_uint16)276,
   (mz_uint16)276,
   (mz_uint16)276,
   (mz_uint16)276,
   (mz_uint16)276,
   (mz_uint16)276,
   (mz_uint16)276,
   (mz_uint16)276,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)285};
static mz_uint8 const s_tdefl_len_extra[256] =
  {(mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)0};
static mz_uint8 const s_tdefl_small_dist_sym[512] =
  {(mz_uint8)0,
   (mz_uint8)1,
   (mz_uint8)2,
   (mz_uint8)3,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)8,
   (mz_uint8)8,
   (mz_uint8)8,
   (mz_uint8)8,
   (mz_uint8)8,
   (mz_uint8)8,
   (mz_uint8)8,
   (mz_uint8)8,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17};
static mz_uint8 const s_tdefl_small_dist_extra[512] =
  {(mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7};
static mz_uint8 const s_tdefl_large_dist_sym[128] =
  {(mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)18,
   (mz_uint8)19,
   (mz_uint8)20,
   (mz_uint8)20,
   (mz_uint8)21,
   (mz_uint8)21,
   (mz_uint8)22,
   (mz_uint8)22,
   (mz_uint8)22,
   (mz_uint8)22,
   (mz_uint8)23,
   (mz_uint8)23,
   (mz_uint8)23,
   (mz_uint8)23,
   (mz_uint8)24,
   (mz_uint8)24,
   (mz_uint8)24,
   (mz_uint8)24,
   (mz_uint8)24,
   (mz_uint8)24,
   (mz_uint8)24,
   (mz_uint8)24,
   (mz_uint8)25,
   (mz_uint8)25,
   (mz_uint8)25,
   (mz_uint8)25,
   (mz_uint8)25,
   (mz_uint8)25,
   (mz_uint8)25,
   (mz_uint8)25,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29};
static mz_uint8 const s_tdefl_large_dist_extra[128] =
  {(mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)8,
   (mz_uint8)8,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13};
static tdefl_sym_freq *tdefl_radix_sort_syms(mz_uint num_syms,
                                             tdefl_sym_freq *pSyms0,
                                             tdefl_sym_freq *pSyms1)
{
  mz_uint32 pass_shift;
  mz_uint32 pass;
  mz_uint32 i;
  mz_uint32 hist[256 * 2];
  mz_uint32 total_passes = (mz_uint32)2;
  tdefl_sym_freq *pCur_syms = pSyms0;
  tdefl_sym_freq *pNew_syms = pSyms1;
  memset((void *)(& hist),0,sizeof(hist));
  i = (mz_uint32)0;
  while (i < num_syms) {
    {
      mz_uint freq = (mz_uint)(pSyms0 + i)->m_key;
      (hist[freq & (unsigned int)0xFF]) ++;
      (hist[(unsigned int)256 + ((freq >> 8) & (unsigned int)0xFF)]) ++;
    }
    i ++;
  }
  while (1) {
    if (total_passes > (mz_uint32)1) {
      if (! (num_syms == hist[(total_passes - (mz_uint32)1) * (mz_uint32)256])) 
        break;
    }
    else break;
    total_passes --;
  }
  pass_shift = (mz_uint32)0;
  pass = (mz_uint32)0;
  while (pass < total_passes) {
    {
      mz_uint offsets[256];
      mz_uint32 const *pHist = (mz_uint32 const *)(& hist[pass << 8]);
      mz_uint cur_ofs = (mz_uint)0;
      i = (mz_uint32)0;
      while (i < (mz_uint32)256) {
        offsets[i] = cur_ofs;
        cur_ofs += *(pHist + i);
        i ++;
      }
      i = (mz_uint32)0;
      while (i < num_syms) {
        mz_uint tmp;
        tmp = offsets[((int)(pCur_syms + i)->m_key >> pass_shift) & 0xFF];
        (offsets[((int)(pCur_syms + i)->m_key >> pass_shift) & 0xFF]) ++;
        *(pNew_syms + tmp) = *(pCur_syms + i);
        i ++;
      }
      {
        tdefl_sym_freq *t = pCur_syms;
        pCur_syms = pNew_syms;
        pNew_syms = t;
      }
    }
    pass ++;
    pass_shift += (mz_uint32)8;
  }
  return pCur_syms;
}

static void tdefl_calculate_minimum_redundancy(tdefl_sym_freq *A, int n)
{
  int root;
  int leaf;
  int next;
  int avbl;
  int used;
  int dpth;
  if (n == 0) goto return_label;
  else 
    if (n == 1) {
      (A + 0)->m_key = (mz_uint16)1;
      goto return_label;
    }
  (A + 0)->m_key = (mz_uint16)((int)(A + 0)->m_key + (int)(A + 1)->m_key);
  root = 0;
  leaf = 2;
  next = 1;
  while (next < n - 1) {
    if (leaf >= n) goto _LOR;
    else 
      if ((int)(A + root)->m_key < (int)(A + leaf)->m_key) {
        _LOR:
        {
          int tmp;
          (A + next)->m_key = (A + root)->m_key;
          tmp = root;
          root ++;
          (A + tmp)->m_key = (mz_uint16)next;
        }
      }
      else {
        int tmp_0;
        tmp_0 = leaf;
        leaf ++;
        (A + next)->m_key = (A + tmp_0)->m_key;
      }
    if (leaf >= n) goto _LOR_0;
    else 
      if (root < next) {
        if ((int)(A + root)->m_key < (int)(A + leaf)->m_key) {
          _LOR_0:
          {
            int tmp_1;
            (A + next)->m_key = (mz_uint16)((int)(A + next)->m_key + (int)(
                                            A + root)->m_key);
            tmp_1 = root;
            root ++;
            (A + tmp_1)->m_key = (mz_uint16)next;
          }
        }
        else goto _LAND;
      }
      else {
        int tmp_2;
        _LAND:
        { /* sequence */
          tmp_2 = leaf;
          leaf ++;
          (A + next)->m_key = (mz_uint16)((int)(A + next)->m_key + (int)(
                                          A + tmp_2)->m_key);
        }
      }
    next ++;
  }
  (A + (n - 2))->m_key = (mz_uint16)0;
  next = n - 3;
  while (next >= 0) {
    (A + next)->m_key = (mz_uint16)((int)(A + (A + next)->m_key)->m_key + 1);
    next --;
  }
  avbl = 1;
  dpth = 0;
  used = dpth;
  root = n - 2;
  next = n - 1;
  while (avbl > 0) {
    while (1) {
      if (root >= 0) {
        if (! ((int)(A + root)->m_key == dpth)) break;
      }
      else break;
      used ++;
      root --;
    }
    while (avbl > used) {
      int tmp_3;
      tmp_3 = next;
      next --;
      (A + tmp_3)->m_key = (mz_uint16)dpth;
      avbl --;
    }
    avbl = 2 * used;
    dpth ++;
    used = 0;
  }
  return_label: return;
}

static void tdefl_huffman_enforce_max_code_size(int *pNum_codes,
                                                int code_list_len,
                                                int max_code_size)
{
  int i;
  mz_uint32 total = (mz_uint32)0;
  if (code_list_len <= 1) goto return_label;
  i = max_code_size + 1;
  while (i <= TDEFL_MAX_SUPPORTED_HUFF_CODESIZE) {
    *(pNum_codes + max_code_size) += *(pNum_codes + i);
    i ++;
  }
  i = max_code_size;
  while (i > 0) {
    total += (mz_uint32)*(pNum_codes + i) << (max_code_size - i);
    i --;
  }
  while ((unsigned long)total != 1UL << max_code_size) {
    (*(pNum_codes + max_code_size)) --;
    i = max_code_size - 1;
    while (i > 0) {
      if (*(pNum_codes + i)) {
        (*(pNum_codes + i)) --;
        *(pNum_codes + (i + 1)) += 2;
        break;
      }
      i --;
    }
    total --;
  }
  return_label: return;
}

static void tdefl_optimize_huffman_table(tdefl_compressor *d, int table_num,
                                         int table_len, int code_size_limit,
                                         int static_table)
{
  int i;
  int j;
  int l;
  int num_codes[1 + TDEFL_MAX_SUPPORTED_HUFF_CODESIZE];
  mz_uint next_code[TDEFL_MAX_SUPPORTED_HUFF_CODESIZE + 1];
  memset((void *)(& num_codes),0,sizeof(num_codes));
  if (static_table) {
    i = 0;
    while (i < table_len) {
      (num_codes[d->m_huff_code_sizes[table_num][i]]) ++;
      i ++;
    }
  }
  else {
    tdefl_sym_freq syms0[TDEFL_MAX_HUFF_SYMBOLS];
    tdefl_sym_freq syms1[TDEFL_MAX_HUFF_SYMBOLS];
    tdefl_sym_freq *pSyms;
    int num_used_syms = 0;
    mz_uint16 const *pSym_count =
      (mz_uint16 const *)(& d->m_huff_count[table_num][0]);
    i = 0;
    while (i < table_len) {
      if (*(pSym_count + i)) {
        int tmp;
        syms0[num_used_syms].m_key = *(pSym_count + i);
        tmp = num_used_syms;
        num_used_syms ++;
        syms0[tmp].m_sym_index = (mz_uint16)i;
      }
      i ++;
    }
    pSyms = tdefl_radix_sort_syms((mz_uint)num_used_syms,syms0,syms1);
    tdefl_calculate_minimum_redundancy(pSyms,num_used_syms);
    i = 0;
    while (i < num_used_syms) {
      (num_codes[(pSyms + i)->m_key]) ++;
      i ++;
    }
    tdefl_huffman_enforce_max_code_size(num_codes,num_used_syms,
                                        code_size_limit);
    memset((void *)(& d->m_huff_code_sizes[table_num]),0,
           sizeof(d->m_huff_code_sizes[table_num]));
    memset((void *)(& d->m_huff_codes[table_num]),0,
           sizeof(d->m_huff_codes[table_num]));
    i = 1;
    j = num_used_syms;
    while (i <= code_size_limit) {
      l = num_codes[i];
      while (l > 0) {
        j --;
        d->m_huff_code_sizes[table_num][(pSyms + j)->m_sym_index] = (mz_uint8)i;
        l --;
      }
      i ++;
    }
  }
  next_code[1] = (mz_uint)0;
  j = 0;
  i = 2;
  while (i <= code_size_limit) {
    j = (j + num_codes[i - 1]) << 1;
    next_code[i] = (mz_uint)j;
    i ++;
  }
  i = 0;
  while (i < table_len) {
    {
      mz_uint code;
      mz_uint code_size;
      mz_uint tmp_0;
      mz_uint rev_code = (mz_uint)0;
      code_size = (mz_uint)d->m_huff_code_sizes[table_num][i];
      if (code_size == (mz_uint)0) goto __Cont;
      tmp_0 = next_code[code_size];
      (next_code[code_size]) ++;
      code = tmp_0;
      l = (int)code_size;
      while (l > 0) {
        rev_code = (rev_code << 1) | (code & (unsigned int)1);
        l --;
        code >>= 1;
      }
      d->m_huff_codes[table_num][i] = (mz_uint16)rev_code;
    }
    __Cont: i ++;
  }
  return;
}

static mz_uint8 s_tdefl_packed_code_size_syms_swizzle[19] =
  {(mz_uint8)16,
   (mz_uint8)17,
   (mz_uint8)18,
   (mz_uint8)0,
   (mz_uint8)8,
   (mz_uint8)7,
   (mz_uint8)9,
   (mz_uint8)6,
   (mz_uint8)10,
   (mz_uint8)5,
   (mz_uint8)11,
   (mz_uint8)4,
   (mz_uint8)12,
   (mz_uint8)3,
   (mz_uint8)13,
   (mz_uint8)2,
   (mz_uint8)14,
   (mz_uint8)1,
   (mz_uint8)15};
static void tdefl_start_dynamic_block(tdefl_compressor *d)
{
  int num_lit_codes;
  int num_dist_codes;
  int num_bit_lengths;
  mz_uint i;
  mz_uint total_code_sizes_to_pack;
  mz_uint num_packed_code_sizes;
  mz_uint rle_z_count;
  mz_uint rle_repeat_count;
  mz_uint packed_code_sizes_index;
  mz_uint8 code_sizes_to_pack[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1];
  mz_uint8 packed_code_sizes[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1];
  mz_uint8 prev_code_size = (mz_uint8)0xFF;
  d->m_huff_count[0][256] = (mz_uint16)1;
  tdefl_optimize_huffman_table(d,0,TDEFL_MAX_HUFF_SYMBOLS_0,15,0);
  tdefl_optimize_huffman_table(d,1,TDEFL_MAX_HUFF_SYMBOLS_1,15,0);
  num_lit_codes = 286;
  while (num_lit_codes > 257) {
    if (d->m_huff_code_sizes[0][num_lit_codes - 1]) break;
    num_lit_codes --;
  }
  num_dist_codes = 30;
  while (num_dist_codes > 1) {
    if (d->m_huff_code_sizes[1][num_dist_codes - 1]) break;
    num_dist_codes --;
  }
  memcpy((void *)(code_sizes_to_pack),
         (void const *)(& d->m_huff_code_sizes[0][0]),(size_t)num_lit_codes);
  memcpy((void *)(& code_sizes_to_pack[num_lit_codes]),
         (void const *)(& d->m_huff_code_sizes[1][0]),(size_t)num_dist_codes);
  total_code_sizes_to_pack = (mz_uint)(num_lit_codes + num_dist_codes);
  num_packed_code_sizes = (mz_uint)0;
  rle_z_count = (mz_uint)0;
  rle_repeat_count = (mz_uint)0;
  memset((void *)(& d->m_huff_count[2][0]),0,
         sizeof(d->m_huff_count[2][0]) * (unsigned long)TDEFL_MAX_HUFF_SYMBOLS_2);
  i = (mz_uint)0;
  while (i < total_code_sizes_to_pack) {
    {
      mz_uint8 code_size = code_sizes_to_pack[i];
      if (! code_size) {
        if (rle_repeat_count) {
          if (rle_repeat_count < (mz_uint)3) {
            d->m_huff_count[2][prev_code_size] = (mz_uint16)((mz_uint)d->m_huff_count[2][prev_code_size] + rle_repeat_count);
            while (1) {
              mz_uint tmp_0;
              mz_uint tmp;
              tmp_0 = rle_repeat_count;
              rle_repeat_count --;
              ;
              if (! tmp_0) break;
              tmp = num_packed_code_sizes;
              num_packed_code_sizes ++;
              packed_code_sizes[tmp] = prev_code_size;
            }
          }
          else {
            mz_uint tmp_1;
            mz_uint tmp_2;
            d->m_huff_count[2][16] = (mz_uint16)((int)d->m_huff_count[2][16] + 1);
            tmp_1 = num_packed_code_sizes;
            num_packed_code_sizes ++;
            packed_code_sizes[tmp_1] = (mz_uint8)16;
            tmp_2 = num_packed_code_sizes;
            num_packed_code_sizes ++;
            packed_code_sizes[tmp_2] = (mz_uint8)(rle_repeat_count - (mz_uint)3);
          }
          rle_repeat_count = (mz_uint)0;
        }
        rle_z_count ++;
        if (rle_z_count == (mz_uint)138) 
          if (rle_z_count) {
            if (rle_z_count < (mz_uint)3) {
              d->m_huff_count[2][0] = (mz_uint16)((mz_uint)d->m_huff_count[2][0] + rle_z_count);
              while (1) {
                mz_uint tmp_4;
                mz_uint tmp_3;
                tmp_4 = rle_z_count;
                rle_z_count --;
                ;
                if (! tmp_4) break;
                tmp_3 = num_packed_code_sizes;
                num_packed_code_sizes ++;
                packed_code_sizes[tmp_3] = (mz_uint8)0;
              }
            }
            else 
              if (rle_z_count <= (mz_uint)10) {
                mz_uint tmp_5;
                mz_uint tmp_6;
                d->m_huff_count[2][17] = (mz_uint16)((int)d->m_huff_count[2][17] + 1);
                tmp_5 = num_packed_code_sizes;
                num_packed_code_sizes ++;
                packed_code_sizes[tmp_5] = (mz_uint8)17;
                tmp_6 = num_packed_code_sizes;
                num_packed_code_sizes ++;
                packed_code_sizes[tmp_6] = (mz_uint8)(rle_z_count - (mz_uint)3);
              }
              else {
                mz_uint tmp_7;
                mz_uint tmp_8;
                d->m_huff_count[2][18] = (mz_uint16)((int)d->m_huff_count[2][18] + 1);
                tmp_7 = num_packed_code_sizes;
                num_packed_code_sizes ++;
                packed_code_sizes[tmp_7] = (mz_uint8)18;
                tmp_8 = num_packed_code_sizes;
                num_packed_code_sizes ++;
                packed_code_sizes[tmp_8] = (mz_uint8)(rle_z_count - (mz_uint)11);
              }
            rle_z_count = (mz_uint)0;
          }
      }
      else {
        if (rle_z_count) {
          if (rle_z_count < (mz_uint)3) {
            d->m_huff_count[2][0] = (mz_uint16)((mz_uint)d->m_huff_count[2][0] + rle_z_count);
            while (1) {
              mz_uint tmp_10;
              mz_uint tmp_9;
              tmp_10 = rle_z_count;
              rle_z_count --;
              ;
              if (! tmp_10) break;
              tmp_9 = num_packed_code_sizes;
              num_packed_code_sizes ++;
              packed_code_sizes[tmp_9] = (mz_uint8)0;
            }
          }
          else 
            if (rle_z_count <= (mz_uint)10) {
              mz_uint tmp_11;
              mz_uint tmp_12;
              d->m_huff_count[2][17] = (mz_uint16)((int)d->m_huff_count[2][17] + 1);
              tmp_11 = num_packed_code_sizes;
              num_packed_code_sizes ++;
              packed_code_sizes[tmp_11] = (mz_uint8)17;
              tmp_12 = num_packed_code_sizes;
              num_packed_code_sizes ++;
              packed_code_sizes[tmp_12] = (mz_uint8)(rle_z_count - (mz_uint)3);
            }
            else {
              mz_uint tmp_13;
              mz_uint tmp_14;
              d->m_huff_count[2][18] = (mz_uint16)((int)d->m_huff_count[2][18] + 1);
              tmp_13 = num_packed_code_sizes;
              num_packed_code_sizes ++;
              packed_code_sizes[tmp_13] = (mz_uint8)18;
              tmp_14 = num_packed_code_sizes;
              num_packed_code_sizes ++;
              packed_code_sizes[tmp_14] = (mz_uint8)(rle_z_count - (mz_uint)11);
            }
          rle_z_count = (mz_uint)0;
        }
        if ((int)code_size != (int)prev_code_size) {
          mz_uint tmp_19;
          if (rle_repeat_count) {
            if (rle_repeat_count < (mz_uint)3) {
              d->m_huff_count[2][prev_code_size] = (mz_uint16)((mz_uint)d->m_huff_count[2][prev_code_size] + rle_repeat_count);
              while (1) {
                mz_uint tmp_16;
                mz_uint tmp_15;
                tmp_16 = rle_repeat_count;
                rle_repeat_count --;
                ;
                if (! tmp_16) break;
                tmp_15 = num_packed_code_sizes;
                num_packed_code_sizes ++;
                packed_code_sizes[tmp_15] = prev_code_size;
              }
            }
            else {
              mz_uint tmp_17;
              mz_uint tmp_18;
              d->m_huff_count[2][16] = (mz_uint16)((int)d->m_huff_count[2][16] + 1);
              tmp_17 = num_packed_code_sizes;
              num_packed_code_sizes ++;
              packed_code_sizes[tmp_17] = (mz_uint8)16;
              tmp_18 = num_packed_code_sizes;
              num_packed_code_sizes ++;
              packed_code_sizes[tmp_18] = (mz_uint8)(rle_repeat_count - (mz_uint)3);
            }
            rle_repeat_count = (mz_uint)0;
          }
          d->m_huff_count[2][code_size] = (mz_uint16)((int)d->m_huff_count[2][code_size] + 1);
          tmp_19 = num_packed_code_sizes;
          num_packed_code_sizes ++;
          packed_code_sizes[tmp_19] = code_size;
        }
        else {
          rle_repeat_count ++;
          if (rle_repeat_count == (mz_uint)6) 
            if (rle_repeat_count) {
              if (rle_repeat_count < (mz_uint)3) {
                d->m_huff_count[2][prev_code_size] = (mz_uint16)((mz_uint)d->m_huff_count[2][prev_code_size] + rle_repeat_count);
                while (1) {
                  mz_uint tmp_21;
                  mz_uint tmp_20;
                  tmp_21 = rle_repeat_count;
                  rle_repeat_count --;
                  ;
                  if (! tmp_21) break;
                  tmp_20 = num_packed_code_sizes;
                  num_packed_code_sizes ++;
                  packed_code_sizes[tmp_20] = prev_code_size;
                }
              }
              else {
                mz_uint tmp_22;
                mz_uint tmp_23;
                d->m_huff_count[2][16] = (mz_uint16)((int)d->m_huff_count[2][16] + 1);
                tmp_22 = num_packed_code_sizes;
                num_packed_code_sizes ++;
                packed_code_sizes[tmp_22] = (mz_uint8)16;
                tmp_23 = num_packed_code_sizes;
                num_packed_code_sizes ++;
                packed_code_sizes[tmp_23] = (mz_uint8)(rle_repeat_count - (mz_uint)3);
              }
              rle_repeat_count = (mz_uint)0;
            }
        }
      }
      prev_code_size = code_size;
    }
    i ++;
  }
  if (rle_repeat_count) {
    if (rle_repeat_count) {
      if (rle_repeat_count < (mz_uint)3) {
        d->m_huff_count[2][prev_code_size] = (mz_uint16)((mz_uint)d->m_huff_count[2][prev_code_size] + rle_repeat_count);
        while (1) {
          mz_uint tmp_25;
          mz_uint tmp_24;
          tmp_25 = rle_repeat_count;
          rle_repeat_count --;
          ;
          if (! tmp_25) break;
          tmp_24 = num_packed_code_sizes;
          num_packed_code_sizes ++;
          packed_code_sizes[tmp_24] = prev_code_size;
        }
      }
      else {
        mz_uint tmp_26;
        mz_uint tmp_27;
        d->m_huff_count[2][16] = (mz_uint16)((int)d->m_huff_count[2][16] + 1);
        tmp_26 = num_packed_code_sizes;
        num_packed_code_sizes ++;
        packed_code_sizes[tmp_26] = (mz_uint8)16;
        tmp_27 = num_packed_code_sizes;
        num_packed_code_sizes ++;
        packed_code_sizes[tmp_27] = (mz_uint8)(rle_repeat_count - (mz_uint)3);
      }
      rle_repeat_count = (mz_uint)0;
    }
  }
  else 
    if (rle_z_count) {
      if (rle_z_count < (mz_uint)3) {
        d->m_huff_count[2][0] = (mz_uint16)((mz_uint)d->m_huff_count[2][0] + rle_z_count);
        while (1) {
          mz_uint tmp_29;
          mz_uint tmp_28;
          tmp_29 = rle_z_count;
          rle_z_count --;
          ;
          if (! tmp_29) break;
          tmp_28 = num_packed_code_sizes;
          num_packed_code_sizes ++;
          packed_code_sizes[tmp_28] = (mz_uint8)0;
        }
      }
      else 
        if (rle_z_count <= (mz_uint)10) {
          mz_uint tmp_30;
          mz_uint tmp_31;
          d->m_huff_count[2][17] = (mz_uint16)((int)d->m_huff_count[2][17] + 1);
          tmp_30 = num_packed_code_sizes;
          num_packed_code_sizes ++;
          packed_code_sizes[tmp_30] = (mz_uint8)17;
          tmp_31 = num_packed_code_sizes;
          num_packed_code_sizes ++;
          packed_code_sizes[tmp_31] = (mz_uint8)(rle_z_count - (mz_uint)3);
        }
        else {
          mz_uint tmp_32;
          mz_uint tmp_33;
          d->m_huff_count[2][18] = (mz_uint16)((int)d->m_huff_count[2][18] + 1);
          tmp_32 = num_packed_code_sizes;
          num_packed_code_sizes ++;
          packed_code_sizes[tmp_32] = (mz_uint8)18;
          tmp_33 = num_packed_code_sizes;
          num_packed_code_sizes ++;
          packed_code_sizes[tmp_33] = (mz_uint8)(rle_z_count - (mz_uint)11);
        }
      rle_z_count = (mz_uint)0;
    }
  tdefl_optimize_huffman_table(d,2,TDEFL_MAX_HUFF_SYMBOLS_2,7,0);
  {
    mz_uint bits = (mz_uint)2;
    mz_uint len = (mz_uint)2;
    __FC_assert((bits <= (1U << len) - 1U) != 0,"miniz_tdef.c",404,
                "bits <= ((1U << len) - 1U)");
    d->m_bit_buffer |= bits << d->m_bits_in;
    d->m_bits_in += len;
    while (d->m_bits_in >= (mz_uint)8) {
      if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
        mz_uint8 *tmp_34;
        tmp_34 = d->m_pOutput_buf;
        (d->m_pOutput_buf) ++;
        *tmp_34 = (mz_uint8)d->m_bit_buffer;
      }
      d->m_bit_buffer >>= 8;
      d->m_bits_in -= (mz_uint)8;
    }
  }
  {
    mz_uint bits_0 = (mz_uint)(num_lit_codes - 257);
    mz_uint len_0 = (mz_uint)5;
    __FC_assert((bits_0 <= (1U << len_0) - 1U) != 0,"miniz_tdef.c",406,
                "bits <= ((1U << len) - 1U)");
    d->m_bit_buffer |= bits_0 << d->m_bits_in;
    d->m_bits_in += len_0;
    while (d->m_bits_in >= (mz_uint)8) {
      if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
        mz_uint8 *tmp_35;
        tmp_35 = d->m_pOutput_buf;
        (d->m_pOutput_buf) ++;
        *tmp_35 = (mz_uint8)d->m_bit_buffer;
      }
      d->m_bit_buffer >>= 8;
      d->m_bits_in -= (mz_uint)8;
    }
  }
  {
    mz_uint bits_1 = (mz_uint)(num_dist_codes - 1);
    mz_uint len_1 = (mz_uint)5;
    __FC_assert((bits_1 <= (1U << len_1) - 1U) != 0,"miniz_tdef.c",407,
                "bits <= ((1U << len) - 1U)");
    d->m_bit_buffer |= bits_1 << d->m_bits_in;
    d->m_bits_in += len_1;
    while (d->m_bits_in >= (mz_uint)8) {
      if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
        mz_uint8 *tmp_36;
        tmp_36 = d->m_pOutput_buf;
        (d->m_pOutput_buf) ++;
        *tmp_36 = (mz_uint8)d->m_bit_buffer;
      }
      d->m_bit_buffer >>= 8;
      d->m_bits_in -= (mz_uint)8;
    }
  }
  num_bit_lengths = 18;
  while (num_bit_lengths >= 0) {
    if (d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[num_bit_lengths]]) 
      break;
    num_bit_lengths --;
  }
  if (4 > num_bit_lengths + 1) num_bit_lengths = 4; else num_bit_lengths ++;
  {
    mz_uint bits_2 = (mz_uint)(num_bit_lengths - 4);
    mz_uint len_2 = (mz_uint)4;
    __FC_assert((bits_2 <= (1U << len_2) - 1U) != 0,"miniz_tdef.c",413,
                "bits <= ((1U << len) - 1U)");
    d->m_bit_buffer |= bits_2 << d->m_bits_in;
    d->m_bits_in += len_2;
    while (d->m_bits_in >= (mz_uint)8) {
      if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
        mz_uint8 *tmp_37;
        tmp_37 = d->m_pOutput_buf;
        (d->m_pOutput_buf) ++;
        *tmp_37 = (mz_uint8)d->m_bit_buffer;
      }
      d->m_bit_buffer >>= 8;
      d->m_bits_in -= (mz_uint)8;
    }
  }
  i = (mz_uint)0;
  while ((int)i < num_bit_lengths) {
    {
      mz_uint bits_3 =
        (mz_uint)d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[i]];
      mz_uint len_3 = (mz_uint)3;
      __FC_assert((bits_3 <= (1U << len_3) - 1U) != 0,"miniz_tdef.c",415,
                  "bits <= ((1U << len) - 1U)");
      d->m_bit_buffer |= bits_3 << d->m_bits_in;
      d->m_bits_in += len_3;
      while (d->m_bits_in >= (mz_uint)8) {
        if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
          mz_uint8 *tmp_38;
          tmp_38 = d->m_pOutput_buf;
          (d->m_pOutput_buf) ++;
          *tmp_38 = (mz_uint8)d->m_bit_buffer;
        }
        d->m_bit_buffer >>= 8;
        d->m_bits_in -= (mz_uint)8;
      }
    }
    i ++;
  }
  packed_code_sizes_index = (mz_uint)0;
  while (packed_code_sizes_index < num_packed_code_sizes) {
    mz_uint tmp_39;
    tmp_39 = packed_code_sizes_index;
    packed_code_sizes_index ++;
    mz_uint code = (mz_uint)packed_code_sizes[tmp_39];
    __FC_assert((code < (mz_uint)TDEFL_MAX_HUFF_SYMBOLS_2) != 0,
                "miniz_tdef.c",420,"code < TDEFL_MAX_HUFF_SYMBOLS_2");
    {
      mz_uint bits_4 = (mz_uint)d->m_huff_codes[2][code];
      mz_uint len_4 = (mz_uint)d->m_huff_code_sizes[2][code];
      __FC_assert((bits_4 <= (1U << len_4) - 1U) != 0,"miniz_tdef.c",421,
                  "bits <= ((1U << len) - 1U)");
      d->m_bit_buffer |= bits_4 << d->m_bits_in;
      d->m_bits_in += len_4;
      while (d->m_bits_in >= (mz_uint)8) {
        if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
          mz_uint8 *tmp_40;
          tmp_40 = d->m_pOutput_buf;
          (d->m_pOutput_buf) ++;
          *tmp_40 = (mz_uint8)d->m_bit_buffer;
        }
        d->m_bit_buffer >>= 8;
        d->m_bits_in -= (mz_uint)8;
      }
    }
    if (code >= (mz_uint)16) {
      mz_uint tmp_41;
      tmp_41 = packed_code_sizes_index;
      packed_code_sizes_index ++;
      mz_uint bits_5 = (mz_uint)packed_code_sizes[tmp_41];
      mz_uint len_5 = (mz_uint)*("\002\003\a" + (code - (mz_uint)16));
      __FC_assert((bits_5 <= (1U << len_5) - 1U) != 0,"miniz_tdef.c",423,
                  "bits <= ((1U << len) - 1U)");
      d->m_bit_buffer |= bits_5 << d->m_bits_in;
      d->m_bits_in += len_5;
      while (d->m_bits_in >= (mz_uint)8) {
        if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
          mz_uint8 *tmp_42;
          tmp_42 = d->m_pOutput_buf;
          (d->m_pOutput_buf) ++;
          *tmp_42 = (mz_uint8)d->m_bit_buffer;
        }
        d->m_bit_buffer >>= 8;
        d->m_bits_in -= (mz_uint)8;
      }
    }
  }
  return;
}

static void tdefl_start_static_block(tdefl_compressor *d)
{
  mz_uint i;
  mz_uint8 *p = & d->m_huff_code_sizes[0][0];
  i = (mz_uint)0;
  while (i <= (mz_uint)143) {
    mz_uint8 *tmp;
    tmp = p;
    p ++;
    *tmp = (mz_uint8)8;
    i ++;
  }
  while (i <= (mz_uint)255) {
    mz_uint8 *tmp_0;
    tmp_0 = p;
    p ++;
    *tmp_0 = (mz_uint8)9;
    i ++;
  }
  while (i <= (mz_uint)279) {
    mz_uint8 *tmp_1;
    tmp_1 = p;
    p ++;
    *tmp_1 = (mz_uint8)7;
    i ++;
  }
  while (i <= (mz_uint)287) {
    mz_uint8 *tmp_2;
    tmp_2 = p;
    p ++;
    *tmp_2 = (mz_uint8)8;
    i ++;
  }
  memset((void *)(d->m_huff_code_sizes[1]),5,(size_t)32);
  tdefl_optimize_huffman_table(d,0,288,15,1);
  tdefl_optimize_huffman_table(d,1,32,15,1);
  {
    mz_uint bits = (mz_uint)1;
    mz_uint len = (mz_uint)2;
    __FC_assert((bits <= (1U << len) - 1U) != 0,"miniz_tdef.c",446,
                "bits <= ((1U << len) - 1U)");
    d->m_bit_buffer |= bits << d->m_bits_in;
    d->m_bits_in += len;
    while (d->m_bits_in >= (mz_uint)8) {
      if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
        mz_uint8 *tmp_3;
        tmp_3 = d->m_pOutput_buf;
        (d->m_pOutput_buf) ++;
        *tmp_3 = (mz_uint8)d->m_bit_buffer;
      }
      d->m_bit_buffer >>= 8;
      d->m_bits_in -= (mz_uint)8;
    }
  }
  return;
}

static mz_uint const mz_bitmasks[17] =
  {(mz_uint)0x0000,
   (mz_uint)0x0001,
   (mz_uint)0x0003,
   (mz_uint)0x0007,
   (mz_uint)0x000F,
   (mz_uint)0x001F,
   (mz_uint)0x003F,
   (mz_uint)0x007F,
   (mz_uint)0x00FF,
   (mz_uint)0x01FF,
   (mz_uint)0x03FF,
   (mz_uint)0x07FF,
   (mz_uint)0x0FFF,
   (mz_uint)0x1FFF,
   (mz_uint)0x3FFF,
   (mz_uint)0x7FFF,
   (mz_uint)0xFFFF};
static mz_bool tdefl_compress_lz_codes(tdefl_compressor *d)
{
  mz_bool __retres;
  mz_uint flags;
  mz_uint8 *pLZ_codes;
  mz_uint8 *pOutput_buf = d->m_pOutput_buf;
  mz_uint8 *pLZ_code_buf_end = d->m_pLZ_code_buf;
  mz_uint64 bit_buffer = (mz_uint64)d->m_bit_buffer;
  mz_uint bits_in = d->m_bits_in;
  flags = (mz_uint)1;
  pLZ_codes = d->m_lz_code_buf;
  while (pLZ_codes < pLZ_code_buf_end) {
    if (flags == (mz_uint)1) {
      mz_uint8 *tmp;
      tmp = pLZ_codes;
      pLZ_codes ++;
      flags = (mz_uint)((int)*tmp | 0x100);
    }
    if (flags & (unsigned int)1) {
      mz_uint s0;
      mz_uint s1;
      mz_uint n0;
      mz_uint n1;
      mz_uint sym;
      mz_uint num_extra_bits;
      mz_uint match_len = (mz_uint)*(pLZ_codes + 0);
      mz_uint match_dist = (mz_uint)*((mz_uint16 const *)(pLZ_codes + 1));
      pLZ_codes += 3;
      __FC_assert((int)d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]] != 0,
                  "miniz_tdef.c",479,
                  "d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]");
      bit_buffer |= (mz_uint64)d->m_huff_codes[0][s_tdefl_len_sym[match_len]] << bits_in;
      bits_in += (mz_uint)d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]];
      bit_buffer |= (mz_uint64)(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]]) << bits_in;
      bits_in += (mz_uint)s_tdefl_len_extra[match_len];
      s0 = (mz_uint)s_tdefl_small_dist_sym[match_dist & (unsigned int)511];
      n0 = (mz_uint)s_tdefl_small_dist_extra[match_dist & (unsigned int)511];
      s1 = (mz_uint)s_tdefl_large_dist_sym[match_dist >> 8];
      n1 = (mz_uint)s_tdefl_large_dist_extra[match_dist >> 8];
      if (match_dist < (mz_uint)512) sym = s0; else sym = s1;
      if (match_dist < (mz_uint)512) num_extra_bits = n0;
      else num_extra_bits = n1;
      __FC_assert((int)d->m_huff_code_sizes[1][sym] != 0,"miniz_tdef.c",491,
                  "d->m_huff_code_sizes[1][sym]");
      bit_buffer |= (mz_uint64)d->m_huff_codes[1][sym] << bits_in;
      bits_in += (mz_uint)d->m_huff_code_sizes[1][sym];
      bit_buffer |= (mz_uint64)(match_dist & mz_bitmasks[num_extra_bits]) << bits_in;
      bits_in += num_extra_bits;
    }
    else {
      mz_uint8 *tmp_0;
      tmp_0 = pLZ_codes;
      pLZ_codes ++;
      mz_uint lit = (mz_uint)*tmp_0;
      __FC_assert((int)d->m_huff_code_sizes[0][lit] != 0,"miniz_tdef.c",498,
                  "d->m_huff_code_sizes[0][lit]");
      bit_buffer |= (mz_uint64)d->m_huff_codes[0][lit] << bits_in;
      bits_in += (mz_uint)d->m_huff_code_sizes[0][lit];
      if ((flags & (unsigned int)2) == (unsigned int)0) 
        if (pLZ_codes < pLZ_code_buf_end) {
          mz_uint8 *tmp_1;
          flags >>= 1;
          tmp_1 = pLZ_codes;
          pLZ_codes ++;
          lit = (mz_uint)*tmp_1;
          __FC_assert((int)d->m_huff_code_sizes[0][lit] != 0,"miniz_tdef.c",
                      505,"d->m_huff_code_sizes[0][lit]");
          bit_buffer |= (mz_uint64)d->m_huff_codes[0][lit] << bits_in;
          bits_in += (mz_uint)d->m_huff_code_sizes[0][lit];
          if ((flags & (unsigned int)2) == (unsigned int)0) 
            if (pLZ_codes < pLZ_code_buf_end) {
              mz_uint8 *tmp_2;
              flags >>= 1;
              tmp_2 = pLZ_codes;
              pLZ_codes ++;
              lit = (mz_uint)*tmp_2;
              __FC_assert((int)d->m_huff_code_sizes[0][lit] != 0,
                          "miniz_tdef.c",512,"d->m_huff_code_sizes[0][lit]");
              bit_buffer |= (mz_uint64)d->m_huff_codes[0][lit] << bits_in;
              bits_in += (mz_uint)d->m_huff_code_sizes[0][lit];
            }
        }
    }
    if (pOutput_buf >= d->m_pOutput_buf_end) {
      __retres = 0;
      goto return_label;
    }
    *((mz_uint64 *)pOutput_buf) = bit_buffer;
    pOutput_buf += bits_in >> 3;
    bit_buffer >>= bits_in & (unsigned int)(~ 7);
    bits_in &= (unsigned int)7;
    flags >>= 1;
  }
  d->m_pOutput_buf = pOutput_buf;
  d->m_bits_in = (mz_uint)0;
  d->m_bit_buffer = (mz_uint)0;
  while (bits_in) {
    mz_uint tmp_3;
    if (bits_in < (mz_uint)16) tmp_3 = bits_in; else tmp_3 = (mz_uint)16;
    mz_uint32 n = tmp_3;
    {
      mz_uint bits = (mz_uint)bit_buffer & mz_bitmasks[n];
      mz_uint len = n;
      __FC_assert((bits <= (1U << len) - 1U) != 0,"miniz_tdef.c",536,
                  "bits <= ((1U << len) - 1U)");
      d->m_bit_buffer |= bits << d->m_bits_in;
      d->m_bits_in += len;
      while (d->m_bits_in >= (mz_uint)8) {
        if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
          mz_uint8 *tmp_4;
          tmp_4 = d->m_pOutput_buf;
          (d->m_pOutput_buf) ++;
          *tmp_4 = (mz_uint8)d->m_bit_buffer;
        }
        d->m_bit_buffer >>= 8;
        d->m_bits_in -= (mz_uint)8;
      }
    }
    bit_buffer >>= n;
    bits_in -= n;
  }
  {
    mz_uint bits_0 = (mz_uint)d->m_huff_codes[0][256];
    mz_uint len_0 = (mz_uint)d->m_huff_code_sizes[0][256];
    __FC_assert((bits_0 <= (1U << len_0) - 1U) != 0,"miniz_tdef.c",541,
                "bits <= ((1U << len) - 1U)");
    d->m_bit_buffer |= bits_0 << d->m_bits_in;
    d->m_bits_in += len_0;
    while (d->m_bits_in >= (mz_uint)8) {
      if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
        mz_uint8 *tmp_5;
        tmp_5 = d->m_pOutput_buf;
        (d->m_pOutput_buf) ++;
        *tmp_5 = (mz_uint8)d->m_bit_buffer;
      }
      d->m_bit_buffer >>= 8;
      d->m_bits_in -= (mz_uint)8;
    }
  }
  __retres = d->m_pOutput_buf < d->m_pOutput_buf_end;
  return_label: return __retres;
}

static mz_bool tdefl_compress_block(tdefl_compressor *d, mz_bool static_block)
{
  mz_bool tmp;
  if (static_block) tdefl_start_static_block(d);
  else tdefl_start_dynamic_block(d);
  tmp = tdefl_compress_lz_codes(d);
  return tmp;
}

static int tdefl_flush_block(tdefl_compressor *d, int flush)
{
  int __retres;
  mz_uint saved_bit_buf;
  mz_uint saved_bits_in;
  mz_uint8 *pSaved_output_buf;
  int n;
  int tmp;
  mz_uint8 *tmp_0;
  mz_bool comp_block_succeeded = 0;
  if ((d->m_flags & (unsigned int)TDEFL_FORCE_ALL_RAW_BLOCKS) != (unsigned int)0) 
    if (d->m_lookahead_pos - d->m_lz_code_buf_dict_pos <= d->m_dict_size) 
      tmp = 1;
    else tmp = 0;
  else tmp = 0;
  int use_raw_block = tmp;
  if (d->m_pPut_buf_func == (mz_bool (*)(void const *pBuf, int len,
                                         void *pUser))0) 
    if (*(d->m_pOut_buf_size) - d->m_out_buf_ofs >= (size_t)TDEFL_OUT_BUF_SIZE) 
      tmp_0 = (mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs;
    else tmp_0 = d->m_output_buf;
  else tmp_0 = d->m_output_buf;
  mz_uint8 *pOutput_buf_start = tmp_0;
  d->m_pOutput_buf = pOutput_buf_start;
  d->m_pOutput_buf_end = (d->m_pOutput_buf + TDEFL_OUT_BUF_SIZE) - 16;
  __FC_assert(! d->m_output_flush_remaining != 0,"miniz_tdef.c",614,
              "!d->m_output_flush_remaining");
  d->m_output_flush_ofs = (mz_uint)0;
  d->m_output_flush_remaining = (mz_uint)0;
  *(d->m_pLZ_flags) = (mz_uint8)((int)*(d->m_pLZ_flags) >> d->m_num_flags_left);
  d->m_pLZ_code_buf -= d->m_num_flags_left == (mz_uint)8;
  if (d->m_flags & (unsigned int)TDEFL_WRITE_ZLIB_HEADER) 
    if (! d->m_block_index) {
      {
        mz_uint bits = (mz_uint)0x78;
        mz_uint len = (mz_uint)8;
        __FC_assert((bits <= (1U << len) - 1U) != 0,"miniz_tdef.c",623,
                    "bits <= ((1U << len) - 1U)");
        d->m_bit_buffer |= bits << d->m_bits_in;
        d->m_bits_in += len;
        while (d->m_bits_in >= (mz_uint)8) {
          if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
            mz_uint8 *tmp_1;
            tmp_1 = d->m_pOutput_buf;
            (d->m_pOutput_buf) ++;
            *tmp_1 = (mz_uint8)d->m_bit_buffer;
          }
          d->m_bit_buffer >>= 8;
          d->m_bits_in -= (mz_uint)8;
        }
      }
      {
        mz_uint bits_0 = (mz_uint)0x01;
        mz_uint len_0 = (mz_uint)8;
        __FC_assert((bits_0 <= (1U << len_0) - 1U) != 0,"miniz_tdef.c",624,
                    "bits <= ((1U << len) - 1U)");
        d->m_bit_buffer |= bits_0 << d->m_bits_in;
        d->m_bits_in += len_0;
        while (d->m_bits_in >= (mz_uint)8) {
          if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
            mz_uint8 *tmp_2;
            tmp_2 = d->m_pOutput_buf;
            (d->m_pOutput_buf) ++;
            *tmp_2 = (mz_uint8)d->m_bit_buffer;
          }
          d->m_bit_buffer >>= 8;
          d->m_bits_in -= (mz_uint)8;
        }
      }
    }
  {
    mz_uint bits_1 = (mz_uint)(flush == TDEFL_FINISH);
    mz_uint len_1 = (mz_uint)1;
    __FC_assert((bits_1 <= (1U << len_1) - 1U) != 0,"miniz_tdef.c",627,
                "bits <= ((1U << len) - 1U)");
    d->m_bit_buffer |= bits_1 << d->m_bits_in;
    d->m_bits_in += len_1;
    while (d->m_bits_in >= (mz_uint)8) {
      if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
        mz_uint8 *tmp_3;
        tmp_3 = d->m_pOutput_buf;
        (d->m_pOutput_buf) ++;
        *tmp_3 = (mz_uint8)d->m_bit_buffer;
      }
      d->m_bit_buffer >>= 8;
      d->m_bits_in -= (mz_uint)8;
    }
  }
  pSaved_output_buf = d->m_pOutput_buf;
  saved_bit_buf = d->m_bit_buffer;
  saved_bits_in = d->m_bits_in;
  if (! use_raw_block) {
    int tmp_4;
    if (d->m_flags & (unsigned int)TDEFL_FORCE_ALL_STATIC_BLOCKS) tmp_4 = 1;
    else 
      if (d->m_total_lz_bytes < (mz_uint)48) tmp_4 = 1; else tmp_4 = 0;
    ;
    comp_block_succeeded = tdefl_compress_block(d,tmp_4);
  }
  if (use_raw_block) goto _LOR;
  else 
    if (d->m_total_lz_bytes) {
      if ((d->m_pOutput_buf - pSaved_output_buf) + (long)1U >= (long)d->m_total_lz_bytes) {
        _LOR: ;
        if (d->m_lookahead_pos - d->m_lz_code_buf_dict_pos <= d->m_dict_size) {
          mz_uint i;
          d->m_pOutput_buf = pSaved_output_buf;
          d->m_bit_buffer = saved_bit_buf;
          d->m_bits_in = saved_bits_in;
          {
            mz_uint bits_2 = (mz_uint)0;
            mz_uint len_2 = (mz_uint)2;
            __FC_assert((bits_2 <= (1U << len_2) - 1U) != 0,"miniz_tdef.c",
                        643,"bits <= ((1U << len) - 1U)");
            d->m_bit_buffer |= bits_2 << d->m_bits_in;
            d->m_bits_in += len_2;
            while (d->m_bits_in >= (mz_uint)8) {
              if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
                mz_uint8 *tmp_5;
                tmp_5 = d->m_pOutput_buf;
                (d->m_pOutput_buf) ++;
                *tmp_5 = (mz_uint8)d->m_bit_buffer;
              }
              d->m_bit_buffer >>= 8;
              d->m_bits_in -= (mz_uint)8;
            }
          }
          if (d->m_bits_in) {
            mz_uint bits_3 = (mz_uint)0;
            mz_uint len_3 = (mz_uint)8 - d->m_bits_in;
            __FC_assert((bits_3 <= (1U << len_3) - 1U) != 0,"miniz_tdef.c",
                        646,"bits <= ((1U << len) - 1U)");
            d->m_bit_buffer |= bits_3 << d->m_bits_in;
            d->m_bits_in += len_3;
            while (d->m_bits_in >= (mz_uint)8) {
              if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
                mz_uint8 *tmp_6;
                tmp_6 = d->m_pOutput_buf;
                (d->m_pOutput_buf) ++;
                *tmp_6 = (mz_uint8)d->m_bit_buffer;
              }
              d->m_bit_buffer >>= 8;
              d->m_bits_in -= (mz_uint)8;
            }
          }
          i = (mz_uint)2;
          while (i) {
            {
              mz_uint bits_4 = d->m_total_lz_bytes & (unsigned int)0xFFFF;
              mz_uint len_4 = (mz_uint)16;
              __FC_assert((bits_4 <= (1U << len_4) - 1U) != 0,"miniz_tdef.c",
                          650,"bits <= ((1U << len) - 1U)");
              d->m_bit_buffer |= bits_4 << d->m_bits_in;
              d->m_bits_in += len_4;
              while (d->m_bits_in >= (mz_uint)8) {
                if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
                  mz_uint8 *tmp_7;
                  tmp_7 = d->m_pOutput_buf;
                  (d->m_pOutput_buf) ++;
                  *tmp_7 = (mz_uint8)d->m_bit_buffer;
                }
                d->m_bit_buffer >>= 8;
                d->m_bits_in -= (mz_uint)8;
              }
            }
            i --;
            d->m_total_lz_bytes ^= (unsigned int)0xFFFF;
          }
          i = (mz_uint)0;
          while (i < d->m_total_lz_bytes) {
            {
              mz_uint bits_5 =
                (mz_uint)d->m_dict[(d->m_lz_code_buf_dict_pos + i) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK];
              mz_uint len_5 = (mz_uint)8;
              __FC_assert((bits_5 <= (1U << len_5) - 1U) != 0,"miniz_tdef.c",
                          654,"bits <= ((1U << len) - 1U)");
              d->m_bit_buffer |= bits_5 << d->m_bits_in;
              d->m_bits_in += len_5;
              while (d->m_bits_in >= (mz_uint)8) {
                if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
                  mz_uint8 *tmp_8;
                  tmp_8 = d->m_pOutput_buf;
                  (d->m_pOutput_buf) ++;
                  *tmp_8 = (mz_uint8)d->m_bit_buffer;
                }
                d->m_bit_buffer >>= 8;
                d->m_bits_in -= (mz_uint)8;
              }
            }
            i ++;
          }
        }
        else goto _LAND_0;
      }
      else goto _LAND_0;
    }
    else 
      _LAND_0:
      if (! comp_block_succeeded) {
        d->m_pOutput_buf = pSaved_output_buf;
        d->m_bit_buffer = saved_bit_buf;
        d->m_bits_in = saved_bits_in;
        tdefl_compress_block(d,1);
      }
  if (flush) 
    if (flush == TDEFL_FINISH) {
      if (d->m_bits_in) {
        mz_uint bits_6 = (mz_uint)0;
        mz_uint len_6 = (mz_uint)8 - d->m_bits_in;
        __FC_assert((bits_6 <= (1U << len_6) - 1U) != 0,"miniz_tdef.c",671,
                    "bits <= ((1U << len) - 1U)");
        d->m_bit_buffer |= bits_6 << d->m_bits_in;
        d->m_bits_in += len_6;
        while (d->m_bits_in >= (mz_uint)8) {
          if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
            mz_uint8 *tmp_9;
            tmp_9 = d->m_pOutput_buf;
            (d->m_pOutput_buf) ++;
            *tmp_9 = (mz_uint8)d->m_bit_buffer;
          }
          d->m_bit_buffer >>= 8;
          d->m_bits_in -= (mz_uint)8;
        }
      }
      if (d->m_flags & (unsigned int)TDEFL_WRITE_ZLIB_HEADER) {
        mz_uint i_0;
        mz_uint a = d->m_adler32;
        i_0 = (mz_uint)0;
        while (i_0 < (mz_uint)4) {
          {
            mz_uint bits_7 = (a >> 24) & (unsigned int)0xFF;
            mz_uint len_7 = (mz_uint)8;
            __FC_assert((bits_7 <= (1U << len_7) - 1U) != 0,"miniz_tdef.c",
                        678,"bits <= ((1U << len) - 1U)");
            d->m_bit_buffer |= bits_7 << d->m_bits_in;
            d->m_bits_in += len_7;
            while (d->m_bits_in >= (mz_uint)8) {
              if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
                mz_uint8 *tmp_10;
                tmp_10 = d->m_pOutput_buf;
                (d->m_pOutput_buf) ++;
                *tmp_10 = (mz_uint8)d->m_bit_buffer;
              }
              d->m_bit_buffer >>= 8;
              d->m_bits_in -= (mz_uint)8;
            }
          }
          a <<= 8;
          i_0 ++;
        }
      }
    }
    else {
      mz_uint i_1;
      mz_uint z = (mz_uint)0;
      {
        mz_uint bits_8 = (mz_uint)0;
        mz_uint len_8 = (mz_uint)3;
        __FC_assert((bits_8 <= (1U << len_8) - 1U) != 0,"miniz_tdef.c",686,
                    "bits <= ((1U << len) - 1U)");
        d->m_bit_buffer |= bits_8 << d->m_bits_in;
        d->m_bits_in += len_8;
        while (d->m_bits_in >= (mz_uint)8) {
          if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
            mz_uint8 *tmp_11;
            tmp_11 = d->m_pOutput_buf;
            (d->m_pOutput_buf) ++;
            *tmp_11 = (mz_uint8)d->m_bit_buffer;
          }
          d->m_bit_buffer >>= 8;
          d->m_bits_in -= (mz_uint)8;
        }
      }
      if (d->m_bits_in) {
        mz_uint bits_9 = (mz_uint)0;
        mz_uint len_9 = (mz_uint)8 - d->m_bits_in;
        __FC_assert((bits_9 <= (1U << len_9) - 1U) != 0,"miniz_tdef.c",689,
                    "bits <= ((1U << len) - 1U)");
        d->m_bit_buffer |= bits_9 << d->m_bits_in;
        d->m_bits_in += len_9;
        while (d->m_bits_in >= (mz_uint)8) {
          if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
            mz_uint8 *tmp_12;
            tmp_12 = d->m_pOutput_buf;
            (d->m_pOutput_buf) ++;
            *tmp_12 = (mz_uint8)d->m_bit_buffer;
          }
          d->m_bit_buffer >>= 8;
          d->m_bits_in -= (mz_uint)8;
        }
      }
      i_1 = (mz_uint)2;
      while (i_1) {
        {
          mz_uint bits_10 = z & (unsigned int)0xFFFF;
          mz_uint len_10 = (mz_uint)16;
          __FC_assert((bits_10 <= (1U << len_10) - 1U) != 0,"miniz_tdef.c",
                      693,"bits <= ((1U << len) - 1U)");
          d->m_bit_buffer |= bits_10 << d->m_bits_in;
          d->m_bits_in += len_10;
          while (d->m_bits_in >= (mz_uint)8) {
            if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
              mz_uint8 *tmp_13;
              tmp_13 = d->m_pOutput_buf;
              (d->m_pOutput_buf) ++;
              *tmp_13 = (mz_uint8)d->m_bit_buffer;
            }
            d->m_bit_buffer >>= 8;
            d->m_bits_in -= (mz_uint)8;
          }
        }
        i_1 --;
        z ^= (unsigned int)0xFFFF;
      }
    }
  __FC_assert((d->m_pOutput_buf < d->m_pOutput_buf_end) != 0,"miniz_tdef.c",
              698,"d->m_pOutput_buf < d->m_pOutput_buf_end");
  memset((void *)(& d->m_huff_count[0][0]),0,
         sizeof(d->m_huff_count[0][0]) * (unsigned long)TDEFL_MAX_HUFF_SYMBOLS_0);
  memset((void *)(& d->m_huff_count[1][0]),0,
         sizeof(d->m_huff_count[1][0]) * (unsigned long)TDEFL_MAX_HUFF_SYMBOLS_1);
  d->m_pLZ_code_buf = & d->m_lz_code_buf[1];
  d->m_pLZ_flags = d->m_lz_code_buf;
  d->m_num_flags_left = (mz_uint)8;
  d->m_lz_code_buf_dict_pos += d->m_total_lz_bytes;
  d->m_total_lz_bytes = (mz_uint)0;
  (d->m_block_index) ++;
  n = (int)(d->m_pOutput_buf - pOutput_buf_start);
  if (n != 0) 
    if (d->m_pPut_buf_func) {
      mz_bool tmp_15;
      *(d->m_pIn_buf_size) = (size_t)(d->m_pSrc - (mz_uint8 const *)d->m_pIn_buf);
      tmp_15 = (*(d->m_pPut_buf_func))((void const *)(d->m_output_buf),n,
                                       d->m_pPut_buf_user);
      if (! tmp_15) {
        tdefl_status tmp_14;
        tmp_14 = TDEFL_STATUS_PUT_BUF_FAILED;
        d->m_prev_return_status = tmp_14;
        __retres = tmp_14;
        goto return_label;
      }
    }
    else 
      if (pOutput_buf_start == d->m_output_buf) {
        size_t tmp_16;
        if ((size_t)n < *(d->m_pOut_buf_size) - d->m_out_buf_ofs) tmp_16 = (size_t)n;
        else tmp_16 = *(d->m_pOut_buf_size) - d->m_out_buf_ofs;
        int bytes_to_copy = (int)tmp_16;
        memcpy((void *)((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs),
               (void const *)(d->m_output_buf),(size_t)bytes_to_copy);
        d->m_out_buf_ofs += (size_t)bytes_to_copy;
        n -= bytes_to_copy;
        if (n != 0) {
          d->m_output_flush_ofs = (mz_uint)bytes_to_copy;
          d->m_output_flush_remaining = (mz_uint)n;
        }
      }
      else d->m_out_buf_ofs += (size_t)n;
  __retres = (int)d->m_output_flush_remaining;
  return_label: return __retres;
}

static mz_uint16 TDEFL_READ_UNALIGNED_WORD(mz_uint8 const *p)
{
  mz_uint16 ret;
  memcpy((void *)(& ret),(void const *)p,sizeof(mz_uint16));
  return ret;
}

static mz_uint16 TDEFL_READ_UNALIGNED_WORD2(mz_uint16 const *p)
{
  mz_uint16 ret;
  memcpy((void *)(& ret),(void const *)p,sizeof(mz_uint16));
  return ret;
}

__inline static void ( __attribute__((__always_inline__)) tdefl_find_match)
(tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist,
 mz_uint max_match_len, mz_uint *pMatch_dist, mz_uint *pMatch_len)
{
  mz_uint dist;
  mz_uint next_probe_pos;
  mz_uint probe_len;
  mz_uint16 const *p;
  mz_uint16 const *q;
  mz_uint pos = lookahead_pos & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
  mz_uint match_len = *pMatch_len;
  mz_uint probe_pos = pos;
  mz_uint num_probes_left = d->m_max_probes[match_len >= (mz_uint)32];
  mz_uint16 const *s = (mz_uint16 const *)(& d->m_dict[pos]);
  mz_uint16 c01 =
    TDEFL_READ_UNALIGNED_WORD((mz_uint8 const *)(& d->m_dict[(pos + match_len) - (mz_uint)1]));
  mz_uint16 s01 = TDEFL_READ_UNALIGNED_WORD2(s);
  __FC_assert((max_match_len <= (mz_uint)TDEFL_MAX_MATCH_LEN) != 0,
              "miniz_tdef.c",762,"max_match_len <= TDEFL_MAX_MATCH_LEN");
  if (max_match_len <= match_len) goto return_label;
  while (1) {
    {
      mz_uint16 tmp_4;
      while (1) {
        mz_uint16 tmp_1;
        mz_uint16 tmp_2;
        mz_uint16 tmp_3;
        num_probes_left --;
        if (num_probes_left == (mz_uint)0) goto return_label;
        next_probe_pos = (mz_uint)d->m_next[probe_pos];
        if (! next_probe_pos) goto return_label;
        else {
          dist = (mz_uint)((mz_uint16)(lookahead_pos - next_probe_pos));
          ;
          if (dist > max_dist) goto return_label;
        }
        probe_pos = next_probe_pos & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
        tmp_1 = TDEFL_READ_UNALIGNED_WORD((mz_uint8 const *)(& d->m_dict[
                                          (probe_pos + match_len) - (mz_uint)1]));
        ;
        if ((int)tmp_1 == (int)c01) break;
        next_probe_pos = (mz_uint)d->m_next[probe_pos];
        if (! next_probe_pos) goto return_label;
        else {
          dist = (mz_uint)((mz_uint16)(lookahead_pos - next_probe_pos));
          ;
          if (dist > max_dist) goto return_label;
        }
        probe_pos = next_probe_pos & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
        tmp_2 = TDEFL_READ_UNALIGNED_WORD((mz_uint8 const *)(& d->m_dict[
                                          (probe_pos + match_len) - (mz_uint)1]));
        ;
        if ((int)tmp_2 == (int)c01) break;
        next_probe_pos = (mz_uint)d->m_next[probe_pos];
        if (! next_probe_pos) goto return_label;
        else {
          dist = (mz_uint)((mz_uint16)(lookahead_pos - next_probe_pos));
          ;
          if (dist > max_dist) goto return_label;
        }
        probe_pos = next_probe_pos & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
        tmp_3 = TDEFL_READ_UNALIGNED_WORD((mz_uint8 const *)(& d->m_dict[
                                          (probe_pos + match_len) - (mz_uint)1]));
        ;
        if ((int)tmp_3 == (int)c01) break;
      }
      if (! dist) break;
      q = (mz_uint16 const *)(& d->m_dict[probe_pos]);
      tmp_4 = TDEFL_READ_UNALIGNED_WORD2(q);
      ;
      if ((int)tmp_4 != (int)s01) goto __Cont;
      p = s;
      probe_len = (mz_uint)32;
      while (1) {
        mz_uint16 tmp_5;
        mz_uint16 tmp_6;
        p ++;
        tmp_5 = TDEFL_READ_UNALIGNED_WORD2(p);
        q ++;
        tmp_6 = TDEFL_READ_UNALIGNED_WORD2(q);
        if ((int)tmp_5 == (int)tmp_6) {
          mz_uint16 tmp_7;
          mz_uint16 tmp_8;
          p ++;
          tmp_7 = TDEFL_READ_UNALIGNED_WORD2(p);
          q ++;
          tmp_8 = TDEFL_READ_UNALIGNED_WORD2(q);
          if ((int)tmp_7 == (int)tmp_8) {
            mz_uint16 tmp_9;
            mz_uint16 tmp_10;
            p ++;
            tmp_9 = TDEFL_READ_UNALIGNED_WORD2(p);
            q ++;
            tmp_10 = TDEFL_READ_UNALIGNED_WORD2(q);
            if ((int)tmp_9 == (int)tmp_10) {
              mz_uint16 tmp_11;
              mz_uint16 tmp_12;
              p ++;
              tmp_11 = TDEFL_READ_UNALIGNED_WORD2(p);
              q ++;
              tmp_12 = TDEFL_READ_UNALIGNED_WORD2(q);
              if ((int)tmp_11 == (int)tmp_12) {
                probe_len --;
                if (! (probe_len > (mz_uint)0)) break;
              }
              else break;
            }
            else break;
          }
          else break;
        }
        else break;
      }
      if (! probe_len) {
        *pMatch_dist = dist;
        if (max_match_len < (mz_uint)TDEFL_MAX_MATCH_LEN) *pMatch_len = max_match_len;
        else *pMatch_len = (mz_uint)TDEFL_MAX_MATCH_LEN;
        break;
      }
      else {
        probe_len = (mz_uint)(p - s) * (mz_uint)2 + (mz_uint)((int)*((mz_uint8 const *)p) == (int)*((mz_uint8 const *)q));
        ;
        if (probe_len > match_len) {
          mz_uint tmp_13;
          *pMatch_dist = dist;
          if (max_match_len < probe_len) match_len = max_match_len;
          else match_len = probe_len;
          tmp_13 = match_len;
          *pMatch_len = tmp_13;
          ;
          if (tmp_13 == max_match_len) break;
          c01 = TDEFL_READ_UNALIGNED_WORD((mz_uint8 const *)(& d->m_dict[
                                          (pos + match_len) - (mz_uint)1]));
        }
      }
    }
    __Cont: ;
  }
  return_label: return;
}

static mz_uint32 TDEFL_READ_UNALIGNED_WORD32(mz_uint8 const *p)
{
  mz_uint32 ret;
  memcpy((void *)(& ret),(void const *)p,sizeof(mz_uint32));
  return ret;
}

static mz_bool tdefl_compress_fast(tdefl_compressor *d)
{
  mz_bool __retres;
  mz_uint lookahead_pos = d->m_lookahead_pos;
  mz_uint lookahead_size = d->m_lookahead_size;
  mz_uint dict_size = d->m_dict_size;
  mz_uint total_lz_bytes = d->m_total_lz_bytes;
  mz_uint num_flags_left = d->m_num_flags_left;
  mz_uint8 *pLZ_code_buf = d->m_pLZ_code_buf;
  mz_uint8 *pLZ_flags = d->m_pLZ_flags;
  mz_uint cur_pos = lookahead_pos & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
  while (1) {
    if (! d->m_src_buf_left) 
      if (d->m_flush) {
        if (! lookahead_size) break;
      }
      else break;
    {
      size_t tmp;
      mz_uint const TDEFL_COMP_FAST_LOOKAHEAD_SIZE = (mz_uint)4096;
      mz_uint dst_pos =
        (lookahead_pos + lookahead_size) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
      if (d->m_src_buf_left < (size_t)(TDEFL_COMP_FAST_LOOKAHEAD_SIZE - lookahead_size)) 
        tmp = d->m_src_buf_left;
      else tmp = (size_t)(TDEFL_COMP_FAST_LOOKAHEAD_SIZE - lookahead_size);
      mz_uint num_bytes_to_process = (mz_uint)tmp;
      d->m_src_buf_left -= (size_t)num_bytes_to_process;
      lookahead_size += num_bytes_to_process;
      while (num_bytes_to_process) {
        mz_uint tmp_0;
        if ((mz_uint)TDEFL_LZ_DICT_SIZE - dst_pos < num_bytes_to_process) 
          tmp_0 = (mz_uint)TDEFL_LZ_DICT_SIZE - dst_pos;
        else tmp_0 = num_bytes_to_process;
        mz_uint32 n = tmp_0;
        memcpy((void *)(& d->m_dict[dst_pos]),(void const *)d->m_pSrc,
               (size_t)n);
        if (dst_pos < (mz_uint)(TDEFL_MAX_MATCH_LEN - 1)) {
          mz_uint32 tmp_1;
          if (n < (mz_uint)(TDEFL_MAX_MATCH_LEN - 1) - dst_pos) tmp_1 = n;
          else tmp_1 = (mz_uint)(TDEFL_MAX_MATCH_LEN - 1) - dst_pos;
          ;
          ;
          memcpy((void *)(& d->m_dict[TDEFL_LZ_DICT_SIZE] + dst_pos),
                 (void const *)d->m_pSrc,(size_t)tmp_1);
        }
        d->m_pSrc += n;
        dst_pos = (dst_pos + n) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
        num_bytes_to_process -= n;
      }
      if ((mz_uint)TDEFL_LZ_DICT_SIZE - lookahead_size < dict_size) dict_size = 
                                                                    (mz_uint)TDEFL_LZ_DICT_SIZE - lookahead_size;
      else dict_size = dict_size;
      if (! d->m_flush) 
        if (lookahead_size < TDEFL_COMP_FAST_LOOKAHEAD_SIZE) break;
      while (lookahead_size >= (mz_uint)4) {
        mz_uint cur_match_dist;
        mz_uint32 tmp_2;
        mz_uint cur_match_len = (mz_uint)1;
        mz_uint8 *pCur_dict = & d->m_dict[cur_pos];
        tmp_2 = TDEFL_READ_UNALIGNED_WORD32((mz_uint8 const *)pCur_dict);
        mz_uint first_trigram = tmp_2 & (unsigned int)0xFFFFFF;
        mz_uint hash =
          (first_trigram ^ (first_trigram >> (24 - (TDEFL_LZ_HASH_BITS - 8)))) & (unsigned int)TDEFL_LEVEL1_HASH_SIZE_MASK;
        mz_uint probe_pos = (mz_uint)d->m_hash[hash];
        d->m_hash[hash] = (mz_uint16)lookahead_pos;
        cur_match_dist = (mz_uint)((mz_uint16)(lookahead_pos - probe_pos));
        ;
        if (cur_match_dist <= dict_size) {
          mz_uint32 tmp_15;
          probe_pos &= (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
          ;
          tmp_15 = TDEFL_READ_UNALIGNED_WORD32((mz_uint8 const *)(& d->m_dict[probe_pos]));
          ;
          if ((tmp_15 & (unsigned int)0xFFFFFF) == first_trigram) {
            mz_uint16 const *p = (mz_uint16 const *)pCur_dict;
            mz_uint16 const *q = (mz_uint16 const *)(& d->m_dict[probe_pos]);
            mz_uint32 probe_len = (mz_uint32)32;
            while (1) {
              mz_uint16 tmp_3;
              mz_uint16 tmp_4;
              p ++;
              tmp_3 = TDEFL_READ_UNALIGNED_WORD2(p);
              q ++;
              tmp_4 = TDEFL_READ_UNALIGNED_WORD2(q);
              if ((int)tmp_3 == (int)tmp_4) {
                mz_uint16 tmp_5;
                mz_uint16 tmp_6;
                p ++;
                tmp_5 = TDEFL_READ_UNALIGNED_WORD2(p);
                q ++;
                tmp_6 = TDEFL_READ_UNALIGNED_WORD2(q);
                if ((int)tmp_5 == (int)tmp_6) {
                  mz_uint16 tmp_7;
                  mz_uint16 tmp_8;
                  p ++;
                  tmp_7 = TDEFL_READ_UNALIGNED_WORD2(p);
                  q ++;
                  tmp_8 = TDEFL_READ_UNALIGNED_WORD2(q);
                  if ((int)tmp_7 == (int)tmp_8) {
                    mz_uint16 tmp_9;
                    mz_uint16 tmp_10;
                    p ++;
                    tmp_9 = TDEFL_READ_UNALIGNED_WORD2(p);
                    q ++;
                    tmp_10 = TDEFL_READ_UNALIGNED_WORD2(q);
                    if ((int)tmp_9 == (int)tmp_10) {
                      probe_len --;
                      if (! (probe_len > (mz_uint32)0)) break;
                    }
                    else break;
                  }
                  else break;
                }
                else break;
              }
              else break;
            }
            cur_match_len = (mz_uint)(p - (mz_uint16 const *)pCur_dict) * (mz_uint)2 + (mz_uint)(
                            (int)*((mz_uint8 const *)p) == (int)*((mz_uint8 const *)q));
            if (! probe_len) 
              if (cur_match_dist) cur_match_len = (mz_uint)TDEFL_MAX_MATCH_LEN;
              else cur_match_len = (mz_uint)0;
            if (cur_match_len < (mz_uint)TDEFL_MIN_MATCH_LEN) goto _LOR;
            else 
              if (cur_match_len == (mz_uint)TDEFL_MIN_MATCH_LEN) {
                if (cur_match_dist >= 8U * 1024U) {
                  _LOR:
                  {
                    mz_uint8 *tmp_11;
                    cur_match_len = (mz_uint)1;
                    tmp_11 = pLZ_code_buf;
                    pLZ_code_buf ++;
                    *tmp_11 = (mz_uint8)first_trigram;
                    *pLZ_flags = (mz_uint8)((int)*pLZ_flags >> 1);
                    d->m_huff_count[0][(mz_uint8)first_trigram] = (mz_uint16)(
                    (int)d->m_huff_count[0][(mz_uint8)first_trigram] + 1);
                  }
                }
                else goto _LAND;
              }
              else {
                _LAND:
                {
                  mz_uint32 s0;
                  mz_uint32 s1;
                  int tmp_12;
                  mz_uint32 tmp_13;
                  if (cur_match_len < lookahead_size) cur_match_len = cur_match_len;
                  else cur_match_len = lookahead_size;
                  if (cur_match_len >= (mz_uint)TDEFL_MIN_MATCH_LEN) 
                    if (cur_match_dist >= (mz_uint)1) 
                      if (cur_match_dist <= (mz_uint)TDEFL_LZ_DICT_SIZE) 
                        tmp_12 = 1;
                      else tmp_12 = 0;
                    else tmp_12 = 0;
                  else tmp_12 = 0;
                  __FC_assert(tmp_12 != 0,"miniz_tdef.c",929,
                              "(cur_match_len >= TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 1) && (cur_match_dist <= TDEFL_LZ_DICT_SIZE)");
                  cur_match_dist --;
                  *(pLZ_code_buf + 0) = (mz_uint8)(cur_match_len - (mz_uint)TDEFL_MIN_MATCH_LEN);
                  memcpy((void *)(pLZ_code_buf + 1),
                         (void const *)(& cur_match_dist),
                         sizeof(cur_match_dist));
                  pLZ_code_buf += 3;
                  *pLZ_flags = (mz_uint8)(((int)*pLZ_flags >> 1) | 0x80);
                  s0 = (mz_uint32)s_tdefl_small_dist_sym[cur_match_dist & (unsigned int)511];
                  s1 = (mz_uint32)s_tdefl_large_dist_sym[cur_match_dist >> 8];
                  if (cur_match_dist < (mz_uint)512) tmp_13 = s0;
                  else tmp_13 = s1;
                  d->m_huff_count[1][tmp_13] = (mz_uint16)((int)d->m_huff_count[1][tmp_13] + 1);
                  d->m_huff_count[0][s_tdefl_len_sym[cur_match_len - (mz_uint)TDEFL_MIN_MATCH_LEN]] = (mz_uint16)(
                  (int)d->m_huff_count[0][s_tdefl_len_sym[cur_match_len - (mz_uint)TDEFL_MIN_MATCH_LEN]] + 1);
                }
              }
          }
          else goto _LAND_0;
        }
        else {
          _LAND_0:
          {
            mz_uint8 *tmp_14;
            tmp_14 = pLZ_code_buf;
            pLZ_code_buf ++;
            *tmp_14 = (mz_uint8)first_trigram;
            *pLZ_flags = (mz_uint8)((int)*pLZ_flags >> 1);
            d->m_huff_count[0][(mz_uint8)first_trigram] = (mz_uint16)(
            (int)d->m_huff_count[0][(mz_uint8)first_trigram] + 1);
          }
        }
        num_flags_left --;
        if (num_flags_left == (mz_uint)0) {
          mz_uint8 *tmp_16;
          num_flags_left = (mz_uint)8;
          tmp_16 = pLZ_code_buf;
          pLZ_code_buf ++;
          pLZ_flags = tmp_16;
        }
        total_lz_bytes += cur_match_len;
        lookahead_pos += cur_match_len;
        if (dict_size + cur_match_len < (mz_uint)TDEFL_LZ_DICT_SIZE) 
          dict_size += cur_match_len;
        else dict_size = (mz_uint)TDEFL_LZ_DICT_SIZE;
        cur_pos = (cur_pos + cur_match_len) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
        __FC_assert((lookahead_size >= cur_match_len) != 0,"miniz_tdef.c",
                    966,"lookahead_size >= cur_match_len");
        lookahead_size -= cur_match_len;
        if (pLZ_code_buf > & d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) {
          int n_0;
          d->m_lookahead_pos = lookahead_pos;
          d->m_lookahead_size = lookahead_size;
          d->m_dict_size = dict_size;
          d->m_total_lz_bytes = total_lz_bytes;
          d->m_pLZ_code_buf = pLZ_code_buf;
          d->m_pLZ_flags = pLZ_flags;
          d->m_num_flags_left = num_flags_left;
          n_0 = tdefl_flush_block(d,0);
          if (n_0 != 0) {
            int tmp_17;
            if (n_0 < 0) tmp_17 = 0; else tmp_17 = 1;
            __retres = tmp_17;
            goto return_label;
          }
          total_lz_bytes = d->m_total_lz_bytes;
          pLZ_code_buf = d->m_pLZ_code_buf;
          pLZ_flags = d->m_pLZ_flags;
          num_flags_left = d->m_num_flags_left;
        }
      }
      while (lookahead_size) {
        mz_uint8 *tmp_18;
        mz_uint8 lit = d->m_dict[cur_pos];
        total_lz_bytes ++;
        tmp_18 = pLZ_code_buf;
        pLZ_code_buf ++;
        *tmp_18 = lit;
        *pLZ_flags = (mz_uint8)((int)*pLZ_flags >> 1);
        num_flags_left --;
        if (num_flags_left == (mz_uint)0) {
          mz_uint8 *tmp_19;
          num_flags_left = (mz_uint)8;
          tmp_19 = pLZ_code_buf;
          pLZ_code_buf ++;
          pLZ_flags = tmp_19;
        }
        d->m_huff_count[0][lit] = (mz_uint16)((int)d->m_huff_count[0][lit] + 1);
        lookahead_pos ++;
        if (dict_size + (mz_uint)1 < (mz_uint)TDEFL_LZ_DICT_SIZE) dict_size += (mz_uint)1;
        else dict_size = (mz_uint)TDEFL_LZ_DICT_SIZE;
        cur_pos = (cur_pos + (mz_uint)1) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
        lookahead_size --;
        if (pLZ_code_buf > & d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) {
          int n_1;
          d->m_lookahead_pos = lookahead_pos;
          d->m_lookahead_size = lookahead_size;
          d->m_dict_size = dict_size;
          d->m_total_lz_bytes = total_lz_bytes;
          d->m_pLZ_code_buf = pLZ_code_buf;
          d->m_pLZ_flags = pLZ_flags;
          d->m_num_flags_left = num_flags_left;
          n_1 = tdefl_flush_block(d,0);
          if (n_1 != 0) {
            int tmp_20;
            if (n_1 < 0) tmp_20 = 0; else tmp_20 = 1;
            __retres = tmp_20;
            goto return_label;
          }
          total_lz_bytes = d->m_total_lz_bytes;
          pLZ_code_buf = d->m_pLZ_code_buf;
          pLZ_flags = d->m_pLZ_flags;
          num_flags_left = d->m_num_flags_left;
        }
      }
    }
  }
  d->m_lookahead_pos = lookahead_pos;
  d->m_lookahead_size = lookahead_size;
  d->m_dict_size = dict_size;
  d->m_total_lz_bytes = total_lz_bytes;
  d->m_pLZ_code_buf = pLZ_code_buf;
  d->m_pLZ_flags = pLZ_flags;
  d->m_num_flags_left = num_flags_left;
  __retres = 1;
  return_label: return __retres;
}

__inline static void ( __attribute__((__always_inline__)) tdefl_record_literal)
(tdefl_compressor *d, mz_uint8 lit)
{
  mz_uint8 *tmp;
  (d->m_total_lz_bytes) ++;
  tmp = d->m_pLZ_code_buf;
  (d->m_pLZ_code_buf) ++;
  *tmp = lit;
  *(d->m_pLZ_flags) = (mz_uint8)((int)*(d->m_pLZ_flags) >> 1);
  (d->m_num_flags_left) --;
  if (d->m_num_flags_left == (mz_uint)0) {
    mz_uint8 *tmp_0;
    d->m_num_flags_left = (mz_uint)8;
    tmp_0 = d->m_pLZ_code_buf;
    (d->m_pLZ_code_buf) ++;
    d->m_pLZ_flags = tmp_0;
  }
  d->m_huff_count[0][lit] = (mz_uint16)((int)d->m_huff_count[0][lit] + 1);
  return;
}

__inline static void ( __attribute__((__always_inline__)) tdefl_record_match)
(tdefl_compressor *d, mz_uint match_len, mz_uint match_dist)
{
  mz_uint32 s0;
  mz_uint32 s1;
  int tmp;
  mz_uint32 tmp_1;
  if (match_len >= (mz_uint)TDEFL_MIN_MATCH_LEN) 
    if (match_dist >= (mz_uint)1) 
      if (match_dist <= (mz_uint)TDEFL_LZ_DICT_SIZE) tmp = 1; else tmp = 0;
    else tmp = 0;
  else tmp = 0;
  __FC_assert(tmp != 0,"miniz_tdef.c",1056,
              "(match_len >= TDEFL_MIN_MATCH_LEN) && (match_dist >= 1) && (match_dist <= TDEFL_LZ_DICT_SIZE)");
  d->m_total_lz_bytes += match_len;
  *(d->m_pLZ_code_buf + 0) = (mz_uint8)(match_len - (mz_uint)TDEFL_MIN_MATCH_LEN);
  match_dist -= (mz_uint)1;
  *(d->m_pLZ_code_buf + 1) = (mz_uint8)(match_dist & (unsigned int)0xFF);
  *(d->m_pLZ_code_buf + 2) = (mz_uint8)(match_dist >> 8);
  d->m_pLZ_code_buf += 3;
  *(d->m_pLZ_flags) = (mz_uint8)(((int)*(d->m_pLZ_flags) >> 1) | 0x80);
  (d->m_num_flags_left) --;
  if (d->m_num_flags_left == (mz_uint)0) {
    mz_uint8 *tmp_0;
    d->m_num_flags_left = (mz_uint)8;
    tmp_0 = d->m_pLZ_code_buf;
    (d->m_pLZ_code_buf) ++;
    d->m_pLZ_flags = tmp_0;
  }
  s0 = (mz_uint32)s_tdefl_small_dist_sym[match_dist & (unsigned int)511];
  s1 = (mz_uint32)s_tdefl_large_dist_sym[(match_dist >> 8) & (unsigned int)127];
  if (match_dist < (mz_uint)512) tmp_1 = s0; else tmp_1 = s1;
  d->m_huff_count[1][tmp_1] = (mz_uint16)((int)d->m_huff_count[1][tmp_1] + 1);
  if (match_len >= (mz_uint)TDEFL_MIN_MATCH_LEN) d->m_huff_count[0][s_tdefl_len_sym[
                                                 match_len - (mz_uint)TDEFL_MIN_MATCH_LEN]] = (mz_uint16)(
                                                 (int)d->m_huff_count[0][s_tdefl_len_sym[
                                                 match_len - (mz_uint)TDEFL_MIN_MATCH_LEN]] + 1);
  return;
}

static mz_bool tdefl_compress_normal(tdefl_compressor *d)
{
  mz_bool __retres;
  mz_uint8 const *pSrc = d->m_pSrc;
  size_t src_buf_left = d->m_src_buf_left;
  tdefl_flush flush = d->m_flush;
  while (1) {
    if (! src_buf_left) 
      if (flush) {
        if (! d->m_lookahead_size) break;
      }
      else break;
    {
      mz_uint len_to_move;
      mz_uint cur_match_dist;
      mz_uint cur_match_len;
      mz_uint cur_pos;
      if (d->m_lookahead_size + d->m_dict_size >= (mz_uint)(TDEFL_MIN_MATCH_LEN - 1)) {
        size_t tmp;
        mz_uint dst_pos =
          (d->m_lookahead_pos + d->m_lookahead_size) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
        mz_uint ins_pos =
          (d->m_lookahead_pos + d->m_lookahead_size) - (mz_uint)2;
        mz_uint hash =
          (mz_uint)(((int)d->m_dict[ins_pos & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT) ^ (int)d->m_dict[
                    (ins_pos + (mz_uint)1) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK]);
        if (src_buf_left < (size_t)((mz_uint)TDEFL_MAX_MATCH_LEN - d->m_lookahead_size)) 
          tmp = src_buf_left;
        else tmp = (size_t)((mz_uint)TDEFL_MAX_MATCH_LEN - d->m_lookahead_size);
        mz_uint num_bytes_to_process = (mz_uint)tmp;
        mz_uint8 const *pSrc_end = pSrc + num_bytes_to_process;
        src_buf_left -= (size_t)num_bytes_to_process;
        d->m_lookahead_size += num_bytes_to_process;
        while (pSrc != pSrc_end) {
          mz_uint8 const *tmp_0;
          tmp_0 = pSrc;
          pSrc ++;
          mz_uint8 c = *tmp_0;
          d->m_dict[dst_pos] = c;
          if (dst_pos < (mz_uint)(TDEFL_MAX_MATCH_LEN - 1)) d->m_dict[
                                                            (mz_uint)TDEFL_LZ_DICT_SIZE + dst_pos] = c;
          hash = ((hash << TDEFL_LZ_HASH_SHIFT) ^ (unsigned int)c) & (unsigned int)(
                 TDEFL_LZ_HASH_SIZE - 1);
          d->m_next[ins_pos & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash];
          d->m_hash[hash] = (mz_uint16)ins_pos;
          dst_pos = (dst_pos + (mz_uint)1) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
          ins_pos ++;
        }
      }
      else 
        while (1) {
          if (src_buf_left) {
            if (! (d->m_lookahead_size < (mz_uint)TDEFL_MAX_MATCH_LEN)) 
              break;
          }
          else break;
          {
            mz_uint8 const *tmp_1;
            tmp_1 = pSrc;
            pSrc ++;
            mz_uint8 c_0 = *tmp_1;
            mz_uint dst_pos_0 =
              (d->m_lookahead_pos + d->m_lookahead_size) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
            src_buf_left --;
            d->m_dict[dst_pos_0] = c_0;
            if (dst_pos_0 < (mz_uint)(TDEFL_MAX_MATCH_LEN - 1)) d->m_dict[
                                                                (mz_uint)TDEFL_LZ_DICT_SIZE + dst_pos_0] = c_0;
            (d->m_lookahead_size) ++;
            ;
            if (d->m_lookahead_size + d->m_dict_size >= (mz_uint)TDEFL_MIN_MATCH_LEN) {
              mz_uint ins_pos_0 =
                (d->m_lookahead_pos + (d->m_lookahead_size - (mz_uint)1)) - (mz_uint)2;
              mz_uint hash_0 =
                (mz_uint)(((((int)d->m_dict[ins_pos_0 & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK] << 
                             TDEFL_LZ_HASH_SHIFT * 2) ^ ((int)d->m_dict[
                                                         (ins_pos_0 + (mz_uint)1) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT)) ^ (int)c_0) & (
                          TDEFL_LZ_HASH_SIZE - 1));
              d->m_next[ins_pos_0 & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash_0];
              d->m_hash[hash_0] = (mz_uint16)ins_pos_0;
            }
          }
        }
      if ((mz_uint)TDEFL_LZ_DICT_SIZE - d->m_lookahead_size < d->m_dict_size) 
        d->m_dict_size = (mz_uint)TDEFL_LZ_DICT_SIZE - d->m_lookahead_size;
      else d->m_dict_size = d->m_dict_size;
      if (! flush) 
        if (d->m_lookahead_size < (mz_uint)TDEFL_MAX_MATCH_LEN) break;
      len_to_move = (mz_uint)1;
      cur_match_dist = (mz_uint)0;
      if (d->m_saved_match_len) cur_match_len = d->m_saved_match_len;
      else cur_match_len = (mz_uint)(TDEFL_MIN_MATCH_LEN - 1);
      cur_pos = d->m_lookahead_pos & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
      if (d->m_flags & (unsigned int)(TDEFL_RLE_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS)) {
        if (d->m_dict_size) 
          if (! (d->m_flags & (unsigned int)TDEFL_FORCE_ALL_RAW_BLOCKS)) {
            mz_uint8 c_1 =
              d->m_dict[(cur_pos - (mz_uint)1) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK];
            cur_match_len = (mz_uint)0;
            while (cur_match_len < d->m_lookahead_size) {
              if ((int)d->m_dict[cur_pos + cur_match_len] != (int)c_1) 
                break;
              cur_match_len ++;
            }
            if (cur_match_len < (mz_uint)TDEFL_MIN_MATCH_LEN) cur_match_len = (mz_uint)0;
            else cur_match_dist = (mz_uint)1;
          }
      }
      else tdefl_find_match(d,d->m_lookahead_pos,d->m_dict_size,
                            d->m_lookahead_size,& cur_match_dist,
                            & cur_match_len);
      if (cur_match_len == (mz_uint)TDEFL_MIN_MATCH_LEN) {
        if (cur_match_dist >= 8U * 1024U) goto _LOR; else goto _LAND;
      }
      else {
        _LAND: ;
        if (cur_pos == cur_match_dist) goto _LOR;
        else 
          if (d->m_flags & (unsigned int)TDEFL_FILTER_MATCHES) 
            if (cur_match_len <= (mz_uint)5) {
              _LOR:
              {
                cur_match_len = (mz_uint)0;
                cur_match_dist = cur_match_len;
              }
            }
      }
      if (d->m_saved_match_len) 
        if (cur_match_len > d->m_saved_match_len) {
          tdefl_record_literal(d,(mz_uint8)d->m_saved_lit);
          if (cur_match_len >= (mz_uint)128) {
            tdefl_record_match(d,cur_match_len,cur_match_dist);
            d->m_saved_match_len = (mz_uint)0;
            len_to_move = cur_match_len;
          }
          else {
            d->m_saved_lit = (mz_uint)d->m_dict[cur_pos];
            d->m_saved_match_dist = cur_match_dist;
            d->m_saved_match_len = cur_match_len;
          }
        }
        else {
          tdefl_record_match(d,d->m_saved_match_len,d->m_saved_match_dist);
          len_to_move = d->m_saved_match_len - (mz_uint)1;
          d->m_saved_match_len = (mz_uint)0;
        }
      else 
        if (! cur_match_dist) {
          unsigned long tmp_2;
          if ((unsigned long)cur_pos < sizeof(d->m_dict) - (unsigned long)1) 
            tmp_2 = (unsigned long)cur_pos;
          else tmp_2 = sizeof(d->m_dict) - (unsigned long)1;
          ;
          ;
          tdefl_record_literal(d,d->m_dict[tmp_2]);
        }
        else 
          if (d->m_greedy_parsing) goto _LOR_0;
          else 
            if (d->m_flags & (unsigned int)TDEFL_RLE_MATCHES) goto _LOR_0;
            else 
              if (cur_match_len >= (mz_uint)128) {
                _LOR_0:
                {
                  tdefl_record_match(d,cur_match_len,cur_match_dist);
                  len_to_move = cur_match_len;
                }
              }
              else {
                unsigned long tmp_3;
                if ((unsigned long)cur_pos < sizeof(d->m_dict) - (unsigned long)1) 
                  tmp_3 = (unsigned long)cur_pos;
                else tmp_3 = sizeof(d->m_dict) - (unsigned long)1;
                d->m_saved_lit = (mz_uint)d->m_dict[tmp_3];
                d->m_saved_match_dist = cur_match_dist;
                d->m_saved_match_len = cur_match_len;
              }
      d->m_lookahead_pos += len_to_move;
      __FC_assert((d->m_lookahead_size >= len_to_move) != 0,"miniz_tdef.c",
                  1207,"d->m_lookahead_size >= len_to_move");
      d->m_lookahead_size -= len_to_move;
      if (d->m_dict_size + len_to_move < (mz_uint)TDEFL_LZ_DICT_SIZE) 
        d->m_dict_size += len_to_move;
      else d->m_dict_size = (mz_uint)TDEFL_LZ_DICT_SIZE;
      if (d->m_pLZ_code_buf > & d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) 
        goto _LOR_2;
      else 
        if (d->m_total_lz_bytes > (mz_uint)(31 * 1024)) 
          if ((mz_uint)(d->m_pLZ_code_buf - d->m_lz_code_buf) * (mz_uint)115 >> 7 >= d->m_total_lz_bytes) 
            goto _LOR_2;
          else 
            if (d->m_flags & (unsigned int)TDEFL_FORCE_ALL_RAW_BLOCKS) {
              _LOR_2:
              {
                int n;
                d->m_pSrc = pSrc;
                d->m_src_buf_left = src_buf_left;
                n = tdefl_flush_block(d,0);
                if (n != 0) {
                  int tmp_4;
                  if (n < 0) tmp_4 = 0; else tmp_4 = 1;
                  __retres = tmp_4;
                  goto return_label;
                }
              }
            }
    }
  }
  d->m_pSrc = pSrc;
  d->m_src_buf_left = src_buf_left;
  __retres = 1;
  return_label: return __retres;
}

static tdefl_status tdefl_flush_output_buffer(tdefl_compressor *d)
{
  int tmp_0;
  if (d->m_pIn_buf_size) *(d->m_pIn_buf_size) = (size_t)(d->m_pSrc - (mz_uint8 const *)d->m_pIn_buf);
  if (d->m_pOut_buf_size) {
    size_t tmp;
    if (*(d->m_pOut_buf_size) - d->m_out_buf_ofs < (size_t)d->m_output_flush_remaining) 
      tmp = *(d->m_pOut_buf_size) - d->m_out_buf_ofs;
    else tmp = (size_t)d->m_output_flush_remaining;
    size_t n = tmp;
    memcpy((void *)((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs),
           (void const *)(& d->m_output_buf[d->m_output_flush_ofs]),n);
    d->m_output_flush_ofs += (mz_uint)n;
    d->m_output_flush_remaining -= (mz_uint)n;
    d->m_out_buf_ofs += n;
    *(d->m_pOut_buf_size) = d->m_out_buf_ofs;
  }
  if (d->m_finished) 
    if (! d->m_output_flush_remaining) tmp_0 = TDEFL_STATUS_DONE;
    else tmp_0 = TDEFL_STATUS_OKAY;
  else tmp_0 = TDEFL_STATUS_OKAY;
  return tmp_0;
}

tdefl_status __attribute__((__visibility__("default"))) tdefl_compress
(tdefl_compressor *d, void const *pIn_buf, size_t *pIn_buf_size,
 void *pOut_buf, size_t *pOut_buf_size, tdefl_flush flush)
{
  tdefl_status __attribute__((__visibility__("default"))) __retres;
  int tmp_0;
  tdefl_status tmp_6;
  if (! d) {
    if (pIn_buf_size) *pIn_buf_size = (size_t)0;
    if (pOut_buf_size) *pOut_buf_size = (size_t)0;
    __retres = TDEFL_STATUS_BAD_PARAM;
    goto return_label;
  }
  d->m_pIn_buf = pIn_buf;
  d->m_pIn_buf_size = pIn_buf_size;
  d->m_pOut_buf = pOut_buf;
  d->m_pOut_buf_size = pOut_buf_size;
  d->m_pSrc = (mz_uint8 const *)pIn_buf;
  if (pIn_buf_size) d->m_src_buf_left = *pIn_buf_size;
  else d->m_src_buf_left = (size_t)0;
  d->m_out_buf_ofs = (size_t)0;
  d->m_flush = flush;
  if (pOut_buf != (void *)0) tmp_0 = 1;
  else 
    if (pOut_buf_size != (size_t *)0) tmp_0 = 1; else tmp_0 = 0;
  ;
  if ((d->m_pPut_buf_func != (mz_bool (*)(void const *pBuf, int len,
                                          void *pUser))0) == tmp_0) goto _LOR;
  else 
    if (d->m_prev_return_status != TDEFL_STATUS_OKAY) goto _LOR;
    else 
      if (d->m_wants_to_finish) {
        if (flush != (unsigned int)TDEFL_FINISH) goto _LOR;
        else goto _LAND_1;
      }
      else {
        _LAND_1: ;
        if (pIn_buf_size) {
          if (*pIn_buf_size) {
            if (! pIn_buf) goto _LOR; else goto _LAND_0;
          }
          else goto _LAND_0;
        }
        else {
          _LAND_0: ;
          if (pOut_buf_size) 
            if (*pOut_buf_size) 
              if (! pOut_buf) {
                _LOR:
                {
                  tdefl_status tmp;
                  if (pIn_buf_size) *pIn_buf_size = (size_t)0;
                  if (pOut_buf_size) *pOut_buf_size = (size_t)0;
                  tmp = TDEFL_STATUS_BAD_PARAM;
                  d->m_prev_return_status = tmp;
                  __retres = (tdefl_status __attribute__((__visibility__("default"))))tmp;
                  goto return_label;
                }
              }
        }
      }
  d->m_wants_to_finish |= (unsigned int)(flush == (unsigned int)TDEFL_FINISH);
  if (d->m_output_flush_remaining) goto _LOR_0;
  else 
    if (d->m_finished) {
      tdefl_status tmp_1;
      _LOR_0: tmp_1 = tdefl_flush_output_buffer(d);
      d->m_prev_return_status = tmp_1;
      __retres = (tdefl_status __attribute__((__visibility__("default"))))tmp_1;
      goto return_label;
    }
  if ((d->m_flags & (unsigned int)TDEFL_MAX_PROBES_MASK) == (unsigned int)1) {
    if ((d->m_flags & (unsigned int)TDEFL_GREEDY_PARSING_FLAG) != (unsigned int)0) {
      if ((d->m_flags & (unsigned int)((TDEFL_FILTER_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS) | TDEFL_RLE_MATCHES)) == (unsigned int)0) {
        mz_bool tmp_2;
        tmp_2 = tdefl_compress_fast(d);
        if (! tmp_2) {
          __retres = (tdefl_status __attribute__((__visibility__("default"))))d->m_prev_return_status;
          goto return_label;
        }
      }
      else goto _LAND_3;
    }
    else goto _LAND_3;
  }
  else {
    _LAND_3:
    {
      mz_bool tmp_3;
      tmp_3 = tdefl_compress_normal(d);
      if (! tmp_3) {
        __retres = (tdefl_status __attribute__((__visibility__("default"))))d->m_prev_return_status;
        goto return_label;
      }
    }
  }
  if (d->m_flags & (unsigned int)(TDEFL_WRITE_ZLIB_HEADER | TDEFL_COMPUTE_ADLER32)) 
    if (pIn_buf) {
      mz_ulong __attribute__((__visibility__("default"))) tmp_4;
      tmp_4 = mz_adler32((mz_ulong)d->m_adler32,(mz_uint8 const *)pIn_buf,
                         (size_t)(d->m_pSrc - (mz_uint8 const *)pIn_buf));
      d->m_adler32 = (mz_uint32)tmp_4;
    }
  if (flush) 
    if (! d->m_lookahead_size) 
      if (! d->m_src_buf_left) 
        if (! d->m_output_flush_remaining) {
          int tmp_5;
          tmp_5 = tdefl_flush_block(d,(int)flush);
          if (tmp_5 < 0) {
            __retres = (tdefl_status __attribute__((__visibility__("default"))))d->m_prev_return_status;
            goto return_label;
          }
          d->m_finished = (mz_uint)(flush == (unsigned int)TDEFL_FINISH);
          if (flush == (unsigned int)TDEFL_FULL_FLUSH) {
            memset((void *)(& d->m_hash),0,sizeof(d->m_hash));
            memset((void *)(& d->m_next),0,sizeof(d->m_next));
            d->m_dict_size = (mz_uint)0;
          }
        }
  tmp_6 = tdefl_flush_output_buffer(d);
  d->m_prev_return_status = tmp_6;
  __retres = (tdefl_status __attribute__((__visibility__("default"))))tmp_6;
  return_label: return __retres;
}

tdefl_status __attribute__((__visibility__("default"))) tdefl_compress_buffer
(tdefl_compressor *d, void const *pIn_buf, size_t in_buf_size,
 tdefl_flush flush)
{
  tdefl_status __attribute__((__visibility__("default"))) tmp;
  __FC_assert(d->m_pPut_buf_func != (mz_bool (*)(void const *pBuf, int len,
                                                 void *pUser))0,
              "miniz_tdef.c",1318,"d->m_pPut_buf_func");
  tmp = tdefl_compress(d,pIn_buf,& in_buf_size,(void *)0,(size_t *)0,flush);
  return tmp;
}

tdefl_status __attribute__((__visibility__("default"))) tdefl_init(tdefl_compressor *d,
                                                                   mz_bool (*pPut_buf_func)
                                                                   (void const *pBuf,
                                                                    int len,
                                                                    void *pUser),
                                                                   void *pPut_buf_user,
                                                                   int flags)
{
  tdefl_status __attribute__((__visibility__("default"))) __retres;
  mz_uint tmp_3;
  mz_uint tmp_2;
  mz_uint tmp_1;
  mz_uint tmp_0;
  mz_uint tmp;
  mz_uint tmp_8;
  mz_uint tmp_7;
  mz_uint tmp_6;
  mz_uint tmp_5;
  mz_uint tmp_4;
  mz_uint tmp_10;
  mz_uint tmp_9;
  d->m_pPut_buf_func = pPut_buf_func;
  d->m_pPut_buf_user = pPut_buf_user;
  d->m_flags = (mz_uint)flags;
  d->m_max_probes[0] = (mz_uint)(1 + ((flags & 0xFFF) + 2) / 3);
  d->m_greedy_parsing = (flags & TDEFL_GREEDY_PARSING_FLAG) != 0;
  d->m_max_probes[1] = (mz_uint)(1 + (((flags & 0xFFF) >> 2) + 2) / 3);
  if (! (flags & TDEFL_NONDETERMINISTIC_PARSING_FLAG)) memset((void *)(& d->m_hash),
                                                              0,
                                                              sizeof(d->m_hash));
  tmp_3 = (mz_uint)0;
  d->m_bits_in = tmp_3;
  tmp_2 = tmp_3;
  d->m_lz_code_buf_dict_pos = tmp_2;
  tmp_1 = tmp_2;
  d->m_total_lz_bytes = tmp_1;
  tmp_0 = tmp_1;
  d->m_dict_size = tmp_0;
  tmp = tmp_0;
  d->m_lookahead_size = tmp;
  d->m_lookahead_pos = tmp;
  tmp_8 = (mz_uint)0;
  d->m_wants_to_finish = tmp_8;
  tmp_7 = tmp_8;
  d->m_bit_buffer = tmp_7;
  tmp_6 = tmp_7;
  d->m_block_index = tmp_6;
  tmp_5 = tmp_6;
  d->m_finished = tmp_5;
  tmp_4 = tmp_5;
  d->m_output_flush_remaining = tmp_4;
  d->m_output_flush_ofs = tmp_4;
  d->m_pLZ_code_buf = & d->m_lz_code_buf[1];
  d->m_pLZ_flags = d->m_lz_code_buf;
  *(d->m_pLZ_flags) = (mz_uint8)0;
  d->m_num_flags_left = (mz_uint)8;
  d->m_pOutput_buf = d->m_output_buf;
  d->m_pOutput_buf_end = d->m_output_buf;
  d->m_prev_return_status = TDEFL_STATUS_OKAY;
  tmp_10 = (mz_uint)0;
  d->m_saved_lit = tmp_10;
  tmp_9 = tmp_10;
  d->m_saved_match_len = tmp_9;
  d->m_saved_match_dist = tmp_9;
  d->m_adler32 = (mz_uint)1;
  d->m_pIn_buf = (void const *)0;
  d->m_pOut_buf = (void *)0;
  d->m_pIn_buf_size = (size_t *)0;
  d->m_pOut_buf_size = (size_t *)0;
  d->m_flush = TDEFL_NO_FLUSH;
  d->m_pSrc = (mz_uint8 const *)0;
  d->m_src_buf_left = (size_t)0;
  d->m_out_buf_ofs = (size_t)0;
  if (! (flags & TDEFL_NONDETERMINISTIC_PARSING_FLAG)) memset((void *)(& d->m_dict),
                                                              0,
                                                              sizeof(d->m_dict));
  memset((void *)(& d->m_huff_count[0][0]),0,
         sizeof(d->m_huff_count[0][0]) * (unsigned long)TDEFL_MAX_HUFF_SYMBOLS_0);
  memset((void *)(& d->m_huff_count[1][0]),0,
         sizeof(d->m_huff_count[1][0]) * (unsigned long)TDEFL_MAX_HUFF_SYMBOLS_1);
  __retres = TDEFL_STATUS_OKAY;
  return __retres;
}

tdefl_status __attribute__((__visibility__("default"))) tdefl_get_prev_return_status
(tdefl_compressor *d)
{
  tdefl_status __attribute__((__visibility__("default"))) __retres;
  __retres = (tdefl_status __attribute__((__visibility__("default"))))d->m_prev_return_status;
  return __retres;
}

mz_uint32 __attribute__((__visibility__("default"))) tdefl_get_adler32
(tdefl_compressor *d)
{
  mz_uint32 __attribute__((__visibility__("default"))) __retres;
  __retres = (mz_uint32 __attribute__((__visibility__("default"))))d->m_adler32;
  return __retres;
}

mz_bool __attribute__((__visibility__("default"))) tdefl_compress_mem_to_output
(void const *pBuf, size_t buf_len,
 mz_bool (*pPut_buf_func)(void const *pBuf, int len, void *pUser),
 void *pPut_buf_user, int flags)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  tdefl_compressor *pComp;
  mz_bool succeeded;
  tdefl_status __attribute__((__visibility__("default"))) tmp_0;
  int tmp_2;
  if (buf_len) {
    if (! pBuf) {
      __retres = (mz_bool __attribute__((__visibility__("default"))))0;
      goto return_label;
    }
    else goto _LAND;
  }
  else 
    _LAND:
    if (! pPut_buf_func) {
      __retres = (mz_bool __attribute__((__visibility__("default"))))0;
      goto return_label;
    }
  pComp = (tdefl_compressor *)malloc(sizeof(tdefl_compressor));
  if (! pComp) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  tmp_0 = tdefl_init(pComp,pPut_buf_func,pPut_buf_user,flags);
  succeeded = tmp_0 == (int __attribute__((__visibility__("default"))))TDEFL_STATUS_OKAY;
  if (succeeded) {
    tdefl_status __attribute__((__visibility__("default"))) tmp_1;
    tmp_1 = tdefl_compress_buffer(pComp,pBuf,buf_len,TDEFL_FINISH);
    if (tmp_1 == (int __attribute__((__visibility__("default"))))TDEFL_STATUS_DONE) 
      tmp_2 = 1;
    else tmp_2 = 0;
  }
  else tmp_2 = 0;
  succeeded = tmp_2;
  free((void *)pComp);
  __retres = (mz_bool __attribute__((__visibility__("default"))))succeeded;
  return_label: return __retres;
}

static mz_bool tdefl_output_buffer_putter(void const *pBuf, int len,
                                          void *pUser)
{
  mz_bool __retres;
  tdefl_output_buffer *p = (tdefl_output_buffer *)pUser;
  size_t new_size = p->m_size + (size_t)len;
  if (new_size > p->m_capacity) {
    mz_uint8 *pNew_buf;
    size_t new_capacity = p->m_capacity;
    if (! p->m_expandable) {
      __retres = 0;
      goto return_label;
    }
    while (1) {
      if ((size_t)128U > new_capacity << 1U) new_capacity = (size_t)128U;
      else new_capacity <<= 1U;
      if (! (new_size > new_capacity)) break;
    }
    pNew_buf = (mz_uint8 *)realloc((void *)p->m_pBuf,new_capacity);
    if (! pNew_buf) {
      __retres = 0;
      goto return_label;
    }
    p->m_pBuf = pNew_buf;
    p->m_capacity = new_capacity;
  }
  memcpy((void *)(p->m_pBuf + p->m_size),pBuf,(size_t)len);
  p->m_size = new_size;
  __retres = 1;
  return_label: return __retres;
}

void __attribute__((__visibility__("default"))) *tdefl_compress_mem_to_heap
(void const *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)
{
  void __attribute__((__visibility__("default"))) *__retres;
  tdefl_output_buffer out_buf;
  mz_bool __attribute__((__visibility__("default"))) tmp;
  memset((void *)(& out_buf),0,sizeof(out_buf));
  if (! pOut_len) {
    __retres = (void __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  else *pOut_len = (size_t)0;
  out_buf.m_expandable = 1;
  tmp = tdefl_compress_mem_to_output(pSrc_buf,src_buf_len,
                                     & tdefl_output_buffer_putter,
                                     (void *)(& out_buf),flags);
  if (! tmp) {
    __retres = (void __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  *pOut_len = out_buf.m_size;
  __retres = (void __attribute__((__visibility__("default"))) *)out_buf.m_pBuf;
  return_label: return __retres;
}

size_t __attribute__((__visibility__("default"))) tdefl_compress_mem_to_mem
(void *pOut_buf, size_t out_buf_len, void const *pSrc_buf,
 size_t src_buf_len, int flags)
{
  size_t __attribute__((__visibility__("default"))) __retres;
  tdefl_output_buffer out_buf;
  mz_bool __attribute__((__visibility__("default"))) tmp;
  memset((void *)(& out_buf),0,sizeof(out_buf));
  if (! pOut_buf) {
    __retres = (size_t __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  out_buf.m_pBuf = (mz_uint8 *)pOut_buf;
  out_buf.m_capacity = out_buf_len;
  tmp = tdefl_compress_mem_to_output(pSrc_buf,src_buf_len,
                                     & tdefl_output_buffer_putter,
                                     (void *)(& out_buf),flags);
  if (! tmp) {
    __retres = (size_t __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  __retres = (size_t __attribute__((__visibility__("default"))))out_buf.m_size;
  return_label: return __retres;
}

static mz_uint const s_tdefl_num_probes[11] =
  {(mz_uint)0,
   (mz_uint)1,
   (mz_uint)6,
   (mz_uint)32,
   (mz_uint)16,
   (mz_uint)32,
   (mz_uint)128,
   (mz_uint)256,
   (mz_uint)512,
   (mz_uint)768,
   (mz_uint)1500};
mz_uint __attribute__((__visibility__("default"))) tdefl_create_comp_flags_from_zip_params
(int level, int window_bits, int strategy)
{
  mz_uint __attribute__((__visibility__("default"))) __retres;
  int tmp_0;
  int tmp_1;
  if (level >= 0) {
    int tmp;
    if (10 < level) tmp = 10; else tmp = level;
    tmp_0 = tmp;
  }
  else tmp_0 = MZ_DEFAULT_LEVEL;
  if (level <= 3) tmp_1 = TDEFL_GREEDY_PARSING_FLAG; else tmp_1 = 0;
  mz_uint comp_flags = s_tdefl_num_probes[tmp_0] | (unsigned int)tmp_1;
  if (window_bits > 0) comp_flags |= (unsigned int)TDEFL_WRITE_ZLIB_HEADER;
  if (! level) comp_flags |= (unsigned int)TDEFL_FORCE_ALL_RAW_BLOCKS;
  else 
    if (strategy == MZ_FILTERED) comp_flags |= (unsigned int)TDEFL_FILTER_MATCHES;
    else 
      if (strategy == MZ_HUFFMAN_ONLY) comp_flags &= (unsigned int)(~ TDEFL_MAX_PROBES_MASK);
      else 
        if (strategy == MZ_FIXED) comp_flags |= (unsigned int)TDEFL_FORCE_ALL_STATIC_BLOCKS;
        else 
          if (strategy == MZ_RLE) comp_flags |= (unsigned int)TDEFL_RLE_MATCHES;
  __retres = (mz_uint __attribute__((__visibility__("default"))))comp_flags;
  return __retres;
}

static mz_uint const tdefl_write_image_to_png_file_in_memory_ex_s_tdefl_png_num_probes[11] =
  {(mz_uint)0,
   (mz_uint)1,
   (mz_uint)6,
   (mz_uint)32,
   (mz_uint)16,
   (mz_uint)32,
   (mz_uint)128,
   (mz_uint)256,
   (mz_uint)512,
   (mz_uint)768,
   (mz_uint)1500};
static mz_uint8 const tdefl_write_image_to_png_file_in_memory_ex_chans[5] =
  {(mz_uint8)0x00,
   (mz_uint8)0x00,
   (mz_uint8)0x04,
   (mz_uint8)0x02,
   (mz_uint8)0x06};
void __attribute__((__visibility__("default"))) *tdefl_write_image_to_png_file_in_memory_ex
(void const *pImage, int w, int h, int num_chans, size_t *pLen_out,
 mz_uint level, mz_bool flip)
{
  void __attribute__((__visibility__("default"))) *__retres;
  tdefl_output_buffer out_buf;
  int i;
  int y;
  int z;
  mz_uint32 c;
  int tmp_0;
  mz_uint tmp_2;
  tdefl_status __attribute__((__visibility__("default"))) tmp_4;
  mz_bool tmp_6;
  mz_ulong __attribute__((__visibility__("default"))) tmp_7;
  tdefl_compressor *pComp = malloc(sizeof(tdefl_compressor));
  int bpl = w * num_chans;
  *pLen_out = (size_t)0;
  if (! pComp) {
    __retres = (void __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  memset((void *)(& out_buf),0,sizeof(out_buf));
  out_buf.m_expandable = 1;
  if (64 > (1 + bpl) * h) tmp_0 = 64; else tmp_0 = (1 + bpl) * h;
  out_buf.m_capacity = (size_t)(57 + tmp_0);
  out_buf.m_pBuf = (mz_uint8 *)malloc(out_buf.m_capacity);
  if ((mz_uint8 *)0 == out_buf.m_pBuf) {
    free((void *)pComp);
    __retres = (void __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  z = 41;
  while (z) {
    tdefl_output_buffer_putter((void const *)(& z),1,(void *)(& out_buf));
    z --;
  }
  if ((mz_uint)10 < level) tmp_2 = (mz_uint)10; else tmp_2 = level;
  ;
  ;
  tdefl_init(pComp,& tdefl_output_buffer_putter,(void *)(& out_buf),
             (int)(tdefl_write_image_to_png_file_in_memory_ex_s_tdefl_png_num_probes[tmp_2] | (unsigned int)TDEFL_WRITE_ZLIB_HEADER));
  y = 0;
  while (y < h) {
    {
      int tmp_3;
      tdefl_compress_buffer(pComp,(void const *)(& z),(size_t)1,
                            TDEFL_NO_FLUSH);
      ;
      if (flip) tmp_3 = (h - 1) - y; else tmp_3 = y;
      ;
      ;
      tdefl_compress_buffer(pComp,
                            (void const *)((mz_uint8 *)pImage + tmp_3 * bpl),
                            (size_t)bpl,TDEFL_NO_FLUSH);
    }
    y ++;
  }
  tmp_4 = tdefl_compress_buffer(pComp,(void const *)0,(size_t)0,TDEFL_FINISH);
  if (tmp_4 != (int __attribute__((__visibility__("default"))))TDEFL_STATUS_DONE) {
    free((void *)pComp);
    free((void *)out_buf.m_pBuf);
    __retres = (void __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  *pLen_out = out_buf.m_size - (size_t)41;
  {
    mz_ulong __attribute__((__visibility__("default"))) tmp_5;
    mz_uint8 pnghdr[41] =
      {(mz_uint8)0x89,
       (mz_uint8)0x50,
       (mz_uint8)0x4e,
       (mz_uint8)0x47,
       (mz_uint8)0x0d,
       (mz_uint8)0x0a,
       (mz_uint8)0x1a,
       (mz_uint8)0x0a,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x0d,
       (mz_uint8)0x49,
       (mz_uint8)0x48,
       (mz_uint8)0x44,
       (mz_uint8)0x52,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x08,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x49,
       (mz_uint8)0x44,
       (mz_uint8)0x41,
       (mz_uint8)0x54};
    pnghdr[18] = (mz_uint8)(w >> 8);
    pnghdr[19] = (mz_uint8)w;
    pnghdr[22] = (mz_uint8)(h >> 8);
    pnghdr[23] = (mz_uint8)h;
    pnghdr[25] = tdefl_write_image_to_png_file_in_memory_ex_chans[num_chans];
    pnghdr[33] = (mz_uint8)(*pLen_out >> 24);
    pnghdr[34] = (mz_uint8)(*pLen_out >> 16);
    pnghdr[35] = (mz_uint8)(*pLen_out >> 8);
    pnghdr[36] = (mz_uint8)*pLen_out;
    tmp_5 = mz_crc32((mz_ulong)0,(unsigned char const *)(& pnghdr[12]),
                     (size_t)17);
    c = (mz_uint32)tmp_5;
    i = 0;
    while (i < 4) {
      *(& pnghdr[29] + i) = (mz_uint8)(c >> 24);
      i ++;
      c <<= 8;
    }
    memcpy((void *)out_buf.m_pBuf,(void const *)(pnghdr),(size_t)41);
  }
  tmp_6 = tdefl_output_buffer_putter((void const *)"\000\000\000\000\000\000\000\000IEND\256B`\202",
                                     16,(void *)(& out_buf));
  if (! tmp_6) {
    *pLen_out = (size_t)0;
    free((void *)pComp);
    free((void *)out_buf.m_pBuf);
    __retres = (void __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  tmp_7 = mz_crc32((mz_ulong)0,
                   (unsigned char const *)((out_buf.m_pBuf + 41) - 4),
                   *pLen_out + (size_t)4);
  c = (mz_uint32)tmp_7;
  i = 0;
  while (i < 4) {
    *(((out_buf.m_pBuf + out_buf.m_size) - 16) + i) = (mz_uint8)(c >> 24);
    i ++;
    c <<= 8;
  }
  *pLen_out += (size_t)57;
  free((void *)pComp);
  __retres = (void __attribute__((__visibility__("default"))) *)out_buf.m_pBuf;
  return_label: return __retres;
}

void __attribute__((__visibility__("default"))) *tdefl_write_image_to_png_file_in_memory
(void const *pImage, int w, int h, int num_chans, size_t *pLen_out)
{
  void __attribute__((__visibility__("default"))) *tmp;
  tmp = tdefl_write_image_to_png_file_in_memory_ex(pImage,w,h,num_chans,
                                                   pLen_out,(mz_uint)6,0);
  return tmp;
}

tdefl_compressor __attribute__((__visibility__("default"))) *tdefl_compressor_alloc
(void)
{
  tdefl_compressor __attribute__((__visibility__("default"))) *__retres;
  tdefl_compressor *tmp;
  tmp = (tdefl_compressor *)malloc(sizeof(tdefl_compressor));
  __retres = (tdefl_compressor __attribute__((__visibility__("default"))) *)tmp;
  return __retres;
}

void __attribute__((__visibility__("default"))) tdefl_compressor_free
(tdefl_compressor *pComp)
{
  free((void *)pComp);
  return;
}

static int const tinfl_decompress_s_length_base[31] =
  {3,
   4,
   5,
   6,
   7,
   8,
   9,
   10,
   11,
   13,
   15,
   17,
   19,
   23,
   27,
   31,
   35,
   43,
   51,
   59,
   67,
   83,
   99,
   115,
   131,
   163,
   195,
   227,
   258,
   0,
   0};
static int const tinfl_decompress_s_length_extra[31] =
  {0,
   0,
   0,
   0,
   0,
   0,
   0,
   0,
   1,
   1,
   1,
   1,
   2,
   2,
   2,
   2,
   3,
   3,
   3,
   3,
   4,
   4,
   4,
   4,
   5,
   5,
   5,
   5,
   0,
   0,
   0};
static int const tinfl_decompress_s_dist_base[32] =
  {1,
   2,
   3,
   4,
   5,
   7,
   9,
   13,
   17,
   25,
   33,
   49,
   65,
   97,
   129,
   193,
   257,
   385,
   513,
   769,
   1025,
   1537,
   2049,
   3073,
   4097,
   6145,
   8193,
   12289,
   16385,
   24577,
   0,
   0};
static int const tinfl_decompress_s_dist_extra[32] =
  {0,
   0,
   0,
   0,
   1,
   1,
   2,
   2,
   3,
   3,
   4,
   4,
   5,
   5,
   6,
   6,
   7,
   7,
   8,
   8,
   9,
   9,
   10,
   10,
   11,
   11,
   12,
   12,
   13,
   13};
static mz_uint8 const tinfl_decompress_s_length_dezigzag[19] =
  {(mz_uint8)16,
   (mz_uint8)17,
   (mz_uint8)18,
   (mz_uint8)0,
   (mz_uint8)8,
   (mz_uint8)7,
   (mz_uint8)9,
   (mz_uint8)6,
   (mz_uint8)10,
   (mz_uint8)5,
   (mz_uint8)11,
   (mz_uint8)4,
   (mz_uint8)12,
   (mz_uint8)3,
   (mz_uint8)13,
   (mz_uint8)2,
   (mz_uint8)14,
   (mz_uint8)1,
   (mz_uint8)15};
static int const tinfl_decompress_s_min_table_sizes[3] = {257, 1, 4};
tinfl_status __attribute__((__visibility__("default"))) tinfl_decompress
(tinfl_decompressor *r, mz_uint8 const *pIn_buf_next, size_t *pIn_buf_size,
 mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size,
 mz_uint32 const decomp_flags)
{
  tinfl_status __attribute__((__visibility__("default"))) __retres;
  mz_uint32 num_bits;
  mz_uint32 dist;
  mz_uint32 counter;
  mz_uint32 num_extra;
  tinfl_bit_buf_t bit_buf;
  size_t tmp;
  size_t dist_from_out_buf_start;
  tinfl_status status = TINFL_STATUS_FAILED;
  mz_uint8 const *pIn_buf_cur = pIn_buf_next;
  mz_uint8 const * const pIn_buf_end = pIn_buf_next + *pIn_buf_size;
  mz_uint8 *pOut_buf_cur = pOut_buf_next;
  mz_uint8 * const pOut_buf_end = pOut_buf_next + *pOut_buf_size;
  if (decomp_flags & (unsigned int)TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF) 
    tmp = (size_t)(-1);
  else tmp = ((size_t)(pOut_buf_next - pOut_buf_start) + *pOut_buf_size) - (size_t)1;
  size_t out_buf_size_mask = tmp;
  if ((out_buf_size_mask + (size_t)1) & out_buf_size_mask) goto _LOR;
  else 
    if (pOut_buf_next < pOut_buf_start) {
      _LOR:
      {
        size_t tmp_0;
        tmp_0 = (size_t)0;
        *pOut_buf_size = tmp_0;
        *pIn_buf_size = tmp_0;
        __retres = TINFL_STATUS_BAD_PARAM;
        goto return_label;
      }
    }
  num_bits = r->m_num_bits;
  bit_buf = r->m_bit_buf;
  dist = r->m_dist;
  counter = r->m_counter;
  num_extra = r->m_num_extra;
  dist_from_out_buf_start = r->m_dist_from_out_buf_start;
  switch (r->m_state) {
    mz_uint32 tmp_2;
    mz_uint32 tmp_1;
    mz_uint32 tmp_3;
    case (mz_uint32)0:
    { /* sequence */
      tmp_2 = (mz_uint32)0;
      r->m_zhdr1 = tmp_2;
      tmp_1 = tmp_2;
      r->m_zhdr0 = tmp_1;
      num_extra = tmp_1;
      counter = num_extra;
      dist = counter;
      num_bits = dist;
      bit_buf = (tinfl_bit_buf_t)num_bits;
    }
    tmp_3 = (mz_uint32)1;
    r->m_check_adler32 = tmp_3;
    r->m_z_adler32 = tmp_3;
    if (decomp_flags & (unsigned int)TINFL_FLAG_PARSE_ZLIB_HEADER) {
      int tmp_6;
      {
        mz_uint8 const *tmp_4;
        while (pIn_buf_cur >= pIn_buf_end) {
          if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
            status = TINFL_STATUS_NEEDS_MORE_INPUT;
          else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
          r->m_state = (mz_uint32)1;
          goto common_exit;
          case (mz_uint32)1: ;
        }
        tmp_4 = pIn_buf_cur;
        pIn_buf_cur ++;
        r->m_zhdr0 = (mz_uint32)*tmp_4;
      }
      {
        mz_uint8 const *tmp_5;
        while (pIn_buf_cur >= pIn_buf_end) {
          if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
            status = TINFL_STATUS_NEEDS_MORE_INPUT;
          else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
          r->m_state = (mz_uint32)2;
          goto common_exit;
          case (mz_uint32)2: ;
        }
        tmp_5 = pIn_buf_cur;
        pIn_buf_cur ++;
        r->m_zhdr1 = (mz_uint32)*tmp_5;
      }
      if ((r->m_zhdr0 * (mz_uint32)256 + r->m_zhdr1) % (unsigned int)31 != (unsigned int)0) 
        tmp_6 = 1;
      else 
        if (r->m_zhdr1 & (unsigned int)32) tmp_6 = 1;
        else 
          if ((r->m_zhdr0 & (unsigned int)15) != (unsigned int)8) tmp_6 = 1;
          else tmp_6 = 0;
      counter = (mz_uint32)tmp_6;
      if (! (decomp_flags & (unsigned int)TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)) {
        int tmp_7;
        if (1U << (8U + (r->m_zhdr0 >> 4)) > 32768U) tmp_7 = 1;
        else 
          if (out_buf_size_mask + (size_t)1 < (size_t)(1U << (8U + (r->m_zhdr0 >> 4)))) 
            tmp_7 = 1;
          else tmp_7 = 0;
        counter |= (unsigned int)tmp_7;
      }
      if (counter) 
        while (1) {
          status = TINFL_STATUS_FAILED;
          r->m_state = (mz_uint32)36;
          goto common_exit;
          case (mz_uint32)36: ;
        }
    }
    while (1) {
      if (num_bits < (mz_uint)3) 
        while (1) {
          {
            mz_uint c;
            {
              mz_uint8 const *tmp_8;
              while (pIn_buf_cur >= pIn_buf_end) {
                if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                  status = TINFL_STATUS_NEEDS_MORE_INPUT;
                else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                r->m_state = (mz_uint32)3;
                goto common_exit;
                case (mz_uint32)3: ;
              }
              tmp_8 = pIn_buf_cur;
              pIn_buf_cur ++;
              c = (mz_uint)*tmp_8;
            }
            bit_buf |= (tinfl_bit_buf_t)c << num_bits;
            num_bits += (mz_uint32)8;
          }
          if (! (num_bits < (mz_uint)3)) break;
        }
      r->m_final = (mz_uint32)(bit_buf & (unsigned long)((1 << 3) - 1));
      bit_buf >>= 3;
      num_bits -= (mz_uint32)3;
      r->m_type = r->m_final >> 1;
      if (r->m_type == (mz_uint32)0) {
        if (num_bits < (num_bits & (unsigned int)7)) 
          while (1) {
            {
              mz_uint c_0;
              {
                mz_uint8 const *tmp_9;
                while (pIn_buf_cur >= pIn_buf_end) {
                  if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                    status = TINFL_STATUS_NEEDS_MORE_INPUT;
                  else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                  r->m_state = (mz_uint32)5;
                  goto common_exit;
                  case (mz_uint32)5: ;
                }
                tmp_9 = pIn_buf_cur;
                pIn_buf_cur ++;
                c_0 = (mz_uint)*tmp_9;
              }
              bit_buf |= (tinfl_bit_buf_t)c_0 << num_bits;
              num_bits += (mz_uint32)8;
            }
            if (! (num_bits < (num_bits & (unsigned int)7))) break;
          }
        bit_buf >>= num_bits & (unsigned int)7;
        num_bits -= num_bits & (unsigned int)7;
        counter = (mz_uint32)0;
        while (counter < (mz_uint32)4) {
          if (num_bits) {
            if (num_bits < (mz_uint)8) 
              while (1) {
                {
                  mz_uint c_1;
                  {
                    mz_uint8 const *tmp_10;
                    while (pIn_buf_cur >= pIn_buf_end) {
                      if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                        status = TINFL_STATUS_NEEDS_MORE_INPUT;
                      else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                      r->m_state = (mz_uint32)6;
                      goto common_exit;
                      case (mz_uint32)6: ;
                    }
                    tmp_10 = pIn_buf_cur;
                    pIn_buf_cur ++;
                    c_1 = (mz_uint)*tmp_10;
                  }
                  bit_buf |= (tinfl_bit_buf_t)c_1 << num_bits;
                  num_bits += (mz_uint32)8;
                }
                if (! (num_bits < (mz_uint)8)) break;
              }
            r->m_raw_header[counter] = (mz_uint8)(bit_buf & (unsigned long)(
                                                  (1 << 8) - 1));
            bit_buf >>= 8;
            num_bits -= (mz_uint32)8;
          }
          else {
            mz_uint8 const *tmp_11;
            while (pIn_buf_cur >= pIn_buf_end) {
              if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                status = TINFL_STATUS_NEEDS_MORE_INPUT;
              else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
              r->m_state = (mz_uint32)7;
              goto common_exit;
              case (mz_uint32)7: ;
            }
            tmp_11 = pIn_buf_cur;
            pIn_buf_cur ++;
            r->m_raw_header[counter] = *tmp_11;
          }
          counter ++;
        }
        counter = (mz_uint32)((int)r->m_raw_header[0] | ((int)r->m_raw_header[1] << 8));
        ;
        if (counter != (mz_uint)(0xFFFF ^ ((int)r->m_raw_header[2] | (
                                           (int)r->m_raw_header[3] << 8)))) 
          while (1) {
            status = TINFL_STATUS_FAILED;
            r->m_state = (mz_uint32)39;
            goto common_exit;
            case (mz_uint32)39: ;
          }
        while (1) {
          if (counter) {
            if (! num_bits) break;
          }
          else break;
          {
            mz_uint8 *tmp_13;
            if (num_bits < (mz_uint)8) 
              while (1) {
                {
                  mz_uint c_2;
                  {
                    mz_uint8 const *tmp_12;
                    while (pIn_buf_cur >= pIn_buf_end) {
                      if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                        status = TINFL_STATUS_NEEDS_MORE_INPUT;
                      else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                      r->m_state = (mz_uint32)51;
                      goto common_exit;
                      case (mz_uint32)51: ;
                    }
                    tmp_12 = pIn_buf_cur;
                    pIn_buf_cur ++;
                    c_2 = (mz_uint)*tmp_12;
                  }
                  bit_buf |= (tinfl_bit_buf_t)c_2 << num_bits;
                  num_bits += (mz_uint32)8;
                }
                if (! (num_bits < (mz_uint)8)) break;
              }
            dist = (mz_uint32)(bit_buf & (unsigned long)((1 << 8) - 1));
            bit_buf >>= 8;
            num_bits -= (mz_uint32)8;
            while (pOut_buf_cur >= pOut_buf_end) {
              status = TINFL_STATUS_HAS_MORE_OUTPUT;
              r->m_state = (mz_uint32)52;
              goto common_exit;
              case (mz_uint32)52: ;
            }
            tmp_13 = pOut_buf_cur;
            pOut_buf_cur ++;
            *tmp_13 = (mz_uint8)dist;
            counter --;
          }
        }
        while (counter) {
          size_t n;
          size_t tmp_14;
          while (pOut_buf_cur >= pOut_buf_end) {
            status = TINFL_STATUS_HAS_MORE_OUTPUT;
            r->m_state = (mz_uint32)9;
            goto common_exit;
            case (mz_uint32)9: ;
          }
          while (pIn_buf_cur >= pIn_buf_end) {
            if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
              status = TINFL_STATUS_NEEDS_MORE_INPUT;
            else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
            r->m_state = (mz_uint32)38;
            goto common_exit;
            case (mz_uint32)38: ;
          }
          if ((size_t)(pOut_buf_end - pOut_buf_cur) < (size_t)(pIn_buf_end - pIn_buf_cur)) 
            tmp_14 = (size_t)(pOut_buf_end - pOut_buf_cur);
          else tmp_14 = (size_t)(pIn_buf_end - pIn_buf_cur);
          ;
          if (tmp_14 < (size_t)counter) {
            size_t tmp_15;
            if ((size_t)(pOut_buf_end - pOut_buf_cur) < (size_t)(pIn_buf_end - pIn_buf_cur)) 
              tmp_15 = (size_t)(pOut_buf_end - pOut_buf_cur);
            else tmp_15 = (size_t)(pIn_buf_end - pIn_buf_cur);
            n = tmp_15;
          }
          else n = (size_t)counter;
          memcpy((void *)pOut_buf_cur,(void const *)pIn_buf_cur,n);
          pIn_buf_cur += n;
          pOut_buf_cur += n;
          counter -= (mz_uint)n;
        }
      }
      else 
        if (r->m_type == (mz_uint32)3) 
          while (1) {
            status = TINFL_STATUS_FAILED;
            r->m_state = (mz_uint32)10;
            goto common_exit;
            case (mz_uint32)10: ;
          }
        else {
          if (r->m_type == (mz_uint32)1) {
            mz_uint i;
            mz_uint8 *p = r->m_tables[0].m_code_size;
            r->m_table_sizes[0] = (mz_uint32)288;
            r->m_table_sizes[1] = (mz_uint32)32;
            memset((void *)(r->m_tables[1].m_code_size),5,(size_t)32);
            i = (mz_uint)0;
            while (i <= (mz_uint)143) {
              mz_uint8 *tmp_16;
              tmp_16 = p;
              p ++;
              *tmp_16 = (mz_uint8)8;
              i ++;
            }
            while (i <= (mz_uint)255) {
              mz_uint8 *tmp_17;
              tmp_17 = p;
              p ++;
              *tmp_17 = (mz_uint8)9;
              i ++;
            }
            while (i <= (mz_uint)279) {
              mz_uint8 *tmp_18;
              tmp_18 = p;
              p ++;
              *tmp_18 = (mz_uint8)7;
              i ++;
            }
            while (i <= (mz_uint)287) {
              mz_uint8 *tmp_19;
              tmp_19 = p;
              p ++;
              *tmp_19 = (mz_uint8)8;
              i ++;
            }
          }
          else {
            counter = (mz_uint32)0;
            while (counter < (mz_uint32)3) {
              if (num_bits < (mz_uint)*("\005\005\004" + counter)) 
                while (1) {
                  {
                    mz_uint c_3;
                    {
                      mz_uint8 const *tmp_20;
                      while (pIn_buf_cur >= pIn_buf_end) {
                        if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                          status = TINFL_STATUS_NEEDS_MORE_INPUT;
                        else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                        r->m_state = (mz_uint32)11;
                        goto common_exit;
                        case (mz_uint32)11: ;
                      }
                      tmp_20 = pIn_buf_cur;
                      pIn_buf_cur ++;
                      c_3 = (mz_uint)*tmp_20;
                    }
                    bit_buf |= (tinfl_bit_buf_t)c_3 << num_bits;
                    num_bits += (mz_uint32)8;
                  }
                  if (! (num_bits < (mz_uint)*("\005\005\004" + counter))) 
                    break;
                }
              r->m_table_sizes[counter] = (mz_uint32)(bit_buf & (unsigned long)(
                                                      (1 << (int)*("\005\005\004" + counter)) - 1));
              bit_buf >>= (int)*("\005\005\004" + counter);
              num_bits -= (mz_uint32)*("\005\005\004" + counter);
              r->m_table_sizes[counter] += (mz_uint32)tinfl_decompress_s_min_table_sizes[counter];
              counter ++;
            }
            memset((void *)(& r->m_tables[2].m_code_size),0,
                   sizeof(r->m_tables[2].m_code_size));
            counter = (mz_uint32)0;
            while (counter < r->m_table_sizes[2]) {
              {
                mz_uint s;
                if (num_bits < (mz_uint)3) 
                  while (1) {
                    {
                      mz_uint c_4;
                      {
                        mz_uint8 const *tmp_21;
                        while (pIn_buf_cur >= pIn_buf_end) {
                          if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                            status = TINFL_STATUS_NEEDS_MORE_INPUT;
                          else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                          r->m_state = (mz_uint32)14;
                          goto common_exit;
                          case (mz_uint32)14: ;
                        }
                        tmp_21 = pIn_buf_cur;
                        pIn_buf_cur ++;
                        c_4 = (mz_uint)*tmp_21;
                      }
                      bit_buf |= (tinfl_bit_buf_t)c_4 << num_bits;
                      num_bits += (mz_uint32)8;
                    }
                    if (! (num_bits < (mz_uint)3)) break;
                  }
                s = (mz_uint)(bit_buf & (unsigned long)((1 << 3) - 1));
                bit_buf >>= 3;
                num_bits -= (mz_uint32)3;
                r->m_tables[2].m_code_size[tinfl_decompress_s_length_dezigzag[counter]] = (mz_uint8)s;
              }
              counter ++;
            }
            r->m_table_sizes[2] = (mz_uint32)19;
          }
          while ((int)r->m_type >= 0) {
            {
              int tree_next;
              int tree_cur;
              tinfl_huff_table *pTable;
              mz_uint i_0;
              mz_uint j;
              mz_uint used_syms;
              mz_uint total;
              mz_uint sym_index;
              mz_uint next_code[17];
              mz_uint total_syms[16];
              pTable = & r->m_tables[r->m_type];
              memset((void *)(& total_syms),0,sizeof(total_syms));
              memset((void *)(& pTable->m_look_up),0,
                     sizeof(pTable->m_look_up));
              memset((void *)(& pTable->m_tree),0,sizeof(pTable->m_tree));
              i_0 = (mz_uint)0;
              while (i_0 < r->m_table_sizes[r->m_type]) {
                (total_syms[pTable->m_code_size[i_0]]) ++;
                i_0 ++;
              }
              used_syms = (mz_uint)0;
              total = (mz_uint)0;
              next_code[1] = (mz_uint)0;
              next_code[0] = next_code[1];
              i_0 = (mz_uint)1;
              while (i_0 <= (mz_uint)15) {
                used_syms += total_syms[i_0];
                total = (total + total_syms[i_0]) << 1;
                next_code[i_0 + (mz_uint)1] = total;
                i_0 ++;
              }
              if ((mz_uint)65536 != total) 
                if (used_syms > (mz_uint)1) 
                  while (1) {
                    status = TINFL_STATUS_FAILED;
                    r->m_state = (mz_uint32)35;
                    goto common_exit;
                    case (mz_uint32)35: ;
                  }
              tree_next = -1;
              sym_index = (mz_uint)0;
              while (sym_index < r->m_table_sizes[r->m_type]) {
                {
                  mz_uint l;
                  mz_uint cur_code;
                  mz_uint tmp_22;
                  mz_uint rev_code = (mz_uint)0;
                  mz_uint code_size =
                    (mz_uint)pTable->m_code_size[sym_index];
                  if (! code_size) goto __Cont;
                  tmp_22 = next_code[code_size];
                  (next_code[code_size]) ++;
                  cur_code = tmp_22;
                  l = code_size;
                  while (l > (mz_uint)0) {
                    rev_code = (rev_code << 1) | (cur_code & (unsigned int)1);
                    l --;
                    cur_code >>= 1;
                  }
                  if (code_size <= (mz_uint)TINFL_FAST_LOOKUP_BITS) {
                    mz_int16 k = (mz_int16)((code_size << 9) | sym_index);
                    while (rev_code < (mz_uint)TINFL_FAST_LOOKUP_SIZE) {
                      pTable->m_look_up[rev_code] = k;
                      rev_code += (mz_uint)(1 << code_size);
                    }
                    goto __Cont;
                  }
                  tree_cur = (int)pTable->m_look_up[rev_code & (unsigned int)(
                                                    TINFL_FAST_LOOKUP_SIZE - 1)];
                  if (0 == tree_cur) {
                    pTable->m_look_up[rev_code & (unsigned int)(TINFL_FAST_LOOKUP_SIZE - 1)] = (mz_int16)tree_next;
                    tree_cur = tree_next;
                    tree_next -= 2;
                  }
                  rev_code >>= TINFL_FAST_LOOKUP_BITS - 1;
                  j = code_size;
                  while (j > (mz_uint)(TINFL_FAST_LOOKUP_BITS + 1)) {
                    rev_code >>= 1;
                    tree_cur = (int)((unsigned int)tree_cur - (rev_code & (unsigned int)1));
                    if (! pTable->m_tree[- tree_cur - 1]) {
                      pTable->m_tree[- tree_cur - 1] = (mz_int16)tree_next;
                      tree_cur = tree_next;
                      tree_next -= 2;
                    }
                    else tree_cur = (int)pTable->m_tree[- tree_cur - 1];
                    j --;
                  }
                  rev_code >>= 1;
                  tree_cur = (int)((unsigned int)tree_cur - (rev_code & (unsigned int)1));
                  pTable->m_tree[- tree_cur - 1] = (mz_int16)sym_index;
                }
                __Cont: sym_index ++;
              }
              if (r->m_type == (mz_uint32)2) {
                counter = (mz_uint32)0;
                while (counter < r->m_table_sizes[0] + r->m_table_sizes[1]) {
                  {
                    mz_uint s_0;
                    int tmp_28;
                    {
                      int temp;
                      mz_uint code_len;
                      mz_uint c_5;
                      if (num_bits < (mz_uint32)15) 
                        if (pIn_buf_end - pIn_buf_cur < (long)2) 
                          while (1) {
                            temp = (int)r->m_tables[2].m_look_up[bit_buf & (unsigned long)(
                                                                 TINFL_FAST_LOOKUP_SIZE - 1)];
                            if (temp >= 0) {
                              code_len = (mz_uint)(temp >> 9);
                              if (code_len) 
                                if (num_bits >= code_len) break;
                            }
                            else 
                              if (num_bits > (mz_uint32)TINFL_FAST_LOOKUP_BITS) {
                                code_len = (mz_uint)TINFL_FAST_LOOKUP_BITS;
                                while (1) {
                                  {
                                    mz_uint tmp_23;
                                    tmp_23 = code_len;
                                    code_len ++;
                                    temp = (int)r->m_tables[2].m_tree[
                                    (unsigned long)(~ temp) + ((bit_buf >> tmp_23) & (unsigned long)1)];
                                  }
                                  if (temp < 0) {
                                    if (! (num_bits >= code_len + (mz_uint)1)) 
                                      break;
                                  }
                                  else break;
                                }
                                if (temp >= 0) break;
                              }
                            {
                              mz_uint8 const *tmp_24;
                              while (pIn_buf_cur >= pIn_buf_end) {
                                if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                                  status = TINFL_STATUS_NEEDS_MORE_INPUT;
                                else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                                r->m_state = (mz_uint32)16;
                                goto common_exit;
                                case (mz_uint32)16: ;
                              }
                              tmp_24 = pIn_buf_cur;
                              pIn_buf_cur ++;
                              c_5 = (mz_uint)*tmp_24;
                            }
                            bit_buf |= (tinfl_bit_buf_t)c_5 << num_bits;
                            num_bits += (mz_uint32)8;
                            if (! (num_bits < (mz_uint32)15)) break;
                          }
                        else {
                          bit_buf |= ((tinfl_bit_buf_t)*(pIn_buf_cur + 0) << num_bits) | (
                                     (tinfl_bit_buf_t)*(pIn_buf_cur + 1) << (
                                     num_bits + (mz_uint32)8));
                          pIn_buf_cur += 2;
                          num_bits += (mz_uint32)16;
                        }
                      temp = (int)r->m_tables[2].m_look_up[bit_buf & (unsigned long)(
                                                           TINFL_FAST_LOOKUP_SIZE - 1)];
                      if (temp >= 0) {
                        code_len = (mz_uint)(temp >> 9);
                        temp &= 511;
                      }
                      else {
                        code_len = (mz_uint)TINFL_FAST_LOOKUP_BITS;
                        while (1) {
                          {
                            mz_uint tmp_25;
                            tmp_25 = code_len;
                            code_len ++;
                            temp = (int)r->m_tables[2].m_tree[(unsigned long)(~ temp) + (
                                                              (bit_buf >> tmp_25) & (unsigned long)1)];
                          }
                          if (! (temp < 0)) break;
                        }
                      }
                      dist = (mz_uint32)temp;
                      bit_buf >>= code_len;
                      num_bits -= code_len;
                    }
                    if (dist < (mz_uint32)16) {
                      mz_uint32 tmp_26;
                      tmp_26 = counter;
                      counter ++;
                      r->m_len_codes[tmp_26] = (mz_uint8)dist;
                      goto __Cont_0;
                    }
                    if (dist == (mz_uint32)16) 
                      if (! counter) 
                        while (1) {
                          status = TINFL_STATUS_FAILED;
                          r->m_state = (mz_uint32)17;
                          goto common_exit;
                          case (mz_uint32)17: ;
                        }
                    num_extra = (mz_uint32)*("\002\003\a" + (dist - (mz_uint32)16));
                    if (num_bits < num_extra) 
                      while (1) {
                        {
                          mz_uint c_6;
                          {
                            mz_uint8 const *tmp_27;
                            while (pIn_buf_cur >= pIn_buf_end) {
                              if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                                status = TINFL_STATUS_NEEDS_MORE_INPUT;
                              else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                              r->m_state = (mz_uint32)18;
                              goto common_exit;
                              case (mz_uint32)18: ;
                            }
                            tmp_27 = pIn_buf_cur;
                            pIn_buf_cur ++;
                            c_6 = (mz_uint)*tmp_27;
                          }
                          bit_buf |= (tinfl_bit_buf_t)c_6 << num_bits;
                          num_bits += (mz_uint32)8;
                        }
                        if (! (num_bits < num_extra)) break;
                      }
                    s_0 = (mz_uint)(bit_buf & (unsigned long)((1 << num_extra) - 1));
                    bit_buf >>= num_extra;
                    num_bits -= num_extra;
                    s_0 += (mz_uint)*("\003\003\v" + (dist - (mz_uint32)16));
                    ;
                    if (dist == (mz_uint32)16) tmp_28 = (int)r->m_len_codes[
                                               counter - (mz_uint32)1];
                    else tmp_28 = 0;
                    ;
                    memset((void *)(& r->m_len_codes[counter]),tmp_28,
                           (size_t)s_0);
                    counter += s_0;
                  }
                  __Cont_0: ;
                }
                if (r->m_table_sizes[0] + r->m_table_sizes[1] != counter) 
                  while (1) {
                    status = TINFL_STATUS_FAILED;
                    r->m_state = (mz_uint32)21;
                    goto common_exit;
                    case (mz_uint32)21: ;
                  }
                memcpy((void *)(r->m_tables[0].m_code_size),
                       (void const *)(r->m_len_codes),
                       (size_t)r->m_table_sizes[0]);
                memcpy((void *)(r->m_tables[1].m_code_size),
                       (void const *)(& r->m_len_codes[r->m_table_sizes[0]]),
                       (size_t)r->m_table_sizes[1]);
              }
            }
            (r->m_type) --;
          }
          while (1) {
            {
              mz_uint8 *pSrc;
              mz_uint8 *tmp_43;
              while (1) 
                if (pIn_buf_end - pIn_buf_cur < (long)4) goto _LOR_0;
                else 
                  if (pOut_buf_end - pOut_buf_cur < (long)2) {
                    _LOR_0:
                    {
                      mz_uint8 *tmp_32;
                      {
                        int temp_0;
                        mz_uint code_len_0;
                        mz_uint c_7;
                        if (num_bits < (mz_uint32)15) 
                          if (pIn_buf_end - pIn_buf_cur < (long)2) 
                            while (1) {
                              temp_0 = (int)r->m_tables[0].m_look_up[
                              bit_buf & (unsigned long)(TINFL_FAST_LOOKUP_SIZE - 1)];
                              if (temp_0 >= 0) {
                                code_len_0 = (mz_uint)(temp_0 >> 9);
                                if (code_len_0) 
                                  if (num_bits >= code_len_0) break;
                              }
                              else 
                                if (num_bits > (mz_uint32)TINFL_FAST_LOOKUP_BITS) {
                                  code_len_0 = (mz_uint)TINFL_FAST_LOOKUP_BITS;
                                  while (1) {
                                    {
                                      mz_uint tmp_29;
                                      tmp_29 = code_len_0;
                                      code_len_0 ++;
                                      temp_0 = (int)r->m_tables[0].m_tree[
                                      (unsigned long)(~ temp_0) + ((bit_buf >> tmp_29) & (unsigned long)1)];
                                    }
                                    if (temp_0 < 0) {
                                      if (! (num_bits >= code_len_0 + (mz_uint)1)) 
                                        break;
                                    }
                                    else break;
                                  }
                                  if (temp_0 >= 0) break;
                                }
                              {
                                mz_uint8 const *tmp_30;
                                while (pIn_buf_cur >= pIn_buf_end) {
                                  if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                                    status = TINFL_STATUS_NEEDS_MORE_INPUT;
                                  else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                                  r->m_state = (mz_uint32)23;
                                  goto common_exit;
                                  case (mz_uint32)23: ;
                                }
                                tmp_30 = pIn_buf_cur;
                                pIn_buf_cur ++;
                                c_7 = (mz_uint)*tmp_30;
                              }
                              bit_buf |= (tinfl_bit_buf_t)c_7 << num_bits;
                              num_bits += (mz_uint32)8;
                              if (! (num_bits < (mz_uint32)15)) break;
                            }
                          else {
                            bit_buf |= ((tinfl_bit_buf_t)*(pIn_buf_cur + 0) << num_bits) | (
                                       (tinfl_bit_buf_t)*(pIn_buf_cur + 1) << (
                                       num_bits + (mz_uint32)8));
                            pIn_buf_cur += 2;
                            num_bits += (mz_uint32)16;
                          }
                        temp_0 = (int)r->m_tables[0].m_look_up[bit_buf & (unsigned long)(
                                                               TINFL_FAST_LOOKUP_SIZE - 1)];
                        if (temp_0 >= 0) {
                          code_len_0 = (mz_uint)(temp_0 >> 9);
                          temp_0 &= 511;
                        }
                        else {
                          code_len_0 = (mz_uint)TINFL_FAST_LOOKUP_BITS;
                          while (1) {
                            {
                              mz_uint tmp_31;
                              tmp_31 = code_len_0;
                              code_len_0 ++;
                              temp_0 = (int)r->m_tables[0].m_tree[(unsigned long)(~ temp_0) + (
                                                                  (bit_buf >> tmp_31) & (unsigned long)1)];
                            }
                            if (! (temp_0 < 0)) break;
                          }
                        }
                        counter = (mz_uint32)temp_0;
                        bit_buf >>= code_len_0;
                        num_bits -= code_len_0;
                      }
                      if (counter >= (mz_uint32)256) break;
                      while (pOut_buf_cur >= pOut_buf_end) {
                        status = TINFL_STATUS_HAS_MORE_OUTPUT;
                        r->m_state = (mz_uint32)24;
                        goto common_exit;
                        case (mz_uint32)24: ;
                      }
                      tmp_32 = pOut_buf_cur;
                      pOut_buf_cur ++;
                      *tmp_32 = (mz_uint8)counter;
                    }
                  }
                  else {
                    int sym2;
                    mz_uint code_len_1;
                    if (num_bits < (mz_uint32)30) {
                      bit_buf |= (tinfl_bit_buf_t)*((mz_uint32 const *)pIn_buf_cur) << num_bits;
                      pIn_buf_cur += 4;
                      num_bits += (mz_uint32)32;
                    }
                    sym2 = (int)r->m_tables[0].m_look_up[bit_buf & (unsigned long)(
                                                         TINFL_FAST_LOOKUP_SIZE - 1)];
                    if (sym2 >= 0) code_len_1 = (mz_uint)(sym2 >> 9);
                    else {
                      code_len_1 = (mz_uint)TINFL_FAST_LOOKUP_BITS;
                      while (1) {
                        {
                          mz_uint tmp_33;
                          tmp_33 = code_len_1;
                          code_len_1 ++;
                          sym2 = (int)r->m_tables[0].m_tree[(unsigned long)(~ sym2) + (
                                                            (bit_buf >> tmp_33) & (unsigned long)1)];
                        }
                        if (! (sym2 < 0)) break;
                      }
                    }
                    counter = (mz_uint32)sym2;
                    bit_buf >>= code_len_1;
                    num_bits -= code_len_1;
                    if (counter & (unsigned int)256) break;
                    sym2 = (int)r->m_tables[0].m_look_up[bit_buf & (unsigned long)(
                                                         TINFL_FAST_LOOKUP_SIZE - 1)];
                    if (sym2 >= 0) code_len_1 = (mz_uint)(sym2 >> 9);
                    else {
                      code_len_1 = (mz_uint)TINFL_FAST_LOOKUP_BITS;
                      while (1) {
                        {
                          mz_uint tmp_34;
                          tmp_34 = code_len_1;
                          code_len_1 ++;
                          sym2 = (int)r->m_tables[0].m_tree[(unsigned long)(~ sym2) + (
                                                            (bit_buf >> tmp_34) & (unsigned long)1)];
                        }
                        if (! (sym2 < 0)) break;
                      }
                    }
                    bit_buf >>= code_len_1;
                    num_bits -= code_len_1;
                    *(pOut_buf_cur + 0) = (mz_uint8)counter;
                    if (sym2 & 256) {
                      pOut_buf_cur ++;
                      counter = (mz_uint32)sym2;
                      break;
                    }
                    *(pOut_buf_cur + 1) = (mz_uint8)sym2;
                    pOut_buf_cur += 2;
                  }
              counter &= (unsigned int)511;
              if (counter == (mz_uint32)256) break;
              num_extra = (mz_uint32)tinfl_decompress_s_length_extra[
              counter - (mz_uint32)257];
              counter = (mz_uint32)tinfl_decompress_s_length_base[counter - (mz_uint32)257];
              if (num_extra) {
                mz_uint extra_bits;
                if (num_bits < num_extra) 
                  while (1) {
                    {
                      mz_uint c_8;
                      {
                        mz_uint8 const *tmp_35;
                        while (pIn_buf_cur >= pIn_buf_end) {
                          if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                            status = TINFL_STATUS_NEEDS_MORE_INPUT;
                          else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                          r->m_state = (mz_uint32)25;
                          goto common_exit;
                          case (mz_uint32)25: ;
                        }
                        tmp_35 = pIn_buf_cur;
                        pIn_buf_cur ++;
                        c_8 = (mz_uint)*tmp_35;
                      }
                      bit_buf |= (tinfl_bit_buf_t)c_8 << num_bits;
                      num_bits += (mz_uint32)8;
                    }
                    if (! (num_bits < num_extra)) break;
                  }
                extra_bits = (mz_uint)(bit_buf & (unsigned long)((1 << num_extra) - 1));
                bit_buf >>= num_extra;
                num_bits -= num_extra;
                counter += extra_bits;
              }
              {
                int temp_1;
                mz_uint code_len_2;
                mz_uint c_9;
                if (num_bits < (mz_uint32)15) 
                  if (pIn_buf_end - pIn_buf_cur < (long)2) 
                    while (1) {
                      temp_1 = (int)r->m_tables[1].m_look_up[bit_buf & (unsigned long)(
                                                             TINFL_FAST_LOOKUP_SIZE - 1)];
                      if (temp_1 >= 0) {
                        code_len_2 = (mz_uint)(temp_1 >> 9);
                        if (code_len_2) 
                          if (num_bits >= code_len_2) break;
                      }
                      else 
                        if (num_bits > (mz_uint32)TINFL_FAST_LOOKUP_BITS) {
                          code_len_2 = (mz_uint)TINFL_FAST_LOOKUP_BITS;
                          while (1) {
                            {
                              mz_uint tmp_36;
                              tmp_36 = code_len_2;
                              code_len_2 ++;
                              temp_1 = (int)r->m_tables[1].m_tree[(unsigned long)(~ temp_1) + (
                                                                  (bit_buf >> tmp_36) & (unsigned long)1)];
                            }
                            if (temp_1 < 0) {
                              if (! (num_bits >= code_len_2 + (mz_uint)1)) 
                                break;
                            }
                            else break;
                          }
                          if (temp_1 >= 0) break;
                        }
                      {
                        mz_uint8 const *tmp_37;
                        while (pIn_buf_cur >= pIn_buf_end) {
                          if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                            status = TINFL_STATUS_NEEDS_MORE_INPUT;
                          else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                          r->m_state = (mz_uint32)26;
                          goto common_exit;
                          case (mz_uint32)26: ;
                        }
                        tmp_37 = pIn_buf_cur;
                        pIn_buf_cur ++;
                        c_9 = (mz_uint)*tmp_37;
                      }
                      bit_buf |= (tinfl_bit_buf_t)c_9 << num_bits;
                      num_bits += (mz_uint32)8;
                      if (! (num_bits < (mz_uint32)15)) break;
                    }
                  else {
                    bit_buf |= ((tinfl_bit_buf_t)*(pIn_buf_cur + 0) << num_bits) | (
                               (tinfl_bit_buf_t)*(pIn_buf_cur + 1) << (
                               num_bits + (mz_uint32)8));
                    pIn_buf_cur += 2;
                    num_bits += (mz_uint32)16;
                  }
                temp_1 = (int)r->m_tables[1].m_look_up[bit_buf & (unsigned long)(
                                                       TINFL_FAST_LOOKUP_SIZE - 1)];
                if (temp_1 >= 0) {
                  code_len_2 = (mz_uint)(temp_1 >> 9);
                  temp_1 &= 511;
                }
                else {
                  code_len_2 = (mz_uint)TINFL_FAST_LOOKUP_BITS;
                  while (1) {
                    {
                      mz_uint tmp_38;
                      tmp_38 = code_len_2;
                      code_len_2 ++;
                      temp_1 = (int)r->m_tables[1].m_tree[(unsigned long)(~ temp_1) + (
                                                          (bit_buf >> tmp_38) & (unsigned long)1)];
                    }
                    if (! (temp_1 < 0)) break;
                  }
                }
                dist = (mz_uint32)temp_1;
                bit_buf >>= code_len_2;
                num_bits -= code_len_2;
              }
              num_extra = (mz_uint32)tinfl_decompress_s_dist_extra[dist];
              dist = (mz_uint32)tinfl_decompress_s_dist_base[dist];
              if (num_extra) {
                mz_uint extra_bits_0;
                if (num_bits < num_extra) 
                  while (1) {
                    {
                      mz_uint c_10;
                      {
                        mz_uint8 const *tmp_39;
                        while (pIn_buf_cur >= pIn_buf_end) {
                          if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                            status = TINFL_STATUS_NEEDS_MORE_INPUT;
                          else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                          r->m_state = (mz_uint32)27;
                          goto common_exit;
                          case (mz_uint32)27: ;
                        }
                        tmp_39 = pIn_buf_cur;
                        pIn_buf_cur ++;
                        c_10 = (mz_uint)*tmp_39;
                      }
                      bit_buf |= (tinfl_bit_buf_t)c_10 << num_bits;
                      num_bits += (mz_uint32)8;
                    }
                    if (! (num_bits < num_extra)) break;
                  }
                extra_bits_0 = (mz_uint)(bit_buf & (unsigned long)((1 << num_extra) - 1));
                bit_buf >>= num_extra;
                num_bits -= num_extra;
                dist += extra_bits_0;
              }
              dist_from_out_buf_start = (size_t)(pOut_buf_cur - pOut_buf_start);
              if (dist == (mz_uint32)0) goto _LOR_1;
              else 
                if ((size_t)dist > dist_from_out_buf_start) goto _LOR_1;
                else 
                  if (dist_from_out_buf_start == (size_t)0) {
                    _LOR_1: ;
                    if (decomp_flags & (unsigned int)TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF) 
                      while (1) {
                        status = TINFL_STATUS_FAILED;
                        r->m_state = (mz_uint32)37;
                        goto common_exit;
                        case (mz_uint32)37: ;
                      }
                  }
              pSrc = pOut_buf_start + ((dist_from_out_buf_start - (size_t)dist) & out_buf_size_mask);
              if (pOut_buf_cur > pSrc) tmp_43 = pOut_buf_cur;
              else tmp_43 = pSrc;
              ;
              if (tmp_43 + counter > pOut_buf_end) {
                while (1) {
                  mz_uint32 tmp_42;
                  tmp_42 = counter;
                  counter --;
                  ;
                  if (! tmp_42) break;
                  {
                    mz_uint8 *tmp_40;
                    size_t tmp_41;
                    while (pOut_buf_cur >= pOut_buf_end) {
                      status = TINFL_STATUS_HAS_MORE_OUTPUT;
                      r->m_state = (mz_uint32)53;
                      goto common_exit;
                      case (mz_uint32)53: ;
                    }
                    tmp_40 = pOut_buf_cur;
                    pOut_buf_cur ++;
                    tmp_41 = dist_from_out_buf_start;
                    dist_from_out_buf_start ++;
                    *tmp_40 = *(pOut_buf_start + ((tmp_41 - (size_t)dist) & out_buf_size_mask));
                  }
                }
                goto __Cont_1;
              }
              else 
                if (counter >= (mz_uint32)9) 
                  if (counter <= dist) {
                    mz_uint8 const *pSrc_end =
                      (mz_uint8 const *)(pSrc + (counter & (unsigned int)(~ 7)));
                    while (1) {
                      memcpy((void *)pOut_buf_cur,(void const *)pSrc,
                             sizeof(mz_uint32) * (unsigned long)2);
                      pOut_buf_cur += 8;
                      pSrc += 8;
                      ;
                      if (! ((void *)pSrc < (void *)pSrc_end)) break;
                    }
                    counter &= (unsigned int)7;
                    if (counter < (mz_uint32)3) {
                      if (counter) {
                        *(pOut_buf_cur + 0) = *(pSrc + 0);
                        if (counter > (mz_uint32)1) *(pOut_buf_cur + 1) = *(
                                                    pSrc + 1);
                        pOut_buf_cur += counter;
                      }
                      goto __Cont_1;
                    }
                  }
              while (counter > (mz_uint32)2) {
                *(pOut_buf_cur + 0) = *(pSrc + 0);
                *(pOut_buf_cur + 1) = *(pSrc + 1);
                *(pOut_buf_cur + 2) = *(pSrc + 2);
                pOut_buf_cur += 3;
                pSrc += 3;
                counter -= (mz_uint32)3;
              }
              if (counter > (mz_uint32)0) {
                *(pOut_buf_cur + 0) = *(pSrc + 0);
                if (counter > (mz_uint32)1) *(pOut_buf_cur + 1) = *(pSrc + 1);
                pOut_buf_cur += counter;
              }
            }
            __Cont_1: ;
          }
        }
      if (! (! (r->m_final & (unsigned int)1))) break;
    }
    if (num_bits < (num_bits & (unsigned int)7)) 
      while (1) {
        {
          mz_uint c_11;
          {
            mz_uint8 const *tmp_44;
            while (pIn_buf_cur >= pIn_buf_end) {
              if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                status = TINFL_STATUS_NEEDS_MORE_INPUT;
              else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
              r->m_state = (mz_uint32)32;
              goto common_exit;
              case (mz_uint32)32: ;
            }
            tmp_44 = pIn_buf_cur;
            pIn_buf_cur ++;
            c_11 = (mz_uint)*tmp_44;
          }
          bit_buf |= (tinfl_bit_buf_t)c_11 << num_bits;
          num_bits += (mz_uint32)8;
        }
        if (! (num_bits < (num_bits & (unsigned int)7))) break;
      }
    bit_buf >>= num_bits & (unsigned int)7;
    num_bits -= num_bits & (unsigned int)7;
    while (1) {
      if (pIn_buf_cur > pIn_buf_next) {
        if (! (num_bits >= (mz_uint32)8)) break;
      }
      else break;
      pIn_buf_cur --;
      num_bits -= (mz_uint32)8;
    }
    bit_buf &= ((mz_uint64)1 << num_bits) - (mz_uint64)1;
    __FC_assert(! num_bits != 0,"miniz_tinfl.c",576,"!num_bits");
    if (decomp_flags & (unsigned int)TINFL_FLAG_PARSE_ZLIB_HEADER) {
      counter = (mz_uint32)0;
      while (counter < (mz_uint32)4) {
        {
          mz_uint s_1;
          if (num_bits) {
            if (num_bits < (mz_uint)8) 
              while (1) {
                {
                  mz_uint c_12;
                  {
                    mz_uint8 const *tmp_45;
                    while (pIn_buf_cur >= pIn_buf_end) {
                      if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                        status = TINFL_STATUS_NEEDS_MORE_INPUT;
                      else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                      r->m_state = (mz_uint32)41;
                      goto common_exit;
                      case (mz_uint32)41: ;
                    }
                    tmp_45 = pIn_buf_cur;
                    pIn_buf_cur ++;
                    c_12 = (mz_uint)*tmp_45;
                  }
                  bit_buf |= (tinfl_bit_buf_t)c_12 << num_bits;
                  num_bits += (mz_uint32)8;
                }
                if (! (num_bits < (mz_uint)8)) break;
              }
            s_1 = (mz_uint)(bit_buf & (unsigned long)((1 << 8) - 1));
            bit_buf >>= 8;
            num_bits -= (mz_uint32)8;
          }
          else {
            mz_uint8 const *tmp_46;
            while (pIn_buf_cur >= pIn_buf_end) {
              if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                status = TINFL_STATUS_NEEDS_MORE_INPUT;
              else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
              r->m_state = (mz_uint32)42;
              goto common_exit;
              case (mz_uint32)42: ;
            }
            tmp_46 = pIn_buf_cur;
            pIn_buf_cur ++;
            s_1 = (mz_uint)*tmp_46;
          }
          r->m_z_adler32 = (r->m_z_adler32 << 8) | s_1;
        }
        counter ++;
      }
    }
    while (1) {
      status = TINFL_STATUS_DONE;
      r->m_state = (mz_uint32)34;
      goto common_exit;
      case (mz_uint32)34: ;
    }
  }
  common_exit: ;
  if (status != TINFL_STATUS_NEEDS_MORE_INPUT) 
    if (status != TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS) 
      while (1) {
        if (pIn_buf_cur > pIn_buf_next) {
          if (! (num_bits >= (mz_uint32)8)) break;
        }
        else break;
        pIn_buf_cur --;
        num_bits -= (mz_uint32)8;
      }
  r->m_num_bits = num_bits;
  r->m_bit_buf = bit_buf & (((mz_uint64)1 << num_bits) - (mz_uint64)1);
  r->m_dist = dist;
  r->m_counter = counter;
  r->m_num_extra = num_extra;
  r->m_dist_from_out_buf_start = dist_from_out_buf_start;
  *pIn_buf_size = (size_t)(pIn_buf_cur - pIn_buf_next);
  *pOut_buf_size = (size_t)(pOut_buf_cur - pOut_buf_next);
  if (decomp_flags & (unsigned int)(TINFL_FLAG_PARSE_ZLIB_HEADER | TINFL_FLAG_COMPUTE_ADLER32)) 
    if (status >= 0) {
      mz_uint32 i_1;
      mz_uint8 const *ptr = (mz_uint8 const *)pOut_buf_next;
      size_t buf_len = *pOut_buf_size;
      mz_uint32 s1 = r->m_check_adler32 & (unsigned int)0xffff;
      mz_uint32 s2 = r->m_check_adler32 >> 16;
      size_t block_len = buf_len % (unsigned long)5552;
      while (buf_len) {
        i_1 = (mz_uint32)0;
        while ((size_t)(i_1 + (mz_uint32)7) < block_len) {
          s1 += (mz_uint32)*(ptr + 0);
          s2 += s1;
          s1 += (mz_uint32)*(ptr + 1);
          s2 += s1;
          s1 += (mz_uint32)*(ptr + 2);
          s2 += s1;
          s1 += (mz_uint32)*(ptr + 3);
          s2 += s1;
          s1 += (mz_uint32)*(ptr + 4);
          s2 += s1;
          s1 += (mz_uint32)*(ptr + 5);
          s2 += s1;
          s1 += (mz_uint32)*(ptr + 6);
          s2 += s1;
          s1 += (mz_uint32)*(ptr + 7);
          s2 += s1;
          i_1 += (mz_uint32)8;
          ptr += 8;
        }
        while ((size_t)i_1 < block_len) {
          mz_uint8 const *tmp_47;
          tmp_47 = ptr;
          ptr ++;
          s1 += (mz_uint32)*tmp_47;
          s2 += s1;
          i_1 ++;
        }
        s1 %= 65521U;
        s2 %= 65521U;
        buf_len -= block_len;
        block_len = (size_t)5552;
      }
      r->m_check_adler32 = (s2 << 16) + s1;
      if (status == TINFL_STATUS_DONE) 
        if (decomp_flags & (unsigned int)TINFL_FLAG_PARSE_ZLIB_HEADER) 
          if (r->m_check_adler32 != r->m_z_adler32) status = TINFL_STATUS_ADLER32_MISMATCH;
    }
  __retres = (tinfl_status __attribute__((__visibility__("default"))))status;
  return_label: return __retres;
}

void __attribute__((__visibility__("default"))) *tinfl_decompress_mem_to_heap
(void const *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)
{
  void __attribute__((__visibility__("default"))) *__retres;
  tinfl_decompressor decomp;
  void *pNew_buf;
  void *pBuf = (void *)0;
  size_t src_buf_ofs = (size_t)0;
  size_t out_buf_capacity = (size_t)0;
  *pOut_len = (size_t)0;
  decomp.m_state = (mz_uint32)0;
  decomp.m_num_bits = (mz_uint32)0;
  decomp.m_bit_buf = (tinfl_bit_buf_t)0;
  decomp.m_dist = (mz_uint32)0;
  decomp.m_counter = (mz_uint32)0;
  decomp.m_num_extra = (mz_uint32)0;
  decomp.m_dist_from_out_buf_start = (size_t)0;
  while (1) {
    size_t new_out_buf_capacity;
    tinfl_status __attribute__((__visibility__("default"))) tmp_0;
    mz_uint8 *tmp;
    size_t src_buf_size = src_buf_len - src_buf_ofs;
    size_t dst_buf_size = out_buf_capacity - *pOut_len;
    ;
    if (pBuf) tmp = (mz_uint8 *)pBuf + *pOut_len; else tmp = (mz_uint8 *)0;
    ;
    ;
    tmp_0 = tinfl_decompress(& decomp,
                             (mz_uint8 const *)pSrc_buf + src_buf_ofs,
                             & src_buf_size,(mz_uint8 *)pBuf,tmp,
                             & dst_buf_size,
                             (mz_uint32)((flags & ~ TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF));
    tinfl_status status = (tinfl_status)tmp_0;
    if (status < 0) goto _LOR;
    else 
      if (status == TINFL_STATUS_NEEDS_MORE_INPUT) {
        _LOR:
        {
          free(pBuf);
          *pOut_len = (size_t)0;
          __retres = (void __attribute__((__visibility__("default"))) *)0;
          goto return_label;
        }
      }
    src_buf_ofs += src_buf_size;
    *pOut_len += dst_buf_size;
    if (status == TINFL_STATUS_DONE) break;
    new_out_buf_capacity = out_buf_capacity * (size_t)2;
    if (new_out_buf_capacity < (size_t)128) new_out_buf_capacity = (size_t)128;
    pNew_buf = realloc(pBuf,new_out_buf_capacity);
    if (! pNew_buf) {
      free(pBuf);
      *pOut_len = (size_t)0;
      __retres = (void __attribute__((__visibility__("default"))) *)0;
      goto return_label;
    }
    pBuf = pNew_buf;
    out_buf_capacity = new_out_buf_capacity;
  }
  __retres = (void __attribute__((__visibility__("default"))) *)pBuf;
  return_label: return __retres;
}

size_t __attribute__((__visibility__("default"))) tinfl_decompress_mem_to_mem
(void *pOut_buf, size_t out_buf_len, void const *pSrc_buf,
 size_t src_buf_len, int flags)
{
  size_t __attribute__((__visibility__("default"))) __retres;
  tinfl_decompressor decomp;
  tinfl_status status;
  tinfl_status __attribute__((__visibility__("default"))) tmp;
  size_t tmp_0;
  decomp.m_state = (mz_uint32)0;
  decomp.m_num_bits = (mz_uint32)0;
  decomp.m_bit_buf = (tinfl_bit_buf_t)0;
  decomp.m_dist = (mz_uint32)0;
  decomp.m_counter = (mz_uint32)0;
  decomp.m_num_extra = (mz_uint32)0;
  decomp.m_dist_from_out_buf_start = (size_t)0;
  tmp = tinfl_decompress(& decomp,(mz_uint8 const *)pSrc_buf,& src_buf_len,
                         (mz_uint8 *)pOut_buf,(mz_uint8 *)pOut_buf,
                         & out_buf_len,
                         (mz_uint32)((flags & ~ TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF));
  status = (tinfl_status)tmp;
  if (status != TINFL_STATUS_DONE) tmp_0 = (size_t)(-1);
  else tmp_0 = out_buf_len;
  __retres = (size_t __attribute__((__visibility__("default"))))tmp_0;
  return __retres;
}

int __attribute__((__visibility__("default"))) tinfl_decompress_mem_to_callback
(void const *pIn_buf, size_t *pIn_buf_size,
 int (*pPut_buf_func)(void const *pBuf, int len, void *pUser),
 void *pPut_buf_user, int flags)
{
  int __attribute__((__visibility__("default"))) __retres;
  tinfl_decompressor decomp;
  int result = 0;
  mz_uint8 *pDict = malloc((size_t)32768);
  size_t in_buf_ofs = (size_t)0;
  size_t dict_ofs = (size_t)0;
  if (! pDict) {
    __retres = (int __attribute__((__visibility__("default"))))TINFL_STATUS_FAILED;
    goto return_label;
  }
  decomp.m_state = (mz_uint32)0;
  decomp.m_num_bits = (mz_uint32)0;
  decomp.m_bit_buf = (tinfl_bit_buf_t)0;
  decomp.m_dist = (mz_uint32)0;
  decomp.m_counter = (mz_uint32)0;
  decomp.m_num_extra = (mz_uint32)0;
  decomp.m_dist_from_out_buf_start = (size_t)0;
  while (1) {
    tinfl_status __attribute__((__visibility__("default"))) tmp_0;
    size_t in_buf_size = *pIn_buf_size - in_buf_ofs;
    size_t dst_buf_size = (size_t)32768 - dict_ofs;
    tmp_0 = tinfl_decompress(& decomp,(mz_uint8 const *)pIn_buf + in_buf_ofs,
                             & in_buf_size,pDict,pDict + dict_ofs,
                             & dst_buf_size,
                             (mz_uint32)(flags & ~ (TINFL_FLAG_HAS_MORE_INPUT | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)));
    tinfl_status status = (tinfl_status)tmp_0;
    in_buf_ofs += in_buf_size;
    if (dst_buf_size) {
      int tmp_1;
      tmp_1 = (*pPut_buf_func)((void const *)(pDict + dict_ofs),
                               (int)dst_buf_size,pPut_buf_user);
      if (! tmp_1) break;
    }
    if (status != TINFL_STATUS_HAS_MORE_OUTPUT) {
      result = status == TINFL_STATUS_DONE;
      break;
    }
    dict_ofs = (dict_ofs + dst_buf_size) & (unsigned long)(32768 - 1);
  }
  free((void *)pDict);
  *pIn_buf_size = in_buf_ofs;
  __retres = (int __attribute__((__visibility__("default"))))result;
  return_label: return __retres;
}

tinfl_decompressor __attribute__((__visibility__("default"))) *tinfl_decompressor_alloc
(void)
{
  tinfl_decompressor __attribute__((__visibility__("default"))) *__retres;
  tinfl_decompressor *pDecomp = malloc(sizeof(tinfl_decompressor));
  if (pDecomp) {
    pDecomp->m_state = (mz_uint32)0;
    pDecomp->m_num_bits = (mz_uint32)0;
    pDecomp->m_bit_buf = (tinfl_bit_buf_t)0;
    pDecomp->m_dist = (mz_uint32)0;
    pDecomp->m_counter = (mz_uint32)0;
    pDecomp->m_num_extra = (mz_uint32)0;
    pDecomp->m_dist_from_out_buf_start = (size_t)0;
  }
  __retres = (tinfl_decompressor __attribute__((__visibility__("default"))) *)pDecomp;
  return __retres;
}

void __attribute__((__visibility__("default"))) tinfl_decompressor_free
(tinfl_decompressor *pDecomp)
{
  free((void *)pDecomp);
  return;
}


