/* Generated by Frama-C */
#include "__fc_builtin.h"
#include "assert.h"
#include "errno.h"
#include "math.h"
#include "stdarg.h"
#include "stddef.h"
#include "stdint.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "strings.h"
typedef unsigned long mz_ulong;
enum __anonenum_1 {
    MZ_DEFAULT_STRATEGY = 0,
    MZ_FILTERED = 1,
    MZ_HUFFMAN_ONLY = 2,
    MZ_RLE = 3,
    MZ_FIXED = 4
};
enum __anonenum_2 {
    MZ_NO_COMPRESSION = 0,
    MZ_BEST_SPEED = 1,
    MZ_BEST_COMPRESSION = 9,
    MZ_UBER_COMPRESSION = 10,
    MZ_DEFAULT_LEVEL = 6,
    MZ_DEFAULT_COMPRESSION = -1
};
typedef unsigned char mz_uint8;
typedef short mz_int16;
typedef unsigned short mz_uint16;
typedef unsigned int mz_uint32;
typedef unsigned int mz_uint;
typedef uint64_t mz_uint64;
typedef int mz_bool;
enum __anonenum_3 {
    TDEFL_HUFFMAN_ONLY = 0,
    TDEFL_DEFAULT_MAX_PROBES = 128,
    TDEFL_MAX_PROBES_MASK = 0xFFF
};
enum __anonenum_4 {
    TDEFL_WRITE_ZLIB_HEADER = 0x01000,
    TDEFL_COMPUTE_ADLER32 = 0x02000,
    TDEFL_GREEDY_PARSING_FLAG = 0x04000,
    TDEFL_NONDETERMINISTIC_PARSING_FLAG = 0x08000,
    TDEFL_RLE_MATCHES = 0x10000,
    TDEFL_FILTER_MATCHES = 0x20000,
    TDEFL_FORCE_ALL_STATIC_BLOCKS = 0x40000,
    TDEFL_FORCE_ALL_RAW_BLOCKS = 0x80000
};
enum __anonenum_5 {
    TDEFL_MAX_HUFF_TABLES = 3,
    TDEFL_MAX_HUFF_SYMBOLS_0 = 288,
    TDEFL_MAX_HUFF_SYMBOLS_1 = 32,
    TDEFL_MAX_HUFF_SYMBOLS_2 = 19,
    TDEFL_LZ_DICT_SIZE = 32768,
    TDEFL_LZ_DICT_SIZE_MASK = TDEFL_LZ_DICT_SIZE - 1,
    TDEFL_MIN_MATCH_LEN = 3,
    TDEFL_MAX_MATCH_LEN = 258
};
enum __anonenum_6 {
    TDEFL_LZ_CODE_BUF_SIZE = 64 * 1024,
    TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13) / 10,
    TDEFL_MAX_HUFF_SYMBOLS = 288,
    TDEFL_LZ_HASH_BITS = 15,
    TDEFL_LEVEL1_HASH_SIZE_MASK = 4095,
    TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3,
    TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS
};
enum __anonenum_tdefl_status_7 {
    TDEFL_STATUS_BAD_PARAM = -2,
    TDEFL_STATUS_PUT_BUF_FAILED = -1,
    TDEFL_STATUS_OKAY = 0,
    TDEFL_STATUS_DONE = 1
};
typedef enum __anonenum_tdefl_status_7 tdefl_status;
enum __anonenum_tdefl_flush_8 {
    TDEFL_NO_FLUSH = 0,
    TDEFL_SYNC_FLUSH = 2,
    TDEFL_FULL_FLUSH = 3,
    TDEFL_FINISH = 4
};
typedef enum __anonenum_tdefl_flush_8 tdefl_flush;
struct __anonstruct_tdefl_compressor_9 {
   mz_bool (*m_pPut_buf_func)(void const *pBuf, int len, void *pUser) ;
   void *m_pPut_buf_user ;
   mz_uint m_flags ;
   mz_uint m_max_probes[2] ;
   int m_greedy_parsing ;
   mz_uint m_adler32 ;
   mz_uint m_lookahead_pos ;
   mz_uint m_lookahead_size ;
   mz_uint m_dict_size ;
   mz_uint8 *m_pLZ_code_buf ;
   mz_uint8 *m_pLZ_flags ;
   mz_uint8 *m_pOutput_buf ;
   mz_uint8 *m_pOutput_buf_end ;
   mz_uint m_num_flags_left ;
   mz_uint m_total_lz_bytes ;
   mz_uint m_lz_code_buf_dict_pos ;
   mz_uint m_bits_in ;
   mz_uint m_bit_buffer ;
   mz_uint m_saved_match_dist ;
   mz_uint m_saved_match_len ;
   mz_uint m_saved_lit ;
   mz_uint m_output_flush_ofs ;
   mz_uint m_output_flush_remaining ;
   mz_uint m_finished ;
   mz_uint m_block_index ;
   mz_uint m_wants_to_finish ;
   tdefl_status m_prev_return_status ;
   void const *m_pIn_buf ;
   void *m_pOut_buf ;
   size_t *m_pIn_buf_size ;
   size_t *m_pOut_buf_size ;
   tdefl_flush m_flush ;
   mz_uint8 const *m_pSrc ;
   size_t m_src_buf_left ;
   size_t m_out_buf_ofs ;
   mz_uint8 m_dict[(TDEFL_LZ_DICT_SIZE + TDEFL_MAX_MATCH_LEN) - 1] ;
   mz_uint16 m_huff_count[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS] ;
   mz_uint16 m_huff_codes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS] ;
   mz_uint8 m_huff_code_sizes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS] ;
   mz_uint8 m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE] ;
   mz_uint16 m_next[TDEFL_LZ_DICT_SIZE] ;
   mz_uint16 m_hash[TDEFL_LZ_HASH_SIZE] ;
   mz_uint8 m_output_buf[TDEFL_OUT_BUF_SIZE] ;
};
typedef struct __anonstruct_tdefl_compressor_9 tdefl_compressor;
enum __anonenum_10 {
    TINFL_FLAG_PARSE_ZLIB_HEADER = 1,
    TINFL_FLAG_HAS_MORE_INPUT = 2,
    TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF = 4,
    TINFL_FLAG_COMPUTE_ADLER32 = 8
};
struct tinfl_decompressor_tag;
typedef struct tinfl_decompressor_tag tinfl_decompressor;
enum __anonenum_tinfl_status_11 {
    TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS = -4,
    TINFL_STATUS_BAD_PARAM = -3,
    TINFL_STATUS_ADLER32_MISMATCH = -2,
    TINFL_STATUS_FAILED = -1,
    TINFL_STATUS_DONE = 0,
    TINFL_STATUS_NEEDS_MORE_INPUT = 1,
    TINFL_STATUS_HAS_MORE_OUTPUT = 2
};
typedef enum __anonenum_tinfl_status_11 tinfl_status;
enum __anonenum_12 {
    TINFL_MAX_HUFF_TABLES = 3,
    TINFL_MAX_HUFF_SYMBOLS_0 = 288,
    TINFL_MAX_HUFF_SYMBOLS_1 = 32,
    TINFL_MAX_HUFF_SYMBOLS_2 = 19,
    TINFL_FAST_LOOKUP_BITS = 10,
    TINFL_FAST_LOOKUP_SIZE = 1 << TINFL_FAST_LOOKUP_BITS
};
struct __anonstruct_tinfl_huff_table_13 {
   mz_uint8 m_code_size[TINFL_MAX_HUFF_SYMBOLS_0] ;
   mz_int16 m_look_up[TINFL_FAST_LOOKUP_SIZE] ;
   mz_int16 m_tree[TINFL_MAX_HUFF_SYMBOLS_0 * 2] ;
};
typedef struct __anonstruct_tinfl_huff_table_13 tinfl_huff_table;
typedef mz_uint64 tinfl_bit_buf_t;
struct tinfl_decompressor_tag {
   mz_uint32 m_state ;
   mz_uint32 m_num_bits ;
   mz_uint32 m_zhdr0 ;
   mz_uint32 m_zhdr1 ;
   mz_uint32 m_z_adler32 ;
   mz_uint32 m_final ;
   mz_uint32 m_type ;
   mz_uint32 m_check_adler32 ;
   mz_uint32 m_dist ;
   mz_uint32 m_counter ;
   mz_uint32 m_num_extra ;
   mz_uint32 m_table_sizes[TINFL_MAX_HUFF_TABLES] ;
   tinfl_bit_buf_t m_bit_buf ;
   size_t m_dist_from_out_buf_start ;
   tinfl_huff_table m_tables[TINFL_MAX_HUFF_TABLES] ;
   mz_uint8 m_raw_header[4] ;
   mz_uint8 m_len_codes[(TINFL_MAX_HUFF_SYMBOLS_0 + TINFL_MAX_HUFF_SYMBOLS_1) + 137] ;
};
typedef unsigned char uint8;
typedef unsigned int uint;
struct __anonstruct_rgb_t_22 {
   uint8 r ;
   uint8 g ;
   uint8 b ;
};
typedef struct __anonstruct_rgb_t_22 rgb_t;
enum __anonenum_0 {
    MZ_NO_FLUSH = 0,
    MZ_PARTIAL_FLUSH = 1,
    MZ_SYNC_FLUSH = 2,
    MZ_FULL_FLUSH = 3,
    MZ_FINISH = 4,
    MZ_BLOCK = 5
};
enum __anonenum_7 {
    MZ_OK = 0,
    MZ_STREAM_END = 1,
    MZ_NEED_DICT = 2,
    MZ_ERRNO = -1,
    MZ_STREAM_ERROR = -2,
    MZ_DATA_ERROR = -3,
    MZ_MEM_ERROR = -4,
    MZ_BUF_ERROR = -5,
    MZ_VERSION_ERROR = -6,
    MZ_PARAM_ERROR = -10000
};
struct mz_internal_state;
struct mz_stream_s {
   unsigned char const *next_in ;
   unsigned int avail_in ;
   mz_ulong total_in ;
   unsigned char *next_out ;
   unsigned int avail_out ;
   mz_ulong total_out ;
   char *msg ;
   struct mz_internal_state *state ;
   void *(*zalloc)(void *opaque, size_t items, size_t size) ;
   void (*zfree)(void *opaque, void *address) ;
   void *opaque ;
   int data_type ;
   mz_ulong adler ;
   mz_ulong reserved ;
};
typedef struct mz_stream_s mz_stream;
typedef mz_stream *mz_streamp;
struct __anonstruct_inflate_state_24 {
   tinfl_decompressor m_decomp ;
   mz_uint m_dict_ofs ;
   mz_uint m_dict_avail ;
   mz_uint m_first_call ;
   mz_uint m_has_flushed ;
   int m_window_bits ;
   mz_uint8 m_dict[32768] ;
   tinfl_status m_last_status ;
};
typedef struct __anonstruct_inflate_state_24 inflate_state;
struct __anonstruct_s_error_descs_25 {
   int m_err ;
   char const *m_pDesc ;
};
struct __anonstruct_tdefl_sym_freq_24 {
   mz_uint16 m_key ;
   mz_uint16 m_sym_index ;
};
typedef struct __anonstruct_tdefl_sym_freq_24 tdefl_sym_freq;
enum __anonenum_25 {
    TDEFL_MAX_SUPPORTED_HUFF_CODESIZE = 32
};
struct __anonstruct_tdefl_output_buffer_26 {
   size_t m_size ;
   size_t m_capacity ;
   mz_uint8 *m_pBuf ;
   mz_bool m_expandable ;
};
typedef struct __anonstruct_tdefl_output_buffer_26 tdefl_output_buffer;
int main(int argc, char **argv);

int eva_main(void)
{
  char argv0[256];
  char argv1[256];
  char argv2[256];
  char argv3[256];
  char argv4[256];
  int tmp_0;
  int argc = Frama_C_interval(0,5);
  char *argv[6] = {argv0, argv1, argv2, argv3, argv4, (char *)0};
  {
    int i = 0;
    /*@ loop unroll 5; */
    while (i < 5) {
      Frama_C_make_unknown(argv[i],(size_t)255);
      *(argv[i] + 255) = (char)0;
      i ++;
    }
  }
  tmp_0 = main(argc,argv);
  return tmp_0;
}

void __attribute__((__visibility__("default"))) mz_free(void *p);

mz_ulong __attribute__((__visibility__("default"))) mz_adler32(mz_ulong adler,
                                                               unsigned char const *ptr,
                                                               size_t buf_len);

mz_ulong __attribute__((__visibility__("default"))) mz_crc32(mz_ulong crc,
                                                             unsigned char const *ptr,
                                                             size_t buf_len);

void __attribute__((__visibility__("default"))) *miniz_def_alloc_func
(void *opaque, size_t items, size_t size);

void __attribute__((__visibility__("default"))) miniz_def_free_func(void *opaque,
                                                                    void *address);

void __attribute__((__visibility__("default"))) *miniz_def_realloc_func
(void *opaque, void *address, size_t items, size_t size);

void __attribute__((__visibility__("default"))) *tdefl_compress_mem_to_heap
(void const *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags);

size_t __attribute__((__visibility__("default"))) tdefl_compress_mem_to_mem
(void *pOut_buf, size_t out_buf_len, void const *pSrc_buf,
 size_t src_buf_len, int flags);

void __attribute__((__visibility__("default"))) *tdefl_write_image_to_png_file_in_memory_ex
(void const *pImage, int w, int h, int num_chans, size_t *pLen_out,
 mz_uint level, mz_bool flip);

void __attribute__((__visibility__("default"))) *tdefl_write_image_to_png_file_in_memory
(void const *pImage, int w, int h, int num_chans, size_t *pLen_out);

mz_bool __attribute__((__visibility__("default"))) tdefl_compress_mem_to_output
(void const *pBuf, size_t buf_len,
 mz_bool (*pPut_buf_func)(void const *pBuf, int len, void *pUser),
 void *pPut_buf_user, int flags);

tdefl_status __attribute__((__visibility__("default"))) tdefl_init(tdefl_compressor *d,
                                                                   mz_bool (*pPut_buf_func)
                                                                   (void const *pBuf,
                                                                    int len,
                                                                    void *pUser),
                                                                   void *pPut_buf_user,
                                                                   int flags);

tdefl_status __attribute__((__visibility__("default"))) tdefl_compress
(tdefl_compressor *d, void const *pIn_buf, size_t *pIn_buf_size,
 void *pOut_buf, size_t *pOut_buf_size, tdefl_flush flush);

tdefl_status __attribute__((__visibility__("default"))) tdefl_compress_buffer
(tdefl_compressor *d, void const *pIn_buf, size_t in_buf_size,
 tdefl_flush flush);

tdefl_status __attribute__((__visibility__("default"))) tdefl_get_prev_return_status
(tdefl_compressor *d);

mz_uint32 __attribute__((__visibility__("default"))) tdefl_get_adler32
(tdefl_compressor *d);

mz_uint __attribute__((__visibility__("default"))) tdefl_create_comp_flags_from_zip_params
(int level, int window_bits, int strategy);

tdefl_compressor __attribute__((__visibility__("default"))) *tdefl_compressor_alloc
(void);

void __attribute__((__visibility__("default"))) tdefl_compressor_free
(tdefl_compressor *pComp);

tinfl_status __attribute__((__visibility__("default"))) tinfl_decompress
(tinfl_decompressor *r, mz_uint8 const *pIn_buf_next, size_t *pIn_buf_size,
 mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size,
 mz_uint32 const decomp_flags);

static void hsv_to_rgb(int hue, int min, int max, rgb_t *p)
{
  double tmp_3;
  double tmp_2;
  uint8 tmp_5;
  uint8 tmp_4;
  int const invert = 0;
  int const saturation = 1;
  int const color_rotate = 0;
  if (min == max) max = min + 1;
  if (invert) hue = max - (hue - min);
  if (! saturation) {
    uint8 tmp_0;
    uint8 tmp;
    tmp_0 = (uint8)((255 * (max - hue)) / (max - min));
    p->b = tmp_0;
    tmp = tmp_0;
    p->g = tmp;
    p->r = tmp;
    goto return_label;
  }
  double h =
    fmod(((double)color_rotate + 1e-4) + (4.0 * (double)(hue - min)) / (double)(
                                         max - min),(double)6);
  double c = (double)(255.0f * (float)saturation);
  tmp_2 = fmod(h,(double)2);
  tmp_3 = fabs(tmp_2 - (double)1);
  double X = c * ((double)1 - tmp_3);
  tmp_5 = (uint8)0;
  p->b = tmp_5;
  tmp_4 = tmp_5;
  p->g = tmp_4;
  p->r = tmp_4;
  switch ((int)h) {
    case 0: p->r = (uint8)c;
    p->g = (uint8)X;
    goto return_label;
    case 1: p->r = (uint8)X;
    p->g = (uint8)c;
    goto return_label;
    case 2: p->g = (uint8)c;
    p->b = (uint8)X;
    goto return_label;
    case 3: p->g = (uint8)X;
    p->b = (uint8)c;
    goto return_label;
    case 4: p->r = (uint8)X;
    p->b = (uint8)c;
    goto return_label;
    default: p->r = (uint8)c;
    p->b = (uint8)X;
  }
  return_label: return;
}

static char const *main_pFilename = "mandelbrot.png";
/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_1(FILE * restrict stream, char const * restrict format);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_1(char const * restrict format, char *param0);

int main(int argc, char **argv)
{
  int __retres;
  int iX;
  int iY;
  double Zx;
  double Zy;
  double Zx2;
  double Zy2;
  int Iteration;
  double Cx;
  double Cy;
  int const iXmax = 4096;
  int const iYmax = 4096;
  double const CxMin = - 2.5;
  double const CxMax = 1.5;
  double const CyMin = - 2.0;
  double const CyMax = 2.0;
  double PixelWidth = (CxMax - CxMin) / (double)iXmax;
  double PixelHeight = (CyMax - CyMin) / (double)iYmax;
  int const IterationMax = 200;
  double const EscapeRadius = (double)2;
  double ER2 = EscapeRadius * EscapeRadius;
  uint8 *pImage = malloc((size_t)((iXmax * 3) * iYmax));
  int MinIter = 9999;
  int MaxIter = 0;
  iY = 0;
  while (iY < iYmax) {
    {
      double tmp_0;
      Cy = CyMin + (double)iY * PixelHeight;
      tmp_0 = fabs(Cy);
      ;
      if (tmp_0 < PixelHeight / (double)2) Cy = 0.0;
      iX = 0;
      while (iX < iXmax) {
        {
          uint8 *color = (pImage + iX * 3) + (iY * iXmax) * 3;
          Cx = CxMin + (double)iX * PixelWidth;
          Zx = 0.0;
          Zy = 0.0;
          Zx2 = Zx * Zx;
          Zy2 = Zy * Zy;
          Iteration = 0;
          while (1) {
            if (Iteration < IterationMax) {
              if (! (Zx2 + Zy2 < ER2)) break;
            }
            else break;
            Zy = ((double)2 * Zx) * Zy + Cy;
            Zx = (Zx2 - Zy2) + Cx;
            Zx2 = Zx * Zx;
            Zy2 = Zy * Zy;
            Iteration ++;
          }
          *(color + 0) = (uint8)Iteration;
          *(color + 1) = (uint8)((int)((uint8)Iteration) >> 8);
          *(color + 2) = (uint8)0;
          if (Iteration < MinIter) MinIter = Iteration;
          if (Iteration > MaxIter) MaxIter = Iteration;
        }
        iX ++;
      }
    }
    iY ++;
  }
  iY = 0;
  while (iY < iYmax) {
    iX = 0;
    while (iX < iXmax) {
      {
        uint8 *color_0 = (pImage + iX * 3) + (iY * iXmax) * 3;
        uint Iterations =
          (uint)((int)*(color_0 + 0) | ((int)*(color_0 + 1) << 8U));
        hsv_to_rgb((int)Iterations,MinIter,MaxIter,(rgb_t *)color_0);
      }
      iX ++;
    }
    iY ++;
  }
  {
    size_t png_data_size = (size_t)0;
    void *pPNG_data =
      tdefl_write_image_to_png_file_in_memory_ex((void const *)pImage,iXmax,
                                                 iYmax,3,& png_data_size,
                                                 (mz_uint)6,0);
    if (! pPNG_data) fprintf(__fc_stderr,
                             "tdefl_write_image_to_png_file_in_memory_ex() failed!\n"); /* fprintf_va_1 */
    else {
      FILE *pFile = fopen(main_pFilename,"wb");
      fwrite((void const *)pPNG_data,(size_t)1,png_data_size,pFile);
      fclose(pFile);
      printf("Wrote %s\n",(char *)main_pFilename); /* printf_va_1 */
    }
    mz_free(pPNG_data);
  }
  free((void *)pImage);
  __retres = 0;
  return __retres;
}

char const __attribute__((__visibility__("default"))) *mz_version(void);

int __attribute__((__visibility__("default"))) mz_deflateInit(mz_streamp pStream,
                                                              int level);

int __attribute__((__visibility__("default"))) mz_deflateInit2(mz_streamp pStream,
                                                               int level,
                                                               int method,
                                                               int window_bits,
                                                               int mem_level,
                                                               int strategy);

int __attribute__((__visibility__("default"))) mz_deflateReset(mz_streamp pStream);

int __attribute__((__visibility__("default"))) mz_deflate(mz_streamp pStream,
                                                          int flush);

int __attribute__((__visibility__("default"))) mz_deflateEnd(mz_streamp pStream);

mz_ulong __attribute__((__visibility__("default"))) mz_deflateBound(mz_streamp pStream,
                                                                    mz_ulong source_len);

int __attribute__((__visibility__("default"))) mz_compress(unsigned char *pDest,
                                                           mz_ulong *pDest_len,
                                                           unsigned char const *pSource,
                                                           mz_ulong source_len);

int __attribute__((__visibility__("default"))) mz_compress2(unsigned char *pDest,
                                                            mz_ulong *pDest_len,
                                                            unsigned char const *pSource,
                                                            mz_ulong source_len,
                                                            int level);

mz_ulong __attribute__((__visibility__("default"))) mz_compressBound(
                                                                    mz_ulong source_len);

int __attribute__((__visibility__("default"))) mz_inflateInit(mz_streamp pStream);

int __attribute__((__visibility__("default"))) mz_inflateInit2(mz_streamp pStream,
                                                               int window_bits);

int __attribute__((__visibility__("default"))) mz_inflateReset(mz_streamp pStream);

int __attribute__((__visibility__("default"))) mz_inflate(mz_streamp pStream,
                                                          int flush);

int __attribute__((__visibility__("default"))) mz_inflateEnd(mz_streamp pStream);

int __attribute__((__visibility__("default"))) mz_uncompress(unsigned char *pDest,
                                                             mz_ulong *pDest_len,
                                                             unsigned char const *pSource,
                                                             mz_ulong source_len);

int __attribute__((__visibility__("default"))) mz_uncompress2(unsigned char *pDest,
                                                              mz_ulong *pDest_len,
                                                              unsigned char const *pSource,
                                                              mz_ulong *pSource_len);

char const __attribute__((__visibility__("default"))) *mz_error(int err);

mz_ulong __attribute__((__visibility__("default"))) mz_adler32(mz_ulong adler,
                                                               unsigned char const *ptr,
                                                               size_t buf_len)
{
  mz_ulong __attribute__((__visibility__("default"))) __retres;
  mz_uint32 i;
  mz_uint32 s1 = (mz_uint32)(adler & (unsigned long)0xffff);
  mz_uint32 s2 = (mz_uint32)(adler >> 16);
  size_t block_len = buf_len % (unsigned long)5552;
  if (! ptr) {
    __retres = (mz_ulong __attribute__((__visibility__("default"))))1;
    goto return_label;
  }
  while (buf_len) {
    i = (mz_uint32)0;
    while ((size_t)(i + (mz_uint32)7) < block_len) {
      s1 += (mz_uint32)*(ptr + 0);
      s2 += s1;
      s1 += (mz_uint32)*(ptr + 1);
      s2 += s1;
      s1 += (mz_uint32)*(ptr + 2);
      s2 += s1;
      s1 += (mz_uint32)*(ptr + 3);
      s2 += s1;
      s1 += (mz_uint32)*(ptr + 4);
      s2 += s1;
      s1 += (mz_uint32)*(ptr + 5);
      s2 += s1;
      s1 += (mz_uint32)*(ptr + 6);
      s2 += s1;
      s1 += (mz_uint32)*(ptr + 7);
      s2 += s1;
      i += (mz_uint32)8;
      ptr += 8;
    }
    while ((size_t)i < block_len) {
      unsigned char const *tmp;
      tmp = ptr;
      ptr ++;
      s1 += (mz_uint32)*tmp;
      s2 += s1;
      i ++;
    }
    s1 %= 65521U;
    s2 %= 65521U;
    buf_len -= block_len;
    block_len = (size_t)5552;
  }
  __retres = (mz_ulong __attribute__((__visibility__("default"))))((s2 << 16) + s1);
  return_label: return __retres;
}

static mz_uint32 const mz_crc32_s_crc_table[256] =
  {(mz_uint32)0x00000000,
   (mz_uint32)0x77073096,
   0xEE0E612C,
   0x990951BA,
   (mz_uint32)0x076DC419,
   (mz_uint32)0x706AF48F,
   0xE963A535,
   0x9E6495A3,
   (mz_uint32)0x0EDB8832,
   (mz_uint32)0x79DCB8A4,
   0xE0D5E91E,
   0x97D2D988,
   (mz_uint32)0x09B64C2B,
   (mz_uint32)0x7EB17CBD,
   0xE7B82D07,
   0x90BF1D91,
   (mz_uint32)0x1DB71064,
   (mz_uint32)0x6AB020F2,
   0xF3B97148,
   0x84BE41DE,
   (mz_uint32)0x1ADAD47D,
   (mz_uint32)0x6DDDE4EB,
   0xF4D4B551,
   0x83D385C7,
   (mz_uint32)0x136C9856,
   (mz_uint32)0x646BA8C0,
   0xFD62F97A,
   0x8A65C9EC,
   (mz_uint32)0x14015C4F,
   (mz_uint32)0x63066CD9,
   0xFA0F3D63,
   0x8D080DF5,
   (mz_uint32)0x3B6E20C8,
   (mz_uint32)0x4C69105E,
   0xD56041E4,
   0xA2677172,
   (mz_uint32)0x3C03E4D1,
   (mz_uint32)0x4B04D447,
   0xD20D85FD,
   0xA50AB56B,
   (mz_uint32)0x35B5A8FA,
   (mz_uint32)0x42B2986C,
   0xDBBBC9D6,
   0xACBCF940,
   (mz_uint32)0x32D86CE3,
   (mz_uint32)0x45DF5C75,
   0xDCD60DCF,
   0xABD13D59,
   (mz_uint32)0x26D930AC,
   (mz_uint32)0x51DE003A,
   0xC8D75180,
   0xBFD06116,
   (mz_uint32)0x21B4F4B5,
   (mz_uint32)0x56B3C423,
   0xCFBA9599,
   0xB8BDA50F,
   (mz_uint32)0x2802B89E,
   (mz_uint32)0x5F058808,
   0xC60CD9B2,
   0xB10BE924,
   (mz_uint32)0x2F6F7C87,
   (mz_uint32)0x58684C11,
   0xC1611DAB,
   0xB6662D3D,
   (mz_uint32)0x76DC4190,
   (mz_uint32)0x01DB7106,
   0x98D220BC,
   0xEFD5102A,
   (mz_uint32)0x71B18589,
   (mz_uint32)0x06B6B51F,
   0x9FBFE4A5,
   0xE8B8D433,
   (mz_uint32)0x7807C9A2,
   (mz_uint32)0x0F00F934,
   0x9609A88E,
   0xE10E9818,
   (mz_uint32)0x7F6A0DBB,
   (mz_uint32)0x086D3D2D,
   0x91646C97,
   0xE6635C01,
   (mz_uint32)0x6B6B51F4,
   (mz_uint32)0x1C6C6162,
   0x856530D8,
   0xF262004E,
   (mz_uint32)0x6C0695ED,
   (mz_uint32)0x1B01A57B,
   0x8208F4C1,
   0xF50FC457,
   (mz_uint32)0x65B0D9C6,
   (mz_uint32)0x12B7E950,
   0x8BBEB8EA,
   0xFCB9887C,
   (mz_uint32)0x62DD1DDF,
   (mz_uint32)0x15DA2D49,
   0x8CD37CF3,
   0xFBD44C65,
   (mz_uint32)0x4DB26158,
   (mz_uint32)0x3AB551CE,
   0xA3BC0074,
   0xD4BB30E2,
   (mz_uint32)0x4ADFA541,
   (mz_uint32)0x3DD895D7,
   0xA4D1C46D,
   0xD3D6F4FB,
   (mz_uint32)0x4369E96A,
   (mz_uint32)0x346ED9FC,
   0xAD678846,
   0xDA60B8D0,
   (mz_uint32)0x44042D73,
   (mz_uint32)0x33031DE5,
   0xAA0A4C5F,
   0xDD0D7CC9,
   (mz_uint32)0x5005713C,
   (mz_uint32)0x270241AA,
   0xBE0B1010,
   0xC90C2086,
   (mz_uint32)0x5768B525,
   (mz_uint32)0x206F85B3,
   0xB966D409,
   0xCE61E49F,
   (mz_uint32)0x5EDEF90E,
   (mz_uint32)0x29D9C998,
   0xB0D09822,
   0xC7D7A8B4,
   (mz_uint32)0x59B33D17,
   (mz_uint32)0x2EB40D81,
   0xB7BD5C3B,
   0xC0BA6CAD,
   0xEDB88320,
   0x9ABFB3B6,
   (mz_uint32)0x03B6E20C,
   (mz_uint32)0x74B1D29A,
   0xEAD54739,
   0x9DD277AF,
   (mz_uint32)0x04DB2615,
   (mz_uint32)0x73DC1683,
   0xE3630B12,
   0x94643B84,
   (mz_uint32)0x0D6D6A3E,
   (mz_uint32)0x7A6A5AA8,
   0xE40ECF0B,
   0x9309FF9D,
   (mz_uint32)0x0A00AE27,
   (mz_uint32)0x7D079EB1,
   0xF00F9344,
   0x8708A3D2,
   (mz_uint32)0x1E01F268,
   (mz_uint32)0x6906C2FE,
   0xF762575D,
   0x806567CB,
   (mz_uint32)0x196C3671,
   (mz_uint32)0x6E6B06E7,
   0xFED41B76,
   0x89D32BE0,
   (mz_uint32)0x10DA7A5A,
   (mz_uint32)0x67DD4ACC,
   0xF9B9DF6F,
   0x8EBEEFF9,
   (mz_uint32)0x17B7BE43,
   (mz_uint32)0x60B08ED5,
   0xD6D6A3E8,
   0xA1D1937E,
   (mz_uint32)0x38D8C2C4,
   (mz_uint32)0x4FDFF252,
   0xD1BB67F1,
   0xA6BC5767,
   (mz_uint32)0x3FB506DD,
   (mz_uint32)0x48B2364B,
   0xD80D2BDA,
   0xAF0A1B4C,
   (mz_uint32)0x36034AF6,
   (mz_uint32)0x41047A60,
   0xDF60EFC3,
   0xA867DF55,
   (mz_uint32)0x316E8EEF,
   (mz_uint32)0x4669BE79,
   0xCB61B38C,
   0xBC66831A,
   (mz_uint32)0x256FD2A0,
   (mz_uint32)0x5268E236,
   0xCC0C7795,
   0xBB0B4703,
   (mz_uint32)0x220216B9,
   (mz_uint32)0x5505262F,
   0xC5BA3BBE,
   0xB2BD0B28,
   (mz_uint32)0x2BB45A92,
   (mz_uint32)0x5CB36A04,
   0xC2D7FFA7,
   0xB5D0CF31,
   (mz_uint32)0x2CD99E8B,
   (mz_uint32)0x5BDEAE1D,
   0x9B64C2B0,
   0xEC63F226,
   (mz_uint32)0x756AA39C,
   (mz_uint32)0x026D930A,
   0x9C0906A9,
   0xEB0E363F,
   (mz_uint32)0x72076785,
   (mz_uint32)0x05005713,
   0x95BF4A82,
   0xE2B87A14,
   (mz_uint32)0x7BB12BAE,
   (mz_uint32)0x0CB61B38,
   0x92D28E9B,
   0xE5D5BE0D,
   (mz_uint32)0x7CDCEFB7,
   (mz_uint32)0x0BDBDF21,
   0x86D3D2D4,
   0xF1D4E242,
   (mz_uint32)0x68DDB3F8,
   (mz_uint32)0x1FDA836E,
   0x81BE16CD,
   0xF6B9265B,
   (mz_uint32)0x6FB077E1,
   (mz_uint32)0x18B74777,
   0x88085AE6,
   0xFF0F6A70,
   (mz_uint32)0x66063BCA,
   (mz_uint32)0x11010B5C,
   0x8F659EFF,
   0xF862AE69,
   (mz_uint32)0x616BFFD3,
   (mz_uint32)0x166CCF45,
   0xA00AE278,
   0xD70DD2EE,
   (mz_uint32)0x4E048354,
   (mz_uint32)0x3903B3C2,
   0xA7672661,
   0xD06016F7,
   (mz_uint32)0x4969474D,
   (mz_uint32)0x3E6E77DB,
   0xAED16A4A,
   0xD9D65ADC,
   (mz_uint32)0x40DF0B66,
   (mz_uint32)0x37D83BF0,
   0xA9BCAE53,
   0xDEBB9EC5,
   (mz_uint32)0x47B2CF7F,
   (mz_uint32)0x30B5FFE9,
   0xBDBDF21C,
   0xCABAC28A,
   (mz_uint32)0x53B39330,
   (mz_uint32)0x24B4A3A6,
   0xBAD03605,
   0xCDD70693,
   (mz_uint32)0x54DE5729,
   (mz_uint32)0x23D967BF,
   0xB3667A2E,
   0xC4614AB8,
   (mz_uint32)0x5D681B02,
   (mz_uint32)0x2A6F2B94,
   0xB40BBE37,
   0xC30C8EA1,
   (mz_uint32)0x5A05DF1B,
   (mz_uint32)0x2D02EF8D};
mz_ulong __attribute__((__visibility__("default"))) mz_crc32(mz_ulong crc,
                                                             unsigned char const *ptr,
                                                             size_t buf_len)
{
  mz_ulong __attribute__((__visibility__("default"))) __retres;
  mz_uint32 mz_crc32_0 = (mz_uint32)crc ^ 0xFFFFFFFF;
  mz_uint8 const *pByte_buf = ptr;
  while (buf_len >= (size_t)4) {
    mz_crc32_0 = (mz_crc32_0 >> 8) ^ mz_crc32_s_crc_table[(mz_crc32_0 ^ (unsigned int)*(
                                                           pByte_buf + 0)) & (unsigned int)0xFF];
    mz_crc32_0 = (mz_crc32_0 >> 8) ^ mz_crc32_s_crc_table[(mz_crc32_0 ^ (unsigned int)*(
                                                           pByte_buf + 1)) & (unsigned int)0xFF];
    mz_crc32_0 = (mz_crc32_0 >> 8) ^ mz_crc32_s_crc_table[(mz_crc32_0 ^ (unsigned int)*(
                                                           pByte_buf + 2)) & (unsigned int)0xFF];
    mz_crc32_0 = (mz_crc32_0 >> 8) ^ mz_crc32_s_crc_table[(mz_crc32_0 ^ (unsigned int)*(
                                                           pByte_buf + 3)) & (unsigned int)0xFF];
    pByte_buf += 4;
    buf_len -= (size_t)4;
  }
  while (buf_len) {
    mz_crc32_0 = (mz_crc32_0 >> 8) ^ mz_crc32_s_crc_table[(mz_crc32_0 ^ (unsigned int)*(
                                                           pByte_buf + 0)) & (unsigned int)0xFF];
    pByte_buf ++;
    buf_len --;
  }
  __retres = (mz_ulong __attribute__((__visibility__("default"))))(~ mz_crc32_0);
  return __retres;
}

void __attribute__((__visibility__("default"))) mz_free(void *p)
{
  free(p);
  return;
}

void __attribute__((__visibility__("default"))) *miniz_def_alloc_func
(void *opaque, size_t items, size_t size)
{
  void __attribute__((__visibility__("default"))) *tmp;
  tmp = (void __attribute__((__visibility__("default"))) *)malloc(items * size);
  return tmp;
}

void __attribute__((__visibility__("default"))) miniz_def_free_func(void *opaque,
                                                                    void *address)
{
  free(address);
  return;
}

void __attribute__((__visibility__("default"))) *miniz_def_realloc_func
(void *opaque, void *address, size_t items, size_t size)
{
  void __attribute__((__visibility__("default"))) *tmp;
  tmp = (void __attribute__((__visibility__("default"))) *)realloc(address,
                                                                   items * size);
  return tmp;
}

char const __attribute__((__visibility__("default"))) *mz_version(void)
{
  char const __attribute__((__visibility__("default"))) *__retres;
  __retres = (char const __attribute__((__visibility__("default"))) *)"10.1.0";
  return __retres;
}

int __attribute__((__visibility__("default"))) mz_deflateInit(mz_streamp pStream,
                                                              int level)
{
  int __attribute__((__visibility__("default"))) tmp;
  tmp = mz_deflateInit2(pStream,level,8,15,9,MZ_DEFAULT_STRATEGY);
  return tmp;
}

int __attribute__((__visibility__("default"))) mz_deflateInit2(mz_streamp pStream,
                                                               int level,
                                                               int method,
                                                               int window_bits,
                                                               int mem_level,
                                                               int strategy)
{
  int __attribute__((__visibility__("default"))) __retres;
  tdefl_compressor *pComp;
  mz_uint __attribute__((__visibility__("default"))) tmp;
  tdefl_status __attribute__((__visibility__("default"))) tmp_1;
  tmp = tdefl_create_comp_flags_from_zip_params(level,window_bits,strategy);
  mz_uint comp_flags =
    (mz_uint)((unsigned int __attribute__((__visibility__("default"))))TDEFL_COMPUTE_ADLER32 | tmp);
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  if (method != 8) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
    goto return_label;
  }
  else 
    if (mem_level < 1) {
      __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
      goto return_label;
    }
    else 
      if (mem_level > 9) {
        __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
        goto return_label;
      }
      else 
        if (window_bits != 15) 
          if (- window_bits != 15) {
            __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
            goto return_label;
          }
  pStream->data_type = 0;
  pStream->adler = (mz_ulong)1;
  pStream->msg = (char *)0;
  pStream->reserved = (mz_ulong)0;
  pStream->total_in = (mz_ulong)0;
  pStream->total_out = (mz_ulong)0;
  if (! pStream->zalloc) pStream->zalloc = (void *(*)(void *opaque,
                                                      size_t items,
                                                      size_t size))(& miniz_def_alloc_func);
  if (! pStream->zfree) pStream->zfree = (void (*)(void *opaque,
                                                   void *address))(& miniz_def_free_func);
  pComp = (tdefl_compressor *)(*(pStream->zalloc))(pStream->opaque,(size_t)1,
                                                   sizeof(tdefl_compressor));
  if (! pComp) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_MEM_ERROR;
    goto return_label;
  }
  pStream->state = (struct mz_internal_state *)pComp;
  tmp_1 = tdefl_init(pComp,
                     (mz_bool (*)(void const *pBuf, int len, void *pUser))0,
                     (void *)0,(int)comp_flags);
  if (tmp_1 != (int __attribute__((__visibility__("default"))))TDEFL_STATUS_OKAY) {
    mz_deflateEnd(pStream);
    __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
    goto return_label;
  }
  __retres = (int __attribute__((__visibility__("default"))))MZ_OK;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_deflateReset(mz_streamp pStream)
{
  int __attribute__((__visibility__("default"))) __retres;
  mz_ulong tmp;
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  else 
    if (! pStream->state) {
      __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
      goto return_label;
    }
    else 
      if (! pStream->zalloc) {
        __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
        goto return_label;
      }
      else 
        if (! pStream->zfree) {
          __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
          goto return_label;
        }
  tmp = (mz_ulong)0;
  pStream->total_out = tmp;
  pStream->total_in = tmp;
  tdefl_init((tdefl_compressor *)pStream->state,
             (mz_bool (*)(void const *pBuf, int len, void *pUser))0,
             (void *)0,(int)((tdefl_compressor *)pStream->state)->m_flags);
  __retres = (int __attribute__((__visibility__("default"))))MZ_OK;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_deflate(mz_streamp pStream,
                                                          int flush)
{
  int __attribute__((__visibility__("default"))) __retres;
  size_t in_bytes;
  size_t out_bytes;
  mz_ulong orig_total_in;
  mz_ulong orig_total_out;
  int mz_status = MZ_OK;
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  else 
    if (! pStream->state) {
      __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
      goto return_label;
    }
    else 
      if (flush < 0) {
        __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
        goto return_label;
      }
      else 
        if (flush > MZ_FINISH) {
          __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
          goto return_label;
        }
        else 
          if (! pStream->next_out) {
            __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
            goto return_label;
          }
  if (! pStream->avail_out) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_BUF_ERROR;
    goto return_label;
  }
  if (flush == MZ_PARTIAL_FLUSH) flush = MZ_SYNC_FLUSH;
  if (((tdefl_compressor *)pStream->state)->m_prev_return_status == TDEFL_STATUS_DONE) {
    int tmp;
    if (flush == MZ_FINISH) tmp = MZ_STREAM_END; else tmp = MZ_BUF_ERROR;
    __retres = (int __attribute__((__visibility__("default"))))tmp;
    goto return_label;
  }
  orig_total_in = pStream->total_in;
  orig_total_out = pStream->total_out;
  while (1) {
    tdefl_status defl_status;
    tdefl_status __attribute__((__visibility__("default"))) tmp_0;
    mz_uint32 __attribute__((__visibility__("default"))) tmp_1;
    in_bytes = (size_t)pStream->avail_in;
    out_bytes = (size_t)pStream->avail_out;
    tmp_0 = tdefl_compress((tdefl_compressor *)pStream->state,
                           (void const *)pStream->next_in,& in_bytes,
                           (void *)pStream->next_out,& out_bytes,
                           (tdefl_flush)flush);
    defl_status = (tdefl_status)tmp_0;
    pStream->next_in += (mz_uint)in_bytes;
    pStream->avail_in -= (mz_uint)in_bytes;
    pStream->total_in += (mz_ulong)((mz_uint)in_bytes);
    tmp_1 = tdefl_get_adler32((tdefl_compressor *)pStream->state);
    pStream->adler = (mz_ulong)tmp_1;
    pStream->next_out += (mz_uint)out_bytes;
    pStream->avail_out -= (mz_uint)out_bytes;
    pStream->total_out += (mz_ulong)((mz_uint)out_bytes);
    if (defl_status < 0) {
      mz_status = MZ_STREAM_ERROR;
      break;
    }
    else 
      if (defl_status == TDEFL_STATUS_DONE) {
        mz_status = MZ_STREAM_END;
        break;
      }
      else 
        if (! pStream->avail_out) break;
        else 
          if (! pStream->avail_in) 
            if (flush != MZ_FINISH) {
              if (flush) break;
              else 
                if (pStream->total_in != orig_total_in) break;
                else 
                  if (pStream->total_out != orig_total_out) break;
              __retres = (int __attribute__((__visibility__("default"))))MZ_BUF_ERROR;
              goto return_label;
            }
  }
  __retres = (int __attribute__((__visibility__("default"))))mz_status;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_deflateEnd(mz_streamp pStream)
{
  int __attribute__((__visibility__("default"))) __retres;
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  if (pStream->state) {
    (*(pStream->zfree))(pStream->opaque,(void *)pStream->state);
    pStream->state = (struct mz_internal_state *)0;
  }
  __retres = (int __attribute__((__visibility__("default"))))MZ_OK;
  return_label: return __retres;
}

mz_ulong __attribute__((__visibility__("default"))) mz_deflateBound(mz_streamp pStream,
                                                                    mz_ulong source_len)
{
  mz_ulong __attribute__((__visibility__("default"))) __retres;
  mz_ulong tmp;
  if ((mz_ulong)128 + (source_len * (mz_ulong)110) / (mz_ulong)100 > 
      ((mz_ulong)128 + source_len) + (source_len / (mz_ulong)(31 * 1024) + (mz_ulong)1) * (mz_ulong)5) 
    tmp = (mz_ulong)128 + (source_len * (mz_ulong)110) / (mz_ulong)100;
  else tmp = ((mz_ulong)128 + source_len) + (source_len / (mz_ulong)(
                                             31 * 1024) + (mz_ulong)1) * (mz_ulong)5;
  __retres = (mz_ulong __attribute__((__visibility__("default"))))tmp;
  return __retres;
}

int __attribute__((__visibility__("default"))) mz_compress2(unsigned char *pDest,
                                                            mz_ulong *pDest_len,
                                                            unsigned char const *pSource,
                                                            mz_ulong source_len,
                                                            int level)
{
  int __attribute__((__visibility__("default"))) __retres;
  int status;
  mz_stream stream;
  int __attribute__((__visibility__("default"))) tmp_0;
  memset((void *)(& stream),0,sizeof(stream));
  if ((source_len | *pDest_len) > (unsigned long)0xFFFFFFFFU) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
    goto return_label;
  }
  stream.next_in = pSource;
  stream.avail_in = (mz_uint32)source_len;
  stream.next_out = pDest;
  stream.avail_out = (mz_uint32)*pDest_len;
  status = (int)mz_deflateInit(& stream,level);
  if (status != MZ_OK) {
    __retres = (int __attribute__((__visibility__("default"))))status;
    goto return_label;
  }
  status = (int)mz_deflate(& stream,MZ_FINISH);
  if (status != MZ_STREAM_END) {
    int tmp;
    mz_deflateEnd(& stream);
    if (status == MZ_OK) tmp = MZ_BUF_ERROR; else tmp = status;
    __retres = (int __attribute__((__visibility__("default"))))tmp;
    goto return_label;
  }
  *pDest_len = stream.total_out;
  tmp_0 = mz_deflateEnd(& stream);
  __retres = tmp_0;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_compress(unsigned char *pDest,
                                                           mz_ulong *pDest_len,
                                                           unsigned char const *pSource,
                                                           mz_ulong source_len)
{
  int __attribute__((__visibility__("default"))) tmp;
  tmp = mz_compress2(pDest,pDest_len,pSource,source_len,
                     MZ_DEFAULT_COMPRESSION);
  return tmp;
}

mz_ulong __attribute__((__visibility__("default"))) mz_compressBound(
                                                                    mz_ulong source_len)
{
  mz_ulong __attribute__((__visibility__("default"))) tmp;
  tmp = mz_deflateBound((mz_streamp)0,source_len);
  return tmp;
}

int __attribute__((__visibility__("default"))) mz_inflateInit2(mz_streamp pStream,
                                                               int window_bits)
{
  int __attribute__((__visibility__("default"))) __retres;
  inflate_state *pDecomp;
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  if (window_bits != 15) 
    if (- window_bits != 15) {
      __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
      goto return_label;
    }
  pStream->data_type = 0;
  pStream->adler = (mz_ulong)0;
  pStream->msg = (char *)0;
  pStream->total_in = (mz_ulong)0;
  pStream->total_out = (mz_ulong)0;
  pStream->reserved = (mz_ulong)0;
  if (! pStream->zalloc) pStream->zalloc = (void *(*)(void *opaque,
                                                      size_t items,
                                                      size_t size))(& miniz_def_alloc_func);
  if (! pStream->zfree) pStream->zfree = (void (*)(void *opaque,
                                                   void *address))(& miniz_def_free_func);
  pDecomp = (inflate_state *)(*(pStream->zalloc))(pStream->opaque,(size_t)1,
                                                  sizeof(inflate_state));
  if (! pDecomp) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_MEM_ERROR;
    goto return_label;
  }
  pStream->state = (struct mz_internal_state *)pDecomp;
  pDecomp->m_decomp.m_state = (mz_uint32)0;
  pDecomp->m_decomp.m_num_bits = (mz_uint32)0;
  pDecomp->m_decomp.m_bit_buf = (tinfl_bit_buf_t)0;
  pDecomp->m_decomp.m_dist = (mz_uint32)0;
  pDecomp->m_decomp.m_counter = (mz_uint32)0;
  pDecomp->m_decomp.m_num_extra = (mz_uint32)0;
  pDecomp->m_decomp.m_dist_from_out_buf_start = (size_t)0;
  pDecomp->m_dict_ofs = (mz_uint)0;
  pDecomp->m_dict_avail = (mz_uint)0;
  pDecomp->m_last_status = TINFL_STATUS_NEEDS_MORE_INPUT;
  pDecomp->m_first_call = (mz_uint)1;
  pDecomp->m_has_flushed = (mz_uint)0;
  pDecomp->m_window_bits = window_bits;
  __retres = (int __attribute__((__visibility__("default"))))MZ_OK;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_inflateInit(mz_streamp pStream)
{
  int __attribute__((__visibility__("default"))) tmp;
  tmp = mz_inflateInit2(pStream,15);
  return tmp;
}

int __attribute__((__visibility__("default"))) mz_inflateReset(mz_streamp pStream)
{
  int __attribute__((__visibility__("default"))) __retres;
  inflate_state *pDecomp;
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  pStream->data_type = 0;
  pStream->adler = (mz_ulong)0;
  pStream->msg = (char *)0;
  pStream->total_in = (mz_ulong)0;
  pStream->total_out = (mz_ulong)0;
  pStream->reserved = (mz_ulong)0;
  pDecomp = (inflate_state *)pStream->state;
  pDecomp->m_decomp.m_state = (mz_uint32)0;
  pDecomp->m_decomp.m_num_bits = (mz_uint32)0;
  pDecomp->m_decomp.m_bit_buf = (tinfl_bit_buf_t)0;
  pDecomp->m_decomp.m_dist = (mz_uint32)0;
  pDecomp->m_decomp.m_counter = (mz_uint32)0;
  pDecomp->m_decomp.m_num_extra = (mz_uint32)0;
  pDecomp->m_decomp.m_dist_from_out_buf_start = (size_t)0;
  pDecomp->m_dict_ofs = (mz_uint)0;
  pDecomp->m_dict_avail = (mz_uint)0;
  pDecomp->m_last_status = TINFL_STATUS_NEEDS_MORE_INPUT;
  pDecomp->m_first_call = (mz_uint)1;
  pDecomp->m_has_flushed = (mz_uint)0;
  __retres = (int __attribute__((__visibility__("default"))))MZ_OK;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_inflate(mz_streamp pStream,
                                                          int flush)
{
  int __attribute__((__visibility__("default"))) __retres;
  inflate_state *pState;
  mz_uint n;
  mz_uint first_call;
  size_t in_bytes;
  size_t out_bytes;
  size_t orig_avail_in;
  tinfl_status status;
  int tmp_3;
  mz_uint decomp_flags = (mz_uint)TINFL_FLAG_COMPUTE_ADLER32;
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  else 
    if (! pStream->state) {
      __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
      goto return_label;
    }
  if (flush == MZ_PARTIAL_FLUSH) flush = MZ_SYNC_FLUSH;
  if (flush) 
    if (flush != MZ_SYNC_FLUSH) 
      if (flush != MZ_FINISH) {
        __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
        goto return_label;
      }
  pState = (inflate_state *)pStream->state;
  if (pState->m_window_bits > 0) decomp_flags |= (unsigned int)TINFL_FLAG_PARSE_ZLIB_HEADER;
  orig_avail_in = (size_t)pStream->avail_in;
  first_call = pState->m_first_call;
  pState->m_first_call = (mz_uint)0;
  if (pState->m_last_status < 0) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_DATA_ERROR;
    goto return_label;
  }
  if (pState->m_has_flushed) 
    if (flush != MZ_FINISH) {
      __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
      goto return_label;
    }
  pState->m_has_flushed |= (unsigned int)(flush == MZ_FINISH);
  if (flush == MZ_FINISH) 
    if (first_call) {
      tinfl_status __attribute__((__visibility__("default"))) tmp;
      decomp_flags |= (unsigned int)TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF;
      in_bytes = (size_t)pStream->avail_in;
      out_bytes = (size_t)pStream->avail_out;
      tmp = tinfl_decompress(& pState->m_decomp,pStream->next_in,& in_bytes,
                             pStream->next_out,pStream->next_out,& out_bytes,
                             decomp_flags);
      status = (tinfl_status)tmp;
      pState->m_last_status = status;
      pStream->next_in += (mz_uint)in_bytes;
      pStream->avail_in -= (mz_uint)in_bytes;
      pStream->total_in += (mz_ulong)((mz_uint)in_bytes);
      pStream->adler = (mz_ulong)pState->m_decomp.m_check_adler32;
      pStream->next_out += (mz_uint)out_bytes;
      pStream->avail_out -= (mz_uint)out_bytes;
      pStream->total_out += (mz_ulong)((mz_uint)out_bytes);
      if (status < 0) {
        __retres = (int __attribute__((__visibility__("default"))))MZ_DATA_ERROR;
        goto return_label;
      }
      else 
        if (status != TINFL_STATUS_DONE) {
          pState->m_last_status = TINFL_STATUS_FAILED;
          __retres = (int __attribute__((__visibility__("default"))))MZ_BUF_ERROR;
          goto return_label;
        }
      __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_END;
      goto return_label;
    }
  if (flush != MZ_FINISH) decomp_flags |= (unsigned int)TINFL_FLAG_HAS_MORE_INPUT;
  if (pState->m_dict_avail) {
    int tmp_0;
    if (pState->m_dict_avail < pStream->avail_out) n = pState->m_dict_avail;
    else n = pStream->avail_out;
    memcpy((void *)pStream->next_out,
           (void const *)(& pState->m_dict[pState->m_dict_ofs]),(size_t)n);
    pStream->next_out += n;
    pStream->avail_out -= n;
    pStream->total_out += (mz_ulong)n;
    pState->m_dict_avail -= n;
    pState->m_dict_ofs = (pState->m_dict_ofs + n) & (unsigned int)(32768 - 1);
    if (pState->m_last_status == TINFL_STATUS_DONE) 
      if (! pState->m_dict_avail) tmp_0 = MZ_STREAM_END; else tmp_0 = MZ_OK;
    else tmp_0 = MZ_OK;
    __retres = (int __attribute__((__visibility__("default"))))tmp_0;
    goto return_label;
  }
  while (1) {
    tinfl_status __attribute__((__visibility__("default"))) tmp_1;
    in_bytes = (size_t)pStream->avail_in;
    out_bytes = (size_t)((mz_uint)32768 - pState->m_dict_ofs);
    tmp_1 = tinfl_decompress(& pState->m_decomp,pStream->next_in,& in_bytes,
                             pState->m_dict,
                             & pState->m_dict[pState->m_dict_ofs],
                             & out_bytes,decomp_flags);
    status = (tinfl_status)tmp_1;
    pState->m_last_status = status;
    pStream->next_in += (mz_uint)in_bytes;
    pStream->avail_in -= (mz_uint)in_bytes;
    pStream->total_in += (mz_ulong)((mz_uint)in_bytes);
    pStream->adler = (mz_ulong)pState->m_decomp.m_check_adler32;
    pState->m_dict_avail = (mz_uint)out_bytes;
    if (pState->m_dict_avail < pStream->avail_out) n = pState->m_dict_avail;
    else n = pStream->avail_out;
    memcpy((void *)pStream->next_out,
           (void const *)(& pState->m_dict[pState->m_dict_ofs]),(size_t)n);
    pStream->next_out += n;
    pStream->avail_out -= n;
    pStream->total_out += (mz_ulong)n;
    pState->m_dict_avail -= n;
    pState->m_dict_ofs = (pState->m_dict_ofs + n) & (unsigned int)(32768 - 1);
    if (status < 0) {
      __retres = (int __attribute__((__visibility__("default"))))MZ_DATA_ERROR;
      goto return_label;
    }
    else 
      if (status == TINFL_STATUS_NEEDS_MORE_INPUT) {
        if (! orig_avail_in) {
          __retres = (int __attribute__((__visibility__("default"))))MZ_BUF_ERROR;
          goto return_label;
        }
        else goto _LAND;
      }
      else {
        _LAND: ;
        if (flush == MZ_FINISH) {
          if (status == TINFL_STATUS_DONE) {
            int tmp_2;
            if (pState->m_dict_avail) tmp_2 = MZ_BUF_ERROR;
            else tmp_2 = MZ_STREAM_END;
            __retres = (int __attribute__((__visibility__("default"))))tmp_2;
            goto return_label;
          }
          else 
            if (! pStream->avail_out) {
              __retres = (int __attribute__((__visibility__("default"))))MZ_BUF_ERROR;
              goto return_label;
            }
        }
        else 
          if (status == TINFL_STATUS_DONE) break;
          else 
            if (! pStream->avail_in) break;
            else 
              if (! pStream->avail_out) break;
              else 
                if (pState->m_dict_avail) break;
      }
  }
  if (status == TINFL_STATUS_DONE) 
    if (! pState->m_dict_avail) tmp_3 = MZ_STREAM_END; else tmp_3 = MZ_OK;
  else tmp_3 = MZ_OK;
  __retres = (int __attribute__((__visibility__("default"))))tmp_3;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_inflateEnd(mz_streamp pStream)
{
  int __attribute__((__visibility__("default"))) __retres;
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  if (pStream->state) {
    (*(pStream->zfree))(pStream->opaque,(void *)pStream->state);
    pStream->state = (struct mz_internal_state *)0;
  }
  __retres = (int __attribute__((__visibility__("default"))))MZ_OK;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_uncompress2(unsigned char *pDest,
                                                              mz_ulong *pDest_len,
                                                              unsigned char const *pSource,
                                                              mz_ulong *pSource_len)
{
  int __attribute__((__visibility__("default"))) __retres;
  mz_stream stream;
  int status;
  int __attribute__((__visibility__("default"))) tmp_0;
  memset((void *)(& stream),0,sizeof(stream));
  if ((*pSource_len | *pDest_len) > (unsigned long)0xFFFFFFFFU) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
    goto return_label;
  }
  stream.next_in = pSource;
  stream.avail_in = (mz_uint32)*pSource_len;
  stream.next_out = pDest;
  stream.avail_out = (mz_uint32)*pDest_len;
  status = (int)mz_inflateInit(& stream);
  if (status != MZ_OK) {
    __retres = (int __attribute__((__visibility__("default"))))status;
    goto return_label;
  }
  status = (int)mz_inflate(& stream,MZ_FINISH);
  *pSource_len -= (mz_ulong)stream.avail_in;
  if (status != MZ_STREAM_END) {
    int tmp;
    mz_inflateEnd(& stream);
    if (status == MZ_BUF_ERROR) 
      if (! stream.avail_in) tmp = MZ_DATA_ERROR; else tmp = status;
    else tmp = status;
    __retres = (int __attribute__((__visibility__("default"))))tmp;
    goto return_label;
  }
  *pDest_len = stream.total_out;
  tmp_0 = mz_inflateEnd(& stream);
  __retres = tmp_0;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_uncompress(unsigned char *pDest,
                                                             mz_ulong *pDest_len,
                                                             unsigned char const *pSource,
                                                             mz_ulong source_len)
{
  int __attribute__((__visibility__("default"))) tmp;
  tmp = mz_uncompress2(pDest,pDest_len,pSource,& source_len);
  return tmp;
}

static struct __anonstruct_s_error_descs_25 mz_error_s_error_descs[10] =
  {{.m_err = MZ_OK, .m_pDesc = ""},
   {.m_err = MZ_STREAM_END, .m_pDesc = "stream end"},
   {.m_err = MZ_NEED_DICT, .m_pDesc = "need dictionary"},
   {.m_err = MZ_ERRNO, .m_pDesc = "file error"},
   {.m_err = MZ_STREAM_ERROR, .m_pDesc = "stream error"},
   {.m_err = MZ_DATA_ERROR, .m_pDesc = "data error"},
   {.m_err = MZ_MEM_ERROR, .m_pDesc = "out of memory"},
   {.m_err = MZ_BUF_ERROR, .m_pDesc = "buf error"},
   {.m_err = MZ_VERSION_ERROR, .m_pDesc = "version error"},
   {.m_err = MZ_PARAM_ERROR, .m_pDesc = "parameter error"}};
char const __attribute__((__visibility__("default"))) *mz_error(int err)
{
  char const __attribute__((__visibility__("default"))) *__retres;
  mz_uint i;
  i = (mz_uint)0;
  while ((unsigned long)i < sizeof(mz_error_s_error_descs) / sizeof(mz_error_s_error_descs[0])) {
    if (mz_error_s_error_descs[i].m_err == err) {
      __retres = (char const __attribute__((__visibility__("default"))) *)mz_error_s_error_descs[i].m_pDesc;
      goto return_label;
    }
    i ++;
  }
  __retres = (char const __attribute__((__visibility__("default"))) *)0;
  return_label: return __retres;
}

static mz_uint16 const s_tdefl_len_sym[256] =
  {(mz_uint16)257,
   (mz_uint16)258,
   (mz_uint16)259,
   (mz_uint16)260,
   (mz_uint16)261,
   (mz_uint16)262,
   (mz_uint16)263,
   (mz_uint16)264,
   (mz_uint16)265,
   (mz_uint16)265,
   (mz_uint16)266,
   (mz_uint16)266,
   (mz_uint16)267,
   (mz_uint16)267,
   (mz_uint16)268,
   (mz_uint16)268,
   (mz_uint16)269,
   (mz_uint16)269,
   (mz_uint16)269,
   (mz_uint16)269,
   (mz_uint16)270,
   (mz_uint16)270,
   (mz_uint16)270,
   (mz_uint16)270,
   (mz_uint16)271,
   (mz_uint16)271,
   (mz_uint16)271,
   (mz_uint16)271,
   (mz_uint16)272,
   (mz_uint16)272,
   (mz_uint16)272,
   (mz_uint16)272,
   (mz_uint16)273,
   (mz_uint16)273,
   (mz_uint16)273,
   (mz_uint16)273,
   (mz_uint16)273,
   (mz_uint16)273,
   (mz_uint16)273,
   (mz_uint16)273,
   (mz_uint16)274,
   (mz_uint16)274,
   (mz_uint16)274,
   (mz_uint16)274,
   (mz_uint16)274,
   (mz_uint16)274,
   (mz_uint16)274,
   (mz_uint16)274,
   (mz_uint16)275,
   (mz_uint16)275,
   (mz_uint16)275,
   (mz_uint16)275,
   (mz_uint16)275,
   (mz_uint16)275,
   (mz_uint16)275,
   (mz_uint16)275,
   (mz_uint16)276,
   (mz_uint16)276,
   (mz_uint16)276,
   (mz_uint16)276,
   (mz_uint16)276,
   (mz_uint16)276,
   (mz_uint16)276,
   (mz_uint16)276,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)285};
static mz_uint8 const s_tdefl_len_extra[256] =
  {(mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)0};
static mz_uint8 const s_tdefl_small_dist_sym[512] =
  {(mz_uint8)0,
   (mz_uint8)1,
   (mz_uint8)2,
   (mz_uint8)3,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)8,
   (mz_uint8)8,
   (mz_uint8)8,
   (mz_uint8)8,
   (mz_uint8)8,
   (mz_uint8)8,
   (mz_uint8)8,
   (mz_uint8)8,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17};
static mz_uint8 const s_tdefl_small_dist_extra[512] =
  {(mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7};
static mz_uint8 const s_tdefl_large_dist_sym[128] =
  {(mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)18,
   (mz_uint8)19,
   (mz_uint8)20,
   (mz_uint8)20,
   (mz_uint8)21,
   (mz_uint8)21,
   (mz_uint8)22,
   (mz_uint8)22,
   (mz_uint8)22,
   (mz_uint8)22,
   (mz_uint8)23,
   (mz_uint8)23,
   (mz_uint8)23,
   (mz_uint8)23,
   (mz_uint8)24,
   (mz_uint8)24,
   (mz_uint8)24,
   (mz_uint8)24,
   (mz_uint8)24,
   (mz_uint8)24,
   (mz_uint8)24,
   (mz_uint8)24,
   (mz_uint8)25,
   (mz_uint8)25,
   (mz_uint8)25,
   (mz_uint8)25,
   (mz_uint8)25,
   (mz_uint8)25,
   (mz_uint8)25,
   (mz_uint8)25,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29};
static mz_uint8 const s_tdefl_large_dist_extra[128] =
  {(mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)8,
   (mz_uint8)8,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13};
static tdefl_sym_freq *tdefl_radix_sort_syms(mz_uint num_syms,
                                             tdefl_sym_freq *pSyms0,
                                             tdefl_sym_freq *pSyms1)
{
  mz_uint32 pass_shift;
  mz_uint32 pass;
  mz_uint32 i;
  mz_uint32 hist[256 * 2];
  mz_uint32 total_passes = (mz_uint32)2;
  tdefl_sym_freq *pCur_syms = pSyms0;
  tdefl_sym_freq *pNew_syms = pSyms1;
  memset((void *)(& hist),0,sizeof(hist));
  i = (mz_uint32)0;
  while (i < num_syms) {
    {
      mz_uint freq = (mz_uint)(pSyms0 + i)->m_key;
      (hist[freq & (unsigned int)0xFF]) ++;
      (hist[(unsigned int)256 + ((freq >> 8) & (unsigned int)0xFF)]) ++;
    }
    i ++;
  }
  while (1) {
    if (total_passes > (mz_uint32)1) {
      if (! (num_syms == hist[(total_passes - (mz_uint32)1) * (mz_uint32)256])) 
        break;
    }
    else break;
    total_passes --;
  }
  pass_shift = (mz_uint32)0;
  pass = (mz_uint32)0;
  while (pass < total_passes) {
    {
      mz_uint offsets[256];
      mz_uint32 const *pHist = (mz_uint32 const *)(& hist[pass << 8]);
      mz_uint cur_ofs = (mz_uint)0;
      i = (mz_uint32)0;
      while (i < (mz_uint32)256) {
        offsets[i] = cur_ofs;
        cur_ofs += *(pHist + i);
        i ++;
      }
      i = (mz_uint32)0;
      while (i < num_syms) {
        mz_uint tmp;
        tmp = offsets[((int)(pCur_syms + i)->m_key >> pass_shift) & 0xFF];
        (offsets[((int)(pCur_syms + i)->m_key >> pass_shift) & 0xFF]) ++;
        *(pNew_syms + tmp) = *(pCur_syms + i);
        i ++;
      }
      {
        tdefl_sym_freq *t = pCur_syms;
        pCur_syms = pNew_syms;
        pNew_syms = t;
      }
    }
    pass ++;
    pass_shift += (mz_uint32)8;
  }
  return pCur_syms;
}

static void tdefl_calculate_minimum_redundancy(tdefl_sym_freq *A, int n)
{
  int root;
  int leaf;
  int next;
  int avbl;
  int used;
  int dpth;
  if (n == 0) goto return_label;
  else 
    if (n == 1) {
      (A + 0)->m_key = (mz_uint16)1;
      goto return_label;
    }
  (A + 0)->m_key = (mz_uint16)((int)(A + 0)->m_key + (int)(A + 1)->m_key);
  root = 0;
  leaf = 2;
  next = 1;
  while (next < n - 1) {
    if (leaf >= n) goto _LOR;
    else 
      if ((int)(A + root)->m_key < (int)(A + leaf)->m_key) {
        _LOR:
        {
          int tmp;
          (A + next)->m_key = (A + root)->m_key;
          tmp = root;
          root ++;
          (A + tmp)->m_key = (mz_uint16)next;
        }
      }
      else {
        int tmp_0;
        tmp_0 = leaf;
        leaf ++;
        (A + next)->m_key = (A + tmp_0)->m_key;
      }
    if (leaf >= n) goto _LOR_0;
    else 
      if (root < next) {
        if ((int)(A + root)->m_key < (int)(A + leaf)->m_key) {
          _LOR_0:
          {
            int tmp_1;
            (A + next)->m_key = (mz_uint16)((int)(A + next)->m_key + (int)(
                                            A + root)->m_key);
            tmp_1 = root;
            root ++;
            (A + tmp_1)->m_key = (mz_uint16)next;
          }
        }
        else goto _LAND;
      }
      else {
        int tmp_2;
        _LAND:
        { /* sequence */
          tmp_2 = leaf;
          leaf ++;
          (A + next)->m_key = (mz_uint16)((int)(A + next)->m_key + (int)(
                                          A + tmp_2)->m_key);
        }
      }
    next ++;
  }
  (A + (n - 2))->m_key = (mz_uint16)0;
  next = n - 3;
  while (next >= 0) {
    (A + next)->m_key = (mz_uint16)((int)(A + (A + next)->m_key)->m_key + 1);
    next --;
  }
  avbl = 1;
  dpth = 0;
  used = dpth;
  root = n - 2;
  next = n - 1;
  while (avbl > 0) {
    while (1) {
      if (root >= 0) {
        if (! ((int)(A + root)->m_key == dpth)) break;
      }
      else break;
      used ++;
      root --;
    }
    while (avbl > used) {
      int tmp_3;
      tmp_3 = next;
      next --;
      (A + tmp_3)->m_key = (mz_uint16)dpth;
      avbl --;
    }
    avbl = 2 * used;
    dpth ++;
    used = 0;
  }
  return_label: return;
}

static void tdefl_huffman_enforce_max_code_size(int *pNum_codes,
                                                int code_list_len,
                                                int max_code_size)
{
  int i;
  mz_uint32 total = (mz_uint32)0;
  if (code_list_len <= 1) goto return_label;
  i = max_code_size + 1;
  while (i <= TDEFL_MAX_SUPPORTED_HUFF_CODESIZE) {
    *(pNum_codes + max_code_size) += *(pNum_codes + i);
    i ++;
  }
  i = max_code_size;
  while (i > 0) {
    total += (mz_uint32)*(pNum_codes + i) << (max_code_size - i);
    i --;
  }
  while ((unsigned long)total != 1UL << max_code_size) {
    (*(pNum_codes + max_code_size)) --;
    i = max_code_size - 1;
    while (i > 0) {
      if (*(pNum_codes + i)) {
        (*(pNum_codes + i)) --;
        *(pNum_codes + (i + 1)) += 2;
        break;
      }
      i --;
    }
    total --;
  }
  return_label: return;
}

static void tdefl_optimize_huffman_table(tdefl_compressor *d, int table_num,
                                         int table_len, int code_size_limit,
                                         int static_table)
{
  int i;
  int j;
  int l;
  int num_codes[1 + TDEFL_MAX_SUPPORTED_HUFF_CODESIZE];
  mz_uint next_code[TDEFL_MAX_SUPPORTED_HUFF_CODESIZE + 1];
  memset((void *)(& num_codes),0,sizeof(num_codes));
  if (static_table) {
    i = 0;
    while (i < table_len) {
      (num_codes[d->m_huff_code_sizes[table_num][i]]) ++;
      i ++;
    }
  }
  else {
    tdefl_sym_freq syms0[TDEFL_MAX_HUFF_SYMBOLS];
    tdefl_sym_freq syms1[TDEFL_MAX_HUFF_SYMBOLS];
    tdefl_sym_freq *pSyms;
    int num_used_syms = 0;
    mz_uint16 const *pSym_count =
      (mz_uint16 const *)(& d->m_huff_count[table_num][0]);
    i = 0;
    while (i < table_len) {
      if (*(pSym_count + i)) {
        int tmp;
        syms0[num_used_syms].m_key = *(pSym_count + i);
        tmp = num_used_syms;
        num_used_syms ++;
        syms0[tmp].m_sym_index = (mz_uint16)i;
      }
      i ++;
    }
    pSyms = tdefl_radix_sort_syms((mz_uint)num_used_syms,syms0,syms1);
    tdefl_calculate_minimum_redundancy(pSyms,num_used_syms);
    i = 0;
    while (i < num_used_syms) {
      (num_codes[(pSyms + i)->m_key]) ++;
      i ++;
    }
    tdefl_huffman_enforce_max_code_size(num_codes,num_used_syms,
                                        code_size_limit);
    memset((void *)(& d->m_huff_code_sizes[table_num]),0,
           sizeof(d->m_huff_code_sizes[table_num]));
    memset((void *)(& d->m_huff_codes[table_num]),0,
           sizeof(d->m_huff_codes[table_num]));
    i = 1;
    j = num_used_syms;
    while (i <= code_size_limit) {
      l = num_codes[i];
      while (l > 0) {
        j --;
        d->m_huff_code_sizes[table_num][(pSyms + j)->m_sym_index] = (mz_uint8)i;
        l --;
      }
      i ++;
    }
  }
  next_code[1] = (mz_uint)0;
  j = 0;
  i = 2;
  while (i <= code_size_limit) {
    j = (j + num_codes[i - 1]) << 1;
    next_code[i] = (mz_uint)j;
    i ++;
  }
  i = 0;
  while (i < table_len) {
    {
      mz_uint code;
      mz_uint code_size;
      mz_uint tmp_0;
      mz_uint rev_code = (mz_uint)0;
      code_size = (mz_uint)d->m_huff_code_sizes[table_num][i];
      if (code_size == (mz_uint)0) goto __Cont;
      tmp_0 = next_code[code_size];
      (next_code[code_size]) ++;
      code = tmp_0;
      l = (int)code_size;
      while (l > 0) {
        rev_code = (rev_code << 1) | (code & (unsigned int)1);
        l --;
        code >>= 1;
      }
      d->m_huff_codes[table_num][i] = (mz_uint16)rev_code;
    }
    __Cont: i ++;
  }
  return;
}

static mz_uint8 s_tdefl_packed_code_size_syms_swizzle[19] =
  {(mz_uint8)16,
   (mz_uint8)17,
   (mz_uint8)18,
   (mz_uint8)0,
   (mz_uint8)8,
   (mz_uint8)7,
   (mz_uint8)9,
   (mz_uint8)6,
   (mz_uint8)10,
   (mz_uint8)5,
   (mz_uint8)11,
   (mz_uint8)4,
   (mz_uint8)12,
   (mz_uint8)3,
   (mz_uint8)13,
   (mz_uint8)2,
   (mz_uint8)14,
   (mz_uint8)1,
   (mz_uint8)15};
static void tdefl_start_dynamic_block(tdefl_compressor *d)
{
  int num_lit_codes;
  int num_dist_codes;
  int num_bit_lengths;
  mz_uint i;
  mz_uint total_code_sizes_to_pack;
  mz_uint num_packed_code_sizes;
  mz_uint rle_z_count;
  mz_uint rle_repeat_count;
  mz_uint packed_code_sizes_index;
  mz_uint8 code_sizes_to_pack[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1];
  mz_uint8 packed_code_sizes[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1];
  mz_uint8 prev_code_size = (mz_uint8)0xFF;
  d->m_huff_count[0][256] = (mz_uint16)1;
  tdefl_optimize_huffman_table(d,0,TDEFL_MAX_HUFF_SYMBOLS_0,15,0);
  tdefl_optimize_huffman_table(d,1,TDEFL_MAX_HUFF_SYMBOLS_1,15,0);
  num_lit_codes = 286;
  while (num_lit_codes > 257) {
    if (d->m_huff_code_sizes[0][num_lit_codes - 1]) break;
    num_lit_codes --;
  }
  num_dist_codes = 30;
  while (num_dist_codes > 1) {
    if (d->m_huff_code_sizes[1][num_dist_codes - 1]) break;
    num_dist_codes --;
  }
  memcpy((void *)(code_sizes_to_pack),
         (void const *)(& d->m_huff_code_sizes[0][0]),(size_t)num_lit_codes);
  memcpy((void *)(& code_sizes_to_pack[num_lit_codes]),
         (void const *)(& d->m_huff_code_sizes[1][0]),(size_t)num_dist_codes);
  total_code_sizes_to_pack = (mz_uint)(num_lit_codes + num_dist_codes);
  num_packed_code_sizes = (mz_uint)0;
  rle_z_count = (mz_uint)0;
  rle_repeat_count = (mz_uint)0;
  memset((void *)(& d->m_huff_count[2][0]),0,
         sizeof(d->m_huff_count[2][0]) * (unsigned long)TDEFL_MAX_HUFF_SYMBOLS_2);
  i = (mz_uint)0;
  while (i < total_code_sizes_to_pack) {
    {
      mz_uint8 code_size = code_sizes_to_pack[i];
      if (! code_size) {
        if (rle_repeat_count) {
          if (rle_repeat_count < (mz_uint)3) {
            d->m_huff_count[2][prev_code_size] = (mz_uint16)((mz_uint)d->m_huff_count[2][prev_code_size] + rle_repeat_count);
            while (1) {
              mz_uint tmp_0;
              mz_uint tmp;
              tmp_0 = rle_repeat_count;
              rle_repeat_count --;
              ;
              if (! tmp_0) break;
              tmp = num_packed_code_sizes;
              num_packed_code_sizes ++;
              packed_code_sizes[tmp] = prev_code_size;
            }
          }
          else {
            mz_uint tmp_1;
            mz_uint tmp_2;
            d->m_huff_count[2][16] = (mz_uint16)((int)d->m_huff_count[2][16] + 1);
            tmp_1 = num_packed_code_sizes;
            num_packed_code_sizes ++;
            packed_code_sizes[tmp_1] = (mz_uint8)16;
            tmp_2 = num_packed_code_sizes;
            num_packed_code_sizes ++;
            packed_code_sizes[tmp_2] = (mz_uint8)(rle_repeat_count - (mz_uint)3);
          }
          rle_repeat_count = (mz_uint)0;
        }
        rle_z_count ++;
        if (rle_z_count == (mz_uint)138) 
          if (rle_z_count) {
            if (rle_z_count < (mz_uint)3) {
              d->m_huff_count[2][0] = (mz_uint16)((mz_uint)d->m_huff_count[2][0] + rle_z_count);
              while (1) {
                mz_uint tmp_4;
                mz_uint tmp_3;
                tmp_4 = rle_z_count;
                rle_z_count --;
                ;
                if (! tmp_4) break;
                tmp_3 = num_packed_code_sizes;
                num_packed_code_sizes ++;
                packed_code_sizes[tmp_3] = (mz_uint8)0;
              }
            }
            else 
              if (rle_z_count <= (mz_uint)10) {
                mz_uint tmp_5;
                mz_uint tmp_6;
                d->m_huff_count[2][17] = (mz_uint16)((int)d->m_huff_count[2][17] + 1);
                tmp_5 = num_packed_code_sizes;
                num_packed_code_sizes ++;
                packed_code_sizes[tmp_5] = (mz_uint8)17;
                tmp_6 = num_packed_code_sizes;
                num_packed_code_sizes ++;
                packed_code_sizes[tmp_6] = (mz_uint8)(rle_z_count - (mz_uint)3);
              }
              else {
                mz_uint tmp_7;
                mz_uint tmp_8;
                d->m_huff_count[2][18] = (mz_uint16)((int)d->m_huff_count[2][18] + 1);
                tmp_7 = num_packed_code_sizes;
                num_packed_code_sizes ++;
                packed_code_sizes[tmp_7] = (mz_uint8)18;
                tmp_8 = num_packed_code_sizes;
                num_packed_code_sizes ++;
                packed_code_sizes[tmp_8] = (mz_uint8)(rle_z_count - (mz_uint)11);
              }
            rle_z_count = (mz_uint)0;
          }
      }
      else {
        if (rle_z_count) {
          if (rle_z_count < (mz_uint)3) {
            d->m_huff_count[2][0] = (mz_uint16)((mz_uint)d->m_huff_count[2][0] + rle_z_count);
            while (1) {
              mz_uint tmp_10;
              mz_uint tmp_9;
              tmp_10 = rle_z_count;
              rle_z_count --;
              ;
              if (! tmp_10) break;
              tmp_9 = num_packed_code_sizes;
              num_packed_code_sizes ++;
              packed_code_sizes[tmp_9] = (mz_uint8)0;
            }
          }
          else 
            if (rle_z_count <= (mz_uint)10) {
              mz_uint tmp_11;
              mz_uint tmp_12;
              d->m_huff_count[2][17] = (mz_uint16)((int)d->m_huff_count[2][17] + 1);
              tmp_11 = num_packed_code_sizes;
              num_packed_code_sizes ++;
              packed_code_sizes[tmp_11] = (mz_uint8)17;
              tmp_12 = num_packed_code_sizes;
              num_packed_code_sizes ++;
              packed_code_sizes[tmp_12] = (mz_uint8)(rle_z_count - (mz_uint)3);
            }
            else {
              mz_uint tmp_13;
              mz_uint tmp_14;
              d->m_huff_count[2][18] = (mz_uint16)((int)d->m_huff_count[2][18] + 1);
              tmp_13 = num_packed_code_sizes;
              num_packed_code_sizes ++;
              packed_code_sizes[tmp_13] = (mz_uint8)18;
              tmp_14 = num_packed_code_sizes;
              num_packed_code_sizes ++;
              packed_code_sizes[tmp_14] = (mz_uint8)(rle_z_count - (mz_uint)11);
            }
          rle_z_count = (mz_uint)0;
        }
        if ((int)code_size != (int)prev_code_size) {
          mz_uint tmp_19;
          if (rle_repeat_count) {
            if (rle_repeat_count < (mz_uint)3) {
              d->m_huff_count[2][prev_code_size] = (mz_uint16)((mz_uint)d->m_huff_count[2][prev_code_size] + rle_repeat_count);
              while (1) {
                mz_uint tmp_16;
                mz_uint tmp_15;
                tmp_16 = rle_repeat_count;
                rle_repeat_count --;
                ;
                if (! tmp_16) break;
                tmp_15 = num_packed_code_sizes;
                num_packed_code_sizes ++;
                packed_code_sizes[tmp_15] = prev_code_size;
              }
            }
            else {
              mz_uint tmp_17;
              mz_uint tmp_18;
              d->m_huff_count[2][16] = (mz_uint16)((int)d->m_huff_count[2][16] + 1);
              tmp_17 = num_packed_code_sizes;
              num_packed_code_sizes ++;
              packed_code_sizes[tmp_17] = (mz_uint8)16;
              tmp_18 = num_packed_code_sizes;
              num_packed_code_sizes ++;
              packed_code_sizes[tmp_18] = (mz_uint8)(rle_repeat_count - (mz_uint)3);
            }
            rle_repeat_count = (mz_uint)0;
          }
          d->m_huff_count[2][code_size] = (mz_uint16)((int)d->m_huff_count[2][code_size] + 1);
          tmp_19 = num_packed_code_sizes;
          num_packed_code_sizes ++;
          packed_code_sizes[tmp_19] = code_size;
        }
        else {
          rle_repeat_count ++;
          if (rle_repeat_count == (mz_uint)6) 
            if (rle_repeat_count) {
              if (rle_repeat_count < (mz_uint)3) {
                d->m_huff_count[2][prev_code_size] = (mz_uint16)((mz_uint)d->m_huff_count[2][prev_code_size] + rle_repeat_count);
                while (1) {
                  mz_uint tmp_21;
                  mz_uint tmp_20;
                  tmp_21 = rle_repeat_count;
                  rle_repeat_count --;
                  ;
                  if (! tmp_21) break;
                  tmp_20 = num_packed_code_sizes;
                  num_packed_code_sizes ++;
                  packed_code_sizes[tmp_20] = prev_code_size;
                }
              }
              else {
                mz_uint tmp_22;
                mz_uint tmp_23;
                d->m_huff_count[2][16] = (mz_uint16)((int)d->m_huff_count[2][16] + 1);
                tmp_22 = num_packed_code_sizes;
                num_packed_code_sizes ++;
                packed_code_sizes[tmp_22] = (mz_uint8)16;
                tmp_23 = num_packed_code_sizes;
                num_packed_code_sizes ++;
                packed_code_sizes[tmp_23] = (mz_uint8)(rle_repeat_count - (mz_uint)3);
              }
              rle_repeat_count = (mz_uint)0;
            }
        }
      }
      prev_code_size = code_size;
    }
    i ++;
  }
  if (rle_repeat_count) {
    if (rle_repeat_count) {
      if (rle_repeat_count < (mz_uint)3) {
        d->m_huff_count[2][prev_code_size] = (mz_uint16)((mz_uint)d->m_huff_count[2][prev_code_size] + rle_repeat_count);
        while (1) {
          mz_uint tmp_25;
          mz_uint tmp_24;
          tmp_25 = rle_repeat_count;
          rle_repeat_count --;
          ;
          if (! tmp_25) break;
          tmp_24 = num_packed_code_sizes;
          num_packed_code_sizes ++;
          packed_code_sizes[tmp_24] = prev_code_size;
        }
      }
      else {
        mz_uint tmp_26;
        mz_uint tmp_27;
        d->m_huff_count[2][16] = (mz_uint16)((int)d->m_huff_count[2][16] + 1);
        tmp_26 = num_packed_code_sizes;
        num_packed_code_sizes ++;
        packed_code_sizes[tmp_26] = (mz_uint8)16;
        tmp_27 = num_packed_code_sizes;
        num_packed_code_sizes ++;
        packed_code_sizes[tmp_27] = (mz_uint8)(rle_repeat_count - (mz_uint)3);
      }
      rle_repeat_count = (mz_uint)0;
    }
  }
  else 
    if (rle_z_count) {
      if (rle_z_count < (mz_uint)3) {
        d->m_huff_count[2][0] = (mz_uint16)((mz_uint)d->m_huff_count[2][0] + rle_z_count);
        while (1) {
          mz_uint tmp_29;
          mz_uint tmp_28;
          tmp_29 = rle_z_count;
          rle_z_count --;
          ;
          if (! tmp_29) break;
          tmp_28 = num_packed_code_sizes;
          num_packed_code_sizes ++;
          packed_code_sizes[tmp_28] = (mz_uint8)0;
        }
      }
      else 
        if (rle_z_count <= (mz_uint)10) {
          mz_uint tmp_30;
          mz_uint tmp_31;
          d->m_huff_count[2][17] = (mz_uint16)((int)d->m_huff_count[2][17] + 1);
          tmp_30 = num_packed_code_sizes;
          num_packed_code_sizes ++;
          packed_code_sizes[tmp_30] = (mz_uint8)17;
          tmp_31 = num_packed_code_sizes;
          num_packed_code_sizes ++;
          packed_code_sizes[tmp_31] = (mz_uint8)(rle_z_count - (mz_uint)3);
        }
        else {
          mz_uint tmp_32;
          mz_uint tmp_33;
          d->m_huff_count[2][18] = (mz_uint16)((int)d->m_huff_count[2][18] + 1);
          tmp_32 = num_packed_code_sizes;
          num_packed_code_sizes ++;
          packed_code_sizes[tmp_32] = (mz_uint8)18;
          tmp_33 = num_packed_code_sizes;
          num_packed_code_sizes ++;
          packed_code_sizes[tmp_33] = (mz_uint8)(rle_z_count - (mz_uint)11);
        }
      rle_z_count = (mz_uint)0;
    }
  tdefl_optimize_huffman_table(d,2,TDEFL_MAX_HUFF_SYMBOLS_2,7,0);
  {
    mz_uint bits = (mz_uint)2;
    mz_uint len = (mz_uint)2;
    __FC_assert((bits <= (1U << len) - 1U) != 0,"miniz_tdef.c",404,
                "bits <= ((1U << len) - 1U)");
    d->m_bit_buffer |= bits << d->m_bits_in;
    d->m_bits_in += len;
    while (d->m_bits_in >= (mz_uint)8) {
      if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
        mz_uint8 *tmp_34;
        tmp_34 = d->m_pOutput_buf;
        (d->m_pOutput_buf) ++;
        *tmp_34 = (mz_uint8)d->m_bit_buffer;
      }
      d->m_bit_buffer >>= 8;
      d->m_bits_in -= (mz_uint)8;
    }
  }
  {
    mz_uint bits_0 = (mz_uint)(num_lit_codes - 257);
    mz_uint len_0 = (mz_uint)5;
    __FC_assert((bits_0 <= (1U << len_0) - 1U) != 0,"miniz_tdef.c",406,
                "bits <= ((1U << len) - 1U)");
    d->m_bit_buffer |= bits_0 << d->m_bits_in;
    d->m_bits_in += len_0;
    while (d->m_bits_in >= (mz_uint)8) {
      if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
        mz_uint8 *tmp_35;
        tmp_35 = d->m_pOutput_buf;
        (d->m_pOutput_buf) ++;
        *tmp_35 = (mz_uint8)d->m_bit_buffer;
      }
      d->m_bit_buffer >>= 8;
      d->m_bits_in -= (mz_uint)8;
    }
  }
  {
    mz_uint bits_1 = (mz_uint)(num_dist_codes - 1);
    mz_uint len_1 = (mz_uint)5;
    __FC_assert((bits_1 <= (1U << len_1) - 1U) != 0,"miniz_tdef.c",407,
                "bits <= ((1U << len) - 1U)");
    d->m_bit_buffer |= bits_1 << d->m_bits_in;
    d->m_bits_in += len_1;
    while (d->m_bits_in >= (mz_uint)8) {
      if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
        mz_uint8 *tmp_36;
        tmp_36 = d->m_pOutput_buf;
        (d->m_pOutput_buf) ++;
        *tmp_36 = (mz_uint8)d->m_bit_buffer;
      }
      d->m_bit_buffer >>= 8;
      d->m_bits_in -= (mz_uint)8;
    }
  }
  num_bit_lengths = 18;
  while (num_bit_lengths >= 0) {
    if (d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[num_bit_lengths]]) 
      break;
    num_bit_lengths --;
  }
  if (4 > num_bit_lengths + 1) num_bit_lengths = 4; else num_bit_lengths ++;
  {
    mz_uint bits_2 = (mz_uint)(num_bit_lengths - 4);
    mz_uint len_2 = (mz_uint)4;
    __FC_assert((bits_2 <= (1U << len_2) - 1U) != 0,"miniz_tdef.c",413,
                "bits <= ((1U << len) - 1U)");
    d->m_bit_buffer |= bits_2 << d->m_bits_in;
    d->m_bits_in += len_2;
    while (d->m_bits_in >= (mz_uint)8) {
      if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
        mz_uint8 *tmp_37;
        tmp_37 = d->m_pOutput_buf;
        (d->m_pOutput_buf) ++;
        *tmp_37 = (mz_uint8)d->m_bit_buffer;
      }
      d->m_bit_buffer >>= 8;
      d->m_bits_in -= (mz_uint)8;
    }
  }
  i = (mz_uint)0;
  while ((int)i < num_bit_lengths) {
    {
      mz_uint bits_3 =
        (mz_uint)d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[i]];
      mz_uint len_3 = (mz_uint)3;
      __FC_assert((bits_3 <= (1U << len_3) - 1U) != 0,"miniz_tdef.c",415,
                  "bits <= ((1U << len) - 1U)");
      d->m_bit_buffer |= bits_3 << d->m_bits_in;
      d->m_bits_in += len_3;
      while (d->m_bits_in >= (mz_uint)8) {
        if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
          mz_uint8 *tmp_38;
          tmp_38 = d->m_pOutput_buf;
          (d->m_pOutput_buf) ++;
          *tmp_38 = (mz_uint8)d->m_bit_buffer;
        }
        d->m_bit_buffer >>= 8;
        d->m_bits_in -= (mz_uint)8;
      }
    }
    i ++;
  }
  packed_code_sizes_index = (mz_uint)0;
  while (packed_code_sizes_index < num_packed_code_sizes) {
    mz_uint tmp_39;
    tmp_39 = packed_code_sizes_index;
    packed_code_sizes_index ++;
    mz_uint code = (mz_uint)packed_code_sizes[tmp_39];
    __FC_assert((code < (mz_uint)TDEFL_MAX_HUFF_SYMBOLS_2) != 0,
                "miniz_tdef.c",420,"code < TDEFL_MAX_HUFF_SYMBOLS_2");
    {
      mz_uint bits_4 = (mz_uint)d->m_huff_codes[2][code];
      mz_uint len_4 = (mz_uint)d->m_huff_code_sizes[2][code];
      __FC_assert((bits_4 <= (1U << len_4) - 1U) != 0,"miniz_tdef.c",421,
                  "bits <= ((1U << len) - 1U)");
      d->m_bit_buffer |= bits_4 << d->m_bits_in;
      d->m_bits_in += len_4;
      while (d->m_bits_in >= (mz_uint)8) {
        if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
          mz_uint8 *tmp_40;
          tmp_40 = d->m_pOutput_buf;
          (d->m_pOutput_buf) ++;
          *tmp_40 = (mz_uint8)d->m_bit_buffer;
        }
        d->m_bit_buffer >>= 8;
        d->m_bits_in -= (mz_uint)8;
      }
    }
    if (code >= (mz_uint)16) {
      mz_uint tmp_41;
      tmp_41 = packed_code_sizes_index;
      packed_code_sizes_index ++;
      mz_uint bits_5 = (mz_uint)packed_code_sizes[tmp_41];
      mz_uint len_5 = (mz_uint)*("\002\003\a" + (code - (mz_uint)16));
      __FC_assert((bits_5 <= (1U << len_5) - 1U) != 0,"miniz_tdef.c",423,
                  "bits <= ((1U << len) - 1U)");
      d->m_bit_buffer |= bits_5 << d->m_bits_in;
      d->m_bits_in += len_5;
      while (d->m_bits_in >= (mz_uint)8) {
        if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
          mz_uint8 *tmp_42;
          tmp_42 = d->m_pOutput_buf;
          (d->m_pOutput_buf) ++;
          *tmp_42 = (mz_uint8)d->m_bit_buffer;
        }
        d->m_bit_buffer >>= 8;
        d->m_bits_in -= (mz_uint)8;
      }
    }
  }
  return;
}

static void tdefl_start_static_block(tdefl_compressor *d)
{
  mz_uint i;
  mz_uint8 *p = & d->m_huff_code_sizes[0][0];
  i = (mz_uint)0;
  while (i <= (mz_uint)143) {
    mz_uint8 *tmp;
    tmp = p;
    p ++;
    *tmp = (mz_uint8)8;
    i ++;
  }
  while (i <= (mz_uint)255) {
    mz_uint8 *tmp_0;
    tmp_0 = p;
    p ++;
    *tmp_0 = (mz_uint8)9;
    i ++;
  }
  while (i <= (mz_uint)279) {
    mz_uint8 *tmp_1;
    tmp_1 = p;
    p ++;
    *tmp_1 = (mz_uint8)7;
    i ++;
  }
  while (i <= (mz_uint)287) {
    mz_uint8 *tmp_2;
    tmp_2 = p;
    p ++;
    *tmp_2 = (mz_uint8)8;
    i ++;
  }
  memset((void *)(d->m_huff_code_sizes[1]),5,(size_t)32);
  tdefl_optimize_huffman_table(d,0,288,15,1);
  tdefl_optimize_huffman_table(d,1,32,15,1);
  {
    mz_uint bits = (mz_uint)1;
    mz_uint len = (mz_uint)2;
    __FC_assert((bits <= (1U << len) - 1U) != 0,"miniz_tdef.c",446,
                "bits <= ((1U << len) - 1U)");
    d->m_bit_buffer |= bits << d->m_bits_in;
    d->m_bits_in += len;
    while (d->m_bits_in >= (mz_uint)8) {
      if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
        mz_uint8 *tmp_3;
        tmp_3 = d->m_pOutput_buf;
        (d->m_pOutput_buf) ++;
        *tmp_3 = (mz_uint8)d->m_bit_buffer;
      }
      d->m_bit_buffer >>= 8;
      d->m_bits_in -= (mz_uint)8;
    }
  }
  return;
}

static mz_uint const mz_bitmasks[17] =
  {(mz_uint)0x0000,
   (mz_uint)0x0001,
   (mz_uint)0x0003,
   (mz_uint)0x0007,
   (mz_uint)0x000F,
   (mz_uint)0x001F,
   (mz_uint)0x003F,
   (mz_uint)0x007F,
   (mz_uint)0x00FF,
   (mz_uint)0x01FF,
   (mz_uint)0x03FF,
   (mz_uint)0x07FF,
   (mz_uint)0x0FFF,
   (mz_uint)0x1FFF,
   (mz_uint)0x3FFF,
   (mz_uint)0x7FFF,
   (mz_uint)0xFFFF};
static mz_bool tdefl_compress_lz_codes(tdefl_compressor *d)
{
  mz_bool __retres;
  mz_uint flags;
  mz_uint8 *pLZ_codes;
  mz_uint8 *pOutput_buf = d->m_pOutput_buf;
  mz_uint8 *pLZ_code_buf_end = d->m_pLZ_code_buf;
  mz_uint64 bit_buffer = (mz_uint64)d->m_bit_buffer;
  mz_uint bits_in = d->m_bits_in;
  flags = (mz_uint)1;
  pLZ_codes = d->m_lz_code_buf;
  while (pLZ_codes < pLZ_code_buf_end) {
    if (flags == (mz_uint)1) {
      mz_uint8 *tmp;
      tmp = pLZ_codes;
      pLZ_codes ++;
      flags = (mz_uint)((int)*tmp | 0x100);
    }
    if (flags & (unsigned int)1) {
      mz_uint s0;
      mz_uint s1;
      mz_uint n0;
      mz_uint n1;
      mz_uint sym;
      mz_uint num_extra_bits;
      mz_uint match_len = (mz_uint)*(pLZ_codes + 0);
      mz_uint match_dist = (mz_uint)*((mz_uint16 const *)(pLZ_codes + 1));
      pLZ_codes += 3;
      __FC_assert((int)d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]] != 0,
                  "miniz_tdef.c",479,
                  "d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]");
      bit_buffer |= (mz_uint64)d->m_huff_codes[0][s_tdefl_len_sym[match_len]] << bits_in;
      bits_in += (mz_uint)d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]];
      bit_buffer |= (mz_uint64)(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]]) << bits_in;
      bits_in += (mz_uint)s_tdefl_len_extra[match_len];
      s0 = (mz_uint)s_tdefl_small_dist_sym[match_dist & (unsigned int)511];
      n0 = (mz_uint)s_tdefl_small_dist_extra[match_dist & (unsigned int)511];
      s1 = (mz_uint)s_tdefl_large_dist_sym[match_dist >> 8];
      n1 = (mz_uint)s_tdefl_large_dist_extra[match_dist >> 8];
      if (match_dist < (mz_uint)512) sym = s0; else sym = s1;
      if (match_dist < (mz_uint)512) num_extra_bits = n0;
      else num_extra_bits = n1;
      __FC_assert((int)d->m_huff_code_sizes[1][sym] != 0,"miniz_tdef.c",491,
                  "d->m_huff_code_sizes[1][sym]");
      bit_buffer |= (mz_uint64)d->m_huff_codes[1][sym] << bits_in;
      bits_in += (mz_uint)d->m_huff_code_sizes[1][sym];
      bit_buffer |= (mz_uint64)(match_dist & mz_bitmasks[num_extra_bits]) << bits_in;
      bits_in += num_extra_bits;
    }
    else {
      mz_uint8 *tmp_0;
      tmp_0 = pLZ_codes;
      pLZ_codes ++;
      mz_uint lit = (mz_uint)*tmp_0;
      __FC_assert((int)d->m_huff_code_sizes[0][lit] != 0,"miniz_tdef.c",498,
                  "d->m_huff_code_sizes[0][lit]");
      bit_buffer |= (mz_uint64)d->m_huff_codes[0][lit] << bits_in;
      bits_in += (mz_uint)d->m_huff_code_sizes[0][lit];
      if ((flags & (unsigned int)2) == (unsigned int)0) 
        if (pLZ_codes < pLZ_code_buf_end) {
          mz_uint8 *tmp_1;
          flags >>= 1;
          tmp_1 = pLZ_codes;
          pLZ_codes ++;
          lit = (mz_uint)*tmp_1;
          __FC_assert((int)d->m_huff_code_sizes[0][lit] != 0,"miniz_tdef.c",
                      505,"d->m_huff_code_sizes[0][lit]");
          bit_buffer |= (mz_uint64)d->m_huff_codes[0][lit] << bits_in;
          bits_in += (mz_uint)d->m_huff_code_sizes[0][lit];
          if ((flags & (unsigned int)2) == (unsigned int)0) 
            if (pLZ_codes < pLZ_code_buf_end) {
              mz_uint8 *tmp_2;
              flags >>= 1;
              tmp_2 = pLZ_codes;
              pLZ_codes ++;
              lit = (mz_uint)*tmp_2;
              __FC_assert((int)d->m_huff_code_sizes[0][lit] != 0,
                          "miniz_tdef.c",512,"d->m_huff_code_sizes[0][lit]");
              bit_buffer |= (mz_uint64)d->m_huff_codes[0][lit] << bits_in;
              bits_in += (mz_uint)d->m_huff_code_sizes[0][lit];
            }
        }
    }
    if (pOutput_buf >= d->m_pOutput_buf_end) {
      __retres = 0;
      goto return_label;
    }
    *((mz_uint64 *)pOutput_buf) = bit_buffer;
    pOutput_buf += bits_in >> 3;
    bit_buffer >>= bits_in & (unsigned int)(~ 7);
    bits_in &= (unsigned int)7;
    flags >>= 1;
  }
  d->m_pOutput_buf = pOutput_buf;
  d->m_bits_in = (mz_uint)0;
  d->m_bit_buffer = (mz_uint)0;
  while (bits_in) {
    mz_uint tmp_3;
    if (bits_in < (mz_uint)16) tmp_3 = bits_in; else tmp_3 = (mz_uint)16;
    mz_uint32 n = tmp_3;
    {
      mz_uint bits = (mz_uint)bit_buffer & mz_bitmasks[n];
      mz_uint len = n;
      __FC_assert((bits <= (1U << len) - 1U) != 0,"miniz_tdef.c",536,
                  "bits <= ((1U << len) - 1U)");
      d->m_bit_buffer |= bits << d->m_bits_in;
      d->m_bits_in += len;
      while (d->m_bits_in >= (mz_uint)8) {
        if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
          mz_uint8 *tmp_4;
          tmp_4 = d->m_pOutput_buf;
          (d->m_pOutput_buf) ++;
          *tmp_4 = (mz_uint8)d->m_bit_buffer;
        }
        d->m_bit_buffer >>= 8;
        d->m_bits_in -= (mz_uint)8;
      }
    }
    bit_buffer >>= n;
    bits_in -= n;
  }
  {
    mz_uint bits_0 = (mz_uint)d->m_huff_codes[0][256];
    mz_uint len_0 = (mz_uint)d->m_huff_code_sizes[0][256];
    __FC_assert((bits_0 <= (1U << len_0) - 1U) != 0,"miniz_tdef.c",541,
                "bits <= ((1U << len) - 1U)");
    d->m_bit_buffer |= bits_0 << d->m_bits_in;
    d->m_bits_in += len_0;
    while (d->m_bits_in >= (mz_uint)8) {
      if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
        mz_uint8 *tmp_5;
        tmp_5 = d->m_pOutput_buf;
        (d->m_pOutput_buf) ++;
        *tmp_5 = (mz_uint8)d->m_bit_buffer;
      }
      d->m_bit_buffer >>= 8;
      d->m_bits_in -= (mz_uint)8;
    }
  }
  __retres = d->m_pOutput_buf < d->m_pOutput_buf_end;
  return_label: return __retres;
}

static mz_bool tdefl_compress_block(tdefl_compressor *d, mz_bool static_block)
{
  mz_bool tmp;
  if (static_block) tdefl_start_static_block(d);
  else tdefl_start_dynamic_block(d);
  tmp = tdefl_compress_lz_codes(d);
  return tmp;
}

static int tdefl_flush_block(tdefl_compressor *d, int flush)
{
  int __retres;
  mz_uint saved_bit_buf;
  mz_uint saved_bits_in;
  mz_uint8 *pSaved_output_buf;
  int n;
  int tmp;
  mz_uint8 *tmp_0;
  mz_bool comp_block_succeeded = 0;
  if ((d->m_flags & (unsigned int)TDEFL_FORCE_ALL_RAW_BLOCKS) != (unsigned int)0) 
    if (d->m_lookahead_pos - d->m_lz_code_buf_dict_pos <= d->m_dict_size) 
      tmp = 1;
    else tmp = 0;
  else tmp = 0;
  int use_raw_block = tmp;
  if (d->m_pPut_buf_func == (mz_bool (*)(void const *pBuf, int len,
                                         void *pUser))0) 
    if (*(d->m_pOut_buf_size) - d->m_out_buf_ofs >= (size_t)TDEFL_OUT_BUF_SIZE) 
      tmp_0 = (mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs;
    else tmp_0 = d->m_output_buf;
  else tmp_0 = d->m_output_buf;
  mz_uint8 *pOutput_buf_start = tmp_0;
  d->m_pOutput_buf = pOutput_buf_start;
  d->m_pOutput_buf_end = (d->m_pOutput_buf + TDEFL_OUT_BUF_SIZE) - 16;
  __FC_assert(! d->m_output_flush_remaining != 0,"miniz_tdef.c",614,
              "!d->m_output_flush_remaining");
  d->m_output_flush_ofs = (mz_uint)0;
  d->m_output_flush_remaining = (mz_uint)0;
  *(d->m_pLZ_flags) = (mz_uint8)((int)*(d->m_pLZ_flags) >> d->m_num_flags_left);
  d->m_pLZ_code_buf -= d->m_num_flags_left == (mz_uint)8;
  if (d->m_flags & (unsigned int)TDEFL_WRITE_ZLIB_HEADER) 
    if (! d->m_block_index) {
      {
        mz_uint bits = (mz_uint)0x78;
        mz_uint len = (mz_uint)8;
        __FC_assert((bits <= (1U << len) - 1U) != 0,"miniz_tdef.c",623,
                    "bits <= ((1U << len) - 1U)");
        d->m_bit_buffer |= bits << d->m_bits_in;
        d->m_bits_in += len;
        while (d->m_bits_in >= (mz_uint)8) {
          if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
            mz_uint8 *tmp_1;
            tmp_1 = d->m_pOutput_buf;
            (d->m_pOutput_buf) ++;
            *tmp_1 = (mz_uint8)d->m_bit_buffer;
          }
          d->m_bit_buffer >>= 8;
          d->m_bits_in -= (mz_uint)8;
        }
      }
      {
        mz_uint bits_0 = (mz_uint)0x01;
        mz_uint len_0 = (mz_uint)8;
        __FC_assert((bits_0 <= (1U << len_0) - 1U) != 0,"miniz_tdef.c",624,
                    "bits <= ((1U << len) - 1U)");
        d->m_bit_buffer |= bits_0 << d->m_bits_in;
        d->m_bits_in += len_0;
        while (d->m_bits_in >= (mz_uint)8) {
          if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
            mz_uint8 *tmp_2;
            tmp_2 = d->m_pOutput_buf;
            (d->m_pOutput_buf) ++;
            *tmp_2 = (mz_uint8)d->m_bit_buffer;
          }
          d->m_bit_buffer >>= 8;
          d->m_bits_in -= (mz_uint)8;
        }
      }
    }
  {
    mz_uint bits_1 = (mz_uint)(flush == TDEFL_FINISH);
    mz_uint len_1 = (mz_uint)1;
    __FC_assert((bits_1 <= (1U << len_1) - 1U) != 0,"miniz_tdef.c",627,
                "bits <= ((1U << len) - 1U)");
    d->m_bit_buffer |= bits_1 << d->m_bits_in;
    d->m_bits_in += len_1;
    while (d->m_bits_in >= (mz_uint)8) {
      if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
        mz_uint8 *tmp_3;
        tmp_3 = d->m_pOutput_buf;
        (d->m_pOutput_buf) ++;
        *tmp_3 = (mz_uint8)d->m_bit_buffer;
      }
      d->m_bit_buffer >>= 8;
      d->m_bits_in -= (mz_uint)8;
    }
  }
  pSaved_output_buf = d->m_pOutput_buf;
  saved_bit_buf = d->m_bit_buffer;
  saved_bits_in = d->m_bits_in;
  if (! use_raw_block) {
    int tmp_4;
    if (d->m_flags & (unsigned int)TDEFL_FORCE_ALL_STATIC_BLOCKS) tmp_4 = 1;
    else 
      if (d->m_total_lz_bytes < (mz_uint)48) tmp_4 = 1; else tmp_4 = 0;
    ;
    comp_block_succeeded = tdefl_compress_block(d,tmp_4);
  }
  if (use_raw_block) goto _LOR;
  else 
    if (d->m_total_lz_bytes) {
      if ((d->m_pOutput_buf - pSaved_output_buf) + (long)1U >= (long)d->m_total_lz_bytes) {
        _LOR: ;
        if (d->m_lookahead_pos - d->m_lz_code_buf_dict_pos <= d->m_dict_size) {
          mz_uint i;
          d->m_pOutput_buf = pSaved_output_buf;
          d->m_bit_buffer = saved_bit_buf;
          d->m_bits_in = saved_bits_in;
          {
            mz_uint bits_2 = (mz_uint)0;
            mz_uint len_2 = (mz_uint)2;
            __FC_assert((bits_2 <= (1U << len_2) - 1U) != 0,"miniz_tdef.c",
                        643,"bits <= ((1U << len) - 1U)");
            d->m_bit_buffer |= bits_2 << d->m_bits_in;
            d->m_bits_in += len_2;
            while (d->m_bits_in >= (mz_uint)8) {
              if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
                mz_uint8 *tmp_5;
                tmp_5 = d->m_pOutput_buf;
                (d->m_pOutput_buf) ++;
                *tmp_5 = (mz_uint8)d->m_bit_buffer;
              }
              d->m_bit_buffer >>= 8;
              d->m_bits_in -= (mz_uint)8;
            }
          }
          if (d->m_bits_in) {
            mz_uint bits_3 = (mz_uint)0;
            mz_uint len_3 = (mz_uint)8 - d->m_bits_in;
            __FC_assert((bits_3 <= (1U << len_3) - 1U) != 0,"miniz_tdef.c",
                        646,"bits <= ((1U << len) - 1U)");
            d->m_bit_buffer |= bits_3 << d->m_bits_in;
            d->m_bits_in += len_3;
            while (d->m_bits_in >= (mz_uint)8) {
              if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
                mz_uint8 *tmp_6;
                tmp_6 = d->m_pOutput_buf;
                (d->m_pOutput_buf) ++;
                *tmp_6 = (mz_uint8)d->m_bit_buffer;
              }
              d->m_bit_buffer >>= 8;
              d->m_bits_in -= (mz_uint)8;
            }
          }
          i = (mz_uint)2;
          while (i) {
            {
              mz_uint bits_4 = d->m_total_lz_bytes & (unsigned int)0xFFFF;
              mz_uint len_4 = (mz_uint)16;
              __FC_assert((bits_4 <= (1U << len_4) - 1U) != 0,"miniz_tdef.c",
                          650,"bits <= ((1U << len) - 1U)");
              d->m_bit_buffer |= bits_4 << d->m_bits_in;
              d->m_bits_in += len_4;
              while (d->m_bits_in >= (mz_uint)8) {
                if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
                  mz_uint8 *tmp_7;
                  tmp_7 = d->m_pOutput_buf;
                  (d->m_pOutput_buf) ++;
                  *tmp_7 = (mz_uint8)d->m_bit_buffer;
                }
                d->m_bit_buffer >>= 8;
                d->m_bits_in -= (mz_uint)8;
              }
            }
            i --;
            d->m_total_lz_bytes ^= (unsigned int)0xFFFF;
          }
          i = (mz_uint)0;
          while (i < d->m_total_lz_bytes) {
            {
              mz_uint bits_5 =
                (mz_uint)d->m_dict[(d->m_lz_code_buf_dict_pos + i) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK];
              mz_uint len_5 = (mz_uint)8;
              __FC_assert((bits_5 <= (1U << len_5) - 1U) != 0,"miniz_tdef.c",
                          654,"bits <= ((1U << len) - 1U)");
              d->m_bit_buffer |= bits_5 << d->m_bits_in;
              d->m_bits_in += len_5;
              while (d->m_bits_in >= (mz_uint)8) {
                if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
                  mz_uint8 *tmp_8;
                  tmp_8 = d->m_pOutput_buf;
                  (d->m_pOutput_buf) ++;
                  *tmp_8 = (mz_uint8)d->m_bit_buffer;
                }
                d->m_bit_buffer >>= 8;
                d->m_bits_in -= (mz_uint)8;
              }
            }
            i ++;
          }
        }
        else goto _LAND_0;
      }
      else goto _LAND_0;
    }
    else 
      _LAND_0:
      if (! comp_block_succeeded) {
        d->m_pOutput_buf = pSaved_output_buf;
        d->m_bit_buffer = saved_bit_buf;
        d->m_bits_in = saved_bits_in;
        tdefl_compress_block(d,1);
      }
  if (flush) 
    if (flush == TDEFL_FINISH) {
      if (d->m_bits_in) {
        mz_uint bits_6 = (mz_uint)0;
        mz_uint len_6 = (mz_uint)8 - d->m_bits_in;
        __FC_assert((bits_6 <= (1U << len_6) - 1U) != 0,"miniz_tdef.c",671,
                    "bits <= ((1U << len) - 1U)");
        d->m_bit_buffer |= bits_6 << d->m_bits_in;
        d->m_bits_in += len_6;
        while (d->m_bits_in >= (mz_uint)8) {
          if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
            mz_uint8 *tmp_9;
            tmp_9 = d->m_pOutput_buf;
            (d->m_pOutput_buf) ++;
            *tmp_9 = (mz_uint8)d->m_bit_buffer;
          }
          d->m_bit_buffer >>= 8;
          d->m_bits_in -= (mz_uint)8;
        }
      }
      if (d->m_flags & (unsigned int)TDEFL_WRITE_ZLIB_HEADER) {
        mz_uint i_0;
        mz_uint a = d->m_adler32;
        i_0 = (mz_uint)0;
        while (i_0 < (mz_uint)4) {
          {
            mz_uint bits_7 = (a >> 24) & (unsigned int)0xFF;
            mz_uint len_7 = (mz_uint)8;
            __FC_assert((bits_7 <= (1U << len_7) - 1U) != 0,"miniz_tdef.c",
                        678,"bits <= ((1U << len) - 1U)");
            d->m_bit_buffer |= bits_7 << d->m_bits_in;
            d->m_bits_in += len_7;
            while (d->m_bits_in >= (mz_uint)8) {
              if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
                mz_uint8 *tmp_10;
                tmp_10 = d->m_pOutput_buf;
                (d->m_pOutput_buf) ++;
                *tmp_10 = (mz_uint8)d->m_bit_buffer;
              }
              d->m_bit_buffer >>= 8;
              d->m_bits_in -= (mz_uint)8;
            }
          }
          a <<= 8;
          i_0 ++;
        }
      }
    }
    else {
      mz_uint i_1;
      mz_uint z = (mz_uint)0;
      {
        mz_uint bits_8 = (mz_uint)0;
        mz_uint len_8 = (mz_uint)3;
        __FC_assert((bits_8 <= (1U << len_8) - 1U) != 0,"miniz_tdef.c",686,
                    "bits <= ((1U << len) - 1U)");
        d->m_bit_buffer |= bits_8 << d->m_bits_in;
        d->m_bits_in += len_8;
        while (d->m_bits_in >= (mz_uint)8) {
          if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
            mz_uint8 *tmp_11;
            tmp_11 = d->m_pOutput_buf;
            (d->m_pOutput_buf) ++;
            *tmp_11 = (mz_uint8)d->m_bit_buffer;
          }
          d->m_bit_buffer >>= 8;
          d->m_bits_in -= (mz_uint)8;
        }
      }
      if (d->m_bits_in) {
        mz_uint bits_9 = (mz_uint)0;
        mz_uint len_9 = (mz_uint)8 - d->m_bits_in;
        __FC_assert((bits_9 <= (1U << len_9) - 1U) != 0,"miniz_tdef.c",689,
                    "bits <= ((1U << len) - 1U)");
        d->m_bit_buffer |= bits_9 << d->m_bits_in;
        d->m_bits_in += len_9;
        while (d->m_bits_in >= (mz_uint)8) {
          if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
            mz_uint8 *tmp_12;
            tmp_12 = d->m_pOutput_buf;
            (d->m_pOutput_buf) ++;
            *tmp_12 = (mz_uint8)d->m_bit_buffer;
          }
          d->m_bit_buffer >>= 8;
          d->m_bits_in -= (mz_uint)8;
        }
      }
      i_1 = (mz_uint)2;
      while (i_1) {
        {
          mz_uint bits_10 = z & (unsigned int)0xFFFF;
          mz_uint len_10 = (mz_uint)16;
          __FC_assert((bits_10 <= (1U << len_10) - 1U) != 0,"miniz_tdef.c",
                      693,"bits <= ((1U << len) - 1U)");
          d->m_bit_buffer |= bits_10 << d->m_bits_in;
          d->m_bits_in += len_10;
          while (d->m_bits_in >= (mz_uint)8) {
            if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
              mz_uint8 *tmp_13;
              tmp_13 = d->m_pOutput_buf;
              (d->m_pOutput_buf) ++;
              *tmp_13 = (mz_uint8)d->m_bit_buffer;
            }
            d->m_bit_buffer >>= 8;
            d->m_bits_in -= (mz_uint)8;
          }
        }
        i_1 --;
        z ^= (unsigned int)0xFFFF;
      }
    }
  __FC_assert((d->m_pOutput_buf < d->m_pOutput_buf_end) != 0,"miniz_tdef.c",
              698,"d->m_pOutput_buf < d->m_pOutput_buf_end");
  memset((void *)(& d->m_huff_count[0][0]),0,
         sizeof(d->m_huff_count[0][0]) * (unsigned long)TDEFL_MAX_HUFF_SYMBOLS_0);
  memset((void *)(& d->m_huff_count[1][0]),0,
         sizeof(d->m_huff_count[1][0]) * (unsigned long)TDEFL_MAX_HUFF_SYMBOLS_1);
  d->m_pLZ_code_buf = & d->m_lz_code_buf[1];
  d->m_pLZ_flags = d->m_lz_code_buf;
  d->m_num_flags_left = (mz_uint)8;
  d->m_lz_code_buf_dict_pos += d->m_total_lz_bytes;
  d->m_total_lz_bytes = (mz_uint)0;
  (d->m_block_index) ++;
  n = (int)(d->m_pOutput_buf - pOutput_buf_start);
  if (n != 0) 
    if (d->m_pPut_buf_func) {
      mz_bool tmp_15;
      *(d->m_pIn_buf_size) = (size_t)(d->m_pSrc - (mz_uint8 const *)d->m_pIn_buf);
      tmp_15 = (*(d->m_pPut_buf_func))((void const *)(d->m_output_buf),n,
                                       d->m_pPut_buf_user);
      if (! tmp_15) {
        tdefl_status tmp_14;
        tmp_14 = TDEFL_STATUS_PUT_BUF_FAILED;
        d->m_prev_return_status = tmp_14;
        __retres = tmp_14;
        goto return_label;
      }
    }
    else 
      if (pOutput_buf_start == d->m_output_buf) {
        size_t tmp_16;
        if ((size_t)n < *(d->m_pOut_buf_size) - d->m_out_buf_ofs) tmp_16 = (size_t)n;
        else tmp_16 = *(d->m_pOut_buf_size) - d->m_out_buf_ofs;
        int bytes_to_copy = (int)tmp_16;
        memcpy((void *)((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs),
               (void const *)(d->m_output_buf),(size_t)bytes_to_copy);
        d->m_out_buf_ofs += (size_t)bytes_to_copy;
        n -= bytes_to_copy;
        if (n != 0) {
          d->m_output_flush_ofs = (mz_uint)bytes_to_copy;
          d->m_output_flush_remaining = (mz_uint)n;
        }
      }
      else d->m_out_buf_ofs += (size_t)n;
  __retres = (int)d->m_output_flush_remaining;
  return_label: return __retres;
}

static mz_uint16 TDEFL_READ_UNALIGNED_WORD(mz_uint8 const *p)
{
  mz_uint16 ret;
  memcpy((void *)(& ret),(void const *)p,sizeof(mz_uint16));
  return ret;
}

static mz_uint16 TDEFL_READ_UNALIGNED_WORD2(mz_uint16 const *p)
{
  mz_uint16 ret;
  memcpy((void *)(& ret),(void const *)p,sizeof(mz_uint16));
  return ret;
}

__inline static void ( __attribute__((__always_inline__)) tdefl_find_match)
(tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist,
 mz_uint max_match_len, mz_uint *pMatch_dist, mz_uint *pMatch_len)
{
  mz_uint dist;
  mz_uint next_probe_pos;
  mz_uint probe_len;
  mz_uint16 const *p;
  mz_uint16 const *q;
  mz_uint pos = lookahead_pos & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
  mz_uint match_len = *pMatch_len;
  mz_uint probe_pos = pos;
  mz_uint num_probes_left = d->m_max_probes[match_len >= (mz_uint)32];
  mz_uint16 const *s = (mz_uint16 const *)(& d->m_dict[pos]);
  mz_uint16 c01 =
    TDEFL_READ_UNALIGNED_WORD((mz_uint8 const *)(& d->m_dict[(pos + match_len) - (mz_uint)1]));
  mz_uint16 s01 = TDEFL_READ_UNALIGNED_WORD2(s);
  __FC_assert((max_match_len <= (mz_uint)TDEFL_MAX_MATCH_LEN) != 0,
              "miniz_tdef.c",762,"max_match_len <= TDEFL_MAX_MATCH_LEN");
  if (max_match_len <= match_len) goto return_label;
  while (1) {
    {
      mz_uint16 tmp_4;
      while (1) {
        mz_uint16 tmp_1;
        mz_uint16 tmp_2;
        mz_uint16 tmp_3;
        num_probes_left --;
        if (num_probes_left == (mz_uint)0) goto return_label;
        next_probe_pos = (mz_uint)d->m_next[probe_pos];
        if (! next_probe_pos) goto return_label;
        else {
          dist = (mz_uint)((mz_uint16)(lookahead_pos - next_probe_pos));
          ;
          if (dist > max_dist) goto return_label;
        }
        probe_pos = next_probe_pos & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
        tmp_1 = TDEFL_READ_UNALIGNED_WORD((mz_uint8 const *)(& d->m_dict[
                                          (probe_pos + match_len) - (mz_uint)1]));
        ;
        if ((int)tmp_1 == (int)c01) break;
        next_probe_pos = (mz_uint)d->m_next[probe_pos];
        if (! next_probe_pos) goto return_label;
        else {
          dist = (mz_uint)((mz_uint16)(lookahead_pos - next_probe_pos));
          ;
          if (dist > max_dist) goto return_label;
        }
        probe_pos = next_probe_pos & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
        tmp_2 = TDEFL_READ_UNALIGNED_WORD((mz_uint8 const *)(& d->m_dict[
                                          (probe_pos + match_len) - (mz_uint)1]));
        ;
        if ((int)tmp_2 == (int)c01) break;
        next_probe_pos = (mz_uint)d->m_next[probe_pos];
        if (! next_probe_pos) goto return_label;
        else {
          dist = (mz_uint)((mz_uint16)(lookahead_pos - next_probe_pos));
          ;
          if (dist > max_dist) goto return_label;
        }
        probe_pos = next_probe_pos & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
        tmp_3 = TDEFL_READ_UNALIGNED_WORD((mz_uint8 const *)(& d->m_dict[
                                          (probe_pos + match_len) - (mz_uint)1]));
        ;
        if ((int)tmp_3 == (int)c01) break;
      }
      if (! dist) break;
      q = (mz_uint16 const *)(& d->m_dict[probe_pos]);
      tmp_4 = TDEFL_READ_UNALIGNED_WORD2(q);
      ;
      if ((int)tmp_4 != (int)s01) goto __Cont;
      p = s;
      probe_len = (mz_uint)32;
      while (1) {
        mz_uint16 tmp_5;
        mz_uint16 tmp_6;
        p ++;
        tmp_5 = TDEFL_READ_UNALIGNED_WORD2(p);
        q ++;
        tmp_6 = TDEFL_READ_UNALIGNED_WORD2(q);
        if ((int)tmp_5 == (int)tmp_6) {
          mz_uint16 tmp_7;
          mz_uint16 tmp_8;
          p ++;
          tmp_7 = TDEFL_READ_UNALIGNED_WORD2(p);
          q ++;
          tmp_8 = TDEFL_READ_UNALIGNED_WORD2(q);
          if ((int)tmp_7 == (int)tmp_8) {
            mz_uint16 tmp_9;
            mz_uint16 tmp_10;
            p ++;
            tmp_9 = TDEFL_READ_UNALIGNED_WORD2(p);
            q ++;
            tmp_10 = TDEFL_READ_UNALIGNED_WORD2(q);
            if ((int)tmp_9 == (int)tmp_10) {
              mz_uint16 tmp_11;
              mz_uint16 tmp_12;
              p ++;
              tmp_11 = TDEFL_READ_UNALIGNED_WORD2(p);
              q ++;
              tmp_12 = TDEFL_READ_UNALIGNED_WORD2(q);
              if ((int)tmp_11 == (int)tmp_12) {
                probe_len --;
                if (! (probe_len > (mz_uint)0)) break;
              }
              else break;
            }
            else break;
          }
          else break;
        }
        else break;
      }
      if (! probe_len) {
        *pMatch_dist = dist;
        if (max_match_len < (mz_uint)TDEFL_MAX_MATCH_LEN) *pMatch_len = max_match_len;
        else *pMatch_len = (mz_uint)TDEFL_MAX_MATCH_LEN;
        break;
      }
      else {
        probe_len = (mz_uint)(p - s) * (mz_uint)2 + (mz_uint)((int)*((mz_uint8 const *)p) == (int)*((mz_uint8 const *)q));
        ;
        if (probe_len > match_len) {
          mz_uint tmp_13;
          *pMatch_dist = dist;
          if (max_match_len < probe_len) match_len = max_match_len;
          else match_len = probe_len;
          tmp_13 = match_len;
          *pMatch_len = tmp_13;
          ;
          if (tmp_13 == max_match_len) break;
          c01 = TDEFL_READ_UNALIGNED_WORD((mz_uint8 const *)(& d->m_dict[
                                          (pos + match_len) - (mz_uint)1]));
        }
      }
    }
    __Cont: ;
  }
  return_label: return;
}

static mz_uint32 TDEFL_READ_UNALIGNED_WORD32(mz_uint8 const *p)
{
  mz_uint32 ret;
  memcpy((void *)(& ret),(void const *)p,sizeof(mz_uint32));
  return ret;
}

static mz_bool tdefl_compress_fast(tdefl_compressor *d)
{
  mz_bool __retres;
  mz_uint lookahead_pos = d->m_lookahead_pos;
  mz_uint lookahead_size = d->m_lookahead_size;
  mz_uint dict_size = d->m_dict_size;
  mz_uint total_lz_bytes = d->m_total_lz_bytes;
  mz_uint num_flags_left = d->m_num_flags_left;
  mz_uint8 *pLZ_code_buf = d->m_pLZ_code_buf;
  mz_uint8 *pLZ_flags = d->m_pLZ_flags;
  mz_uint cur_pos = lookahead_pos & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
  while (1) {
    if (! d->m_src_buf_left) 
      if (d->m_flush) {
        if (! lookahead_size) break;
      }
      else break;
    {
      size_t tmp;
      mz_uint const TDEFL_COMP_FAST_LOOKAHEAD_SIZE = (mz_uint)4096;
      mz_uint dst_pos =
        (lookahead_pos + lookahead_size) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
      if (d->m_src_buf_left < (size_t)(TDEFL_COMP_FAST_LOOKAHEAD_SIZE - lookahead_size)) 
        tmp = d->m_src_buf_left;
      else tmp = (size_t)(TDEFL_COMP_FAST_LOOKAHEAD_SIZE - lookahead_size);
      mz_uint num_bytes_to_process = (mz_uint)tmp;
      d->m_src_buf_left -= (size_t)num_bytes_to_process;
      lookahead_size += num_bytes_to_process;
      while (num_bytes_to_process) {
        mz_uint tmp_0;
        if ((mz_uint)TDEFL_LZ_DICT_SIZE - dst_pos < num_bytes_to_process) 
          tmp_0 = (mz_uint)TDEFL_LZ_DICT_SIZE - dst_pos;
        else tmp_0 = num_bytes_to_process;
        mz_uint32 n = tmp_0;
        memcpy((void *)(& d->m_dict[dst_pos]),(void const *)d->m_pSrc,
               (size_t)n);
        if (dst_pos < (mz_uint)(TDEFL_MAX_MATCH_LEN - 1)) {
          mz_uint32 tmp_1;
          if (n < (mz_uint)(TDEFL_MAX_MATCH_LEN - 1) - dst_pos) tmp_1 = n;
          else tmp_1 = (mz_uint)(TDEFL_MAX_MATCH_LEN - 1) - dst_pos;
          ;
          ;
          memcpy((void *)(& d->m_dict[TDEFL_LZ_DICT_SIZE] + dst_pos),
                 (void const *)d->m_pSrc,(size_t)tmp_1);
        }
        d->m_pSrc += n;
        dst_pos = (dst_pos + n) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
        num_bytes_to_process -= n;
      }
      if ((mz_uint)TDEFL_LZ_DICT_SIZE - lookahead_size < dict_size) dict_size = 
                                                                    (mz_uint)TDEFL_LZ_DICT_SIZE - lookahead_size;
      else dict_size = dict_size;
      if (! d->m_flush) 
        if (lookahead_size < TDEFL_COMP_FAST_LOOKAHEAD_SIZE) break;
      while (lookahead_size >= (mz_uint)4) {
        mz_uint cur_match_dist;
        mz_uint32 tmp_2;
        mz_uint cur_match_len = (mz_uint)1;
        mz_uint8 *pCur_dict = & d->m_dict[cur_pos];
        tmp_2 = TDEFL_READ_UNALIGNED_WORD32((mz_uint8 const *)pCur_dict);
        mz_uint first_trigram = tmp_2 & (unsigned int)0xFFFFFF;
        mz_uint hash =
          (first_trigram ^ (first_trigram >> (24 - (TDEFL_LZ_HASH_BITS - 8)))) & (unsigned int)TDEFL_LEVEL1_HASH_SIZE_MASK;
        mz_uint probe_pos = (mz_uint)d->m_hash[hash];
        d->m_hash[hash] = (mz_uint16)lookahead_pos;
        cur_match_dist = (mz_uint)((mz_uint16)(lookahead_pos - probe_pos));
        ;
        if (cur_match_dist <= dict_size) {
          mz_uint32 tmp_15;
          probe_pos &= (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
          ;
          tmp_15 = TDEFL_READ_UNALIGNED_WORD32((mz_uint8 const *)(& d->m_dict[probe_pos]));
          ;
          if ((tmp_15 & (unsigned int)0xFFFFFF) == first_trigram) {
            mz_uint16 const *p = (mz_uint16 const *)pCur_dict;
            mz_uint16 const *q = (mz_uint16 const *)(& d->m_dict[probe_pos]);
            mz_uint32 probe_len = (mz_uint32)32;
            while (1) {
              mz_uint16 tmp_3;
              mz_uint16 tmp_4;
              p ++;
              tmp_3 = TDEFL_READ_UNALIGNED_WORD2(p);
              q ++;
              tmp_4 = TDEFL_READ_UNALIGNED_WORD2(q);
              if ((int)tmp_3 == (int)tmp_4) {
                mz_uint16 tmp_5;
                mz_uint16 tmp_6;
                p ++;
                tmp_5 = TDEFL_READ_UNALIGNED_WORD2(p);
                q ++;
                tmp_6 = TDEFL_READ_UNALIGNED_WORD2(q);
                if ((int)tmp_5 == (int)tmp_6) {
                  mz_uint16 tmp_7;
                  mz_uint16 tmp_8;
                  p ++;
                  tmp_7 = TDEFL_READ_UNALIGNED_WORD2(p);
                  q ++;
                  tmp_8 = TDEFL_READ_UNALIGNED_WORD2(q);
                  if ((int)tmp_7 == (int)tmp_8) {
                    mz_uint16 tmp_9;
                    mz_uint16 tmp_10;
                    p ++;
                    tmp_9 = TDEFL_READ_UNALIGNED_WORD2(p);
                    q ++;
                    tmp_10 = TDEFL_READ_UNALIGNED_WORD2(q);
                    if ((int)tmp_9 == (int)tmp_10) {
                      probe_len --;
                      if (! (probe_len > (mz_uint32)0)) break;
                    }
                    else break;
                  }
                  else break;
                }
                else break;
              }
              else break;
            }
            cur_match_len = (mz_uint)(p - (mz_uint16 const *)pCur_dict) * (mz_uint)2 + (mz_uint)(
                            (int)*((mz_uint8 const *)p) == (int)*((mz_uint8 const *)q));
            if (! probe_len) 
              if (cur_match_dist) cur_match_len = (mz_uint)TDEFL_MAX_MATCH_LEN;
              else cur_match_len = (mz_uint)0;
            if (cur_match_len < (mz_uint)TDEFL_MIN_MATCH_LEN) goto _LOR;
            else 
              if (cur_match_len == (mz_uint)TDEFL_MIN_MATCH_LEN) {
                if (cur_match_dist >= 8U * 1024U) {
                  _LOR:
                  {
                    mz_uint8 *tmp_11;
                    cur_match_len = (mz_uint)1;
                    tmp_11 = pLZ_code_buf;
                    pLZ_code_buf ++;
                    *tmp_11 = (mz_uint8)first_trigram;
                    *pLZ_flags = (mz_uint8)((int)*pLZ_flags >> 1);
                    d->m_huff_count[0][(mz_uint8)first_trigram] = (mz_uint16)(
                    (int)d->m_huff_count[0][(mz_uint8)first_trigram] + 1);
                  }
                }
                else goto _LAND;
              }
              else {
                _LAND:
                {
                  mz_uint32 s0;
                  mz_uint32 s1;
                  int tmp_12;
                  mz_uint32 tmp_13;
                  if (cur_match_len < lookahead_size) cur_match_len = cur_match_len;
                  else cur_match_len = lookahead_size;
                  if (cur_match_len >= (mz_uint)TDEFL_MIN_MATCH_LEN) 
                    if (cur_match_dist >= (mz_uint)1) 
                      if (cur_match_dist <= (mz_uint)TDEFL_LZ_DICT_SIZE) 
                        tmp_12 = 1;
                      else tmp_12 = 0;
                    else tmp_12 = 0;
                  else tmp_12 = 0;
                  __FC_assert(tmp_12 != 0,"miniz_tdef.c",929,
                              "(cur_match_len >= TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 1) && (cur_match_dist <= TDEFL_LZ_DICT_SIZE)");
                  cur_match_dist --;
                  *(pLZ_code_buf + 0) = (mz_uint8)(cur_match_len - (mz_uint)TDEFL_MIN_MATCH_LEN);
                  memcpy((void *)(pLZ_code_buf + 1),
                         (void const *)(& cur_match_dist),
                         sizeof(cur_match_dist));
                  pLZ_code_buf += 3;
                  *pLZ_flags = (mz_uint8)(((int)*pLZ_flags >> 1) | 0x80);
                  s0 = (mz_uint32)s_tdefl_small_dist_sym[cur_match_dist & (unsigned int)511];
                  s1 = (mz_uint32)s_tdefl_large_dist_sym[cur_match_dist >> 8];
                  if (cur_match_dist < (mz_uint)512) tmp_13 = s0;
                  else tmp_13 = s1;
                  d->m_huff_count[1][tmp_13] = (mz_uint16)((int)d->m_huff_count[1][tmp_13] + 1);
                  d->m_huff_count[0][s_tdefl_len_sym[cur_match_len - (mz_uint)TDEFL_MIN_MATCH_LEN]] = (mz_uint16)(
                  (int)d->m_huff_count[0][s_tdefl_len_sym[cur_match_len - (mz_uint)TDEFL_MIN_MATCH_LEN]] + 1);
                }
              }
          }
          else goto _LAND_0;
        }
        else {
          _LAND_0:
          {
            mz_uint8 *tmp_14;
            tmp_14 = pLZ_code_buf;
            pLZ_code_buf ++;
            *tmp_14 = (mz_uint8)first_trigram;
            *pLZ_flags = (mz_uint8)((int)*pLZ_flags >> 1);
            d->m_huff_count[0][(mz_uint8)first_trigram] = (mz_uint16)(
            (int)d->m_huff_count[0][(mz_uint8)first_trigram] + 1);
          }
        }
        num_flags_left --;
        if (num_flags_left == (mz_uint)0) {
          mz_uint8 *tmp_16;
          num_flags_left = (mz_uint)8;
          tmp_16 = pLZ_code_buf;
          pLZ_code_buf ++;
          pLZ_flags = tmp_16;
        }
        total_lz_bytes += cur_match_len;
        lookahead_pos += cur_match_len;
        if (dict_size + cur_match_len < (mz_uint)TDEFL_LZ_DICT_SIZE) 
          dict_size += cur_match_len;
        else dict_size = (mz_uint)TDEFL_LZ_DICT_SIZE;
        cur_pos = (cur_pos + cur_match_len) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
        __FC_assert((lookahead_size >= cur_match_len) != 0,"miniz_tdef.c",
                    966,"lookahead_size >= cur_match_len");
        lookahead_size -= cur_match_len;
        if (pLZ_code_buf > & d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) {
          int n_0;
          d->m_lookahead_pos = lookahead_pos;
          d->m_lookahead_size = lookahead_size;
          d->m_dict_size = dict_size;
          d->m_total_lz_bytes = total_lz_bytes;
          d->m_pLZ_code_buf = pLZ_code_buf;
          d->m_pLZ_flags = pLZ_flags;
          d->m_num_flags_left = num_flags_left;
          n_0 = tdefl_flush_block(d,0);
          if (n_0 != 0) {
            int tmp_17;
            if (n_0 < 0) tmp_17 = 0; else tmp_17 = 1;
            __retres = tmp_17;
            goto return_label;
          }
          total_lz_bytes = d->m_total_lz_bytes;
          pLZ_code_buf = d->m_pLZ_code_buf;
          pLZ_flags = d->m_pLZ_flags;
          num_flags_left = d->m_num_flags_left;
        }
      }
      while (lookahead_size) {
        mz_uint8 *tmp_18;
        mz_uint8 lit = d->m_dict[cur_pos];
        total_lz_bytes ++;
        tmp_18 = pLZ_code_buf;
        pLZ_code_buf ++;
        *tmp_18 = lit;
        *pLZ_flags = (mz_uint8)((int)*pLZ_flags >> 1);
        num_flags_left --;
        if (num_flags_left == (mz_uint)0) {
          mz_uint8 *tmp_19;
          num_flags_left = (mz_uint)8;
          tmp_19 = pLZ_code_buf;
          pLZ_code_buf ++;
          pLZ_flags = tmp_19;
        }
        d->m_huff_count[0][lit] = (mz_uint16)((int)d->m_huff_count[0][lit] + 1);
        lookahead_pos ++;
        if (dict_size + (mz_uint)1 < (mz_uint)TDEFL_LZ_DICT_SIZE) dict_size += (mz_uint)1;
        else dict_size = (mz_uint)TDEFL_LZ_DICT_SIZE;
        cur_pos = (cur_pos + (mz_uint)1) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
        lookahead_size --;
        if (pLZ_code_buf > & d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) {
          int n_1;
          d->m_lookahead_pos = lookahead_pos;
          d->m_lookahead_size = lookahead_size;
          d->m_dict_size = dict_size;
          d->m_total_lz_bytes = total_lz_bytes;
          d->m_pLZ_code_buf = pLZ_code_buf;
          d->m_pLZ_flags = pLZ_flags;
          d->m_num_flags_left = num_flags_left;
          n_1 = tdefl_flush_block(d,0);
          if (n_1 != 0) {
            int tmp_20;
            if (n_1 < 0) tmp_20 = 0; else tmp_20 = 1;
            __retres = tmp_20;
            goto return_label;
          }
          total_lz_bytes = d->m_total_lz_bytes;
          pLZ_code_buf = d->m_pLZ_code_buf;
          pLZ_flags = d->m_pLZ_flags;
          num_flags_left = d->m_num_flags_left;
        }
      }
    }
  }
  d->m_lookahead_pos = lookahead_pos;
  d->m_lookahead_size = lookahead_size;
  d->m_dict_size = dict_size;
  d->m_total_lz_bytes = total_lz_bytes;
  d->m_pLZ_code_buf = pLZ_code_buf;
  d->m_pLZ_flags = pLZ_flags;
  d->m_num_flags_left = num_flags_left;
  __retres = 1;
  return_label: return __retres;
}

__inline static void ( __attribute__((__always_inline__)) tdefl_record_literal)
(tdefl_compressor *d, mz_uint8 lit)
{
  mz_uint8 *tmp;
  (d->m_total_lz_bytes) ++;
  tmp = d->m_pLZ_code_buf;
  (d->m_pLZ_code_buf) ++;
  *tmp = lit;
  *(d->m_pLZ_flags) = (mz_uint8)((int)*(d->m_pLZ_flags) >> 1);
  (d->m_num_flags_left) --;
  if (d->m_num_flags_left == (mz_uint)0) {
    mz_uint8 *tmp_0;
    d->m_num_flags_left = (mz_uint)8;
    tmp_0 = d->m_pLZ_code_buf;
    (d->m_pLZ_code_buf) ++;
    d->m_pLZ_flags = tmp_0;
  }
  d->m_huff_count[0][lit] = (mz_uint16)((int)d->m_huff_count[0][lit] + 1);
  return;
}

__inline static void ( __attribute__((__always_inline__)) tdefl_record_match)
(tdefl_compressor *d, mz_uint match_len, mz_uint match_dist)
{
  mz_uint32 s0;
  mz_uint32 s1;
  int tmp;
  mz_uint32 tmp_1;
  if (match_len >= (mz_uint)TDEFL_MIN_MATCH_LEN) 
    if (match_dist >= (mz_uint)1) 
      if (match_dist <= (mz_uint)TDEFL_LZ_DICT_SIZE) tmp = 1; else tmp = 0;
    else tmp = 0;
  else tmp = 0;
  __FC_assert(tmp != 0,"miniz_tdef.c",1056,
              "(match_len >= TDEFL_MIN_MATCH_LEN) && (match_dist >= 1) && (match_dist <= TDEFL_LZ_DICT_SIZE)");
  d->m_total_lz_bytes += match_len;
  *(d->m_pLZ_code_buf + 0) = (mz_uint8)(match_len - (mz_uint)TDEFL_MIN_MATCH_LEN);
  match_dist -= (mz_uint)1;
  *(d->m_pLZ_code_buf + 1) = (mz_uint8)(match_dist & (unsigned int)0xFF);
  *(d->m_pLZ_code_buf + 2) = (mz_uint8)(match_dist >> 8);
  d->m_pLZ_code_buf += 3;
  *(d->m_pLZ_flags) = (mz_uint8)(((int)*(d->m_pLZ_flags) >> 1) | 0x80);
  (d->m_num_flags_left) --;
  if (d->m_num_flags_left == (mz_uint)0) {
    mz_uint8 *tmp_0;
    d->m_num_flags_left = (mz_uint)8;
    tmp_0 = d->m_pLZ_code_buf;
    (d->m_pLZ_code_buf) ++;
    d->m_pLZ_flags = tmp_0;
  }
  s0 = (mz_uint32)s_tdefl_small_dist_sym[match_dist & (unsigned int)511];
  s1 = (mz_uint32)s_tdefl_large_dist_sym[(match_dist >> 8) & (unsigned int)127];
  if (match_dist < (mz_uint)512) tmp_1 = s0; else tmp_1 = s1;
  d->m_huff_count[1][tmp_1] = (mz_uint16)((int)d->m_huff_count[1][tmp_1] + 1);
  if (match_len >= (mz_uint)TDEFL_MIN_MATCH_LEN) d->m_huff_count[0][s_tdefl_len_sym[
                                                 match_len - (mz_uint)TDEFL_MIN_MATCH_LEN]] = (mz_uint16)(
                                                 (int)d->m_huff_count[0][s_tdefl_len_sym[
                                                 match_len - (mz_uint)TDEFL_MIN_MATCH_LEN]] + 1);
  return;
}

static mz_bool tdefl_compress_normal(tdefl_compressor *d)
{
  mz_bool __retres;
  mz_uint8 const *pSrc = d->m_pSrc;
  size_t src_buf_left = d->m_src_buf_left;
  tdefl_flush flush = d->m_flush;
  while (1) {
    if (! src_buf_left) 
      if (flush) {
        if (! d->m_lookahead_size) break;
      }
      else break;
    {
      mz_uint len_to_move;
      mz_uint cur_match_dist;
      mz_uint cur_match_len;
      mz_uint cur_pos;
      if (d->m_lookahead_size + d->m_dict_size >= (mz_uint)(TDEFL_MIN_MATCH_LEN - 1)) {
        size_t tmp;
        mz_uint dst_pos =
          (d->m_lookahead_pos + d->m_lookahead_size) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
        mz_uint ins_pos =
          (d->m_lookahead_pos + d->m_lookahead_size) - (mz_uint)2;
        mz_uint hash =
          (mz_uint)(((int)d->m_dict[ins_pos & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT) ^ (int)d->m_dict[
                    (ins_pos + (mz_uint)1) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK]);
        if (src_buf_left < (size_t)((mz_uint)TDEFL_MAX_MATCH_LEN - d->m_lookahead_size)) 
          tmp = src_buf_left;
        else tmp = (size_t)((mz_uint)TDEFL_MAX_MATCH_LEN - d->m_lookahead_size);
        mz_uint num_bytes_to_process = (mz_uint)tmp;
        mz_uint8 const *pSrc_end = pSrc + num_bytes_to_process;
        src_buf_left -= (size_t)num_bytes_to_process;
        d->m_lookahead_size += num_bytes_to_process;
        while (pSrc != pSrc_end) {
          mz_uint8 const *tmp_0;
          tmp_0 = pSrc;
          pSrc ++;
          mz_uint8 c = *tmp_0;
          d->m_dict[dst_pos] = c;
          if (dst_pos < (mz_uint)(TDEFL_MAX_MATCH_LEN - 1)) d->m_dict[
                                                            (mz_uint)TDEFL_LZ_DICT_SIZE + dst_pos] = c;
          hash = ((hash << TDEFL_LZ_HASH_SHIFT) ^ (unsigned int)c) & (unsigned int)(
                 TDEFL_LZ_HASH_SIZE - 1);
          d->m_next[ins_pos & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash];
          d->m_hash[hash] = (mz_uint16)ins_pos;
          dst_pos = (dst_pos + (mz_uint)1) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
          ins_pos ++;
        }
      }
      else 
        while (1) {
          if (src_buf_left) {
            if (! (d->m_lookahead_size < (mz_uint)TDEFL_MAX_MATCH_LEN)) 
              break;
          }
          else break;
          {
            mz_uint8 const *tmp_1;
            tmp_1 = pSrc;
            pSrc ++;
            mz_uint8 c_0 = *tmp_1;
            mz_uint dst_pos_0 =
              (d->m_lookahead_pos + d->m_lookahead_size) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
            src_buf_left --;
            d->m_dict[dst_pos_0] = c_0;
            if (dst_pos_0 < (mz_uint)(TDEFL_MAX_MATCH_LEN - 1)) d->m_dict[
                                                                (mz_uint)TDEFL_LZ_DICT_SIZE + dst_pos_0] = c_0;
            (d->m_lookahead_size) ++;
            ;
            if (d->m_lookahead_size + d->m_dict_size >= (mz_uint)TDEFL_MIN_MATCH_LEN) {
              mz_uint ins_pos_0 =
                (d->m_lookahead_pos + (d->m_lookahead_size - (mz_uint)1)) - (mz_uint)2;
              mz_uint hash_0 =
                (mz_uint)(((((int)d->m_dict[ins_pos_0 & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK] << 
                             TDEFL_LZ_HASH_SHIFT * 2) ^ ((int)d->m_dict[
                                                         (ins_pos_0 + (mz_uint)1) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT)) ^ (int)c_0) & (
                          TDEFL_LZ_HASH_SIZE - 1));
              d->m_next[ins_pos_0 & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash_0];
              d->m_hash[hash_0] = (mz_uint16)ins_pos_0;
            }
          }
        }
      if ((mz_uint)TDEFL_LZ_DICT_SIZE - d->m_lookahead_size < d->m_dict_size) 
        d->m_dict_size = (mz_uint)TDEFL_LZ_DICT_SIZE - d->m_lookahead_size;
      else d->m_dict_size = d->m_dict_size;
      if (! flush) 
        if (d->m_lookahead_size < (mz_uint)TDEFL_MAX_MATCH_LEN) break;
      len_to_move = (mz_uint)1;
      cur_match_dist = (mz_uint)0;
      if (d->m_saved_match_len) cur_match_len = d->m_saved_match_len;
      else cur_match_len = (mz_uint)(TDEFL_MIN_MATCH_LEN - 1);
      cur_pos = d->m_lookahead_pos & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
      if (d->m_flags & (unsigned int)(TDEFL_RLE_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS)) {
        if (d->m_dict_size) 
          if (! (d->m_flags & (unsigned int)TDEFL_FORCE_ALL_RAW_BLOCKS)) {
            mz_uint8 c_1 =
              d->m_dict[(cur_pos - (mz_uint)1) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK];
            cur_match_len = (mz_uint)0;
            while (cur_match_len < d->m_lookahead_size) {
              if ((int)d->m_dict[cur_pos + cur_match_len] != (int)c_1) 
                break;
              cur_match_len ++;
            }
            if (cur_match_len < (mz_uint)TDEFL_MIN_MATCH_LEN) cur_match_len = (mz_uint)0;
            else cur_match_dist = (mz_uint)1;
          }
      }
      else tdefl_find_match(d,d->m_lookahead_pos,d->m_dict_size,
                            d->m_lookahead_size,& cur_match_dist,
                            & cur_match_len);
      if (cur_match_len == (mz_uint)TDEFL_MIN_MATCH_LEN) {
        if (cur_match_dist >= 8U * 1024U) goto _LOR; else goto _LAND;
      }
      else {
        _LAND: ;
        if (cur_pos == cur_match_dist) goto _LOR;
        else 
          if (d->m_flags & (unsigned int)TDEFL_FILTER_MATCHES) 
            if (cur_match_len <= (mz_uint)5) {
              _LOR:
              {
                cur_match_len = (mz_uint)0;
                cur_match_dist = cur_match_len;
              }
            }
      }
      if (d->m_saved_match_len) 
        if (cur_match_len > d->m_saved_match_len) {
          tdefl_record_literal(d,(mz_uint8)d->m_saved_lit);
          if (cur_match_len >= (mz_uint)128) {
            tdefl_record_match(d,cur_match_len,cur_match_dist);
            d->m_saved_match_len = (mz_uint)0;
            len_to_move = cur_match_len;
          }
          else {
            d->m_saved_lit = (mz_uint)d->m_dict[cur_pos];
            d->m_saved_match_dist = cur_match_dist;
            d->m_saved_match_len = cur_match_len;
          }
        }
        else {
          tdefl_record_match(d,d->m_saved_match_len,d->m_saved_match_dist);
          len_to_move = d->m_saved_match_len - (mz_uint)1;
          d->m_saved_match_len = (mz_uint)0;
        }
      else 
        if (! cur_match_dist) {
          unsigned long tmp_2;
          if ((unsigned long)cur_pos < sizeof(d->m_dict) - (unsigned long)1) 
            tmp_2 = (unsigned long)cur_pos;
          else tmp_2 = sizeof(d->m_dict) - (unsigned long)1;
          ;
          ;
          tdefl_record_literal(d,d->m_dict[tmp_2]);
        }
        else 
          if (d->m_greedy_parsing) goto _LOR_0;
          else 
            if (d->m_flags & (unsigned int)TDEFL_RLE_MATCHES) goto _LOR_0;
            else 
              if (cur_match_len >= (mz_uint)128) {
                _LOR_0:
                {
                  tdefl_record_match(d,cur_match_len,cur_match_dist);
                  len_to_move = cur_match_len;
                }
              }
              else {
                unsigned long tmp_3;
                if ((unsigned long)cur_pos < sizeof(d->m_dict) - (unsigned long)1) 
                  tmp_3 = (unsigned long)cur_pos;
                else tmp_3 = sizeof(d->m_dict) - (unsigned long)1;
                d->m_saved_lit = (mz_uint)d->m_dict[tmp_3];
                d->m_saved_match_dist = cur_match_dist;
                d->m_saved_match_len = cur_match_len;
              }
      d->m_lookahead_pos += len_to_move;
      __FC_assert((d->m_lookahead_size >= len_to_move) != 0,"miniz_tdef.c",
                  1207,"d->m_lookahead_size >= len_to_move");
      d->m_lookahead_size -= len_to_move;
      if (d->m_dict_size + len_to_move < (mz_uint)TDEFL_LZ_DICT_SIZE) 
        d->m_dict_size += len_to_move;
      else d->m_dict_size = (mz_uint)TDEFL_LZ_DICT_SIZE;
      if (d->m_pLZ_code_buf > & d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) 
        goto _LOR_2;
      else 
        if (d->m_total_lz_bytes > (mz_uint)(31 * 1024)) 
          if ((mz_uint)(d->m_pLZ_code_buf - d->m_lz_code_buf) * (mz_uint)115 >> 7 >= d->m_total_lz_bytes) 
            goto _LOR_2;
          else 
            if (d->m_flags & (unsigned int)TDEFL_FORCE_ALL_RAW_BLOCKS) {
              _LOR_2:
              {
                int n;
                d->m_pSrc = pSrc;
                d->m_src_buf_left = src_buf_left;
                n = tdefl_flush_block(d,0);
                if (n != 0) {
                  int tmp_4;
                  if (n < 0) tmp_4 = 0; else tmp_4 = 1;
                  __retres = tmp_4;
                  goto return_label;
                }
              }
            }
    }
  }
  d->m_pSrc = pSrc;
  d->m_src_buf_left = src_buf_left;
  __retres = 1;
  return_label: return __retres;
}

static tdefl_status tdefl_flush_output_buffer(tdefl_compressor *d)
{
  int tmp_0;
  if (d->m_pIn_buf_size) *(d->m_pIn_buf_size) = (size_t)(d->m_pSrc - (mz_uint8 const *)d->m_pIn_buf);
  if (d->m_pOut_buf_size) {
    size_t tmp;
    if (*(d->m_pOut_buf_size) - d->m_out_buf_ofs < (size_t)d->m_output_flush_remaining) 
      tmp = *(d->m_pOut_buf_size) - d->m_out_buf_ofs;
    else tmp = (size_t)d->m_output_flush_remaining;
    size_t n = tmp;
    memcpy((void *)((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs),
           (void const *)(& d->m_output_buf[d->m_output_flush_ofs]),n);
    d->m_output_flush_ofs += (mz_uint)n;
    d->m_output_flush_remaining -= (mz_uint)n;
    d->m_out_buf_ofs += n;
    *(d->m_pOut_buf_size) = d->m_out_buf_ofs;
  }
  if (d->m_finished) 
    if (! d->m_output_flush_remaining) tmp_0 = TDEFL_STATUS_DONE;
    else tmp_0 = TDEFL_STATUS_OKAY;
  else tmp_0 = TDEFL_STATUS_OKAY;
  return tmp_0;
}

tdefl_status __attribute__((__visibility__("default"))) tdefl_compress
(tdefl_compressor *d, void const *pIn_buf, size_t *pIn_buf_size,
 void *pOut_buf, size_t *pOut_buf_size, tdefl_flush flush)
{
  tdefl_status __attribute__((__visibility__("default"))) __retres;
  int tmp_0;
  tdefl_status tmp_6;
  if (! d) {
    if (pIn_buf_size) *pIn_buf_size = (size_t)0;
    if (pOut_buf_size) *pOut_buf_size = (size_t)0;
    __retres = TDEFL_STATUS_BAD_PARAM;
    goto return_label;
  }
  d->m_pIn_buf = pIn_buf;
  d->m_pIn_buf_size = pIn_buf_size;
  d->m_pOut_buf = pOut_buf;
  d->m_pOut_buf_size = pOut_buf_size;
  d->m_pSrc = (mz_uint8 const *)pIn_buf;
  if (pIn_buf_size) d->m_src_buf_left = *pIn_buf_size;
  else d->m_src_buf_left = (size_t)0;
  d->m_out_buf_ofs = (size_t)0;
  d->m_flush = flush;
  if (pOut_buf != (void *)0) tmp_0 = 1;
  else 
    if (pOut_buf_size != (size_t *)0) tmp_0 = 1; else tmp_0 = 0;
  ;
  if ((d->m_pPut_buf_func != (mz_bool (*)(void const *pBuf, int len,
                                          void *pUser))0) == tmp_0) goto _LOR;
  else 
    if (d->m_prev_return_status != TDEFL_STATUS_OKAY) goto _LOR;
    else 
      if (d->m_wants_to_finish) {
        if (flush != (unsigned int)TDEFL_FINISH) goto _LOR;
        else goto _LAND_1;
      }
      else {
        _LAND_1: ;
        if (pIn_buf_size) {
          if (*pIn_buf_size) {
            if (! pIn_buf) goto _LOR; else goto _LAND_0;
          }
          else goto _LAND_0;
        }
        else {
          _LAND_0: ;
          if (pOut_buf_size) 
            if (*pOut_buf_size) 
              if (! pOut_buf) {
                _LOR:
                {
                  tdefl_status tmp;
                  if (pIn_buf_size) *pIn_buf_size = (size_t)0;
                  if (pOut_buf_size) *pOut_buf_size = (size_t)0;
                  tmp = TDEFL_STATUS_BAD_PARAM;
                  d->m_prev_return_status = tmp;
                  __retres = (tdefl_status __attribute__((__visibility__("default"))))tmp;
                  goto return_label;
                }
              }
        }
      }
  d->m_wants_to_finish |= (unsigned int)(flush == (unsigned int)TDEFL_FINISH);
  if (d->m_output_flush_remaining) goto _LOR_0;
  else 
    if (d->m_finished) {
      tdefl_status tmp_1;
      _LOR_0: tmp_1 = tdefl_flush_output_buffer(d);
      d->m_prev_return_status = tmp_1;
      __retres = (tdefl_status __attribute__((__visibility__("default"))))tmp_1;
      goto return_label;
    }
  if ((d->m_flags & (unsigned int)TDEFL_MAX_PROBES_MASK) == (unsigned int)1) {
    if ((d->m_flags & (unsigned int)TDEFL_GREEDY_PARSING_FLAG) != (unsigned int)0) {
      if ((d->m_flags & (unsigned int)((TDEFL_FILTER_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS) | TDEFL_RLE_MATCHES)) == (unsigned int)0) {
        mz_bool tmp_2;
        tmp_2 = tdefl_compress_fast(d);
        if (! tmp_2) {
          __retres = (tdefl_status __attribute__((__visibility__("default"))))d->m_prev_return_status;
          goto return_label;
        }
      }
      else goto _LAND_3;
    }
    else goto _LAND_3;
  }
  else {
    _LAND_3:
    {
      mz_bool tmp_3;
      tmp_3 = tdefl_compress_normal(d);
      if (! tmp_3) {
        __retres = (tdefl_status __attribute__((__visibility__("default"))))d->m_prev_return_status;
        goto return_label;
      }
    }
  }
  if (d->m_flags & (unsigned int)(TDEFL_WRITE_ZLIB_HEADER | TDEFL_COMPUTE_ADLER32)) 
    if (pIn_buf) {
      mz_ulong __attribute__((__visibility__("default"))) tmp_4;
      tmp_4 = mz_adler32((mz_ulong)d->m_adler32,(mz_uint8 const *)pIn_buf,
                         (size_t)(d->m_pSrc - (mz_uint8 const *)pIn_buf));
      d->m_adler32 = (mz_uint32)tmp_4;
    }
  if (flush) 
    if (! d->m_lookahead_size) 
      if (! d->m_src_buf_left) 
        if (! d->m_output_flush_remaining) {
          int tmp_5;
          tmp_5 = tdefl_flush_block(d,(int)flush);
          if (tmp_5 < 0) {
            __retres = (tdefl_status __attribute__((__visibility__("default"))))d->m_prev_return_status;
            goto return_label;
          }
          d->m_finished = (mz_uint)(flush == (unsigned int)TDEFL_FINISH);
          if (flush == (unsigned int)TDEFL_FULL_FLUSH) {
            memset((void *)(& d->m_hash),0,sizeof(d->m_hash));
            memset((void *)(& d->m_next),0,sizeof(d->m_next));
            d->m_dict_size = (mz_uint)0;
          }
        }
  tmp_6 = tdefl_flush_output_buffer(d);
  d->m_prev_return_status = tmp_6;
  __retres = (tdefl_status __attribute__((__visibility__("default"))))tmp_6;
  return_label: return __retres;
}

tdefl_status __attribute__((__visibility__("default"))) tdefl_compress_buffer
(tdefl_compressor *d, void const *pIn_buf, size_t in_buf_size,
 tdefl_flush flush)
{
  tdefl_status __attribute__((__visibility__("default"))) tmp;
  __FC_assert(d->m_pPut_buf_func != (mz_bool (*)(void const *pBuf, int len,
                                                 void *pUser))0,
              "miniz_tdef.c",1318,"d->m_pPut_buf_func");
  tmp = tdefl_compress(d,pIn_buf,& in_buf_size,(void *)0,(size_t *)0,flush);
  return tmp;
}

tdefl_status __attribute__((__visibility__("default"))) tdefl_init(tdefl_compressor *d,
                                                                   mz_bool (*pPut_buf_func)
                                                                   (void const *pBuf,
                                                                    int len,
                                                                    void *pUser),
                                                                   void *pPut_buf_user,
                                                                   int flags)
{
  tdefl_status __attribute__((__visibility__("default"))) __retres;
  mz_uint tmp_3;
  mz_uint tmp_2;
  mz_uint tmp_1;
  mz_uint tmp_0;
  mz_uint tmp;
  mz_uint tmp_8;
  mz_uint tmp_7;
  mz_uint tmp_6;
  mz_uint tmp_5;
  mz_uint tmp_4;
  mz_uint tmp_10;
  mz_uint tmp_9;
  d->m_pPut_buf_func = pPut_buf_func;
  d->m_pPut_buf_user = pPut_buf_user;
  d->m_flags = (mz_uint)flags;
  d->m_max_probes[0] = (mz_uint)(1 + ((flags & 0xFFF) + 2) / 3);
  d->m_greedy_parsing = (flags & TDEFL_GREEDY_PARSING_FLAG) != 0;
  d->m_max_probes[1] = (mz_uint)(1 + (((flags & 0xFFF) >> 2) + 2) / 3);
  if (! (flags & TDEFL_NONDETERMINISTIC_PARSING_FLAG)) memset((void *)(& d->m_hash),
                                                              0,
                                                              sizeof(d->m_hash));
  tmp_3 = (mz_uint)0;
  d->m_bits_in = tmp_3;
  tmp_2 = tmp_3;
  d->m_lz_code_buf_dict_pos = tmp_2;
  tmp_1 = tmp_2;
  d->m_total_lz_bytes = tmp_1;
  tmp_0 = tmp_1;
  d->m_dict_size = tmp_0;
  tmp = tmp_0;
  d->m_lookahead_size = tmp;
  d->m_lookahead_pos = tmp;
  tmp_8 = (mz_uint)0;
  d->m_wants_to_finish = tmp_8;
  tmp_7 = tmp_8;
  d->m_bit_buffer = tmp_7;
  tmp_6 = tmp_7;
  d->m_block_index = tmp_6;
  tmp_5 = tmp_6;
  d->m_finished = tmp_5;
  tmp_4 = tmp_5;
  d->m_output_flush_remaining = tmp_4;
  d->m_output_flush_ofs = tmp_4;
  d->m_pLZ_code_buf = & d->m_lz_code_buf[1];
  d->m_pLZ_flags = d->m_lz_code_buf;
  *(d->m_pLZ_flags) = (mz_uint8)0;
  d->m_num_flags_left = (mz_uint)8;
  d->m_pOutput_buf = d->m_output_buf;
  d->m_pOutput_buf_end = d->m_output_buf;
  d->m_prev_return_status = TDEFL_STATUS_OKAY;
  tmp_10 = (mz_uint)0;
  d->m_saved_lit = tmp_10;
  tmp_9 = tmp_10;
  d->m_saved_match_len = tmp_9;
  d->m_saved_match_dist = tmp_9;
  d->m_adler32 = (mz_uint)1;
  d->m_pIn_buf = (void const *)0;
  d->m_pOut_buf = (void *)0;
  d->m_pIn_buf_size = (size_t *)0;
  d->m_pOut_buf_size = (size_t *)0;
  d->m_flush = TDEFL_NO_FLUSH;
  d->m_pSrc = (mz_uint8 const *)0;
  d->m_src_buf_left = (size_t)0;
  d->m_out_buf_ofs = (size_t)0;
  if (! (flags & TDEFL_NONDETERMINISTIC_PARSING_FLAG)) memset((void *)(& d->m_dict),
                                                              0,
                                                              sizeof(d->m_dict));
  memset((void *)(& d->m_huff_count[0][0]),0,
         sizeof(d->m_huff_count[0][0]) * (unsigned long)TDEFL_MAX_HUFF_SYMBOLS_0);
  memset((void *)(& d->m_huff_count[1][0]),0,
         sizeof(d->m_huff_count[1][0]) * (unsigned long)TDEFL_MAX_HUFF_SYMBOLS_1);
  __retres = TDEFL_STATUS_OKAY;
  return __retres;
}

tdefl_status __attribute__((__visibility__("default"))) tdefl_get_prev_return_status
(tdefl_compressor *d)
{
  tdefl_status __attribute__((__visibility__("default"))) __retres;
  __retres = (tdefl_status __attribute__((__visibility__("default"))))d->m_prev_return_status;
  return __retres;
}

mz_uint32 __attribute__((__visibility__("default"))) tdefl_get_adler32
(tdefl_compressor *d)
{
  mz_uint32 __attribute__((__visibility__("default"))) __retres;
  __retres = (mz_uint32 __attribute__((__visibility__("default"))))d->m_adler32;
  return __retres;
}

mz_bool __attribute__((__visibility__("default"))) tdefl_compress_mem_to_output
(void const *pBuf, size_t buf_len,
 mz_bool (*pPut_buf_func)(void const *pBuf, int len, void *pUser),
 void *pPut_buf_user, int flags)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  tdefl_compressor *pComp;
  mz_bool succeeded;
  tdefl_status __attribute__((__visibility__("default"))) tmp_0;
  int tmp_2;
  if (buf_len) {
    if (! pBuf) {
      __retres = (mz_bool __attribute__((__visibility__("default"))))0;
      goto return_label;
    }
    else goto _LAND;
  }
  else 
    _LAND:
    if (! pPut_buf_func) {
      __retres = (mz_bool __attribute__((__visibility__("default"))))0;
      goto return_label;
    }
  pComp = (tdefl_compressor *)malloc(sizeof(tdefl_compressor));
  if (! pComp) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  tmp_0 = tdefl_init(pComp,pPut_buf_func,pPut_buf_user,flags);
  succeeded = tmp_0 == (int __attribute__((__visibility__("default"))))TDEFL_STATUS_OKAY;
  if (succeeded) {
    tdefl_status __attribute__((__visibility__("default"))) tmp_1;
    tmp_1 = tdefl_compress_buffer(pComp,pBuf,buf_len,TDEFL_FINISH);
    if (tmp_1 == (int __attribute__((__visibility__("default"))))TDEFL_STATUS_DONE) 
      tmp_2 = 1;
    else tmp_2 = 0;
  }
  else tmp_2 = 0;
  succeeded = tmp_2;
  free((void *)pComp);
  __retres = (mz_bool __attribute__((__visibility__("default"))))succeeded;
  return_label: return __retres;
}

static mz_bool tdefl_output_buffer_putter(void const *pBuf, int len,
                                          void *pUser)
{
  mz_bool __retres;
  tdefl_output_buffer *p = (tdefl_output_buffer *)pUser;
  size_t new_size = p->m_size + (size_t)len;
  if (new_size > p->m_capacity) {
    mz_uint8 *pNew_buf;
    size_t new_capacity = p->m_capacity;
    if (! p->m_expandable) {
      __retres = 0;
      goto return_label;
    }
    while (1) {
      if ((size_t)128U > new_capacity << 1U) new_capacity = (size_t)128U;
      else new_capacity <<= 1U;
      if (! (new_size > new_capacity)) break;
    }
    pNew_buf = (mz_uint8 *)realloc((void *)p->m_pBuf,new_capacity);
    if (! pNew_buf) {
      __retres = 0;
      goto return_label;
    }
    p->m_pBuf = pNew_buf;
    p->m_capacity = new_capacity;
  }
  memcpy((void *)(p->m_pBuf + p->m_size),pBuf,(size_t)len);
  p->m_size = new_size;
  __retres = 1;
  return_label: return __retres;
}

void __attribute__((__visibility__("default"))) *tdefl_compress_mem_to_heap
(void const *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)
{
  void __attribute__((__visibility__("default"))) *__retres;
  tdefl_output_buffer out_buf;
  mz_bool __attribute__((__visibility__("default"))) tmp;
  memset((void *)(& out_buf),0,sizeof(out_buf));
  if (! pOut_len) {
    __retres = (void __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  else *pOut_len = (size_t)0;
  out_buf.m_expandable = 1;
  tmp = tdefl_compress_mem_to_output(pSrc_buf,src_buf_len,
                                     & tdefl_output_buffer_putter,
                                     (void *)(& out_buf),flags);
  if (! tmp) {
    __retres = (void __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  *pOut_len = out_buf.m_size;
  __retres = (void __attribute__((__visibility__("default"))) *)out_buf.m_pBuf;
  return_label: return __retres;
}

size_t __attribute__((__visibility__("default"))) tdefl_compress_mem_to_mem
(void *pOut_buf, size_t out_buf_len, void const *pSrc_buf,
 size_t src_buf_len, int flags)
{
  size_t __attribute__((__visibility__("default"))) __retres;
  tdefl_output_buffer out_buf;
  mz_bool __attribute__((__visibility__("default"))) tmp;
  memset((void *)(& out_buf),0,sizeof(out_buf));
  if (! pOut_buf) {
    __retres = (size_t __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  out_buf.m_pBuf = (mz_uint8 *)pOut_buf;
  out_buf.m_capacity = out_buf_len;
  tmp = tdefl_compress_mem_to_output(pSrc_buf,src_buf_len,
                                     & tdefl_output_buffer_putter,
                                     (void *)(& out_buf),flags);
  if (! tmp) {
    __retres = (size_t __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  __retres = (size_t __attribute__((__visibility__("default"))))out_buf.m_size;
  return_label: return __retres;
}

static mz_uint const s_tdefl_num_probes[11] =
  {(mz_uint)0,
   (mz_uint)1,
   (mz_uint)6,
   (mz_uint)32,
   (mz_uint)16,
   (mz_uint)32,
   (mz_uint)128,
   (mz_uint)256,
   (mz_uint)512,
   (mz_uint)768,
   (mz_uint)1500};
mz_uint __attribute__((__visibility__("default"))) tdefl_create_comp_flags_from_zip_params
(int level, int window_bits, int strategy)
{
  mz_uint __attribute__((__visibility__("default"))) __retres;
  int tmp_0;
  int tmp_1;
  if (level >= 0) {
    int tmp;
    if (10 < level) tmp = 10; else tmp = level;
    tmp_0 = tmp;
  }
  else tmp_0 = MZ_DEFAULT_LEVEL;
  if (level <= 3) tmp_1 = TDEFL_GREEDY_PARSING_FLAG; else tmp_1 = 0;
  mz_uint comp_flags = s_tdefl_num_probes[tmp_0] | (unsigned int)tmp_1;
  if (window_bits > 0) comp_flags |= (unsigned int)TDEFL_WRITE_ZLIB_HEADER;
  if (! level) comp_flags |= (unsigned int)TDEFL_FORCE_ALL_RAW_BLOCKS;
  else 
    if (strategy == MZ_FILTERED) comp_flags |= (unsigned int)TDEFL_FILTER_MATCHES;
    else 
      if (strategy == MZ_HUFFMAN_ONLY) comp_flags &= (unsigned int)(~ TDEFL_MAX_PROBES_MASK);
      else 
        if (strategy == MZ_FIXED) comp_flags |= (unsigned int)TDEFL_FORCE_ALL_STATIC_BLOCKS;
        else 
          if (strategy == MZ_RLE) comp_flags |= (unsigned int)TDEFL_RLE_MATCHES;
  __retres = (mz_uint __attribute__((__visibility__("default"))))comp_flags;
  return __retres;
}

static mz_uint const tdefl_write_image_to_png_file_in_memory_ex_s_tdefl_png_num_probes[11] =
  {(mz_uint)0,
   (mz_uint)1,
   (mz_uint)6,
   (mz_uint)32,
   (mz_uint)16,
   (mz_uint)32,
   (mz_uint)128,
   (mz_uint)256,
   (mz_uint)512,
   (mz_uint)768,
   (mz_uint)1500};
static mz_uint8 const tdefl_write_image_to_png_file_in_memory_ex_chans[5] =
  {(mz_uint8)0x00,
   (mz_uint8)0x00,
   (mz_uint8)0x04,
   (mz_uint8)0x02,
   (mz_uint8)0x06};
void __attribute__((__visibility__("default"))) *tdefl_write_image_to_png_file_in_memory_ex
(void const *pImage, int w, int h, int num_chans, size_t *pLen_out,
 mz_uint level, mz_bool flip)
{
  void __attribute__((__visibility__("default"))) *__retres;
  tdefl_output_buffer out_buf;
  int i;
  int y;
  int z;
  mz_uint32 c;
  int tmp_0;
  mz_uint tmp_2;
  tdefl_status __attribute__((__visibility__("default"))) tmp_4;
  mz_bool tmp_6;
  mz_ulong __attribute__((__visibility__("default"))) tmp_7;
  tdefl_compressor *pComp = malloc(sizeof(tdefl_compressor));
  int bpl = w * num_chans;
  *pLen_out = (size_t)0;
  if (! pComp) {
    __retres = (void __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  memset((void *)(& out_buf),0,sizeof(out_buf));
  out_buf.m_expandable = 1;
  if (64 > (1 + bpl) * h) tmp_0 = 64; else tmp_0 = (1 + bpl) * h;
  out_buf.m_capacity = (size_t)(57 + tmp_0);
  out_buf.m_pBuf = (mz_uint8 *)malloc(out_buf.m_capacity);
  if ((mz_uint8 *)0 == out_buf.m_pBuf) {
    free((void *)pComp);
    __retres = (void __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  z = 41;
  while (z) {
    tdefl_output_buffer_putter((void const *)(& z),1,(void *)(& out_buf));
    z --;
  }
  if ((mz_uint)10 < level) tmp_2 = (mz_uint)10; else tmp_2 = level;
  ;
  ;
  tdefl_init(pComp,& tdefl_output_buffer_putter,(void *)(& out_buf),
             (int)(tdefl_write_image_to_png_file_in_memory_ex_s_tdefl_png_num_probes[tmp_2] | (unsigned int)TDEFL_WRITE_ZLIB_HEADER));
  y = 0;
  while (y < h) {
    {
      int tmp_3;
      tdefl_compress_buffer(pComp,(void const *)(& z),(size_t)1,
                            TDEFL_NO_FLUSH);
      ;
      if (flip) tmp_3 = (h - 1) - y; else tmp_3 = y;
      ;
      ;
      tdefl_compress_buffer(pComp,
                            (void const *)((mz_uint8 *)pImage + tmp_3 * bpl),
                            (size_t)bpl,TDEFL_NO_FLUSH);
    }
    y ++;
  }
  tmp_4 = tdefl_compress_buffer(pComp,(void const *)0,(size_t)0,TDEFL_FINISH);
  if (tmp_4 != (int __attribute__((__visibility__("default"))))TDEFL_STATUS_DONE) {
    free((void *)pComp);
    free((void *)out_buf.m_pBuf);
    __retres = (void __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  *pLen_out = out_buf.m_size - (size_t)41;
  {
    mz_ulong __attribute__((__visibility__("default"))) tmp_5;
    mz_uint8 pnghdr[41] =
      {(mz_uint8)0x89,
       (mz_uint8)0x50,
       (mz_uint8)0x4e,
       (mz_uint8)0x47,
       (mz_uint8)0x0d,
       (mz_uint8)0x0a,
       (mz_uint8)0x1a,
       (mz_uint8)0x0a,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x0d,
       (mz_uint8)0x49,
       (mz_uint8)0x48,
       (mz_uint8)0x44,
       (mz_uint8)0x52,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x08,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x49,
       (mz_uint8)0x44,
       (mz_uint8)0x41,
       (mz_uint8)0x54};
    pnghdr[18] = (mz_uint8)(w >> 8);
    pnghdr[19] = (mz_uint8)w;
    pnghdr[22] = (mz_uint8)(h >> 8);
    pnghdr[23] = (mz_uint8)h;
    pnghdr[25] = tdefl_write_image_to_png_file_in_memory_ex_chans[num_chans];
    pnghdr[33] = (mz_uint8)(*pLen_out >> 24);
    pnghdr[34] = (mz_uint8)(*pLen_out >> 16);
    pnghdr[35] = (mz_uint8)(*pLen_out >> 8);
    pnghdr[36] = (mz_uint8)*pLen_out;
    tmp_5 = mz_crc32((mz_ulong)0,(unsigned char const *)(& pnghdr[12]),
                     (size_t)17);
    c = (mz_uint32)tmp_5;
    i = 0;
    while (i < 4) {
      *(& pnghdr[29] + i) = (mz_uint8)(c >> 24);
      i ++;
      c <<= 8;
    }
    memcpy((void *)out_buf.m_pBuf,(void const *)(pnghdr),(size_t)41);
  }
  tmp_6 = tdefl_output_buffer_putter((void const *)"\000\000\000\000\000\000\000\000IEND\256B`\202",
                                     16,(void *)(& out_buf));
  if (! tmp_6) {
    *pLen_out = (size_t)0;
    free((void *)pComp);
    free((void *)out_buf.m_pBuf);
    __retres = (void __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  tmp_7 = mz_crc32((mz_ulong)0,
                   (unsigned char const *)((out_buf.m_pBuf + 41) - 4),
                   *pLen_out + (size_t)4);
  c = (mz_uint32)tmp_7;
  i = 0;
  while (i < 4) {
    *(((out_buf.m_pBuf + out_buf.m_size) - 16) + i) = (mz_uint8)(c >> 24);
    i ++;
    c <<= 8;
  }
  *pLen_out += (size_t)57;
  free((void *)pComp);
  __retres = (void __attribute__((__visibility__("default"))) *)out_buf.m_pBuf;
  return_label: return __retres;
}

void __attribute__((__visibility__("default"))) *tdefl_write_image_to_png_file_in_memory
(void const *pImage, int w, int h, int num_chans, size_t *pLen_out)
{
  void __attribute__((__visibility__("default"))) *tmp;
  tmp = tdefl_write_image_to_png_file_in_memory_ex(pImage,w,h,num_chans,
                                                   pLen_out,(mz_uint)6,0);
  return tmp;
}

tdefl_compressor __attribute__((__visibility__("default"))) *tdefl_compressor_alloc
(void)
{
  tdefl_compressor __attribute__((__visibility__("default"))) *__retres;
  tdefl_compressor *tmp;
  tmp = (tdefl_compressor *)malloc(sizeof(tdefl_compressor));
  __retres = (tdefl_compressor __attribute__((__visibility__("default"))) *)tmp;
  return __retres;
}

void __attribute__((__visibility__("default"))) tdefl_compressor_free
(tdefl_compressor *pComp)
{
  free((void *)pComp);
  return;
}


