/* Generated by Frama-C */
#include "__fc_builtin.h"
#include "assert.h"
#include "errno.h"
#include "signal.h"
#include "stdarg.h"
#include "stdint.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "strings.h"
#include "sys/select.h"
#include "sys/stat.h"
#include "sys/time.h"
#include "time.h"
#include "utime.h"
typedef unsigned long mz_ulong;
enum __anonenum_1 {
    MZ_DEFAULT_STRATEGY = 0,
    MZ_FILTERED = 1,
    MZ_HUFFMAN_ONLY = 2,
    MZ_RLE = 3,
    MZ_FIXED = 4
};
enum __anonenum_2 {
    MZ_NO_COMPRESSION = 0,
    MZ_BEST_SPEED = 1,
    MZ_BEST_COMPRESSION = 9,
    MZ_UBER_COMPRESSION = 10,
    MZ_DEFAULT_LEVEL = 6,
    MZ_DEFAULT_COMPRESSION = -1
};
enum __anonenum_3 {
    MZ_NO_FLUSH = 0,
    MZ_PARTIAL_FLUSH = 1,
    MZ_SYNC_FLUSH = 2,
    MZ_FULL_FLUSH = 3,
    MZ_FINISH = 4,
    MZ_BLOCK = 5
};
enum __anonenum_4 {
    MZ_OK = 0,
    MZ_STREAM_END = 1,
    MZ_NEED_DICT = 2,
    MZ_ERRNO = -1,
    MZ_STREAM_ERROR = -2,
    MZ_DATA_ERROR = -3,
    MZ_MEM_ERROR = -4,
    MZ_BUF_ERROR = -5,
    MZ_VERSION_ERROR = -6,
    MZ_PARAM_ERROR = -10000
};
struct mz_internal_state;
struct mz_stream_s {
   unsigned char const *next_in ;
   unsigned int avail_in ;
   mz_ulong total_in ;
   unsigned char *next_out ;
   unsigned int avail_out ;
   mz_ulong total_out ;
   char *msg ;
   struct mz_internal_state *state ;
   void *(*zalloc)(void *opaque, size_t items, size_t size) ;
   void (*zfree)(void *opaque, void *address) ;
   void *opaque ;
   int data_type ;
   mz_ulong adler ;
   mz_ulong reserved ;
};
typedef struct mz_stream_s mz_stream;
typedef mz_stream *mz_streamp;
typedef unsigned char mz_uint8;
typedef short mz_int16;
typedef unsigned short mz_uint16;
typedef unsigned int mz_uint32;
typedef unsigned int mz_uint;
typedef int64_t mz_int64;
typedef uint64_t mz_uint64;
typedef int mz_bool;
enum __anonenum_5 {
    TDEFL_HUFFMAN_ONLY = 0,
    TDEFL_DEFAULT_MAX_PROBES = 128,
    TDEFL_MAX_PROBES_MASK = 0xFFF
};
enum __anonenum_6 {
    TDEFL_WRITE_ZLIB_HEADER = 0x01000,
    TDEFL_COMPUTE_ADLER32 = 0x02000,
    TDEFL_GREEDY_PARSING_FLAG = 0x04000,
    TDEFL_NONDETERMINISTIC_PARSING_FLAG = 0x08000,
    TDEFL_RLE_MATCHES = 0x10000,
    TDEFL_FILTER_MATCHES = 0x20000,
    TDEFL_FORCE_ALL_STATIC_BLOCKS = 0x40000,
    TDEFL_FORCE_ALL_RAW_BLOCKS = 0x80000
};
enum __anonenum_7 {
    TDEFL_MAX_HUFF_TABLES = 3,
    TDEFL_MAX_HUFF_SYMBOLS_0 = 288,
    TDEFL_MAX_HUFF_SYMBOLS_1 = 32,
    TDEFL_MAX_HUFF_SYMBOLS_2 = 19,
    TDEFL_LZ_DICT_SIZE = 32768,
    TDEFL_LZ_DICT_SIZE_MASK = TDEFL_LZ_DICT_SIZE - 1,
    TDEFL_MIN_MATCH_LEN = 3,
    TDEFL_MAX_MATCH_LEN = 258
};
enum __anonenum_8 {
    TDEFL_LZ_CODE_BUF_SIZE = 64 * 1024,
    TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13) / 10,
    TDEFL_MAX_HUFF_SYMBOLS = 288,
    TDEFL_LZ_HASH_BITS = 15,
    TDEFL_LEVEL1_HASH_SIZE_MASK = 4095,
    TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3,
    TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS
};
enum __anonenum_tdefl_status_9 {
    TDEFL_STATUS_BAD_PARAM = -2,
    TDEFL_STATUS_PUT_BUF_FAILED = -1,
    TDEFL_STATUS_OKAY = 0,
    TDEFL_STATUS_DONE = 1
};
typedef enum __anonenum_tdefl_status_9 tdefl_status;
enum __anonenum_tdefl_flush_10 {
    TDEFL_NO_FLUSH = 0,
    TDEFL_SYNC_FLUSH = 2,
    TDEFL_FULL_FLUSH = 3,
    TDEFL_FINISH = 4
};
typedef enum __anonenum_tdefl_flush_10 tdefl_flush;
struct __anonstruct_tdefl_compressor_11 {
   mz_bool (*m_pPut_buf_func)(void const *pBuf, int len, void *pUser) ;
   void *m_pPut_buf_user ;
   mz_uint m_flags ;
   mz_uint m_max_probes[2] ;
   int m_greedy_parsing ;
   mz_uint m_adler32 ;
   mz_uint m_lookahead_pos ;
   mz_uint m_lookahead_size ;
   mz_uint m_dict_size ;
   mz_uint8 *m_pLZ_code_buf ;
   mz_uint8 *m_pLZ_flags ;
   mz_uint8 *m_pOutput_buf ;
   mz_uint8 *m_pOutput_buf_end ;
   mz_uint m_num_flags_left ;
   mz_uint m_total_lz_bytes ;
   mz_uint m_lz_code_buf_dict_pos ;
   mz_uint m_bits_in ;
   mz_uint m_bit_buffer ;
   mz_uint m_saved_match_dist ;
   mz_uint m_saved_match_len ;
   mz_uint m_saved_lit ;
   mz_uint m_output_flush_ofs ;
   mz_uint m_output_flush_remaining ;
   mz_uint m_finished ;
   mz_uint m_block_index ;
   mz_uint m_wants_to_finish ;
   tdefl_status m_prev_return_status ;
   void const *m_pIn_buf ;
   void *m_pOut_buf ;
   size_t *m_pIn_buf_size ;
   size_t *m_pOut_buf_size ;
   tdefl_flush m_flush ;
   mz_uint8 const *m_pSrc ;
   size_t m_src_buf_left ;
   size_t m_out_buf_ofs ;
   mz_uint8 m_dict[(TDEFL_LZ_DICT_SIZE + TDEFL_MAX_MATCH_LEN) - 1] ;
   mz_uint16 m_huff_count[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS] ;
   mz_uint16 m_huff_codes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS] ;
   mz_uint8 m_huff_code_sizes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS] ;
   mz_uint8 m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE] ;
   mz_uint16 m_next[TDEFL_LZ_DICT_SIZE] ;
   mz_uint16 m_hash[TDEFL_LZ_HASH_SIZE] ;
   mz_uint8 m_output_buf[TDEFL_OUT_BUF_SIZE] ;
};
typedef struct __anonstruct_tdefl_compressor_11 tdefl_compressor;
enum __anonenum_12 {
    TINFL_FLAG_PARSE_ZLIB_HEADER = 1,
    TINFL_FLAG_HAS_MORE_INPUT = 2,
    TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF = 4,
    TINFL_FLAG_COMPUTE_ADLER32 = 8
};
struct tinfl_decompressor_tag;
typedef struct tinfl_decompressor_tag tinfl_decompressor;
enum __anonenum_tinfl_status_13 {
    TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS = -4,
    TINFL_STATUS_BAD_PARAM = -3,
    TINFL_STATUS_ADLER32_MISMATCH = -2,
    TINFL_STATUS_FAILED = -1,
    TINFL_STATUS_DONE = 0,
    TINFL_STATUS_NEEDS_MORE_INPUT = 1,
    TINFL_STATUS_HAS_MORE_OUTPUT = 2
};
typedef enum __anonenum_tinfl_status_13 tinfl_status;
enum __anonenum_14 {
    TINFL_MAX_HUFF_TABLES = 3,
    TINFL_MAX_HUFF_SYMBOLS_0 = 288,
    TINFL_MAX_HUFF_SYMBOLS_1 = 32,
    TINFL_MAX_HUFF_SYMBOLS_2 = 19,
    TINFL_FAST_LOOKUP_BITS = 10,
    TINFL_FAST_LOOKUP_SIZE = 1 << TINFL_FAST_LOOKUP_BITS
};
struct __anonstruct_tinfl_huff_table_15 {
   mz_uint8 m_code_size[TINFL_MAX_HUFF_SYMBOLS_0] ;
   mz_int16 m_look_up[TINFL_FAST_LOOKUP_SIZE] ;
   mz_int16 m_tree[TINFL_MAX_HUFF_SYMBOLS_0 * 2] ;
};
typedef struct __anonstruct_tinfl_huff_table_15 tinfl_huff_table;
typedef mz_uint64 tinfl_bit_buf_t;
struct tinfl_decompressor_tag {
   mz_uint32 m_state ;
   mz_uint32 m_num_bits ;
   mz_uint32 m_zhdr0 ;
   mz_uint32 m_zhdr1 ;
   mz_uint32 m_z_adler32 ;
   mz_uint32 m_final ;
   mz_uint32 m_type ;
   mz_uint32 m_check_adler32 ;
   mz_uint32 m_dist ;
   mz_uint32 m_counter ;
   mz_uint32 m_num_extra ;
   mz_uint32 m_table_sizes[TINFL_MAX_HUFF_TABLES] ;
   tinfl_bit_buf_t m_bit_buf ;
   size_t m_dist_from_out_buf_start ;
   tinfl_huff_table m_tables[TINFL_MAX_HUFF_TABLES] ;
   mz_uint8 m_raw_header[4] ;
   mz_uint8 m_len_codes[(TINFL_MAX_HUFF_SYMBOLS_0 + TINFL_MAX_HUFF_SYMBOLS_1) + 137] ;
};
enum __anonenum_16 {
    MZ_ZIP_MAX_IO_BUF_SIZE = 64 * 1024,
    MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE = 512,
    MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE = 512
};
struct __anonstruct_mz_zip_archive_file_stat_17 {
   mz_uint32 m_file_index ;
   mz_uint64 m_central_dir_ofs ;
   mz_uint16 m_version_made_by ;
   mz_uint16 m_version_needed ;
   mz_uint16 m_bit_flag ;
   mz_uint16 m_method ;
   time_t m_time ;
   mz_uint32 m_crc32 ;
   mz_uint64 m_comp_size ;
   mz_uint64 m_uncomp_size ;
   mz_uint16 m_internal_attr ;
   mz_uint32 m_external_attr ;
   mz_uint64 m_local_header_ofs ;
   mz_uint32 m_comment_size ;
   mz_bool m_is_directory ;
   mz_bool m_is_encrypted ;
   mz_bool m_is_supported ;
   char m_filename[MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE] ;
   char m_comment[MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE] ;
};
typedef struct __anonstruct_mz_zip_archive_file_stat_17 mz_zip_archive_file_stat;
typedef struct mz_zip_internal_state_tag mz_zip_internal_state;
enum __anonenum_mz_zip_mode_18 {
    MZ_ZIP_MODE_INVALID = 0,
    MZ_ZIP_MODE_READING = 1,
    MZ_ZIP_MODE_WRITING = 2,
    MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED = 3
};
typedef enum __anonenum_mz_zip_mode_18 mz_zip_mode;
enum __anonenum_mz_zip_flags_19 {
    MZ_ZIP_FLAG_CASE_SENSITIVE = 0x0100,
    MZ_ZIP_FLAG_IGNORE_PATH = 0x0200,
    MZ_ZIP_FLAG_COMPRESSED_DATA = 0x0400,
    MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY = 0x0800,
    MZ_ZIP_FLAG_VALIDATE_LOCATE_FILE_FLAG = 0x1000,
    MZ_ZIP_FLAG_VALIDATE_HEADERS_ONLY = 0x2000,
    MZ_ZIP_FLAG_WRITE_ZIP64 = 0x4000,
    MZ_ZIP_FLAG_WRITE_ALLOW_READING = 0x8000,
    MZ_ZIP_FLAG_ASCII_FILENAME = 0x10000
};
enum __anonenum_mz_zip_type_20 {
    MZ_ZIP_TYPE_INVALID = 0,
    MZ_ZIP_TYPE_USER = 1,
    MZ_ZIP_TYPE_MEMORY = 2,
    MZ_ZIP_TYPE_HEAP = 3,
    MZ_ZIP_TYPE_FILE = 4,
    MZ_ZIP_TYPE_CFILE = 5,
    MZ_ZIP_TOTAL_TYPES = 6
};
typedef enum __anonenum_mz_zip_type_20 mz_zip_type;
enum __anonenum_mz_zip_error_21 {
    MZ_ZIP_NO_ERROR = 0,
    MZ_ZIP_UNDEFINED_ERROR = 1,
    MZ_ZIP_TOO_MANY_FILES = 2,
    MZ_ZIP_FILE_TOO_LARGE = 3,
    MZ_ZIP_UNSUPPORTED_METHOD = 4,
    MZ_ZIP_UNSUPPORTED_ENCRYPTION = 5,
    MZ_ZIP_UNSUPPORTED_FEATURE = 6,
    MZ_ZIP_FAILED_FINDING_CENTRAL_DIR = 7,
    MZ_ZIP_NOT_AN_ARCHIVE = 8,
    MZ_ZIP_INVALID_HEADER_OR_CORRUPTED = 9,
    MZ_ZIP_UNSUPPORTED_MULTIDISK = 10,
    MZ_ZIP_DECOMPRESSION_FAILED = 11,
    MZ_ZIP_COMPRESSION_FAILED = 12,
    MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE = 13,
    MZ_ZIP_CRC_CHECK_FAILED = 14,
    MZ_ZIP_UNSUPPORTED_CDIR_SIZE = 15,
    MZ_ZIP_ALLOC_FAILED = 16,
    MZ_ZIP_FILE_OPEN_FAILED = 17,
    MZ_ZIP_FILE_CREATE_FAILED = 18,
    MZ_ZIP_FILE_WRITE_FAILED = 19,
    MZ_ZIP_FILE_READ_FAILED = 20,
    MZ_ZIP_FILE_CLOSE_FAILED = 21,
    MZ_ZIP_FILE_SEEK_FAILED = 22,
    MZ_ZIP_FILE_STAT_FAILED = 23,
    MZ_ZIP_INVALID_PARAMETER = 24,
    MZ_ZIP_INVALID_FILENAME = 25,
    MZ_ZIP_BUF_TOO_SMALL = 26,
    MZ_ZIP_INTERNAL_ERROR = 27,
    MZ_ZIP_FILE_NOT_FOUND = 28,
    MZ_ZIP_ARCHIVE_TOO_LARGE = 29,
    MZ_ZIP_VALIDATION_FAILED = 30,
    MZ_ZIP_WRITE_CALLBACK_FAILED = 31,
    MZ_ZIP_TOTAL_ERRORS = 32
};
typedef enum __anonenum_mz_zip_error_21 mz_zip_error;
struct __anonstruct_mz_zip_archive_22 {
   mz_uint64 m_archive_size ;
   mz_uint64 m_central_directory_file_ofs ;
   mz_uint32 m_total_files ;
   mz_zip_mode m_zip_mode ;
   mz_zip_type m_zip_type ;
   mz_zip_error m_last_error ;
   mz_uint64 m_file_offset_alignment ;
   void *(*m_pAlloc)(void *opaque, size_t items, size_t size) ;
   void (*m_pFree)(void *opaque, void *address) ;
   void *(*m_pRealloc)(void *opaque, void *address, size_t items, size_t size) ;
   void *m_pAlloc_opaque ;
   size_t (*m_pRead)(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n) ;
   size_t (*m_pWrite)(void *pOpaque, mz_uint64 file_ofs, void const *pBuf,
                      size_t n) ;
   mz_bool (*m_pNeeds_keepalive)(void *pOpaque) ;
   void *m_pIO_opaque ;
   mz_zip_internal_state *m_pState ;
};
typedef struct __anonstruct_mz_zip_archive_22 mz_zip_archive;
struct __anonstruct_mz_zip_reader_extract_iter_state_23 {
   mz_zip_archive *pZip ;
   mz_uint flags ;
   int status ;
   mz_uint file_crc32 ;
   mz_uint64 read_buf_size ;
   mz_uint64 read_buf_ofs ;
   mz_uint64 read_buf_avail ;
   mz_uint64 comp_remaining ;
   mz_uint64 out_buf_ofs ;
   mz_uint64 cur_file_ofs ;
   mz_zip_archive_file_stat file_stat ;
   void *pRead_buf ;
   void *pWrite_buf ;
   size_t out_blk_remain ;
   tinfl_decompressor inflator ;
};
typedef struct __anonstruct_mz_zip_reader_extract_iter_state_23 mz_zip_reader_extract_iter_state;
typedef unsigned short uint16;
typedef unsigned int uint;
struct __anonstruct_inflate_state_24 {
   tinfl_decompressor m_decomp ;
   mz_uint m_dict_ofs ;
   mz_uint m_dict_avail ;
   mz_uint m_first_call ;
   mz_uint m_has_flushed ;
   int m_window_bits ;
   mz_uint8 m_dict[32768] ;
   tinfl_status m_last_status ;
};
typedef struct __anonstruct_inflate_state_24 inflate_state;
struct __anonstruct_s_error_descs_25 {
   int m_err ;
   char const *m_pDesc ;
};
struct __anonstruct_tdefl_sym_freq_24 {
   mz_uint16 m_key ;
   mz_uint16 m_sym_index ;
};
typedef struct __anonstruct_tdefl_sym_freq_24 tdefl_sym_freq;
enum __anonenum_25 {
    TDEFL_MAX_SUPPORTED_HUFF_CODESIZE = 32
};
struct __anonstruct_tdefl_output_buffer_26 {
   size_t m_size ;
   size_t m_capacity ;
   mz_uint8 *m_pBuf ;
   mz_bool m_expandable ;
};
typedef struct __anonstruct_tdefl_output_buffer_26 tdefl_output_buffer;
enum __anonenum_24 {
    MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG = 0x06054b50,
    MZ_ZIP_CENTRAL_DIR_HEADER_SIG = 0x02014b50,
    MZ_ZIP_LOCAL_DIR_HEADER_SIG = 0x04034b50,
    MZ_ZIP_LOCAL_DIR_HEADER_SIZE = 30,
    MZ_ZIP_CENTRAL_DIR_HEADER_SIZE = 46,
    MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE = 22,
    MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIG = 0x06064b50,
    MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIG = 0x07064b50,
    MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE = 56,
    MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE = 20,
    MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID = 0x0001,
    MZ_ZIP_DATA_DESCRIPTOR_ID = 0x08074b50,
    MZ_ZIP_DATA_DESCRIPTER_SIZE64 = 24,
    MZ_ZIP_DATA_DESCRIPTER_SIZE32 = 16,
    MZ_ZIP_CDH_SIG_OFS = 0,
    MZ_ZIP_CDH_VERSION_MADE_BY_OFS = 4,
    MZ_ZIP_CDH_VERSION_NEEDED_OFS = 6,
    MZ_ZIP_CDH_BIT_FLAG_OFS = 8,
    MZ_ZIP_CDH_METHOD_OFS = 10,
    MZ_ZIP_CDH_FILE_TIME_OFS = 12,
    MZ_ZIP_CDH_FILE_DATE_OFS = 14,
    MZ_ZIP_CDH_CRC32_OFS = 16,
    MZ_ZIP_CDH_COMPRESSED_SIZE_OFS = 20,
    MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS = 24,
    MZ_ZIP_CDH_FILENAME_LEN_OFS = 28,
    MZ_ZIP_CDH_EXTRA_LEN_OFS = 30,
    MZ_ZIP_CDH_COMMENT_LEN_OFS = 32,
    MZ_ZIP_CDH_DISK_START_OFS = 34,
    MZ_ZIP_CDH_INTERNAL_ATTR_OFS = 36,
    MZ_ZIP_CDH_EXTERNAL_ATTR_OFS = 38,
    MZ_ZIP_CDH_LOCAL_HEADER_OFS = 42,
    MZ_ZIP_LDH_SIG_OFS = 0,
    MZ_ZIP_LDH_VERSION_NEEDED_OFS = 4,
    MZ_ZIP_LDH_BIT_FLAG_OFS = 6,
    MZ_ZIP_LDH_METHOD_OFS = 8,
    MZ_ZIP_LDH_FILE_TIME_OFS = 10,
    MZ_ZIP_LDH_FILE_DATE_OFS = 12,
    MZ_ZIP_LDH_CRC32_OFS = 14,
    MZ_ZIP_LDH_COMPRESSED_SIZE_OFS = 18,
    MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS = 22,
    MZ_ZIP_LDH_FILENAME_LEN_OFS = 26,
    MZ_ZIP_LDH_EXTRA_LEN_OFS = 28,
    MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR = 1 << 3,
    MZ_ZIP_ECDH_SIG_OFS = 0,
    MZ_ZIP_ECDH_NUM_THIS_DISK_OFS = 4,
    MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS = 6,
    MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS = 8,
    MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS = 10,
    MZ_ZIP_ECDH_CDIR_SIZE_OFS = 12,
    MZ_ZIP_ECDH_CDIR_OFS_OFS = 16,
    MZ_ZIP_ECDH_COMMENT_SIZE_OFS = 20,
    MZ_ZIP64_ECDL_SIG_OFS = 0,
    MZ_ZIP64_ECDL_NUM_DISK_CDIR_OFS = 4,
    MZ_ZIP64_ECDL_REL_OFS_TO_ZIP64_ECDR_OFS = 8,
    MZ_ZIP64_ECDL_TOTAL_NUMBER_OF_DISKS_OFS = 16,
    MZ_ZIP64_ECDH_SIG_OFS = 0,
    MZ_ZIP64_ECDH_SIZE_OF_RECORD_OFS = 4,
    MZ_ZIP64_ECDH_VERSION_MADE_BY_OFS = 12,
    MZ_ZIP64_ECDH_VERSION_NEEDED_OFS = 14,
    MZ_ZIP64_ECDH_NUM_THIS_DISK_OFS = 16,
    MZ_ZIP64_ECDH_NUM_DISK_CDIR_OFS = 20,
    MZ_ZIP64_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS = 24,
    MZ_ZIP64_ECDH_CDIR_TOTAL_ENTRIES_OFS = 32,
    MZ_ZIP64_ECDH_CDIR_SIZE_OFS = 40,
    MZ_ZIP64_ECDH_CDIR_OFS_OFS = 48,
    MZ_ZIP_VERSION_MADE_BY_DOS_FILESYSTEM_ID = 0,
    MZ_ZIP_DOS_DIR_ATTRIBUTE_BITFLAG = 0x10,
    MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED = 1,
    MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG = 32,
    MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION = 64,
    MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_LOCAL_DIR_IS_MASKED = 8192,
    MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_UTF8 = 1 << 11
};
struct __anonstruct_mz_zip_array_25 {
   void *m_p ;
   size_t m_size ;
   size_t m_capacity ;
   mz_uint m_element_size ;
};
typedef struct __anonstruct_mz_zip_array_25 mz_zip_array;
struct mz_zip_internal_state_tag {
   mz_zip_array m_central_dir ;
   mz_zip_array m_central_dir_offsets ;
   mz_zip_array m_sorted_central_dir_offsets ;
   uint32_t m_init_flags ;
   mz_bool m_zip64 ;
   mz_bool m_zip64_has_extended_info_fields ;
   FILE *m_pFile ;
   mz_uint64 m_file_archive_start_ofs ;
   void *m_pMem ;
   size_t m_mem_size ;
   size_t m_mem_capacity ;
};
struct __anonstruct_mz_zip_writer_add_state_26 {
   mz_zip_archive *m_pZip ;
   mz_uint64 m_cur_archive_file_ofs ;
   mz_uint64 m_comp_size ;
};
typedef struct __anonstruct_mz_zip_writer_add_state_26 mz_zip_writer_add_state;
int main(int argc, char **argv);

int eva_main(void)
{
  char argv0[256];
  char argv1[256];
  char argv2[256];
  char argv3[256];
  char argv4[256];
  int tmp_0;
  int argc = Frama_C_interval(0,5);
  char *argv[6] = {argv0, argv1, argv2, argv3, argv4, (char *)0};
  {
    int i = 0;
    /*@ loop unroll 5; */
    while (i < 5) {
      Frama_C_make_unknown(argv[i],(size_t)255);
      *(argv[i] + 255) = (char)0;
      i ++;
    }
  }
  tmp_0 = main(argc,argv);
  return tmp_0;
}

void __attribute__((__visibility__("default"))) mz_free(void *p);

mz_ulong __attribute__((__visibility__("default"))) mz_adler32(mz_ulong adler,
                                                               unsigned char const *ptr,
                                                               size_t buf_len);

mz_ulong __attribute__((__visibility__("default"))) mz_crc32(mz_ulong crc,
                                                             unsigned char const *ptr,
                                                             size_t buf_len);

char const __attribute__((__visibility__("default"))) *mz_version(void);

int __attribute__((__visibility__("default"))) mz_deflateInit(mz_streamp pStream,
                                                              int level);

int __attribute__((__visibility__("default"))) mz_deflateInit2(mz_streamp pStream,
                                                               int level,
                                                               int method,
                                                               int window_bits,
                                                               int mem_level,
                                                               int strategy);

int __attribute__((__visibility__("default"))) mz_deflateReset(mz_streamp pStream);

int __attribute__((__visibility__("default"))) mz_deflate(mz_streamp pStream,
                                                          int flush);

int __attribute__((__visibility__("default"))) mz_deflateEnd(mz_streamp pStream);

mz_ulong __attribute__((__visibility__("default"))) mz_deflateBound(mz_streamp pStream,
                                                                    mz_ulong source_len);

int __attribute__((__visibility__("default"))) mz_compress(unsigned char *pDest,
                                                           mz_ulong *pDest_len,
                                                           unsigned char const *pSource,
                                                           mz_ulong source_len);

int __attribute__((__visibility__("default"))) mz_compress2(unsigned char *pDest,
                                                            mz_ulong *pDest_len,
                                                            unsigned char const *pSource,
                                                            mz_ulong source_len,
                                                            int level);

mz_ulong __attribute__((__visibility__("default"))) mz_compressBound(
                                                                    mz_ulong source_len);

int __attribute__((__visibility__("default"))) mz_inflateInit(mz_streamp pStream);

int __attribute__((__visibility__("default"))) mz_inflateInit2(mz_streamp pStream,
                                                               int window_bits);

int __attribute__((__visibility__("default"))) mz_inflateReset(mz_streamp pStream);

int __attribute__((__visibility__("default"))) mz_inflate(mz_streamp pStream,
                                                          int flush);

int __attribute__((__visibility__("default"))) mz_inflateEnd(mz_streamp pStream);

int __attribute__((__visibility__("default"))) mz_uncompress(unsigned char *pDest,
                                                             mz_ulong *pDest_len,
                                                             unsigned char const *pSource,
                                                             mz_ulong source_len);

int __attribute__((__visibility__("default"))) mz_uncompress2(unsigned char *pDest,
                                                              mz_ulong *pDest_len,
                                                              unsigned char const *pSource,
                                                              mz_ulong *pSource_len);

char const __attribute__((__visibility__("default"))) *mz_error(int err);

void __attribute__((__visibility__("default"))) *miniz_def_alloc_func
(void *opaque, size_t items, size_t size);

void __attribute__((__visibility__("default"))) miniz_def_free_func(void *opaque,
                                                                    void *address);

void __attribute__((__visibility__("default"))) *miniz_def_realloc_func
(void *opaque, void *address, size_t items, size_t size);

void __attribute__((__visibility__("default"))) *tdefl_compress_mem_to_heap
(void const *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags);

size_t __attribute__((__visibility__("default"))) tdefl_compress_mem_to_mem
(void *pOut_buf, size_t out_buf_len, void const *pSrc_buf,
 size_t src_buf_len, int flags);

void __attribute__((__visibility__("default"))) *tdefl_write_image_to_png_file_in_memory_ex
(void const *pImage, int w, int h, int num_chans, size_t *pLen_out,
 mz_uint level, mz_bool flip);

void __attribute__((__visibility__("default"))) *tdefl_write_image_to_png_file_in_memory
(void const *pImage, int w, int h, int num_chans, size_t *pLen_out);

mz_bool __attribute__((__visibility__("default"))) tdefl_compress_mem_to_output
(void const *pBuf, size_t buf_len,
 mz_bool (*pPut_buf_func)(void const *pBuf, int len, void *pUser),
 void *pPut_buf_user, int flags);

tdefl_status __attribute__((__visibility__("default"))) tdefl_init(tdefl_compressor *d,
                                                                   mz_bool (*pPut_buf_func)
                                                                   (void const *pBuf,
                                                                    int len,
                                                                    void *pUser),
                                                                   void *pPut_buf_user,
                                                                   int flags);

tdefl_status __attribute__((__visibility__("default"))) tdefl_compress
(tdefl_compressor *d, void const *pIn_buf, size_t *pIn_buf_size,
 void *pOut_buf, size_t *pOut_buf_size, tdefl_flush flush);

tdefl_status __attribute__((__visibility__("default"))) tdefl_compress_buffer
(tdefl_compressor *d, void const *pIn_buf, size_t in_buf_size,
 tdefl_flush flush);

tdefl_status __attribute__((__visibility__("default"))) tdefl_get_prev_return_status
(tdefl_compressor *d);

mz_uint32 __attribute__((__visibility__("default"))) tdefl_get_adler32
(tdefl_compressor *d);

mz_uint __attribute__((__visibility__("default"))) tdefl_create_comp_flags_from_zip_params
(int level, int window_bits, int strategy);

tdefl_compressor __attribute__((__visibility__("default"))) *tdefl_compressor_alloc
(void);

void __attribute__((__visibility__("default"))) tdefl_compressor_free
(tdefl_compressor *pComp);

void __attribute__((__visibility__("default"))) *tinfl_decompress_mem_to_heap
(void const *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags);

size_t __attribute__((__visibility__("default"))) tinfl_decompress_mem_to_mem
(void *pOut_buf, size_t out_buf_len, void const *pSrc_buf,
 size_t src_buf_len, int flags);

int __attribute__((__visibility__("default"))) tinfl_decompress_mem_to_callback
(void const *pIn_buf, size_t *pIn_buf_size,
 int (*pPut_buf_func)(void const *pBuf, int len, void *pUser),
 void *pPut_buf_user, int flags);

tinfl_decompressor __attribute__((__visibility__("default"))) *tinfl_decompressor_alloc
(void);

void __attribute__((__visibility__("default"))) tinfl_decompressor_free
(tinfl_decompressor *pDecomp);

tinfl_status __attribute__((__visibility__("default"))) tinfl_decompress
(tinfl_decompressor *r, mz_uint8 const *pIn_buf_next, size_t *pIn_buf_size,
 mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size,
 mz_uint32 const decomp_flags);

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_init
(mz_zip_archive *pZip, mz_uint64 size, mz_uint flags);

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_init_mem
(mz_zip_archive *pZip, void const *pMem, size_t size, mz_uint flags);

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_init_file
(mz_zip_archive *pZip, char const *pFilename, mz_uint32 flags);

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_init_file_v2
(mz_zip_archive *pZip, char const *pFilename, mz_uint flags,
 mz_uint64 file_start_ofs, mz_uint64 archive_size);

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_init_cfile
(mz_zip_archive *pZip, FILE *pFile, mz_uint64 archive_size, mz_uint flags);

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_end(
                                                                    mz_zip_archive *pZip);

void __attribute__((__visibility__("default"))) mz_zip_zero_struct(mz_zip_archive *pZip);

mz_zip_mode __attribute__((__visibility__("default"))) mz_zip_get_mode
(mz_zip_archive *pZip);

mz_zip_type __attribute__((__visibility__("default"))) mz_zip_get_type
(mz_zip_archive *pZip);

mz_uint __attribute__((__visibility__("default"))) mz_zip_reader_get_num_files
(mz_zip_archive *pZip);

mz_uint64 __attribute__((__visibility__("default"))) mz_zip_get_archive_size
(mz_zip_archive *pZip);

mz_uint64 __attribute__((__visibility__("default"))) mz_zip_get_archive_file_start_offset
(mz_zip_archive *pZip);

FILE __attribute__((__visibility__("default"))) *mz_zip_get_cfile(mz_zip_archive *pZip);

size_t __attribute__((__visibility__("default"))) mz_zip_read_archive_data
(mz_zip_archive *pZip, mz_uint64 file_ofs, void *pBuf, size_t n);

mz_zip_error __attribute__((__visibility__("default"))) mz_zip_set_last_error
(mz_zip_archive *pZip, mz_zip_error err_num);

mz_zip_error __attribute__((__visibility__("default"))) mz_zip_peek_last_error
(mz_zip_archive *pZip);

mz_zip_error __attribute__((__visibility__("default"))) mz_zip_clear_last_error
(mz_zip_archive *pZip);

mz_zip_error __attribute__((__visibility__("default"))) mz_zip_get_last_error
(mz_zip_archive *pZip);

char const __attribute__((__visibility__("default"))) *mz_zip_get_error_string
(mz_zip_error mz_err);

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_is_file_a_directory
(mz_zip_archive *pZip, mz_uint file_index);

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_is_file_encrypted
(mz_zip_archive *pZip, mz_uint file_index);

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_is_file_supported
(mz_zip_archive *pZip, mz_uint file_index);

mz_uint __attribute__((__visibility__("default"))) mz_zip_reader_get_filename
(mz_zip_archive *pZip, mz_uint file_index, char *pFilename,
 mz_uint filename_buf_size);

int __attribute__((__visibility__("default"))) mz_zip_reader_locate_file
(mz_zip_archive *pZip, char const *pName, char const *pComment, mz_uint flags);

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_locate_file_v2
(mz_zip_archive *pZip, char const *pName, char const *pComment,
 mz_uint flags, mz_uint32 *pIndex);

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_file_stat
(mz_zip_archive *pZip, mz_uint file_index, mz_zip_archive_file_stat *pStat);

mz_bool __attribute__((__visibility__("default"))) mz_zip_is_zip64(mz_zip_archive *pZip);

size_t __attribute__((__visibility__("default"))) mz_zip_get_central_dir_size
(mz_zip_archive *pZip);

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_extract_to_mem_no_alloc
(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size,
 mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size);

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_extract_file_to_mem_no_alloc
(mz_zip_archive *pZip, char const *pFilename, void *pBuf, size_t buf_size,
 mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size);

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_extract_to_mem
(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size,
 mz_uint flags);

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_extract_file_to_mem
(mz_zip_archive *pZip, char const *pFilename, void *pBuf, size_t buf_size,
 mz_uint flags);

void __attribute__((__visibility__("default"))) *mz_zip_reader_extract_to_heap
(mz_zip_archive *pZip, mz_uint file_index, size_t *pSize, mz_uint flags);

void __attribute__((__visibility__("default"))) *mz_zip_reader_extract_file_to_heap
(mz_zip_archive *pZip, char const *pFilename, size_t *pSize, mz_uint flags);

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_extract_to_callback
(mz_zip_archive *pZip, mz_uint file_index,
 size_t (*pCallback)(void *pOpaque, mz_uint64 file_ofs, void const *pBuf,
                     size_t n),
 void *pOpaque, mz_uint flags);

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_extract_file_to_callback
(mz_zip_archive *pZip, char const *pFilename,
 size_t (*pCallback)(void *pOpaque, mz_uint64 file_ofs, void const *pBuf,
                     size_t n),
 void *pOpaque, mz_uint flags);

mz_zip_reader_extract_iter_state __attribute__((__visibility__("default"))) *mz_zip_reader_extract_iter_new
(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags);

mz_zip_reader_extract_iter_state __attribute__((__visibility__("default"))) *mz_zip_reader_extract_file_iter_new
(mz_zip_archive *pZip, char const *pFilename, mz_uint flags);

size_t __attribute__((__visibility__("default"))) mz_zip_reader_extract_iter_read
(mz_zip_reader_extract_iter_state *pState, void *pvBuf, size_t buf_size);

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_extract_iter_free
(mz_zip_reader_extract_iter_state *pState);

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_extract_to_file
(mz_zip_archive *pZip, mz_uint file_index, char const *pDst_filename,
 mz_uint flags);

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_extract_file_to_file
(mz_zip_archive *pZip, char const *pArchive_filename,
 char const *pDst_filename, mz_uint flags);

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_extract_to_cfile
(mz_zip_archive *pZip, mz_uint file_index, FILE *pFile, mz_uint flags);

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_extract_file_to_cfile
(mz_zip_archive *pZip, char const *pArchive_filename, FILE *pFile,
 mz_uint flags);

mz_bool __attribute__((__visibility__("default"))) mz_zip_validate_file
(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags);

mz_bool __attribute__((__visibility__("default"))) mz_zip_validate_archive
(mz_zip_archive *pZip, mz_uint flags);

mz_bool __attribute__((__visibility__("default"))) mz_zip_validate_mem_archive
(void const *pMem, size_t size, mz_uint flags, mz_zip_error *pErr);

mz_bool __attribute__((__visibility__("default"))) mz_zip_validate_file_archive
(char const *pFilename, mz_uint flags, mz_zip_error *pErr);

mz_bool __attribute__((__visibility__("default"))) mz_zip_end(mz_zip_archive *pZip);

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_init
(mz_zip_archive *pZip, mz_uint64 existing_size);

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_init_v2
(mz_zip_archive *pZip, mz_uint64 existing_size, mz_uint flags);

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_init_heap
(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning,
 size_t initial_allocation_size);

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_init_heap_v2
(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning,
 size_t initial_allocation_size, mz_uint flags);

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_init_file
(mz_zip_archive *pZip, char const *pFilename,
 mz_uint64 size_to_reserve_at_beginning);

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_init_file_v2
(mz_zip_archive *pZip, char const *pFilename,
 mz_uint64 size_to_reserve_at_beginning, mz_uint flags);

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_init_cfile
(mz_zip_archive *pZip, FILE *pFile, mz_uint flags);

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_init_from_reader
(mz_zip_archive *pZip, char const *pFilename);

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_init_from_reader_v2
(mz_zip_archive *pZip, char const *pFilename, mz_uint flags);

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_add_mem
(mz_zip_archive *pZip, char const *pArchive_name, void const *pBuf,
 size_t buf_size, mz_uint level_and_flags);

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_add_mem_ex
(mz_zip_archive *pZip, char const *pArchive_name, void const *pBuf,
 size_t buf_size, void const *pComment, mz_uint16 comment_size,
 mz_uint level_and_flags, mz_uint64 uncomp_size, mz_uint32 uncomp_crc32);

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_add_mem_ex_v2
(mz_zip_archive *pZip, char const *pArchive_name, void const *pBuf,
 size_t buf_size, void const *pComment, mz_uint16 comment_size,
 mz_uint level_and_flags, mz_uint64 uncomp_size, mz_uint32 uncomp_crc32,
 time_t *last_modified, char const *user_extra_data,
 mz_uint user_extra_data_len, char const *user_extra_data_central,
 mz_uint user_extra_data_central_len);

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_add_read_buf_callback
(mz_zip_archive *pZip, char const *pArchive_name,
 size_t (*read_callback)(void *pOpaque, mz_uint64 file_ofs, void *pBuf,
                         size_t n),
 void *callback_opaque, mz_uint64 max_size, time_t const *pFile_time,
 void const *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
 char const *user_extra_data, mz_uint user_extra_data_len,
 char const *user_extra_data_central, mz_uint user_extra_data_central_len);

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_add_file
(mz_zip_archive *pZip, char const *pArchive_name, char const *pSrc_filename,
 void const *pComment, mz_uint16 comment_size, mz_uint level_and_flags);

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_add_cfile
(mz_zip_archive *pZip, char const *pArchive_name, FILE *pSrc_file,
 mz_uint64 max_size, time_t const *pFile_time, void const *pComment,
 mz_uint16 comment_size, mz_uint level_and_flags,
 char const *user_extra_data, mz_uint user_extra_data_len,
 char const *user_extra_data_central, mz_uint user_extra_data_central_len);

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_add_from_zip_reader
(mz_zip_archive *pZip, mz_zip_archive *pSource_zip, mz_uint src_file_index);

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_finalize_archive
(mz_zip_archive *pZip);

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_finalize_heap_archive
(mz_zip_archive *pZip, void **ppBuf, size_t *pSize);

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_end(
                                                                    mz_zip_archive *pZip);

mz_bool __attribute__((__visibility__("default"))) mz_zip_add_mem_to_archive_file_in_place
(char const *pZip_filename, char const *pArchive_name, void const *pBuf,
 size_t buf_size, void const *pComment, mz_uint16 comment_size,
 mz_uint level_and_flags);

mz_bool __attribute__((__visibility__("default"))) mz_zip_add_mem_to_archive_file_in_place_v2
(char const *pZip_filename, char const *pArchive_name, void const *pBuf,
 size_t buf_size, void const *pComment, mz_uint16 comment_size,
 mz_uint level_and_flags, mz_zip_error *pErr);

void __attribute__((__visibility__("default"))) *mz_zip_extract_archive_file_to_heap
(char const *pZip_filename, char const *pArchive_name, size_t *pSize,
 mz_uint flags);

void __attribute__((__visibility__("default"))) *mz_zip_extract_archive_file_to_heap_v2
(char const *pZip_filename, char const *pArchive_name, char const *pComment,
 size_t *pSize, mz_uint flags, mz_zip_error *pErr);

static char const *s_pTest_str =
  "MISSION CONTROL I wouldn\'t worry too much about the computer. First of all, there is still a chance that he is right, despite your tests, andif it should happen again, we suggest eliminating this possibility by allowing the unit to remain in place and seeing whether or not itactually fails. If the computer should turn out to be wrong, the situation is still not alarming. The type of obsessional error he may beguilty of is not unknown among the latest generation of HAL 9000 computers. It has almost always revolved around a single detail, such asthe one you have described, and it has never interfered with the integrity or reliability of the computer\'s performance in other areas.No one is certain of the cause of this kind of malfunctioning. It may be over-programming, but it could also be any number of reasons. In anyevent, it is somewhat analogous to human neurotic behavior. Does this answer your query?  Zero-five-three-Zero, MC, transmission concluded.";
static char const *s_pComment = "This is a comment";
static char const *main_s_Test_archive_filename = "__mz_example2_test__.zip";
/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_1(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: *(format + (0 ..))), (indirect: param0);
    assigns *(s + (0 ..)) \from (indirect: *(format + (0 ..))), param0;
 */
int sprintf_va_1(char * restrict s, char const * restrict format,
                 unsigned int param0);

/*@ requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: *(format + (0 ..))), (indirect: param2),
            (indirect: *(param1 + (0 ..))), (indirect: param0);
    assigns *(s + (0 ..))
      \from (indirect: *(format + (0 ..))), param2, *(param1 + (0 ..)),
            param0;
 */
int sprintf_va_2(char * restrict s, char const * restrict format,
                 unsigned int param0, char *param1, unsigned int param2);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_2(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_3(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_4(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_5(char const * restrict format);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param4),
            (indirect: param3), (indirect: param2),
            (indirect: *(param1 + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param4, param3, param2, *(param1 + (0 ..)), *(param0 + (0 ..));
 */
int printf_va_6(char const * restrict format, char *param0, char *param1,
                unsigned int param2, unsigned int param3, unsigned int param4);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_7(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_8(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: *(format + (0 ..))), (indirect: param0);
    assigns *(s + (0 ..)) \from (indirect: *(format + (0 ..))), param0;
 */
int sprintf_va_3(char * restrict s, char const * restrict format,
                 unsigned int param0);

/*@ requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: *(format + (0 ..))), (indirect: param2),
            (indirect: *(param1 + (0 ..))), (indirect: param0);
    assigns *(s + (0 ..))
      \from (indirect: *(format + (0 ..))), param2, *(param1 + (0 ..)),
            param0;
 */
int sprintf_va_4(char * restrict s, char const * restrict format,
                 unsigned int param0, char *param1, unsigned int param2);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_9(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_10(char const * restrict format);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, *(param0 + (0 ..));
 */
int printf_va_11(char const * restrict format, char *param0,
                 unsigned int param1);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_12(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_13(char const * restrict format);

int main(int argc, char **argv)
{
  int __retres;
  int i;
  int sort_iter;
  mz_bool status;
  size_t uncomp_size;
  mz_zip_archive zip_archive;
  void *p;
  char data[2048];
  char archive_filename[64];
  size_t tmp;
  size_t tmp_2;
  int const N = 50;
  tmp = strlen(s_pTest_str);
  __FC_assert((tmp + (size_t)64 < sizeof(data)) != 0,"examples/example2.c",
              46,"(strlen(s_pTest_str) + 64) < sizeof(data)");
  printf("miniz.c version: %s\n",(char *)"10.1.0"); /* printf_va_1 */
  remove(main_s_Test_archive_filename);
  i = N - 1;
  while (i >= 0) {
    {
      size_t tmp_0;
      size_t tmp_1;
      sprintf(archive_filename,"%u.txt",(unsigned int)i); /* sprintf_va_1 */
      sprintf(data,"%u %s %u",(unsigned int)((N - 1) - i),
              (char *)s_pTest_str,(unsigned int)i); /* sprintf_va_2 */
      tmp_0 = strlen(s_pComment);
      ;
      tmp_1 = strlen((char const *)(data));
      ;
      status = (mz_bool)mz_zip_add_mem_to_archive_file_in_place(main_s_Test_archive_filename,
                                                                (char const *)(archive_filename),
                                                                (void const *)(data),
                                                                tmp_1 + (size_t)1,
                                                                (void const *)s_pComment,
                                                                (uint16)tmp_0,
                                                                (mz_uint)MZ_BEST_COMPRESSION);
      if (! status) {
        printf("mz_zip_add_mem_to_archive_file_in_place failed!\n"); /* printf_va_2 */
        __retres = 1;
        goto return_label;
      }
    }
    i --;
  }
  tmp_2 = strlen("no comment");
  ;
  status = (mz_bool)mz_zip_add_mem_to_archive_file_in_place(main_s_Test_archive_filename,
                                                            "directory/",
                                                            (void const *)0,
                                                            (size_t)0,
                                                            (void const *)"no comment",
                                                            (uint16)tmp_2,
                                                            (mz_uint)MZ_BEST_COMPRESSION);
  if (! status) {
    printf("mz_zip_add_mem_to_archive_file_in_place failed!\n"); /* printf_va_3 */
    __retres = 1;
    goto return_label;
  }
  memset((void *)(& zip_archive),0,sizeof(zip_archive));
  status = (mz_bool)mz_zip_reader_init_file(& zip_archive,
                                            main_s_Test_archive_filename,
                                            (mz_uint32)0);
  if (! status) {
    printf("mz_zip_reader_init_file() failed!\n"); /* printf_va_4 */
    __retres = 1;
    goto return_label;
  }
  i = 0;
  while (1) {
    mz_uint __attribute__((__visibility__("default"))) tmp_7;
    tmp_7 = mz_zip_reader_get_num_files(& zip_archive);
    ;
    if (! (i < (int)tmp_7)) break;
    {
      mz_zip_archive_file_stat file_stat;
      mz_bool __attribute__((__visibility__("default"))) tmp_3;
      mz_bool __attribute__((__visibility__("default"))) tmp_4;
      int tmp_6;
      tmp_3 = mz_zip_reader_file_stat(& zip_archive,(mz_uint)i,& file_stat);
      if (! tmp_3) {
        printf("mz_zip_reader_file_stat() failed!\n"); /* printf_va_5 */
        mz_zip_reader_end(& zip_archive);
        __retres = 1;
        goto return_label;
      }
      tmp_4 = mz_zip_reader_is_file_a_directory(& zip_archive,(mz_uint)i);
      ;
      ;
      ;
      ;
      printf("Filename: \"%s\", Comment: \"%s\", Uncompressed size: %u, Compressed size: %u, Is Dir: %u\n",
             file_stat.m_filename,file_stat.m_comment,
             (uint)file_stat.m_uncomp_size,(uint)file_stat.m_comp_size,
             (unsigned int)((int)tmp_4)); /* printf_va_6 */
      tmp_6 = strcmp((char const *)(file_stat.m_filename),"directory/");
      if (! tmp_6) {
        mz_bool __attribute__((__visibility__("default"))) tmp_5;
        tmp_5 = mz_zip_reader_is_file_a_directory(& zip_archive,(mz_uint)i);
        if (! tmp_5) {
          printf("mz_zip_reader_is_file_a_directory() didn\'t return the expected results!\n"); /* printf_va_7 */
          mz_zip_reader_end(& zip_archive);
          __retres = 1;
          goto return_label;
        }
      }
    }
    i ++;
  }
  mz_zip_reader_end(& zip_archive);
  sort_iter = 0;
  while (sort_iter < 2) {
    {
      int tmp_8;
      memset((void *)(& zip_archive),0,sizeof(zip_archive));
      if (sort_iter) tmp_8 = MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY;
      else tmp_8 = 0;
      ;
      status = (mz_bool)mz_zip_reader_init_file(& zip_archive,
                                                main_s_Test_archive_filename,
                                                (mz_uint32)tmp_8);
      if (! status) {
        printf("mz_zip_reader_init_file() failed!\n"); /* printf_va_8 */
        __retres = 1;
        goto return_label;
      }
      i = 0;
      while (i < N) {
        {
          size_t tmp_9;
          sprintf(archive_filename,"%u.txt",(unsigned int)i); /* sprintf_va_3 */
          sprintf(data,"%u %s %u",(unsigned int)((N - 1) - i),
                  (char *)s_pTest_str,(unsigned int)i); /* sprintf_va_4 */
          p = (void *)mz_zip_reader_extract_file_to_heap(& zip_archive,
                                                         (char const *)(archive_filename),
                                                         & uncomp_size,
                                                         (mz_uint)0);
          if (! p) {
            printf("mz_zip_reader_extract_file_to_heap() failed!\n"); /* printf_va_9 */
            mz_zip_reader_end(& zip_archive);
            __retres = 1;
            goto return_label;
          }
          tmp_9 = strlen((char const *)(data));
          ;
          if (uncomp_size != tmp_9 + (size_t)1) goto _LOR;
          else {
            int tmp_11;
            size_t tmp_10;
            tmp_10 = strlen((char const *)(data));
            ;
            tmp_11 = memcmp((void const *)p,(void const *)(data),tmp_10);
            if (tmp_11) {
              _LOR:
              {
                printf("mz_zip_reader_extract_file_to_heap() failed to extract the proper data\n"); /* printf_va_10 */
                mz_free(p);
                mz_zip_reader_end(& zip_archive);
                __retres = 1;
                goto return_label;
              }
            }
          }
          printf("Successfully extracted file \"%s\", size %u\n",
                 archive_filename,(uint)uncomp_size); /* printf_va_11 */
          printf("File data: \"%s\"\n",(char *)p); /* printf_va_12 */
          mz_free(p);
        }
        i ++;
      }
      mz_zip_reader_end(& zip_archive);
    }
    sort_iter ++;
  }
  printf("Success.\n"); /* printf_va_13 */
  __retres = 0;
  return_label: return __retres;
}

mz_ulong __attribute__((__visibility__("default"))) mz_adler32(mz_ulong adler,
                                                               unsigned char const *ptr,
                                                               size_t buf_len)
{
  mz_ulong __attribute__((__visibility__("default"))) __retres;
  mz_uint32 i;
  mz_uint32 s1 = (mz_uint32)(adler & (unsigned long)0xffff);
  mz_uint32 s2 = (mz_uint32)(adler >> 16);
  size_t block_len = buf_len % (unsigned long)5552;
  if (! ptr) {
    __retres = (mz_ulong __attribute__((__visibility__("default"))))1;
    goto return_label;
  }
  while (buf_len) {
    i = (mz_uint32)0;
    while ((size_t)(i + (mz_uint32)7) < block_len) {
      s1 += (mz_uint32)*(ptr + 0);
      s2 += s1;
      s1 += (mz_uint32)*(ptr + 1);
      s2 += s1;
      s1 += (mz_uint32)*(ptr + 2);
      s2 += s1;
      s1 += (mz_uint32)*(ptr + 3);
      s2 += s1;
      s1 += (mz_uint32)*(ptr + 4);
      s2 += s1;
      s1 += (mz_uint32)*(ptr + 5);
      s2 += s1;
      s1 += (mz_uint32)*(ptr + 6);
      s2 += s1;
      s1 += (mz_uint32)*(ptr + 7);
      s2 += s1;
      i += (mz_uint32)8;
      ptr += 8;
    }
    while ((size_t)i < block_len) {
      unsigned char const *tmp;
      tmp = ptr;
      ptr ++;
      s1 += (mz_uint32)*tmp;
      s2 += s1;
      i ++;
    }
    s1 %= 65521U;
    s2 %= 65521U;
    buf_len -= block_len;
    block_len = (size_t)5552;
  }
  __retres = (mz_ulong __attribute__((__visibility__("default"))))((s2 << 16) + s1);
  return_label: return __retres;
}

static mz_uint32 const mz_crc32_s_crc_table[256] =
  {(mz_uint32)0x00000000,
   (mz_uint32)0x77073096,
   0xEE0E612C,
   0x990951BA,
   (mz_uint32)0x076DC419,
   (mz_uint32)0x706AF48F,
   0xE963A535,
   0x9E6495A3,
   (mz_uint32)0x0EDB8832,
   (mz_uint32)0x79DCB8A4,
   0xE0D5E91E,
   0x97D2D988,
   (mz_uint32)0x09B64C2B,
   (mz_uint32)0x7EB17CBD,
   0xE7B82D07,
   0x90BF1D91,
   (mz_uint32)0x1DB71064,
   (mz_uint32)0x6AB020F2,
   0xF3B97148,
   0x84BE41DE,
   (mz_uint32)0x1ADAD47D,
   (mz_uint32)0x6DDDE4EB,
   0xF4D4B551,
   0x83D385C7,
   (mz_uint32)0x136C9856,
   (mz_uint32)0x646BA8C0,
   0xFD62F97A,
   0x8A65C9EC,
   (mz_uint32)0x14015C4F,
   (mz_uint32)0x63066CD9,
   0xFA0F3D63,
   0x8D080DF5,
   (mz_uint32)0x3B6E20C8,
   (mz_uint32)0x4C69105E,
   0xD56041E4,
   0xA2677172,
   (mz_uint32)0x3C03E4D1,
   (mz_uint32)0x4B04D447,
   0xD20D85FD,
   0xA50AB56B,
   (mz_uint32)0x35B5A8FA,
   (mz_uint32)0x42B2986C,
   0xDBBBC9D6,
   0xACBCF940,
   (mz_uint32)0x32D86CE3,
   (mz_uint32)0x45DF5C75,
   0xDCD60DCF,
   0xABD13D59,
   (mz_uint32)0x26D930AC,
   (mz_uint32)0x51DE003A,
   0xC8D75180,
   0xBFD06116,
   (mz_uint32)0x21B4F4B5,
   (mz_uint32)0x56B3C423,
   0xCFBA9599,
   0xB8BDA50F,
   (mz_uint32)0x2802B89E,
   (mz_uint32)0x5F058808,
   0xC60CD9B2,
   0xB10BE924,
   (mz_uint32)0x2F6F7C87,
   (mz_uint32)0x58684C11,
   0xC1611DAB,
   0xB6662D3D,
   (mz_uint32)0x76DC4190,
   (mz_uint32)0x01DB7106,
   0x98D220BC,
   0xEFD5102A,
   (mz_uint32)0x71B18589,
   (mz_uint32)0x06B6B51F,
   0x9FBFE4A5,
   0xE8B8D433,
   (mz_uint32)0x7807C9A2,
   (mz_uint32)0x0F00F934,
   0x9609A88E,
   0xE10E9818,
   (mz_uint32)0x7F6A0DBB,
   (mz_uint32)0x086D3D2D,
   0x91646C97,
   0xE6635C01,
   (mz_uint32)0x6B6B51F4,
   (mz_uint32)0x1C6C6162,
   0x856530D8,
   0xF262004E,
   (mz_uint32)0x6C0695ED,
   (mz_uint32)0x1B01A57B,
   0x8208F4C1,
   0xF50FC457,
   (mz_uint32)0x65B0D9C6,
   (mz_uint32)0x12B7E950,
   0x8BBEB8EA,
   0xFCB9887C,
   (mz_uint32)0x62DD1DDF,
   (mz_uint32)0x15DA2D49,
   0x8CD37CF3,
   0xFBD44C65,
   (mz_uint32)0x4DB26158,
   (mz_uint32)0x3AB551CE,
   0xA3BC0074,
   0xD4BB30E2,
   (mz_uint32)0x4ADFA541,
   (mz_uint32)0x3DD895D7,
   0xA4D1C46D,
   0xD3D6F4FB,
   (mz_uint32)0x4369E96A,
   (mz_uint32)0x346ED9FC,
   0xAD678846,
   0xDA60B8D0,
   (mz_uint32)0x44042D73,
   (mz_uint32)0x33031DE5,
   0xAA0A4C5F,
   0xDD0D7CC9,
   (mz_uint32)0x5005713C,
   (mz_uint32)0x270241AA,
   0xBE0B1010,
   0xC90C2086,
   (mz_uint32)0x5768B525,
   (mz_uint32)0x206F85B3,
   0xB966D409,
   0xCE61E49F,
   (mz_uint32)0x5EDEF90E,
   (mz_uint32)0x29D9C998,
   0xB0D09822,
   0xC7D7A8B4,
   (mz_uint32)0x59B33D17,
   (mz_uint32)0x2EB40D81,
   0xB7BD5C3B,
   0xC0BA6CAD,
   0xEDB88320,
   0x9ABFB3B6,
   (mz_uint32)0x03B6E20C,
   (mz_uint32)0x74B1D29A,
   0xEAD54739,
   0x9DD277AF,
   (mz_uint32)0x04DB2615,
   (mz_uint32)0x73DC1683,
   0xE3630B12,
   0x94643B84,
   (mz_uint32)0x0D6D6A3E,
   (mz_uint32)0x7A6A5AA8,
   0xE40ECF0B,
   0x9309FF9D,
   (mz_uint32)0x0A00AE27,
   (mz_uint32)0x7D079EB1,
   0xF00F9344,
   0x8708A3D2,
   (mz_uint32)0x1E01F268,
   (mz_uint32)0x6906C2FE,
   0xF762575D,
   0x806567CB,
   (mz_uint32)0x196C3671,
   (mz_uint32)0x6E6B06E7,
   0xFED41B76,
   0x89D32BE0,
   (mz_uint32)0x10DA7A5A,
   (mz_uint32)0x67DD4ACC,
   0xF9B9DF6F,
   0x8EBEEFF9,
   (mz_uint32)0x17B7BE43,
   (mz_uint32)0x60B08ED5,
   0xD6D6A3E8,
   0xA1D1937E,
   (mz_uint32)0x38D8C2C4,
   (mz_uint32)0x4FDFF252,
   0xD1BB67F1,
   0xA6BC5767,
   (mz_uint32)0x3FB506DD,
   (mz_uint32)0x48B2364B,
   0xD80D2BDA,
   0xAF0A1B4C,
   (mz_uint32)0x36034AF6,
   (mz_uint32)0x41047A60,
   0xDF60EFC3,
   0xA867DF55,
   (mz_uint32)0x316E8EEF,
   (mz_uint32)0x4669BE79,
   0xCB61B38C,
   0xBC66831A,
   (mz_uint32)0x256FD2A0,
   (mz_uint32)0x5268E236,
   0xCC0C7795,
   0xBB0B4703,
   (mz_uint32)0x220216B9,
   (mz_uint32)0x5505262F,
   0xC5BA3BBE,
   0xB2BD0B28,
   (mz_uint32)0x2BB45A92,
   (mz_uint32)0x5CB36A04,
   0xC2D7FFA7,
   0xB5D0CF31,
   (mz_uint32)0x2CD99E8B,
   (mz_uint32)0x5BDEAE1D,
   0x9B64C2B0,
   0xEC63F226,
   (mz_uint32)0x756AA39C,
   (mz_uint32)0x026D930A,
   0x9C0906A9,
   0xEB0E363F,
   (mz_uint32)0x72076785,
   (mz_uint32)0x05005713,
   0x95BF4A82,
   0xE2B87A14,
   (mz_uint32)0x7BB12BAE,
   (mz_uint32)0x0CB61B38,
   0x92D28E9B,
   0xE5D5BE0D,
   (mz_uint32)0x7CDCEFB7,
   (mz_uint32)0x0BDBDF21,
   0x86D3D2D4,
   0xF1D4E242,
   (mz_uint32)0x68DDB3F8,
   (mz_uint32)0x1FDA836E,
   0x81BE16CD,
   0xF6B9265B,
   (mz_uint32)0x6FB077E1,
   (mz_uint32)0x18B74777,
   0x88085AE6,
   0xFF0F6A70,
   (mz_uint32)0x66063BCA,
   (mz_uint32)0x11010B5C,
   0x8F659EFF,
   0xF862AE69,
   (mz_uint32)0x616BFFD3,
   (mz_uint32)0x166CCF45,
   0xA00AE278,
   0xD70DD2EE,
   (mz_uint32)0x4E048354,
   (mz_uint32)0x3903B3C2,
   0xA7672661,
   0xD06016F7,
   (mz_uint32)0x4969474D,
   (mz_uint32)0x3E6E77DB,
   0xAED16A4A,
   0xD9D65ADC,
   (mz_uint32)0x40DF0B66,
   (mz_uint32)0x37D83BF0,
   0xA9BCAE53,
   0xDEBB9EC5,
   (mz_uint32)0x47B2CF7F,
   (mz_uint32)0x30B5FFE9,
   0xBDBDF21C,
   0xCABAC28A,
   (mz_uint32)0x53B39330,
   (mz_uint32)0x24B4A3A6,
   0xBAD03605,
   0xCDD70693,
   (mz_uint32)0x54DE5729,
   (mz_uint32)0x23D967BF,
   0xB3667A2E,
   0xC4614AB8,
   (mz_uint32)0x5D681B02,
   (mz_uint32)0x2A6F2B94,
   0xB40BBE37,
   0xC30C8EA1,
   (mz_uint32)0x5A05DF1B,
   (mz_uint32)0x2D02EF8D};
mz_ulong __attribute__((__visibility__("default"))) mz_crc32(mz_ulong crc,
                                                             unsigned char const *ptr,
                                                             size_t buf_len)
{
  mz_ulong __attribute__((__visibility__("default"))) __retres;
  mz_uint32 mz_crc32_0 = (mz_uint32)crc ^ 0xFFFFFFFF;
  mz_uint8 const *pByte_buf = ptr;
  while (buf_len >= (size_t)4) {
    mz_crc32_0 = (mz_crc32_0 >> 8) ^ mz_crc32_s_crc_table[(mz_crc32_0 ^ (unsigned int)*(
                                                           pByte_buf + 0)) & (unsigned int)0xFF];
    mz_crc32_0 = (mz_crc32_0 >> 8) ^ mz_crc32_s_crc_table[(mz_crc32_0 ^ (unsigned int)*(
                                                           pByte_buf + 1)) & (unsigned int)0xFF];
    mz_crc32_0 = (mz_crc32_0 >> 8) ^ mz_crc32_s_crc_table[(mz_crc32_0 ^ (unsigned int)*(
                                                           pByte_buf + 2)) & (unsigned int)0xFF];
    mz_crc32_0 = (mz_crc32_0 >> 8) ^ mz_crc32_s_crc_table[(mz_crc32_0 ^ (unsigned int)*(
                                                           pByte_buf + 3)) & (unsigned int)0xFF];
    pByte_buf += 4;
    buf_len -= (size_t)4;
  }
  while (buf_len) {
    mz_crc32_0 = (mz_crc32_0 >> 8) ^ mz_crc32_s_crc_table[(mz_crc32_0 ^ (unsigned int)*(
                                                           pByte_buf + 0)) & (unsigned int)0xFF];
    pByte_buf ++;
    buf_len --;
  }
  __retres = (mz_ulong __attribute__((__visibility__("default"))))(~ mz_crc32_0);
  return __retres;
}

void __attribute__((__visibility__("default"))) mz_free(void *p)
{
  free(p);
  return;
}

void __attribute__((__visibility__("default"))) *miniz_def_alloc_func
(void *opaque, size_t items, size_t size)
{
  void __attribute__((__visibility__("default"))) *tmp;
  tmp = (void __attribute__((__visibility__("default"))) *)malloc(items * size);
  return tmp;
}

void __attribute__((__visibility__("default"))) miniz_def_free_func(void *opaque,
                                                                    void *address)
{
  free(address);
  return;
}

void __attribute__((__visibility__("default"))) *miniz_def_realloc_func
(void *opaque, void *address, size_t items, size_t size)
{
  void __attribute__((__visibility__("default"))) *tmp;
  tmp = (void __attribute__((__visibility__("default"))) *)realloc(address,
                                                                   items * size);
  return tmp;
}

char const __attribute__((__visibility__("default"))) *mz_version(void)
{
  char const __attribute__((__visibility__("default"))) *__retres;
  __retres = (char const __attribute__((__visibility__("default"))) *)"10.1.0";
  return __retres;
}

int __attribute__((__visibility__("default"))) mz_deflateInit(mz_streamp pStream,
                                                              int level)
{
  int __attribute__((__visibility__("default"))) tmp;
  tmp = mz_deflateInit2(pStream,level,8,15,9,MZ_DEFAULT_STRATEGY);
  return tmp;
}

int __attribute__((__visibility__("default"))) mz_deflateInit2(mz_streamp pStream,
                                                               int level,
                                                               int method,
                                                               int window_bits,
                                                               int mem_level,
                                                               int strategy)
{
  int __attribute__((__visibility__("default"))) __retres;
  tdefl_compressor *pComp;
  mz_uint __attribute__((__visibility__("default"))) tmp;
  tdefl_status __attribute__((__visibility__("default"))) tmp_1;
  tmp = tdefl_create_comp_flags_from_zip_params(level,window_bits,strategy);
  mz_uint comp_flags =
    (mz_uint)((unsigned int __attribute__((__visibility__("default"))))TDEFL_COMPUTE_ADLER32 | tmp);
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  if (method != 8) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
    goto return_label;
  }
  else 
    if (mem_level < 1) {
      __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
      goto return_label;
    }
    else 
      if (mem_level > 9) {
        __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
        goto return_label;
      }
      else 
        if (window_bits != 15) 
          if (- window_bits != 15) {
            __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
            goto return_label;
          }
  pStream->data_type = 0;
  pStream->adler = (mz_ulong)1;
  pStream->msg = (char *)0;
  pStream->reserved = (mz_ulong)0;
  pStream->total_in = (mz_ulong)0;
  pStream->total_out = (mz_ulong)0;
  if (! pStream->zalloc) pStream->zalloc = (void *(*)(void *opaque,
                                                      size_t items,
                                                      size_t size))(& miniz_def_alloc_func);
  if (! pStream->zfree) pStream->zfree = (void (*)(void *opaque,
                                                   void *address))(& miniz_def_free_func);
  pComp = (tdefl_compressor *)(*(pStream->zalloc))(pStream->opaque,(size_t)1,
                                                   sizeof(tdefl_compressor));
  if (! pComp) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_MEM_ERROR;
    goto return_label;
  }
  pStream->state = (struct mz_internal_state *)pComp;
  tmp_1 = tdefl_init(pComp,
                     (mz_bool (*)(void const *pBuf, int len, void *pUser))0,
                     (void *)0,(int)comp_flags);
  if (tmp_1 != (int __attribute__((__visibility__("default"))))TDEFL_STATUS_OKAY) {
    mz_deflateEnd(pStream);
    __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
    goto return_label;
  }
  __retres = (int __attribute__((__visibility__("default"))))MZ_OK;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_deflateReset(mz_streamp pStream)
{
  int __attribute__((__visibility__("default"))) __retres;
  mz_ulong tmp;
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  else 
    if (! pStream->state) {
      __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
      goto return_label;
    }
    else 
      if (! pStream->zalloc) {
        __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
        goto return_label;
      }
      else 
        if (! pStream->zfree) {
          __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
          goto return_label;
        }
  tmp = (mz_ulong)0;
  pStream->total_out = tmp;
  pStream->total_in = tmp;
  tdefl_init((tdefl_compressor *)pStream->state,
             (mz_bool (*)(void const *pBuf, int len, void *pUser))0,
             (void *)0,(int)((tdefl_compressor *)pStream->state)->m_flags);
  __retres = (int __attribute__((__visibility__("default"))))MZ_OK;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_deflate(mz_streamp pStream,
                                                          int flush)
{
  int __attribute__((__visibility__("default"))) __retres;
  size_t in_bytes;
  size_t out_bytes;
  mz_ulong orig_total_in;
  mz_ulong orig_total_out;
  int mz_status = MZ_OK;
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  else 
    if (! pStream->state) {
      __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
      goto return_label;
    }
    else 
      if (flush < 0) {
        __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
        goto return_label;
      }
      else 
        if (flush > MZ_FINISH) {
          __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
          goto return_label;
        }
        else 
          if (! pStream->next_out) {
            __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
            goto return_label;
          }
  if (! pStream->avail_out) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_BUF_ERROR;
    goto return_label;
  }
  if (flush == MZ_PARTIAL_FLUSH) flush = MZ_SYNC_FLUSH;
  if (((tdefl_compressor *)pStream->state)->m_prev_return_status == TDEFL_STATUS_DONE) {
    int tmp;
    if (flush == MZ_FINISH) tmp = MZ_STREAM_END; else tmp = MZ_BUF_ERROR;
    __retres = (int __attribute__((__visibility__("default"))))tmp;
    goto return_label;
  }
  orig_total_in = pStream->total_in;
  orig_total_out = pStream->total_out;
  while (1) {
    tdefl_status defl_status;
    tdefl_status __attribute__((__visibility__("default"))) tmp_0;
    mz_uint32 __attribute__((__visibility__("default"))) tmp_1;
    in_bytes = (size_t)pStream->avail_in;
    out_bytes = (size_t)pStream->avail_out;
    tmp_0 = tdefl_compress((tdefl_compressor *)pStream->state,
                           (void const *)pStream->next_in,& in_bytes,
                           (void *)pStream->next_out,& out_bytes,
                           (tdefl_flush)flush);
    defl_status = (tdefl_status)tmp_0;
    pStream->next_in += (mz_uint)in_bytes;
    pStream->avail_in -= (mz_uint)in_bytes;
    pStream->total_in += (mz_ulong)((mz_uint)in_bytes);
    tmp_1 = tdefl_get_adler32((tdefl_compressor *)pStream->state);
    pStream->adler = (mz_ulong)tmp_1;
    pStream->next_out += (mz_uint)out_bytes;
    pStream->avail_out -= (mz_uint)out_bytes;
    pStream->total_out += (mz_ulong)((mz_uint)out_bytes);
    if (defl_status < 0) {
      mz_status = MZ_STREAM_ERROR;
      break;
    }
    else 
      if (defl_status == TDEFL_STATUS_DONE) {
        mz_status = MZ_STREAM_END;
        break;
      }
      else 
        if (! pStream->avail_out) break;
        else 
          if (! pStream->avail_in) 
            if (flush != MZ_FINISH) {
              if (flush) break;
              else 
                if (pStream->total_in != orig_total_in) break;
                else 
                  if (pStream->total_out != orig_total_out) break;
              __retres = (int __attribute__((__visibility__("default"))))MZ_BUF_ERROR;
              goto return_label;
            }
  }
  __retres = (int __attribute__((__visibility__("default"))))mz_status;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_deflateEnd(mz_streamp pStream)
{
  int __attribute__((__visibility__("default"))) __retres;
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  if (pStream->state) {
    (*(pStream->zfree))(pStream->opaque,(void *)pStream->state);
    pStream->state = (struct mz_internal_state *)0;
  }
  __retres = (int __attribute__((__visibility__("default"))))MZ_OK;
  return_label: return __retres;
}

mz_ulong __attribute__((__visibility__("default"))) mz_deflateBound(mz_streamp pStream,
                                                                    mz_ulong source_len)
{
  mz_ulong __attribute__((__visibility__("default"))) __retres;
  mz_ulong tmp;
  if ((mz_ulong)128 + (source_len * (mz_ulong)110) / (mz_ulong)100 > 
      ((mz_ulong)128 + source_len) + (source_len / (mz_ulong)(31 * 1024) + (mz_ulong)1) * (mz_ulong)5) 
    tmp = (mz_ulong)128 + (source_len * (mz_ulong)110) / (mz_ulong)100;
  else tmp = ((mz_ulong)128 + source_len) + (source_len / (mz_ulong)(
                                             31 * 1024) + (mz_ulong)1) * (mz_ulong)5;
  __retres = (mz_ulong __attribute__((__visibility__("default"))))tmp;
  return __retres;
}

int __attribute__((__visibility__("default"))) mz_compress2(unsigned char *pDest,
                                                            mz_ulong *pDest_len,
                                                            unsigned char const *pSource,
                                                            mz_ulong source_len,
                                                            int level)
{
  int __attribute__((__visibility__("default"))) __retres;
  int status;
  mz_stream stream;
  int __attribute__((__visibility__("default"))) tmp_0;
  memset((void *)(& stream),0,sizeof(stream));
  if ((source_len | *pDest_len) > (unsigned long)0xFFFFFFFFU) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
    goto return_label;
  }
  stream.next_in = pSource;
  stream.avail_in = (mz_uint32)source_len;
  stream.next_out = pDest;
  stream.avail_out = (mz_uint32)*pDest_len;
  status = (int)mz_deflateInit(& stream,level);
  if (status != MZ_OK) {
    __retres = (int __attribute__((__visibility__("default"))))status;
    goto return_label;
  }
  status = (int)mz_deflate(& stream,MZ_FINISH);
  if (status != MZ_STREAM_END) {
    int tmp;
    mz_deflateEnd(& stream);
    if (status == MZ_OK) tmp = MZ_BUF_ERROR; else tmp = status;
    __retres = (int __attribute__((__visibility__("default"))))tmp;
    goto return_label;
  }
  *pDest_len = stream.total_out;
  tmp_0 = mz_deflateEnd(& stream);
  __retres = tmp_0;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_compress(unsigned char *pDest,
                                                           mz_ulong *pDest_len,
                                                           unsigned char const *pSource,
                                                           mz_ulong source_len)
{
  int __attribute__((__visibility__("default"))) tmp;
  tmp = mz_compress2(pDest,pDest_len,pSource,source_len,
                     MZ_DEFAULT_COMPRESSION);
  return tmp;
}

mz_ulong __attribute__((__visibility__("default"))) mz_compressBound(
                                                                    mz_ulong source_len)
{
  mz_ulong __attribute__((__visibility__("default"))) tmp;
  tmp = mz_deflateBound((mz_streamp)0,source_len);
  return tmp;
}

int __attribute__((__visibility__("default"))) mz_inflateInit2(mz_streamp pStream,
                                                               int window_bits)
{
  int __attribute__((__visibility__("default"))) __retres;
  inflate_state *pDecomp;
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  if (window_bits != 15) 
    if (- window_bits != 15) {
      __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
      goto return_label;
    }
  pStream->data_type = 0;
  pStream->adler = (mz_ulong)0;
  pStream->msg = (char *)0;
  pStream->total_in = (mz_ulong)0;
  pStream->total_out = (mz_ulong)0;
  pStream->reserved = (mz_ulong)0;
  if (! pStream->zalloc) pStream->zalloc = (void *(*)(void *opaque,
                                                      size_t items,
                                                      size_t size))(& miniz_def_alloc_func);
  if (! pStream->zfree) pStream->zfree = (void (*)(void *opaque,
                                                   void *address))(& miniz_def_free_func);
  pDecomp = (inflate_state *)(*(pStream->zalloc))(pStream->opaque,(size_t)1,
                                                  sizeof(inflate_state));
  if (! pDecomp) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_MEM_ERROR;
    goto return_label;
  }
  pStream->state = (struct mz_internal_state *)pDecomp;
  pDecomp->m_decomp.m_state = (mz_uint32)0;
  pDecomp->m_decomp.m_num_bits = (mz_uint32)0;
  pDecomp->m_decomp.m_bit_buf = (tinfl_bit_buf_t)0;
  pDecomp->m_decomp.m_dist = (mz_uint32)0;
  pDecomp->m_decomp.m_counter = (mz_uint32)0;
  pDecomp->m_decomp.m_num_extra = (mz_uint32)0;
  pDecomp->m_decomp.m_dist_from_out_buf_start = (size_t)0;
  pDecomp->m_dict_ofs = (mz_uint)0;
  pDecomp->m_dict_avail = (mz_uint)0;
  pDecomp->m_last_status = TINFL_STATUS_NEEDS_MORE_INPUT;
  pDecomp->m_first_call = (mz_uint)1;
  pDecomp->m_has_flushed = (mz_uint)0;
  pDecomp->m_window_bits = window_bits;
  __retres = (int __attribute__((__visibility__("default"))))MZ_OK;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_inflateInit(mz_streamp pStream)
{
  int __attribute__((__visibility__("default"))) tmp;
  tmp = mz_inflateInit2(pStream,15);
  return tmp;
}

int __attribute__((__visibility__("default"))) mz_inflateReset(mz_streamp pStream)
{
  int __attribute__((__visibility__("default"))) __retres;
  inflate_state *pDecomp;
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  pStream->data_type = 0;
  pStream->adler = (mz_ulong)0;
  pStream->msg = (char *)0;
  pStream->total_in = (mz_ulong)0;
  pStream->total_out = (mz_ulong)0;
  pStream->reserved = (mz_ulong)0;
  pDecomp = (inflate_state *)pStream->state;
  pDecomp->m_decomp.m_state = (mz_uint32)0;
  pDecomp->m_decomp.m_num_bits = (mz_uint32)0;
  pDecomp->m_decomp.m_bit_buf = (tinfl_bit_buf_t)0;
  pDecomp->m_decomp.m_dist = (mz_uint32)0;
  pDecomp->m_decomp.m_counter = (mz_uint32)0;
  pDecomp->m_decomp.m_num_extra = (mz_uint32)0;
  pDecomp->m_decomp.m_dist_from_out_buf_start = (size_t)0;
  pDecomp->m_dict_ofs = (mz_uint)0;
  pDecomp->m_dict_avail = (mz_uint)0;
  pDecomp->m_last_status = TINFL_STATUS_NEEDS_MORE_INPUT;
  pDecomp->m_first_call = (mz_uint)1;
  pDecomp->m_has_flushed = (mz_uint)0;
  __retres = (int __attribute__((__visibility__("default"))))MZ_OK;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_inflate(mz_streamp pStream,
                                                          int flush)
{
  int __attribute__((__visibility__("default"))) __retres;
  inflate_state *pState;
  mz_uint n;
  mz_uint first_call;
  size_t in_bytes;
  size_t out_bytes;
  size_t orig_avail_in;
  tinfl_status status;
  int tmp_3;
  mz_uint decomp_flags = (mz_uint)TINFL_FLAG_COMPUTE_ADLER32;
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  else 
    if (! pStream->state) {
      __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
      goto return_label;
    }
  if (flush == MZ_PARTIAL_FLUSH) flush = MZ_SYNC_FLUSH;
  if (flush) 
    if (flush != MZ_SYNC_FLUSH) 
      if (flush != MZ_FINISH) {
        __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
        goto return_label;
      }
  pState = (inflate_state *)pStream->state;
  if (pState->m_window_bits > 0) decomp_flags |= (unsigned int)TINFL_FLAG_PARSE_ZLIB_HEADER;
  orig_avail_in = (size_t)pStream->avail_in;
  first_call = pState->m_first_call;
  pState->m_first_call = (mz_uint)0;
  if (pState->m_last_status < 0) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_DATA_ERROR;
    goto return_label;
  }
  if (pState->m_has_flushed) 
    if (flush != MZ_FINISH) {
      __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
      goto return_label;
    }
  pState->m_has_flushed |= (unsigned int)(flush == MZ_FINISH);
  if (flush == MZ_FINISH) 
    if (first_call) {
      tinfl_status __attribute__((__visibility__("default"))) tmp;
      decomp_flags |= (unsigned int)TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF;
      in_bytes = (size_t)pStream->avail_in;
      out_bytes = (size_t)pStream->avail_out;
      tmp = tinfl_decompress(& pState->m_decomp,pStream->next_in,& in_bytes,
                             pStream->next_out,pStream->next_out,& out_bytes,
                             decomp_flags);
      status = (tinfl_status)tmp;
      pState->m_last_status = status;
      pStream->next_in += (mz_uint)in_bytes;
      pStream->avail_in -= (mz_uint)in_bytes;
      pStream->total_in += (mz_ulong)((mz_uint)in_bytes);
      pStream->adler = (mz_ulong)pState->m_decomp.m_check_adler32;
      pStream->next_out += (mz_uint)out_bytes;
      pStream->avail_out -= (mz_uint)out_bytes;
      pStream->total_out += (mz_ulong)((mz_uint)out_bytes);
      if (status < 0) {
        __retres = (int __attribute__((__visibility__("default"))))MZ_DATA_ERROR;
        goto return_label;
      }
      else 
        if (status != TINFL_STATUS_DONE) {
          pState->m_last_status = TINFL_STATUS_FAILED;
          __retres = (int __attribute__((__visibility__("default"))))MZ_BUF_ERROR;
          goto return_label;
        }
      __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_END;
      goto return_label;
    }
  if (flush != MZ_FINISH) decomp_flags |= (unsigned int)TINFL_FLAG_HAS_MORE_INPUT;
  if (pState->m_dict_avail) {
    int tmp_0;
    if (pState->m_dict_avail < pStream->avail_out) n = pState->m_dict_avail;
    else n = pStream->avail_out;
    memcpy((void *)pStream->next_out,
           (void const *)(& pState->m_dict[pState->m_dict_ofs]),(size_t)n);
    pStream->next_out += n;
    pStream->avail_out -= n;
    pStream->total_out += (mz_ulong)n;
    pState->m_dict_avail -= n;
    pState->m_dict_ofs = (pState->m_dict_ofs + n) & (unsigned int)(32768 - 1);
    if (pState->m_last_status == TINFL_STATUS_DONE) 
      if (! pState->m_dict_avail) tmp_0 = MZ_STREAM_END; else tmp_0 = MZ_OK;
    else tmp_0 = MZ_OK;
    __retres = (int __attribute__((__visibility__("default"))))tmp_0;
    goto return_label;
  }
  while (1) {
    tinfl_status __attribute__((__visibility__("default"))) tmp_1;
    in_bytes = (size_t)pStream->avail_in;
    out_bytes = (size_t)((mz_uint)32768 - pState->m_dict_ofs);
    tmp_1 = tinfl_decompress(& pState->m_decomp,pStream->next_in,& in_bytes,
                             pState->m_dict,
                             & pState->m_dict[pState->m_dict_ofs],
                             & out_bytes,decomp_flags);
    status = (tinfl_status)tmp_1;
    pState->m_last_status = status;
    pStream->next_in += (mz_uint)in_bytes;
    pStream->avail_in -= (mz_uint)in_bytes;
    pStream->total_in += (mz_ulong)((mz_uint)in_bytes);
    pStream->adler = (mz_ulong)pState->m_decomp.m_check_adler32;
    pState->m_dict_avail = (mz_uint)out_bytes;
    if (pState->m_dict_avail < pStream->avail_out) n = pState->m_dict_avail;
    else n = pStream->avail_out;
    memcpy((void *)pStream->next_out,
           (void const *)(& pState->m_dict[pState->m_dict_ofs]),(size_t)n);
    pStream->next_out += n;
    pStream->avail_out -= n;
    pStream->total_out += (mz_ulong)n;
    pState->m_dict_avail -= n;
    pState->m_dict_ofs = (pState->m_dict_ofs + n) & (unsigned int)(32768 - 1);
    if (status < 0) {
      __retres = (int __attribute__((__visibility__("default"))))MZ_DATA_ERROR;
      goto return_label;
    }
    else 
      if (status == TINFL_STATUS_NEEDS_MORE_INPUT) {
        if (! orig_avail_in) {
          __retres = (int __attribute__((__visibility__("default"))))MZ_BUF_ERROR;
          goto return_label;
        }
        else goto _LAND;
      }
      else {
        _LAND: ;
        if (flush == MZ_FINISH) {
          if (status == TINFL_STATUS_DONE) {
            int tmp_2;
            if (pState->m_dict_avail) tmp_2 = MZ_BUF_ERROR;
            else tmp_2 = MZ_STREAM_END;
            __retres = (int __attribute__((__visibility__("default"))))tmp_2;
            goto return_label;
          }
          else 
            if (! pStream->avail_out) {
              __retres = (int __attribute__((__visibility__("default"))))MZ_BUF_ERROR;
              goto return_label;
            }
        }
        else 
          if (status == TINFL_STATUS_DONE) break;
          else 
            if (! pStream->avail_in) break;
            else 
              if (! pStream->avail_out) break;
              else 
                if (pState->m_dict_avail) break;
      }
  }
  if (status == TINFL_STATUS_DONE) 
    if (! pState->m_dict_avail) tmp_3 = MZ_STREAM_END; else tmp_3 = MZ_OK;
  else tmp_3 = MZ_OK;
  __retres = (int __attribute__((__visibility__("default"))))tmp_3;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_inflateEnd(mz_streamp pStream)
{
  int __attribute__((__visibility__("default"))) __retres;
  if (! pStream) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_STREAM_ERROR;
    goto return_label;
  }
  if (pStream->state) {
    (*(pStream->zfree))(pStream->opaque,(void *)pStream->state);
    pStream->state = (struct mz_internal_state *)0;
  }
  __retres = (int __attribute__((__visibility__("default"))))MZ_OK;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_uncompress2(unsigned char *pDest,
                                                              mz_ulong *pDest_len,
                                                              unsigned char const *pSource,
                                                              mz_ulong *pSource_len)
{
  int __attribute__((__visibility__("default"))) __retres;
  mz_stream stream;
  int status;
  int __attribute__((__visibility__("default"))) tmp_0;
  memset((void *)(& stream),0,sizeof(stream));
  if ((*pSource_len | *pDest_len) > (unsigned long)0xFFFFFFFFU) {
    __retres = (int __attribute__((__visibility__("default"))))MZ_PARAM_ERROR;
    goto return_label;
  }
  stream.next_in = pSource;
  stream.avail_in = (mz_uint32)*pSource_len;
  stream.next_out = pDest;
  stream.avail_out = (mz_uint32)*pDest_len;
  status = (int)mz_inflateInit(& stream);
  if (status != MZ_OK) {
    __retres = (int __attribute__((__visibility__("default"))))status;
    goto return_label;
  }
  status = (int)mz_inflate(& stream,MZ_FINISH);
  *pSource_len -= (mz_ulong)stream.avail_in;
  if (status != MZ_STREAM_END) {
    int tmp;
    mz_inflateEnd(& stream);
    if (status == MZ_BUF_ERROR) 
      if (! stream.avail_in) tmp = MZ_DATA_ERROR; else tmp = status;
    else tmp = status;
    __retres = (int __attribute__((__visibility__("default"))))tmp;
    goto return_label;
  }
  *pDest_len = stream.total_out;
  tmp_0 = mz_inflateEnd(& stream);
  __retres = tmp_0;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_uncompress(unsigned char *pDest,
                                                             mz_ulong *pDest_len,
                                                             unsigned char const *pSource,
                                                             mz_ulong source_len)
{
  int __attribute__((__visibility__("default"))) tmp;
  tmp = mz_uncompress2(pDest,pDest_len,pSource,& source_len);
  return tmp;
}

static struct __anonstruct_s_error_descs_25 mz_error_s_error_descs[10] =
  {{.m_err = MZ_OK, .m_pDesc = ""},
   {.m_err = MZ_STREAM_END, .m_pDesc = "stream end"},
   {.m_err = MZ_NEED_DICT, .m_pDesc = "need dictionary"},
   {.m_err = MZ_ERRNO, .m_pDesc = "file error"},
   {.m_err = MZ_STREAM_ERROR, .m_pDesc = "stream error"},
   {.m_err = MZ_DATA_ERROR, .m_pDesc = "data error"},
   {.m_err = MZ_MEM_ERROR, .m_pDesc = "out of memory"},
   {.m_err = MZ_BUF_ERROR, .m_pDesc = "buf error"},
   {.m_err = MZ_VERSION_ERROR, .m_pDesc = "version error"},
   {.m_err = MZ_PARAM_ERROR, .m_pDesc = "parameter error"}};
char const __attribute__((__visibility__("default"))) *mz_error(int err)
{
  char const __attribute__((__visibility__("default"))) *__retres;
  mz_uint i;
  i = (mz_uint)0;
  while ((unsigned long)i < sizeof(mz_error_s_error_descs) / sizeof(mz_error_s_error_descs[0])) {
    if (mz_error_s_error_descs[i].m_err == err) {
      __retres = (char const __attribute__((__visibility__("default"))) *)mz_error_s_error_descs[i].m_pDesc;
      goto return_label;
    }
    i ++;
  }
  __retres = (char const __attribute__((__visibility__("default"))) *)0;
  return_label: return __retres;
}

static mz_uint16 const s_tdefl_len_sym[256] =
  {(mz_uint16)257,
   (mz_uint16)258,
   (mz_uint16)259,
   (mz_uint16)260,
   (mz_uint16)261,
   (mz_uint16)262,
   (mz_uint16)263,
   (mz_uint16)264,
   (mz_uint16)265,
   (mz_uint16)265,
   (mz_uint16)266,
   (mz_uint16)266,
   (mz_uint16)267,
   (mz_uint16)267,
   (mz_uint16)268,
   (mz_uint16)268,
   (mz_uint16)269,
   (mz_uint16)269,
   (mz_uint16)269,
   (mz_uint16)269,
   (mz_uint16)270,
   (mz_uint16)270,
   (mz_uint16)270,
   (mz_uint16)270,
   (mz_uint16)271,
   (mz_uint16)271,
   (mz_uint16)271,
   (mz_uint16)271,
   (mz_uint16)272,
   (mz_uint16)272,
   (mz_uint16)272,
   (mz_uint16)272,
   (mz_uint16)273,
   (mz_uint16)273,
   (mz_uint16)273,
   (mz_uint16)273,
   (mz_uint16)273,
   (mz_uint16)273,
   (mz_uint16)273,
   (mz_uint16)273,
   (mz_uint16)274,
   (mz_uint16)274,
   (mz_uint16)274,
   (mz_uint16)274,
   (mz_uint16)274,
   (mz_uint16)274,
   (mz_uint16)274,
   (mz_uint16)274,
   (mz_uint16)275,
   (mz_uint16)275,
   (mz_uint16)275,
   (mz_uint16)275,
   (mz_uint16)275,
   (mz_uint16)275,
   (mz_uint16)275,
   (mz_uint16)275,
   (mz_uint16)276,
   (mz_uint16)276,
   (mz_uint16)276,
   (mz_uint16)276,
   (mz_uint16)276,
   (mz_uint16)276,
   (mz_uint16)276,
   (mz_uint16)276,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)277,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)278,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)279,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)280,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)281,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)282,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)283,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)284,
   (mz_uint16)285};
static mz_uint8 const s_tdefl_len_extra[256] =
  {(mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)0};
static mz_uint8 const s_tdefl_small_dist_sym[512] =
  {(mz_uint8)0,
   (mz_uint8)1,
   (mz_uint8)2,
   (mz_uint8)3,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)8,
   (mz_uint8)8,
   (mz_uint8)8,
   (mz_uint8)8,
   (mz_uint8)8,
   (mz_uint8)8,
   (mz_uint8)8,
   (mz_uint8)8,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)14,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)15,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)16,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17,
   (mz_uint8)17};
static mz_uint8 const s_tdefl_small_dist_extra[512] =
  {(mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)1,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)2,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)3,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)4,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)5,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)6,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7,
   (mz_uint8)7};
static mz_uint8 const s_tdefl_large_dist_sym[128] =
  {(mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)18,
   (mz_uint8)19,
   (mz_uint8)20,
   (mz_uint8)20,
   (mz_uint8)21,
   (mz_uint8)21,
   (mz_uint8)22,
   (mz_uint8)22,
   (mz_uint8)22,
   (mz_uint8)22,
   (mz_uint8)23,
   (mz_uint8)23,
   (mz_uint8)23,
   (mz_uint8)23,
   (mz_uint8)24,
   (mz_uint8)24,
   (mz_uint8)24,
   (mz_uint8)24,
   (mz_uint8)24,
   (mz_uint8)24,
   (mz_uint8)24,
   (mz_uint8)24,
   (mz_uint8)25,
   (mz_uint8)25,
   (mz_uint8)25,
   (mz_uint8)25,
   (mz_uint8)25,
   (mz_uint8)25,
   (mz_uint8)25,
   (mz_uint8)25,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)26,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)27,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)28,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29,
   (mz_uint8)29};
static mz_uint8 const s_tdefl_large_dist_extra[128] =
  {(mz_uint8)0,
   (mz_uint8)0,
   (mz_uint8)8,
   (mz_uint8)8,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)9,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)10,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)11,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)12,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13,
   (mz_uint8)13};
static tdefl_sym_freq *tdefl_radix_sort_syms(mz_uint num_syms,
                                             tdefl_sym_freq *pSyms0,
                                             tdefl_sym_freq *pSyms1)
{
  mz_uint32 pass_shift;
  mz_uint32 pass;
  mz_uint32 i;
  mz_uint32 hist[256 * 2];
  mz_uint32 total_passes = (mz_uint32)2;
  tdefl_sym_freq *pCur_syms = pSyms0;
  tdefl_sym_freq *pNew_syms = pSyms1;
  memset((void *)(& hist),0,sizeof(hist));
  i = (mz_uint32)0;
  while (i < num_syms) {
    {
      mz_uint freq = (mz_uint)(pSyms0 + i)->m_key;
      (hist[freq & (unsigned int)0xFF]) ++;
      (hist[(unsigned int)256 + ((freq >> 8) & (unsigned int)0xFF)]) ++;
    }
    i ++;
  }
  while (1) {
    if (total_passes > (mz_uint32)1) {
      if (! (num_syms == hist[(total_passes - (mz_uint32)1) * (mz_uint32)256])) 
        break;
    }
    else break;
    total_passes --;
  }
  pass_shift = (mz_uint32)0;
  pass = (mz_uint32)0;
  while (pass < total_passes) {
    {
      mz_uint offsets[256];
      mz_uint32 const *pHist = (mz_uint32 const *)(& hist[pass << 8]);
      mz_uint cur_ofs = (mz_uint)0;
      i = (mz_uint32)0;
      while (i < (mz_uint32)256) {
        offsets[i] = cur_ofs;
        cur_ofs += *(pHist + i);
        i ++;
      }
      i = (mz_uint32)0;
      while (i < num_syms) {
        mz_uint tmp;
        tmp = offsets[((int)(pCur_syms + i)->m_key >> pass_shift) & 0xFF];
        (offsets[((int)(pCur_syms + i)->m_key >> pass_shift) & 0xFF]) ++;
        *(pNew_syms + tmp) = *(pCur_syms + i);
        i ++;
      }
      {
        tdefl_sym_freq *t = pCur_syms;
        pCur_syms = pNew_syms;
        pNew_syms = t;
      }
    }
    pass ++;
    pass_shift += (mz_uint32)8;
  }
  return pCur_syms;
}

static void tdefl_calculate_minimum_redundancy(tdefl_sym_freq *A, int n)
{
  int root;
  int leaf;
  int next;
  int avbl;
  int used;
  int dpth;
  if (n == 0) goto return_label;
  else 
    if (n == 1) {
      (A + 0)->m_key = (mz_uint16)1;
      goto return_label;
    }
  (A + 0)->m_key = (mz_uint16)((int)(A + 0)->m_key + (int)(A + 1)->m_key);
  root = 0;
  leaf = 2;
  next = 1;
  while (next < n - 1) {
    if (leaf >= n) goto _LOR;
    else 
      if ((int)(A + root)->m_key < (int)(A + leaf)->m_key) {
        _LOR:
        {
          int tmp;
          (A + next)->m_key = (A + root)->m_key;
          tmp = root;
          root ++;
          (A + tmp)->m_key = (mz_uint16)next;
        }
      }
      else {
        int tmp_0;
        tmp_0 = leaf;
        leaf ++;
        (A + next)->m_key = (A + tmp_0)->m_key;
      }
    if (leaf >= n) goto _LOR_0;
    else 
      if (root < next) {
        if ((int)(A + root)->m_key < (int)(A + leaf)->m_key) {
          _LOR_0:
          {
            int tmp_1;
            (A + next)->m_key = (mz_uint16)((int)(A + next)->m_key + (int)(
                                            A + root)->m_key);
            tmp_1 = root;
            root ++;
            (A + tmp_1)->m_key = (mz_uint16)next;
          }
        }
        else goto _LAND;
      }
      else {
        int tmp_2;
        _LAND:
        { /* sequence */
          tmp_2 = leaf;
          leaf ++;
          (A + next)->m_key = (mz_uint16)((int)(A + next)->m_key + (int)(
                                          A + tmp_2)->m_key);
        }
      }
    next ++;
  }
  (A + (n - 2))->m_key = (mz_uint16)0;
  next = n - 3;
  while (next >= 0) {
    (A + next)->m_key = (mz_uint16)((int)(A + (A + next)->m_key)->m_key + 1);
    next --;
  }
  avbl = 1;
  dpth = 0;
  used = dpth;
  root = n - 2;
  next = n - 1;
  while (avbl > 0) {
    while (1) {
      if (root >= 0) {
        if (! ((int)(A + root)->m_key == dpth)) break;
      }
      else break;
      used ++;
      root --;
    }
    while (avbl > used) {
      int tmp_3;
      tmp_3 = next;
      next --;
      (A + tmp_3)->m_key = (mz_uint16)dpth;
      avbl --;
    }
    avbl = 2 * used;
    dpth ++;
    used = 0;
  }
  return_label: return;
}

static void tdefl_huffman_enforce_max_code_size(int *pNum_codes,
                                                int code_list_len,
                                                int max_code_size)
{
  int i;
  mz_uint32 total = (mz_uint32)0;
  if (code_list_len <= 1) goto return_label;
  i = max_code_size + 1;
  while (i <= TDEFL_MAX_SUPPORTED_HUFF_CODESIZE) {
    *(pNum_codes + max_code_size) += *(pNum_codes + i);
    i ++;
  }
  i = max_code_size;
  while (i > 0) {
    total += (mz_uint32)*(pNum_codes + i) << (max_code_size - i);
    i --;
  }
  while ((unsigned long)total != 1UL << max_code_size) {
    (*(pNum_codes + max_code_size)) --;
    i = max_code_size - 1;
    while (i > 0) {
      if (*(pNum_codes + i)) {
        (*(pNum_codes + i)) --;
        *(pNum_codes + (i + 1)) += 2;
        break;
      }
      i --;
    }
    total --;
  }
  return_label: return;
}

static void tdefl_optimize_huffman_table(tdefl_compressor *d, int table_num,
                                         int table_len, int code_size_limit,
                                         int static_table)
{
  int i;
  int j;
  int l;
  int num_codes[1 + TDEFL_MAX_SUPPORTED_HUFF_CODESIZE];
  mz_uint next_code[TDEFL_MAX_SUPPORTED_HUFF_CODESIZE + 1];
  memset((void *)(& num_codes),0,sizeof(num_codes));
  if (static_table) {
    i = 0;
    while (i < table_len) {
      (num_codes[d->m_huff_code_sizes[table_num][i]]) ++;
      i ++;
    }
  }
  else {
    tdefl_sym_freq syms0[TDEFL_MAX_HUFF_SYMBOLS];
    tdefl_sym_freq syms1[TDEFL_MAX_HUFF_SYMBOLS];
    tdefl_sym_freq *pSyms;
    int num_used_syms = 0;
    mz_uint16 const *pSym_count =
      (mz_uint16 const *)(& d->m_huff_count[table_num][0]);
    i = 0;
    while (i < table_len) {
      if (*(pSym_count + i)) {
        int tmp;
        syms0[num_used_syms].m_key = *(pSym_count + i);
        tmp = num_used_syms;
        num_used_syms ++;
        syms0[tmp].m_sym_index = (mz_uint16)i;
      }
      i ++;
    }
    pSyms = tdefl_radix_sort_syms((mz_uint)num_used_syms,syms0,syms1);
    tdefl_calculate_minimum_redundancy(pSyms,num_used_syms);
    i = 0;
    while (i < num_used_syms) {
      (num_codes[(pSyms + i)->m_key]) ++;
      i ++;
    }
    tdefl_huffman_enforce_max_code_size(num_codes,num_used_syms,
                                        code_size_limit);
    memset((void *)(& d->m_huff_code_sizes[table_num]),0,
           sizeof(d->m_huff_code_sizes[table_num]));
    memset((void *)(& d->m_huff_codes[table_num]),0,
           sizeof(d->m_huff_codes[table_num]));
    i = 1;
    j = num_used_syms;
    while (i <= code_size_limit) {
      l = num_codes[i];
      while (l > 0) {
        j --;
        d->m_huff_code_sizes[table_num][(pSyms + j)->m_sym_index] = (mz_uint8)i;
        l --;
      }
      i ++;
    }
  }
  next_code[1] = (mz_uint)0;
  j = 0;
  i = 2;
  while (i <= code_size_limit) {
    j = (j + num_codes[i - 1]) << 1;
    next_code[i] = (mz_uint)j;
    i ++;
  }
  i = 0;
  while (i < table_len) {
    {
      mz_uint code;
      mz_uint code_size;
      mz_uint tmp_0;
      mz_uint rev_code = (mz_uint)0;
      code_size = (mz_uint)d->m_huff_code_sizes[table_num][i];
      if (code_size == (mz_uint)0) goto __Cont;
      tmp_0 = next_code[code_size];
      (next_code[code_size]) ++;
      code = tmp_0;
      l = (int)code_size;
      while (l > 0) {
        rev_code = (rev_code << 1) | (code & (unsigned int)1);
        l --;
        code >>= 1;
      }
      d->m_huff_codes[table_num][i] = (mz_uint16)rev_code;
    }
    __Cont: i ++;
  }
  return;
}

static mz_uint8 s_tdefl_packed_code_size_syms_swizzle[19] =
  {(mz_uint8)16,
   (mz_uint8)17,
   (mz_uint8)18,
   (mz_uint8)0,
   (mz_uint8)8,
   (mz_uint8)7,
   (mz_uint8)9,
   (mz_uint8)6,
   (mz_uint8)10,
   (mz_uint8)5,
   (mz_uint8)11,
   (mz_uint8)4,
   (mz_uint8)12,
   (mz_uint8)3,
   (mz_uint8)13,
   (mz_uint8)2,
   (mz_uint8)14,
   (mz_uint8)1,
   (mz_uint8)15};
static void tdefl_start_dynamic_block(tdefl_compressor *d)
{
  int num_lit_codes;
  int num_dist_codes;
  int num_bit_lengths;
  mz_uint i;
  mz_uint total_code_sizes_to_pack;
  mz_uint num_packed_code_sizes;
  mz_uint rle_z_count;
  mz_uint rle_repeat_count;
  mz_uint packed_code_sizes_index;
  mz_uint8 code_sizes_to_pack[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1];
  mz_uint8 packed_code_sizes[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1];
  mz_uint8 prev_code_size = (mz_uint8)0xFF;
  d->m_huff_count[0][256] = (mz_uint16)1;
  tdefl_optimize_huffman_table(d,0,TDEFL_MAX_HUFF_SYMBOLS_0,15,0);
  tdefl_optimize_huffman_table(d,1,TDEFL_MAX_HUFF_SYMBOLS_1,15,0);
  num_lit_codes = 286;
  while (num_lit_codes > 257) {
    if (d->m_huff_code_sizes[0][num_lit_codes - 1]) break;
    num_lit_codes --;
  }
  num_dist_codes = 30;
  while (num_dist_codes > 1) {
    if (d->m_huff_code_sizes[1][num_dist_codes - 1]) break;
    num_dist_codes --;
  }
  memcpy((void *)(code_sizes_to_pack),
         (void const *)(& d->m_huff_code_sizes[0][0]),(size_t)num_lit_codes);
  memcpy((void *)(& code_sizes_to_pack[num_lit_codes]),
         (void const *)(& d->m_huff_code_sizes[1][0]),(size_t)num_dist_codes);
  total_code_sizes_to_pack = (mz_uint)(num_lit_codes + num_dist_codes);
  num_packed_code_sizes = (mz_uint)0;
  rle_z_count = (mz_uint)0;
  rle_repeat_count = (mz_uint)0;
  memset((void *)(& d->m_huff_count[2][0]),0,
         sizeof(d->m_huff_count[2][0]) * (unsigned long)TDEFL_MAX_HUFF_SYMBOLS_2);
  i = (mz_uint)0;
  while (i < total_code_sizes_to_pack) {
    {
      mz_uint8 code_size = code_sizes_to_pack[i];
      if (! code_size) {
        if (rle_repeat_count) {
          if (rle_repeat_count < (mz_uint)3) {
            d->m_huff_count[2][prev_code_size] = (mz_uint16)((mz_uint)d->m_huff_count[2][prev_code_size] + rle_repeat_count);
            while (1) {
              mz_uint tmp_0;
              mz_uint tmp;
              tmp_0 = rle_repeat_count;
              rle_repeat_count --;
              ;
              if (! tmp_0) break;
              tmp = num_packed_code_sizes;
              num_packed_code_sizes ++;
              packed_code_sizes[tmp] = prev_code_size;
            }
          }
          else {
            mz_uint tmp_1;
            mz_uint tmp_2;
            d->m_huff_count[2][16] = (mz_uint16)((int)d->m_huff_count[2][16] + 1);
            tmp_1 = num_packed_code_sizes;
            num_packed_code_sizes ++;
            packed_code_sizes[tmp_1] = (mz_uint8)16;
            tmp_2 = num_packed_code_sizes;
            num_packed_code_sizes ++;
            packed_code_sizes[tmp_2] = (mz_uint8)(rle_repeat_count - (mz_uint)3);
          }
          rle_repeat_count = (mz_uint)0;
        }
        rle_z_count ++;
        if (rle_z_count == (mz_uint)138) 
          if (rle_z_count) {
            if (rle_z_count < (mz_uint)3) {
              d->m_huff_count[2][0] = (mz_uint16)((mz_uint)d->m_huff_count[2][0] + rle_z_count);
              while (1) {
                mz_uint tmp_4;
                mz_uint tmp_3;
                tmp_4 = rle_z_count;
                rle_z_count --;
                ;
                if (! tmp_4) break;
                tmp_3 = num_packed_code_sizes;
                num_packed_code_sizes ++;
                packed_code_sizes[tmp_3] = (mz_uint8)0;
              }
            }
            else 
              if (rle_z_count <= (mz_uint)10) {
                mz_uint tmp_5;
                mz_uint tmp_6;
                d->m_huff_count[2][17] = (mz_uint16)((int)d->m_huff_count[2][17] + 1);
                tmp_5 = num_packed_code_sizes;
                num_packed_code_sizes ++;
                packed_code_sizes[tmp_5] = (mz_uint8)17;
                tmp_6 = num_packed_code_sizes;
                num_packed_code_sizes ++;
                packed_code_sizes[tmp_6] = (mz_uint8)(rle_z_count - (mz_uint)3);
              }
              else {
                mz_uint tmp_7;
                mz_uint tmp_8;
                d->m_huff_count[2][18] = (mz_uint16)((int)d->m_huff_count[2][18] + 1);
                tmp_7 = num_packed_code_sizes;
                num_packed_code_sizes ++;
                packed_code_sizes[tmp_7] = (mz_uint8)18;
                tmp_8 = num_packed_code_sizes;
                num_packed_code_sizes ++;
                packed_code_sizes[tmp_8] = (mz_uint8)(rle_z_count - (mz_uint)11);
              }
            rle_z_count = (mz_uint)0;
          }
      }
      else {
        if (rle_z_count) {
          if (rle_z_count < (mz_uint)3) {
            d->m_huff_count[2][0] = (mz_uint16)((mz_uint)d->m_huff_count[2][0] + rle_z_count);
            while (1) {
              mz_uint tmp_10;
              mz_uint tmp_9;
              tmp_10 = rle_z_count;
              rle_z_count --;
              ;
              if (! tmp_10) break;
              tmp_9 = num_packed_code_sizes;
              num_packed_code_sizes ++;
              packed_code_sizes[tmp_9] = (mz_uint8)0;
            }
          }
          else 
            if (rle_z_count <= (mz_uint)10) {
              mz_uint tmp_11;
              mz_uint tmp_12;
              d->m_huff_count[2][17] = (mz_uint16)((int)d->m_huff_count[2][17] + 1);
              tmp_11 = num_packed_code_sizes;
              num_packed_code_sizes ++;
              packed_code_sizes[tmp_11] = (mz_uint8)17;
              tmp_12 = num_packed_code_sizes;
              num_packed_code_sizes ++;
              packed_code_sizes[tmp_12] = (mz_uint8)(rle_z_count - (mz_uint)3);
            }
            else {
              mz_uint tmp_13;
              mz_uint tmp_14;
              d->m_huff_count[2][18] = (mz_uint16)((int)d->m_huff_count[2][18] + 1);
              tmp_13 = num_packed_code_sizes;
              num_packed_code_sizes ++;
              packed_code_sizes[tmp_13] = (mz_uint8)18;
              tmp_14 = num_packed_code_sizes;
              num_packed_code_sizes ++;
              packed_code_sizes[tmp_14] = (mz_uint8)(rle_z_count - (mz_uint)11);
            }
          rle_z_count = (mz_uint)0;
        }
        if ((int)code_size != (int)prev_code_size) {
          mz_uint tmp_19;
          if (rle_repeat_count) {
            if (rle_repeat_count < (mz_uint)3) {
              d->m_huff_count[2][prev_code_size] = (mz_uint16)((mz_uint)d->m_huff_count[2][prev_code_size] + rle_repeat_count);
              while (1) {
                mz_uint tmp_16;
                mz_uint tmp_15;
                tmp_16 = rle_repeat_count;
                rle_repeat_count --;
                ;
                if (! tmp_16) break;
                tmp_15 = num_packed_code_sizes;
                num_packed_code_sizes ++;
                packed_code_sizes[tmp_15] = prev_code_size;
              }
            }
            else {
              mz_uint tmp_17;
              mz_uint tmp_18;
              d->m_huff_count[2][16] = (mz_uint16)((int)d->m_huff_count[2][16] + 1);
              tmp_17 = num_packed_code_sizes;
              num_packed_code_sizes ++;
              packed_code_sizes[tmp_17] = (mz_uint8)16;
              tmp_18 = num_packed_code_sizes;
              num_packed_code_sizes ++;
              packed_code_sizes[tmp_18] = (mz_uint8)(rle_repeat_count - (mz_uint)3);
            }
            rle_repeat_count = (mz_uint)0;
          }
          d->m_huff_count[2][code_size] = (mz_uint16)((int)d->m_huff_count[2][code_size] + 1);
          tmp_19 = num_packed_code_sizes;
          num_packed_code_sizes ++;
          packed_code_sizes[tmp_19] = code_size;
        }
        else {
          rle_repeat_count ++;
          if (rle_repeat_count == (mz_uint)6) 
            if (rle_repeat_count) {
              if (rle_repeat_count < (mz_uint)3) {
                d->m_huff_count[2][prev_code_size] = (mz_uint16)((mz_uint)d->m_huff_count[2][prev_code_size] + rle_repeat_count);
                while (1) {
                  mz_uint tmp_21;
                  mz_uint tmp_20;
                  tmp_21 = rle_repeat_count;
                  rle_repeat_count --;
                  ;
                  if (! tmp_21) break;
                  tmp_20 = num_packed_code_sizes;
                  num_packed_code_sizes ++;
                  packed_code_sizes[tmp_20] = prev_code_size;
                }
              }
              else {
                mz_uint tmp_22;
                mz_uint tmp_23;
                d->m_huff_count[2][16] = (mz_uint16)((int)d->m_huff_count[2][16] + 1);
                tmp_22 = num_packed_code_sizes;
                num_packed_code_sizes ++;
                packed_code_sizes[tmp_22] = (mz_uint8)16;
                tmp_23 = num_packed_code_sizes;
                num_packed_code_sizes ++;
                packed_code_sizes[tmp_23] = (mz_uint8)(rle_repeat_count - (mz_uint)3);
              }
              rle_repeat_count = (mz_uint)0;
            }
        }
      }
      prev_code_size = code_size;
    }
    i ++;
  }
  if (rle_repeat_count) {
    if (rle_repeat_count) {
      if (rle_repeat_count < (mz_uint)3) {
        d->m_huff_count[2][prev_code_size] = (mz_uint16)((mz_uint)d->m_huff_count[2][prev_code_size] + rle_repeat_count);
        while (1) {
          mz_uint tmp_25;
          mz_uint tmp_24;
          tmp_25 = rle_repeat_count;
          rle_repeat_count --;
          ;
          if (! tmp_25) break;
          tmp_24 = num_packed_code_sizes;
          num_packed_code_sizes ++;
          packed_code_sizes[tmp_24] = prev_code_size;
        }
      }
      else {
        mz_uint tmp_26;
        mz_uint tmp_27;
        d->m_huff_count[2][16] = (mz_uint16)((int)d->m_huff_count[2][16] + 1);
        tmp_26 = num_packed_code_sizes;
        num_packed_code_sizes ++;
        packed_code_sizes[tmp_26] = (mz_uint8)16;
        tmp_27 = num_packed_code_sizes;
        num_packed_code_sizes ++;
        packed_code_sizes[tmp_27] = (mz_uint8)(rle_repeat_count - (mz_uint)3);
      }
      rle_repeat_count = (mz_uint)0;
    }
  }
  else 
    if (rle_z_count) {
      if (rle_z_count < (mz_uint)3) {
        d->m_huff_count[2][0] = (mz_uint16)((mz_uint)d->m_huff_count[2][0] + rle_z_count);
        while (1) {
          mz_uint tmp_29;
          mz_uint tmp_28;
          tmp_29 = rle_z_count;
          rle_z_count --;
          ;
          if (! tmp_29) break;
          tmp_28 = num_packed_code_sizes;
          num_packed_code_sizes ++;
          packed_code_sizes[tmp_28] = (mz_uint8)0;
        }
      }
      else 
        if (rle_z_count <= (mz_uint)10) {
          mz_uint tmp_30;
          mz_uint tmp_31;
          d->m_huff_count[2][17] = (mz_uint16)((int)d->m_huff_count[2][17] + 1);
          tmp_30 = num_packed_code_sizes;
          num_packed_code_sizes ++;
          packed_code_sizes[tmp_30] = (mz_uint8)17;
          tmp_31 = num_packed_code_sizes;
          num_packed_code_sizes ++;
          packed_code_sizes[tmp_31] = (mz_uint8)(rle_z_count - (mz_uint)3);
        }
        else {
          mz_uint tmp_32;
          mz_uint tmp_33;
          d->m_huff_count[2][18] = (mz_uint16)((int)d->m_huff_count[2][18] + 1);
          tmp_32 = num_packed_code_sizes;
          num_packed_code_sizes ++;
          packed_code_sizes[tmp_32] = (mz_uint8)18;
          tmp_33 = num_packed_code_sizes;
          num_packed_code_sizes ++;
          packed_code_sizes[tmp_33] = (mz_uint8)(rle_z_count - (mz_uint)11);
        }
      rle_z_count = (mz_uint)0;
    }
  tdefl_optimize_huffman_table(d,2,TDEFL_MAX_HUFF_SYMBOLS_2,7,0);
  {
    mz_uint bits = (mz_uint)2;
    mz_uint len = (mz_uint)2;
    __FC_assert((bits <= (1U << len) - 1U) != 0,"miniz_tdef.c",404,
                "bits <= ((1U << len) - 1U)");
    d->m_bit_buffer |= bits << d->m_bits_in;
    d->m_bits_in += len;
    while (d->m_bits_in >= (mz_uint)8) {
      if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
        mz_uint8 *tmp_34;
        tmp_34 = d->m_pOutput_buf;
        (d->m_pOutput_buf) ++;
        *tmp_34 = (mz_uint8)d->m_bit_buffer;
      }
      d->m_bit_buffer >>= 8;
      d->m_bits_in -= (mz_uint)8;
    }
  }
  {
    mz_uint bits_0 = (mz_uint)(num_lit_codes - 257);
    mz_uint len_0 = (mz_uint)5;
    __FC_assert((bits_0 <= (1U << len_0) - 1U) != 0,"miniz_tdef.c",406,
                "bits <= ((1U << len) - 1U)");
    d->m_bit_buffer |= bits_0 << d->m_bits_in;
    d->m_bits_in += len_0;
    while (d->m_bits_in >= (mz_uint)8) {
      if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
        mz_uint8 *tmp_35;
        tmp_35 = d->m_pOutput_buf;
        (d->m_pOutput_buf) ++;
        *tmp_35 = (mz_uint8)d->m_bit_buffer;
      }
      d->m_bit_buffer >>= 8;
      d->m_bits_in -= (mz_uint)8;
    }
  }
  {
    mz_uint bits_1 = (mz_uint)(num_dist_codes - 1);
    mz_uint len_1 = (mz_uint)5;
    __FC_assert((bits_1 <= (1U << len_1) - 1U) != 0,"miniz_tdef.c",407,
                "bits <= ((1U << len) - 1U)");
    d->m_bit_buffer |= bits_1 << d->m_bits_in;
    d->m_bits_in += len_1;
    while (d->m_bits_in >= (mz_uint)8) {
      if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
        mz_uint8 *tmp_36;
        tmp_36 = d->m_pOutput_buf;
        (d->m_pOutput_buf) ++;
        *tmp_36 = (mz_uint8)d->m_bit_buffer;
      }
      d->m_bit_buffer >>= 8;
      d->m_bits_in -= (mz_uint)8;
    }
  }
  num_bit_lengths = 18;
  while (num_bit_lengths >= 0) {
    if (d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[num_bit_lengths]]) 
      break;
    num_bit_lengths --;
  }
  if (4 > num_bit_lengths + 1) num_bit_lengths = 4; else num_bit_lengths ++;
  {
    mz_uint bits_2 = (mz_uint)(num_bit_lengths - 4);
    mz_uint len_2 = (mz_uint)4;
    __FC_assert((bits_2 <= (1U << len_2) - 1U) != 0,"miniz_tdef.c",413,
                "bits <= ((1U << len) - 1U)");
    d->m_bit_buffer |= bits_2 << d->m_bits_in;
    d->m_bits_in += len_2;
    while (d->m_bits_in >= (mz_uint)8) {
      if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
        mz_uint8 *tmp_37;
        tmp_37 = d->m_pOutput_buf;
        (d->m_pOutput_buf) ++;
        *tmp_37 = (mz_uint8)d->m_bit_buffer;
      }
      d->m_bit_buffer >>= 8;
      d->m_bits_in -= (mz_uint)8;
    }
  }
  i = (mz_uint)0;
  while ((int)i < num_bit_lengths) {
    {
      mz_uint bits_3 =
        (mz_uint)d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[i]];
      mz_uint len_3 = (mz_uint)3;
      __FC_assert((bits_3 <= (1U << len_3) - 1U) != 0,"miniz_tdef.c",415,
                  "bits <= ((1U << len) - 1U)");
      d->m_bit_buffer |= bits_3 << d->m_bits_in;
      d->m_bits_in += len_3;
      while (d->m_bits_in >= (mz_uint)8) {
        if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
          mz_uint8 *tmp_38;
          tmp_38 = d->m_pOutput_buf;
          (d->m_pOutput_buf) ++;
          *tmp_38 = (mz_uint8)d->m_bit_buffer;
        }
        d->m_bit_buffer >>= 8;
        d->m_bits_in -= (mz_uint)8;
      }
    }
    i ++;
  }
  packed_code_sizes_index = (mz_uint)0;
  while (packed_code_sizes_index < num_packed_code_sizes) {
    mz_uint tmp_39;
    tmp_39 = packed_code_sizes_index;
    packed_code_sizes_index ++;
    mz_uint code = (mz_uint)packed_code_sizes[tmp_39];
    __FC_assert((code < (mz_uint)TDEFL_MAX_HUFF_SYMBOLS_2) != 0,
                "miniz_tdef.c",420,"code < TDEFL_MAX_HUFF_SYMBOLS_2");
    {
      mz_uint bits_4 = (mz_uint)d->m_huff_codes[2][code];
      mz_uint len_4 = (mz_uint)d->m_huff_code_sizes[2][code];
      __FC_assert((bits_4 <= (1U << len_4) - 1U) != 0,"miniz_tdef.c",421,
                  "bits <= ((1U << len) - 1U)");
      d->m_bit_buffer |= bits_4 << d->m_bits_in;
      d->m_bits_in += len_4;
      while (d->m_bits_in >= (mz_uint)8) {
        if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
          mz_uint8 *tmp_40;
          tmp_40 = d->m_pOutput_buf;
          (d->m_pOutput_buf) ++;
          *tmp_40 = (mz_uint8)d->m_bit_buffer;
        }
        d->m_bit_buffer >>= 8;
        d->m_bits_in -= (mz_uint)8;
      }
    }
    if (code >= (mz_uint)16) {
      mz_uint tmp_41;
      tmp_41 = packed_code_sizes_index;
      packed_code_sizes_index ++;
      mz_uint bits_5 = (mz_uint)packed_code_sizes[tmp_41];
      mz_uint len_5 = (mz_uint)*("\002\003\a" + (code - (mz_uint)16));
      __FC_assert((bits_5 <= (1U << len_5) - 1U) != 0,"miniz_tdef.c",423,
                  "bits <= ((1U << len) - 1U)");
      d->m_bit_buffer |= bits_5 << d->m_bits_in;
      d->m_bits_in += len_5;
      while (d->m_bits_in >= (mz_uint)8) {
        if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
          mz_uint8 *tmp_42;
          tmp_42 = d->m_pOutput_buf;
          (d->m_pOutput_buf) ++;
          *tmp_42 = (mz_uint8)d->m_bit_buffer;
        }
        d->m_bit_buffer >>= 8;
        d->m_bits_in -= (mz_uint)8;
      }
    }
  }
  return;
}

static void tdefl_start_static_block(tdefl_compressor *d)
{
  mz_uint i;
  mz_uint8 *p = & d->m_huff_code_sizes[0][0];
  i = (mz_uint)0;
  while (i <= (mz_uint)143) {
    mz_uint8 *tmp;
    tmp = p;
    p ++;
    *tmp = (mz_uint8)8;
    i ++;
  }
  while (i <= (mz_uint)255) {
    mz_uint8 *tmp_0;
    tmp_0 = p;
    p ++;
    *tmp_0 = (mz_uint8)9;
    i ++;
  }
  while (i <= (mz_uint)279) {
    mz_uint8 *tmp_1;
    tmp_1 = p;
    p ++;
    *tmp_1 = (mz_uint8)7;
    i ++;
  }
  while (i <= (mz_uint)287) {
    mz_uint8 *tmp_2;
    tmp_2 = p;
    p ++;
    *tmp_2 = (mz_uint8)8;
    i ++;
  }
  memset((void *)(d->m_huff_code_sizes[1]),5,(size_t)32);
  tdefl_optimize_huffman_table(d,0,288,15,1);
  tdefl_optimize_huffman_table(d,1,32,15,1);
  {
    mz_uint bits = (mz_uint)1;
    mz_uint len = (mz_uint)2;
    __FC_assert((bits <= (1U << len) - 1U) != 0,"miniz_tdef.c",446,
                "bits <= ((1U << len) - 1U)");
    d->m_bit_buffer |= bits << d->m_bits_in;
    d->m_bits_in += len;
    while (d->m_bits_in >= (mz_uint)8) {
      if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
        mz_uint8 *tmp_3;
        tmp_3 = d->m_pOutput_buf;
        (d->m_pOutput_buf) ++;
        *tmp_3 = (mz_uint8)d->m_bit_buffer;
      }
      d->m_bit_buffer >>= 8;
      d->m_bits_in -= (mz_uint)8;
    }
  }
  return;
}

static mz_uint const mz_bitmasks[17] =
  {(mz_uint)0x0000,
   (mz_uint)0x0001,
   (mz_uint)0x0003,
   (mz_uint)0x0007,
   (mz_uint)0x000F,
   (mz_uint)0x001F,
   (mz_uint)0x003F,
   (mz_uint)0x007F,
   (mz_uint)0x00FF,
   (mz_uint)0x01FF,
   (mz_uint)0x03FF,
   (mz_uint)0x07FF,
   (mz_uint)0x0FFF,
   (mz_uint)0x1FFF,
   (mz_uint)0x3FFF,
   (mz_uint)0x7FFF,
   (mz_uint)0xFFFF};
static mz_bool tdefl_compress_lz_codes(tdefl_compressor *d)
{
  mz_bool __retres;
  mz_uint flags;
  mz_uint8 *pLZ_codes;
  mz_uint8 *pOutput_buf = d->m_pOutput_buf;
  mz_uint8 *pLZ_code_buf_end = d->m_pLZ_code_buf;
  mz_uint64 bit_buffer = (mz_uint64)d->m_bit_buffer;
  mz_uint bits_in = d->m_bits_in;
  flags = (mz_uint)1;
  pLZ_codes = d->m_lz_code_buf;
  while (pLZ_codes < pLZ_code_buf_end) {
    if (flags == (mz_uint)1) {
      mz_uint8 *tmp;
      tmp = pLZ_codes;
      pLZ_codes ++;
      flags = (mz_uint)((int)*tmp | 0x100);
    }
    if (flags & (unsigned int)1) {
      mz_uint s0;
      mz_uint s1;
      mz_uint n0;
      mz_uint n1;
      mz_uint sym;
      mz_uint num_extra_bits;
      mz_uint match_len = (mz_uint)*(pLZ_codes + 0);
      mz_uint match_dist = (mz_uint)*((mz_uint16 const *)(pLZ_codes + 1));
      pLZ_codes += 3;
      __FC_assert((int)d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]] != 0,
                  "miniz_tdef.c",479,
                  "d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]");
      bit_buffer |= (mz_uint64)d->m_huff_codes[0][s_tdefl_len_sym[match_len]] << bits_in;
      bits_in += (mz_uint)d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]];
      bit_buffer |= (mz_uint64)(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]]) << bits_in;
      bits_in += (mz_uint)s_tdefl_len_extra[match_len];
      s0 = (mz_uint)s_tdefl_small_dist_sym[match_dist & (unsigned int)511];
      n0 = (mz_uint)s_tdefl_small_dist_extra[match_dist & (unsigned int)511];
      s1 = (mz_uint)s_tdefl_large_dist_sym[match_dist >> 8];
      n1 = (mz_uint)s_tdefl_large_dist_extra[match_dist >> 8];
      if (match_dist < (mz_uint)512) sym = s0; else sym = s1;
      if (match_dist < (mz_uint)512) num_extra_bits = n0;
      else num_extra_bits = n1;
      __FC_assert((int)d->m_huff_code_sizes[1][sym] != 0,"miniz_tdef.c",491,
                  "d->m_huff_code_sizes[1][sym]");
      bit_buffer |= (mz_uint64)d->m_huff_codes[1][sym] << bits_in;
      bits_in += (mz_uint)d->m_huff_code_sizes[1][sym];
      bit_buffer |= (mz_uint64)(match_dist & mz_bitmasks[num_extra_bits]) << bits_in;
      bits_in += num_extra_bits;
    }
    else {
      mz_uint8 *tmp_0;
      tmp_0 = pLZ_codes;
      pLZ_codes ++;
      mz_uint lit = (mz_uint)*tmp_0;
      __FC_assert((int)d->m_huff_code_sizes[0][lit] != 0,"miniz_tdef.c",498,
                  "d->m_huff_code_sizes[0][lit]");
      bit_buffer |= (mz_uint64)d->m_huff_codes[0][lit] << bits_in;
      bits_in += (mz_uint)d->m_huff_code_sizes[0][lit];
      if ((flags & (unsigned int)2) == (unsigned int)0) 
        if (pLZ_codes < pLZ_code_buf_end) {
          mz_uint8 *tmp_1;
          flags >>= 1;
          tmp_1 = pLZ_codes;
          pLZ_codes ++;
          lit = (mz_uint)*tmp_1;
          __FC_assert((int)d->m_huff_code_sizes[0][lit] != 0,"miniz_tdef.c",
                      505,"d->m_huff_code_sizes[0][lit]");
          bit_buffer |= (mz_uint64)d->m_huff_codes[0][lit] << bits_in;
          bits_in += (mz_uint)d->m_huff_code_sizes[0][lit];
          if ((flags & (unsigned int)2) == (unsigned int)0) 
            if (pLZ_codes < pLZ_code_buf_end) {
              mz_uint8 *tmp_2;
              flags >>= 1;
              tmp_2 = pLZ_codes;
              pLZ_codes ++;
              lit = (mz_uint)*tmp_2;
              __FC_assert((int)d->m_huff_code_sizes[0][lit] != 0,
                          "miniz_tdef.c",512,"d->m_huff_code_sizes[0][lit]");
              bit_buffer |= (mz_uint64)d->m_huff_codes[0][lit] << bits_in;
              bits_in += (mz_uint)d->m_huff_code_sizes[0][lit];
            }
        }
    }
    if (pOutput_buf >= d->m_pOutput_buf_end) {
      __retres = 0;
      goto return_label;
    }
    *((mz_uint64 *)pOutput_buf) = bit_buffer;
    pOutput_buf += bits_in >> 3;
    bit_buffer >>= bits_in & (unsigned int)(~ 7);
    bits_in &= (unsigned int)7;
    flags >>= 1;
  }
  d->m_pOutput_buf = pOutput_buf;
  d->m_bits_in = (mz_uint)0;
  d->m_bit_buffer = (mz_uint)0;
  while (bits_in) {
    mz_uint tmp_3;
    if (bits_in < (mz_uint)16) tmp_3 = bits_in; else tmp_3 = (mz_uint)16;
    mz_uint32 n = tmp_3;
    {
      mz_uint bits = (mz_uint)bit_buffer & mz_bitmasks[n];
      mz_uint len = n;
      __FC_assert((bits <= (1U << len) - 1U) != 0,"miniz_tdef.c",536,
                  "bits <= ((1U << len) - 1U)");
      d->m_bit_buffer |= bits << d->m_bits_in;
      d->m_bits_in += len;
      while (d->m_bits_in >= (mz_uint)8) {
        if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
          mz_uint8 *tmp_4;
          tmp_4 = d->m_pOutput_buf;
          (d->m_pOutput_buf) ++;
          *tmp_4 = (mz_uint8)d->m_bit_buffer;
        }
        d->m_bit_buffer >>= 8;
        d->m_bits_in -= (mz_uint)8;
      }
    }
    bit_buffer >>= n;
    bits_in -= n;
  }
  {
    mz_uint bits_0 = (mz_uint)d->m_huff_codes[0][256];
    mz_uint len_0 = (mz_uint)d->m_huff_code_sizes[0][256];
    __FC_assert((bits_0 <= (1U << len_0) - 1U) != 0,"miniz_tdef.c",541,
                "bits <= ((1U << len) - 1U)");
    d->m_bit_buffer |= bits_0 << d->m_bits_in;
    d->m_bits_in += len_0;
    while (d->m_bits_in >= (mz_uint)8) {
      if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
        mz_uint8 *tmp_5;
        tmp_5 = d->m_pOutput_buf;
        (d->m_pOutput_buf) ++;
        *tmp_5 = (mz_uint8)d->m_bit_buffer;
      }
      d->m_bit_buffer >>= 8;
      d->m_bits_in -= (mz_uint)8;
    }
  }
  __retres = d->m_pOutput_buf < d->m_pOutput_buf_end;
  return_label: return __retres;
}

static mz_bool tdefl_compress_block(tdefl_compressor *d, mz_bool static_block)
{
  mz_bool tmp;
  if (static_block) tdefl_start_static_block(d);
  else tdefl_start_dynamic_block(d);
  tmp = tdefl_compress_lz_codes(d);
  return tmp;
}

static int tdefl_flush_block(tdefl_compressor *d, int flush)
{
  int __retres;
  mz_uint saved_bit_buf;
  mz_uint saved_bits_in;
  mz_uint8 *pSaved_output_buf;
  int n;
  int tmp;
  mz_uint8 *tmp_0;
  mz_bool comp_block_succeeded = 0;
  if ((d->m_flags & (unsigned int)TDEFL_FORCE_ALL_RAW_BLOCKS) != (unsigned int)0) 
    if (d->m_lookahead_pos - d->m_lz_code_buf_dict_pos <= d->m_dict_size) 
      tmp = 1;
    else tmp = 0;
  else tmp = 0;
  int use_raw_block = tmp;
  if (d->m_pPut_buf_func == (mz_bool (*)(void const *pBuf, int len,
                                         void *pUser))0) 
    if (*(d->m_pOut_buf_size) - d->m_out_buf_ofs >= (size_t)TDEFL_OUT_BUF_SIZE) 
      tmp_0 = (mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs;
    else tmp_0 = d->m_output_buf;
  else tmp_0 = d->m_output_buf;
  mz_uint8 *pOutput_buf_start = tmp_0;
  d->m_pOutput_buf = pOutput_buf_start;
  d->m_pOutput_buf_end = (d->m_pOutput_buf + TDEFL_OUT_BUF_SIZE) - 16;
  __FC_assert(! d->m_output_flush_remaining != 0,"miniz_tdef.c",614,
              "!d->m_output_flush_remaining");
  d->m_output_flush_ofs = (mz_uint)0;
  d->m_output_flush_remaining = (mz_uint)0;
  *(d->m_pLZ_flags) = (mz_uint8)((int)*(d->m_pLZ_flags) >> d->m_num_flags_left);
  d->m_pLZ_code_buf -= d->m_num_flags_left == (mz_uint)8;
  if (d->m_flags & (unsigned int)TDEFL_WRITE_ZLIB_HEADER) 
    if (! d->m_block_index) {
      {
        mz_uint bits = (mz_uint)0x78;
        mz_uint len = (mz_uint)8;
        __FC_assert((bits <= (1U << len) - 1U) != 0,"miniz_tdef.c",623,
                    "bits <= ((1U << len) - 1U)");
        d->m_bit_buffer |= bits << d->m_bits_in;
        d->m_bits_in += len;
        while (d->m_bits_in >= (mz_uint)8) {
          if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
            mz_uint8 *tmp_1;
            tmp_1 = d->m_pOutput_buf;
            (d->m_pOutput_buf) ++;
            *tmp_1 = (mz_uint8)d->m_bit_buffer;
          }
          d->m_bit_buffer >>= 8;
          d->m_bits_in -= (mz_uint)8;
        }
      }
      {
        mz_uint bits_0 = (mz_uint)0x01;
        mz_uint len_0 = (mz_uint)8;
        __FC_assert((bits_0 <= (1U << len_0) - 1U) != 0,"miniz_tdef.c",624,
                    "bits <= ((1U << len) - 1U)");
        d->m_bit_buffer |= bits_0 << d->m_bits_in;
        d->m_bits_in += len_0;
        while (d->m_bits_in >= (mz_uint)8) {
          if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
            mz_uint8 *tmp_2;
            tmp_2 = d->m_pOutput_buf;
            (d->m_pOutput_buf) ++;
            *tmp_2 = (mz_uint8)d->m_bit_buffer;
          }
          d->m_bit_buffer >>= 8;
          d->m_bits_in -= (mz_uint)8;
        }
      }
    }
  {
    mz_uint bits_1 = (mz_uint)(flush == TDEFL_FINISH);
    mz_uint len_1 = (mz_uint)1;
    __FC_assert((bits_1 <= (1U << len_1) - 1U) != 0,"miniz_tdef.c",627,
                "bits <= ((1U << len) - 1U)");
    d->m_bit_buffer |= bits_1 << d->m_bits_in;
    d->m_bits_in += len_1;
    while (d->m_bits_in >= (mz_uint)8) {
      if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
        mz_uint8 *tmp_3;
        tmp_3 = d->m_pOutput_buf;
        (d->m_pOutput_buf) ++;
        *tmp_3 = (mz_uint8)d->m_bit_buffer;
      }
      d->m_bit_buffer >>= 8;
      d->m_bits_in -= (mz_uint)8;
    }
  }
  pSaved_output_buf = d->m_pOutput_buf;
  saved_bit_buf = d->m_bit_buffer;
  saved_bits_in = d->m_bits_in;
  if (! use_raw_block) {
    int tmp_4;
    if (d->m_flags & (unsigned int)TDEFL_FORCE_ALL_STATIC_BLOCKS) tmp_4 = 1;
    else 
      if (d->m_total_lz_bytes < (mz_uint)48) tmp_4 = 1; else tmp_4 = 0;
    ;
    comp_block_succeeded = tdefl_compress_block(d,tmp_4);
  }
  if (use_raw_block) goto _LOR;
  else 
    if (d->m_total_lz_bytes) {
      if ((d->m_pOutput_buf - pSaved_output_buf) + (long)1U >= (long)d->m_total_lz_bytes) {
        _LOR: ;
        if (d->m_lookahead_pos - d->m_lz_code_buf_dict_pos <= d->m_dict_size) {
          mz_uint i;
          d->m_pOutput_buf = pSaved_output_buf;
          d->m_bit_buffer = saved_bit_buf;
          d->m_bits_in = saved_bits_in;
          {
            mz_uint bits_2 = (mz_uint)0;
            mz_uint len_2 = (mz_uint)2;
            __FC_assert((bits_2 <= (1U << len_2) - 1U) != 0,"miniz_tdef.c",
                        643,"bits <= ((1U << len) - 1U)");
            d->m_bit_buffer |= bits_2 << d->m_bits_in;
            d->m_bits_in += len_2;
            while (d->m_bits_in >= (mz_uint)8) {
              if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
                mz_uint8 *tmp_5;
                tmp_5 = d->m_pOutput_buf;
                (d->m_pOutput_buf) ++;
                *tmp_5 = (mz_uint8)d->m_bit_buffer;
              }
              d->m_bit_buffer >>= 8;
              d->m_bits_in -= (mz_uint)8;
            }
          }
          if (d->m_bits_in) {
            mz_uint bits_3 = (mz_uint)0;
            mz_uint len_3 = (mz_uint)8 - d->m_bits_in;
            __FC_assert((bits_3 <= (1U << len_3) - 1U) != 0,"miniz_tdef.c",
                        646,"bits <= ((1U << len) - 1U)");
            d->m_bit_buffer |= bits_3 << d->m_bits_in;
            d->m_bits_in += len_3;
            while (d->m_bits_in >= (mz_uint)8) {
              if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
                mz_uint8 *tmp_6;
                tmp_6 = d->m_pOutput_buf;
                (d->m_pOutput_buf) ++;
                *tmp_6 = (mz_uint8)d->m_bit_buffer;
              }
              d->m_bit_buffer >>= 8;
              d->m_bits_in -= (mz_uint)8;
            }
          }
          i = (mz_uint)2;
          while (i) {
            {
              mz_uint bits_4 = d->m_total_lz_bytes & (unsigned int)0xFFFF;
              mz_uint len_4 = (mz_uint)16;
              __FC_assert((bits_4 <= (1U << len_4) - 1U) != 0,"miniz_tdef.c",
                          650,"bits <= ((1U << len) - 1U)");
              d->m_bit_buffer |= bits_4 << d->m_bits_in;
              d->m_bits_in += len_4;
              while (d->m_bits_in >= (mz_uint)8) {
                if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
                  mz_uint8 *tmp_7;
                  tmp_7 = d->m_pOutput_buf;
                  (d->m_pOutput_buf) ++;
                  *tmp_7 = (mz_uint8)d->m_bit_buffer;
                }
                d->m_bit_buffer >>= 8;
                d->m_bits_in -= (mz_uint)8;
              }
            }
            i --;
            d->m_total_lz_bytes ^= (unsigned int)0xFFFF;
          }
          i = (mz_uint)0;
          while (i < d->m_total_lz_bytes) {
            {
              mz_uint bits_5 =
                (mz_uint)d->m_dict[(d->m_lz_code_buf_dict_pos + i) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK];
              mz_uint len_5 = (mz_uint)8;
              __FC_assert((bits_5 <= (1U << len_5) - 1U) != 0,"miniz_tdef.c",
                          654,"bits <= ((1U << len) - 1U)");
              d->m_bit_buffer |= bits_5 << d->m_bits_in;
              d->m_bits_in += len_5;
              while (d->m_bits_in >= (mz_uint)8) {
                if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
                  mz_uint8 *tmp_8;
                  tmp_8 = d->m_pOutput_buf;
                  (d->m_pOutput_buf) ++;
                  *tmp_8 = (mz_uint8)d->m_bit_buffer;
                }
                d->m_bit_buffer >>= 8;
                d->m_bits_in -= (mz_uint)8;
              }
            }
            i ++;
          }
        }
        else goto _LAND_0;
      }
      else goto _LAND_0;
    }
    else 
      _LAND_0:
      if (! comp_block_succeeded) {
        d->m_pOutput_buf = pSaved_output_buf;
        d->m_bit_buffer = saved_bit_buf;
        d->m_bits_in = saved_bits_in;
        tdefl_compress_block(d,1);
      }
  if (flush) 
    if (flush == TDEFL_FINISH) {
      if (d->m_bits_in) {
        mz_uint bits_6 = (mz_uint)0;
        mz_uint len_6 = (mz_uint)8 - d->m_bits_in;
        __FC_assert((bits_6 <= (1U << len_6) - 1U) != 0,"miniz_tdef.c",671,
                    "bits <= ((1U << len) - 1U)");
        d->m_bit_buffer |= bits_6 << d->m_bits_in;
        d->m_bits_in += len_6;
        while (d->m_bits_in >= (mz_uint)8) {
          if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
            mz_uint8 *tmp_9;
            tmp_9 = d->m_pOutput_buf;
            (d->m_pOutput_buf) ++;
            *tmp_9 = (mz_uint8)d->m_bit_buffer;
          }
          d->m_bit_buffer >>= 8;
          d->m_bits_in -= (mz_uint)8;
        }
      }
      if (d->m_flags & (unsigned int)TDEFL_WRITE_ZLIB_HEADER) {
        mz_uint i_0;
        mz_uint a = d->m_adler32;
        i_0 = (mz_uint)0;
        while (i_0 < (mz_uint)4) {
          {
            mz_uint bits_7 = (a >> 24) & (unsigned int)0xFF;
            mz_uint len_7 = (mz_uint)8;
            __FC_assert((bits_7 <= (1U << len_7) - 1U) != 0,"miniz_tdef.c",
                        678,"bits <= ((1U << len) - 1U)");
            d->m_bit_buffer |= bits_7 << d->m_bits_in;
            d->m_bits_in += len_7;
            while (d->m_bits_in >= (mz_uint)8) {
              if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
                mz_uint8 *tmp_10;
                tmp_10 = d->m_pOutput_buf;
                (d->m_pOutput_buf) ++;
                *tmp_10 = (mz_uint8)d->m_bit_buffer;
              }
              d->m_bit_buffer >>= 8;
              d->m_bits_in -= (mz_uint)8;
            }
          }
          a <<= 8;
          i_0 ++;
        }
      }
    }
    else {
      mz_uint i_1;
      mz_uint z = (mz_uint)0;
      {
        mz_uint bits_8 = (mz_uint)0;
        mz_uint len_8 = (mz_uint)3;
        __FC_assert((bits_8 <= (1U << len_8) - 1U) != 0,"miniz_tdef.c",686,
                    "bits <= ((1U << len) - 1U)");
        d->m_bit_buffer |= bits_8 << d->m_bits_in;
        d->m_bits_in += len_8;
        while (d->m_bits_in >= (mz_uint)8) {
          if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
            mz_uint8 *tmp_11;
            tmp_11 = d->m_pOutput_buf;
            (d->m_pOutput_buf) ++;
            *tmp_11 = (mz_uint8)d->m_bit_buffer;
          }
          d->m_bit_buffer >>= 8;
          d->m_bits_in -= (mz_uint)8;
        }
      }
      if (d->m_bits_in) {
        mz_uint bits_9 = (mz_uint)0;
        mz_uint len_9 = (mz_uint)8 - d->m_bits_in;
        __FC_assert((bits_9 <= (1U << len_9) - 1U) != 0,"miniz_tdef.c",689,
                    "bits <= ((1U << len) - 1U)");
        d->m_bit_buffer |= bits_9 << d->m_bits_in;
        d->m_bits_in += len_9;
        while (d->m_bits_in >= (mz_uint)8) {
          if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
            mz_uint8 *tmp_12;
            tmp_12 = d->m_pOutput_buf;
            (d->m_pOutput_buf) ++;
            *tmp_12 = (mz_uint8)d->m_bit_buffer;
          }
          d->m_bit_buffer >>= 8;
          d->m_bits_in -= (mz_uint)8;
        }
      }
      i_1 = (mz_uint)2;
      while (i_1) {
        {
          mz_uint bits_10 = z & (unsigned int)0xFFFF;
          mz_uint len_10 = (mz_uint)16;
          __FC_assert((bits_10 <= (1U << len_10) - 1U) != 0,"miniz_tdef.c",
                      693,"bits <= ((1U << len) - 1U)");
          d->m_bit_buffer |= bits_10 << d->m_bits_in;
          d->m_bits_in += len_10;
          while (d->m_bits_in >= (mz_uint)8) {
            if (d->m_pOutput_buf < d->m_pOutput_buf_end) {
              mz_uint8 *tmp_13;
              tmp_13 = d->m_pOutput_buf;
              (d->m_pOutput_buf) ++;
              *tmp_13 = (mz_uint8)d->m_bit_buffer;
            }
            d->m_bit_buffer >>= 8;
            d->m_bits_in -= (mz_uint)8;
          }
        }
        i_1 --;
        z ^= (unsigned int)0xFFFF;
      }
    }
  __FC_assert((d->m_pOutput_buf < d->m_pOutput_buf_end) != 0,"miniz_tdef.c",
              698,"d->m_pOutput_buf < d->m_pOutput_buf_end");
  memset((void *)(& d->m_huff_count[0][0]),0,
         sizeof(d->m_huff_count[0][0]) * (unsigned long)TDEFL_MAX_HUFF_SYMBOLS_0);
  memset((void *)(& d->m_huff_count[1][0]),0,
         sizeof(d->m_huff_count[1][0]) * (unsigned long)TDEFL_MAX_HUFF_SYMBOLS_1);
  d->m_pLZ_code_buf = & d->m_lz_code_buf[1];
  d->m_pLZ_flags = d->m_lz_code_buf;
  d->m_num_flags_left = (mz_uint)8;
  d->m_lz_code_buf_dict_pos += d->m_total_lz_bytes;
  d->m_total_lz_bytes = (mz_uint)0;
  (d->m_block_index) ++;
  n = (int)(d->m_pOutput_buf - pOutput_buf_start);
  if (n != 0) 
    if (d->m_pPut_buf_func) {
      mz_bool tmp_15;
      *(d->m_pIn_buf_size) = (size_t)(d->m_pSrc - (mz_uint8 const *)d->m_pIn_buf);
      tmp_15 = (*(d->m_pPut_buf_func))((void const *)(d->m_output_buf),n,
                                       d->m_pPut_buf_user);
      if (! tmp_15) {
        tdefl_status tmp_14;
        tmp_14 = TDEFL_STATUS_PUT_BUF_FAILED;
        d->m_prev_return_status = tmp_14;
        __retres = tmp_14;
        goto return_label;
      }
    }
    else 
      if (pOutput_buf_start == d->m_output_buf) {
        size_t tmp_16;
        if ((size_t)n < *(d->m_pOut_buf_size) - d->m_out_buf_ofs) tmp_16 = (size_t)n;
        else tmp_16 = *(d->m_pOut_buf_size) - d->m_out_buf_ofs;
        int bytes_to_copy = (int)tmp_16;
        memcpy((void *)((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs),
               (void const *)(d->m_output_buf),(size_t)bytes_to_copy);
        d->m_out_buf_ofs += (size_t)bytes_to_copy;
        n -= bytes_to_copy;
        if (n != 0) {
          d->m_output_flush_ofs = (mz_uint)bytes_to_copy;
          d->m_output_flush_remaining = (mz_uint)n;
        }
      }
      else d->m_out_buf_ofs += (size_t)n;
  __retres = (int)d->m_output_flush_remaining;
  return_label: return __retres;
}

static mz_uint16 TDEFL_READ_UNALIGNED_WORD(mz_uint8 const *p)
{
  mz_uint16 ret;
  memcpy((void *)(& ret),(void const *)p,sizeof(mz_uint16));
  return ret;
}

static mz_uint16 TDEFL_READ_UNALIGNED_WORD2(mz_uint16 const *p)
{
  mz_uint16 ret;
  memcpy((void *)(& ret),(void const *)p,sizeof(mz_uint16));
  return ret;
}

__inline static void ( __attribute__((__always_inline__)) tdefl_find_match)
(tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist,
 mz_uint max_match_len, mz_uint *pMatch_dist, mz_uint *pMatch_len)
{
  mz_uint dist;
  mz_uint next_probe_pos;
  mz_uint probe_len;
  mz_uint16 const *p;
  mz_uint16 const *q;
  mz_uint pos = lookahead_pos & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
  mz_uint match_len = *pMatch_len;
  mz_uint probe_pos = pos;
  mz_uint num_probes_left = d->m_max_probes[match_len >= (mz_uint)32];
  mz_uint16 const *s = (mz_uint16 const *)(& d->m_dict[pos]);
  mz_uint16 c01 =
    TDEFL_READ_UNALIGNED_WORD((mz_uint8 const *)(& d->m_dict[(pos + match_len) - (mz_uint)1]));
  mz_uint16 s01 = TDEFL_READ_UNALIGNED_WORD2(s);
  __FC_assert((max_match_len <= (mz_uint)TDEFL_MAX_MATCH_LEN) != 0,
              "miniz_tdef.c",762,"max_match_len <= TDEFL_MAX_MATCH_LEN");
  if (max_match_len <= match_len) goto return_label;
  while (1) {
    {
      mz_uint16 tmp_4;
      while (1) {
        mz_uint16 tmp_1;
        mz_uint16 tmp_2;
        mz_uint16 tmp_3;
        num_probes_left --;
        if (num_probes_left == (mz_uint)0) goto return_label;
        next_probe_pos = (mz_uint)d->m_next[probe_pos];
        if (! next_probe_pos) goto return_label;
        else {
          dist = (mz_uint)((mz_uint16)(lookahead_pos - next_probe_pos));
          ;
          if (dist > max_dist) goto return_label;
        }
        probe_pos = next_probe_pos & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
        tmp_1 = TDEFL_READ_UNALIGNED_WORD((mz_uint8 const *)(& d->m_dict[
                                          (probe_pos + match_len) - (mz_uint)1]));
        ;
        if ((int)tmp_1 == (int)c01) break;
        next_probe_pos = (mz_uint)d->m_next[probe_pos];
        if (! next_probe_pos) goto return_label;
        else {
          dist = (mz_uint)((mz_uint16)(lookahead_pos - next_probe_pos));
          ;
          if (dist > max_dist) goto return_label;
        }
        probe_pos = next_probe_pos & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
        tmp_2 = TDEFL_READ_UNALIGNED_WORD((mz_uint8 const *)(& d->m_dict[
                                          (probe_pos + match_len) - (mz_uint)1]));
        ;
        if ((int)tmp_2 == (int)c01) break;
        next_probe_pos = (mz_uint)d->m_next[probe_pos];
        if (! next_probe_pos) goto return_label;
        else {
          dist = (mz_uint)((mz_uint16)(lookahead_pos - next_probe_pos));
          ;
          if (dist > max_dist) goto return_label;
        }
        probe_pos = next_probe_pos & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
        tmp_3 = TDEFL_READ_UNALIGNED_WORD((mz_uint8 const *)(& d->m_dict[
                                          (probe_pos + match_len) - (mz_uint)1]));
        ;
        if ((int)tmp_3 == (int)c01) break;
      }
      if (! dist) break;
      q = (mz_uint16 const *)(& d->m_dict[probe_pos]);
      tmp_4 = TDEFL_READ_UNALIGNED_WORD2(q);
      ;
      if ((int)tmp_4 != (int)s01) goto __Cont;
      p = s;
      probe_len = (mz_uint)32;
      while (1) {
        mz_uint16 tmp_5;
        mz_uint16 tmp_6;
        p ++;
        tmp_5 = TDEFL_READ_UNALIGNED_WORD2(p);
        q ++;
        tmp_6 = TDEFL_READ_UNALIGNED_WORD2(q);
        if ((int)tmp_5 == (int)tmp_6) {
          mz_uint16 tmp_7;
          mz_uint16 tmp_8;
          p ++;
          tmp_7 = TDEFL_READ_UNALIGNED_WORD2(p);
          q ++;
          tmp_8 = TDEFL_READ_UNALIGNED_WORD2(q);
          if ((int)tmp_7 == (int)tmp_8) {
            mz_uint16 tmp_9;
            mz_uint16 tmp_10;
            p ++;
            tmp_9 = TDEFL_READ_UNALIGNED_WORD2(p);
            q ++;
            tmp_10 = TDEFL_READ_UNALIGNED_WORD2(q);
            if ((int)tmp_9 == (int)tmp_10) {
              mz_uint16 tmp_11;
              mz_uint16 tmp_12;
              p ++;
              tmp_11 = TDEFL_READ_UNALIGNED_WORD2(p);
              q ++;
              tmp_12 = TDEFL_READ_UNALIGNED_WORD2(q);
              if ((int)tmp_11 == (int)tmp_12) {
                probe_len --;
                if (! (probe_len > (mz_uint)0)) break;
              }
              else break;
            }
            else break;
          }
          else break;
        }
        else break;
      }
      if (! probe_len) {
        *pMatch_dist = dist;
        if (max_match_len < (mz_uint)TDEFL_MAX_MATCH_LEN) *pMatch_len = max_match_len;
        else *pMatch_len = (mz_uint)TDEFL_MAX_MATCH_LEN;
        break;
      }
      else {
        probe_len = (mz_uint)(p - s) * (mz_uint)2 + (mz_uint)((int)*((mz_uint8 const *)p) == (int)*((mz_uint8 const *)q));
        ;
        if (probe_len > match_len) {
          mz_uint tmp_13;
          *pMatch_dist = dist;
          if (max_match_len < probe_len) match_len = max_match_len;
          else match_len = probe_len;
          tmp_13 = match_len;
          *pMatch_len = tmp_13;
          ;
          if (tmp_13 == max_match_len) break;
          c01 = TDEFL_READ_UNALIGNED_WORD((mz_uint8 const *)(& d->m_dict[
                                          (pos + match_len) - (mz_uint)1]));
        }
      }
    }
    __Cont: ;
  }
  return_label: return;
}

static mz_uint32 TDEFL_READ_UNALIGNED_WORD32(mz_uint8 const *p)
{
  mz_uint32 ret;
  memcpy((void *)(& ret),(void const *)p,sizeof(mz_uint32));
  return ret;
}

static mz_bool tdefl_compress_fast(tdefl_compressor *d)
{
  mz_bool __retres;
  mz_uint lookahead_pos = d->m_lookahead_pos;
  mz_uint lookahead_size = d->m_lookahead_size;
  mz_uint dict_size = d->m_dict_size;
  mz_uint total_lz_bytes = d->m_total_lz_bytes;
  mz_uint num_flags_left = d->m_num_flags_left;
  mz_uint8 *pLZ_code_buf = d->m_pLZ_code_buf;
  mz_uint8 *pLZ_flags = d->m_pLZ_flags;
  mz_uint cur_pos = lookahead_pos & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
  while (1) {
    if (! d->m_src_buf_left) 
      if (d->m_flush) {
        if (! lookahead_size) break;
      }
      else break;
    {
      size_t tmp;
      mz_uint const TDEFL_COMP_FAST_LOOKAHEAD_SIZE = (mz_uint)4096;
      mz_uint dst_pos =
        (lookahead_pos + lookahead_size) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
      if (d->m_src_buf_left < (size_t)(TDEFL_COMP_FAST_LOOKAHEAD_SIZE - lookahead_size)) 
        tmp = d->m_src_buf_left;
      else tmp = (size_t)(TDEFL_COMP_FAST_LOOKAHEAD_SIZE - lookahead_size);
      mz_uint num_bytes_to_process = (mz_uint)tmp;
      d->m_src_buf_left -= (size_t)num_bytes_to_process;
      lookahead_size += num_bytes_to_process;
      while (num_bytes_to_process) {
        mz_uint tmp_0;
        if ((mz_uint)TDEFL_LZ_DICT_SIZE - dst_pos < num_bytes_to_process) 
          tmp_0 = (mz_uint)TDEFL_LZ_DICT_SIZE - dst_pos;
        else tmp_0 = num_bytes_to_process;
        mz_uint32 n = tmp_0;
        memcpy((void *)(& d->m_dict[dst_pos]),(void const *)d->m_pSrc,
               (size_t)n);
        if (dst_pos < (mz_uint)(TDEFL_MAX_MATCH_LEN - 1)) {
          mz_uint32 tmp_1;
          if (n < (mz_uint)(TDEFL_MAX_MATCH_LEN - 1) - dst_pos) tmp_1 = n;
          else tmp_1 = (mz_uint)(TDEFL_MAX_MATCH_LEN - 1) - dst_pos;
          ;
          ;
          memcpy((void *)(& d->m_dict[TDEFL_LZ_DICT_SIZE] + dst_pos),
                 (void const *)d->m_pSrc,(size_t)tmp_1);
        }
        d->m_pSrc += n;
        dst_pos = (dst_pos + n) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
        num_bytes_to_process -= n;
      }
      if ((mz_uint)TDEFL_LZ_DICT_SIZE - lookahead_size < dict_size) dict_size = 
                                                                    (mz_uint)TDEFL_LZ_DICT_SIZE - lookahead_size;
      else dict_size = dict_size;
      if (! d->m_flush) 
        if (lookahead_size < TDEFL_COMP_FAST_LOOKAHEAD_SIZE) break;
      while (lookahead_size >= (mz_uint)4) {
        mz_uint cur_match_dist;
        mz_uint32 tmp_2;
        mz_uint cur_match_len = (mz_uint)1;
        mz_uint8 *pCur_dict = & d->m_dict[cur_pos];
        tmp_2 = TDEFL_READ_UNALIGNED_WORD32((mz_uint8 const *)pCur_dict);
        mz_uint first_trigram = tmp_2 & (unsigned int)0xFFFFFF;
        mz_uint hash =
          (first_trigram ^ (first_trigram >> (24 - (TDEFL_LZ_HASH_BITS - 8)))) & (unsigned int)TDEFL_LEVEL1_HASH_SIZE_MASK;
        mz_uint probe_pos = (mz_uint)d->m_hash[hash];
        d->m_hash[hash] = (mz_uint16)lookahead_pos;
        cur_match_dist = (mz_uint)((mz_uint16)(lookahead_pos - probe_pos));
        ;
        if (cur_match_dist <= dict_size) {
          mz_uint32 tmp_15;
          probe_pos &= (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
          ;
          tmp_15 = TDEFL_READ_UNALIGNED_WORD32((mz_uint8 const *)(& d->m_dict[probe_pos]));
          ;
          if ((tmp_15 & (unsigned int)0xFFFFFF) == first_trigram) {
            mz_uint16 const *p = (mz_uint16 const *)pCur_dict;
            mz_uint16 const *q = (mz_uint16 const *)(& d->m_dict[probe_pos]);
            mz_uint32 probe_len = (mz_uint32)32;
            while (1) {
              mz_uint16 tmp_3;
              mz_uint16 tmp_4;
              p ++;
              tmp_3 = TDEFL_READ_UNALIGNED_WORD2(p);
              q ++;
              tmp_4 = TDEFL_READ_UNALIGNED_WORD2(q);
              if ((int)tmp_3 == (int)tmp_4) {
                mz_uint16 tmp_5;
                mz_uint16 tmp_6;
                p ++;
                tmp_5 = TDEFL_READ_UNALIGNED_WORD2(p);
                q ++;
                tmp_6 = TDEFL_READ_UNALIGNED_WORD2(q);
                if ((int)tmp_5 == (int)tmp_6) {
                  mz_uint16 tmp_7;
                  mz_uint16 tmp_8;
                  p ++;
                  tmp_7 = TDEFL_READ_UNALIGNED_WORD2(p);
                  q ++;
                  tmp_8 = TDEFL_READ_UNALIGNED_WORD2(q);
                  if ((int)tmp_7 == (int)tmp_8) {
                    mz_uint16 tmp_9;
                    mz_uint16 tmp_10;
                    p ++;
                    tmp_9 = TDEFL_READ_UNALIGNED_WORD2(p);
                    q ++;
                    tmp_10 = TDEFL_READ_UNALIGNED_WORD2(q);
                    if ((int)tmp_9 == (int)tmp_10) {
                      probe_len --;
                      if (! (probe_len > (mz_uint32)0)) break;
                    }
                    else break;
                  }
                  else break;
                }
                else break;
              }
              else break;
            }
            cur_match_len = (mz_uint)(p - (mz_uint16 const *)pCur_dict) * (mz_uint)2 + (mz_uint)(
                            (int)*((mz_uint8 const *)p) == (int)*((mz_uint8 const *)q));
            if (! probe_len) 
              if (cur_match_dist) cur_match_len = (mz_uint)TDEFL_MAX_MATCH_LEN;
              else cur_match_len = (mz_uint)0;
            if (cur_match_len < (mz_uint)TDEFL_MIN_MATCH_LEN) goto _LOR;
            else 
              if (cur_match_len == (mz_uint)TDEFL_MIN_MATCH_LEN) {
                if (cur_match_dist >= 8U * 1024U) {
                  _LOR:
                  {
                    mz_uint8 *tmp_11;
                    cur_match_len = (mz_uint)1;
                    tmp_11 = pLZ_code_buf;
                    pLZ_code_buf ++;
                    *tmp_11 = (mz_uint8)first_trigram;
                    *pLZ_flags = (mz_uint8)((int)*pLZ_flags >> 1);
                    d->m_huff_count[0][(mz_uint8)first_trigram] = (mz_uint16)(
                    (int)d->m_huff_count[0][(mz_uint8)first_trigram] + 1);
                  }
                }
                else goto _LAND;
              }
              else {
                _LAND:
                {
                  mz_uint32 s0;
                  mz_uint32 s1;
                  int tmp_12;
                  mz_uint32 tmp_13;
                  if (cur_match_len < lookahead_size) cur_match_len = cur_match_len;
                  else cur_match_len = lookahead_size;
                  if (cur_match_len >= (mz_uint)TDEFL_MIN_MATCH_LEN) 
                    if (cur_match_dist >= (mz_uint)1) 
                      if (cur_match_dist <= (mz_uint)TDEFL_LZ_DICT_SIZE) 
                        tmp_12 = 1;
                      else tmp_12 = 0;
                    else tmp_12 = 0;
                  else tmp_12 = 0;
                  __FC_assert(tmp_12 != 0,"miniz_tdef.c",929,
                              "(cur_match_len >= TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 1) && (cur_match_dist <= TDEFL_LZ_DICT_SIZE)");
                  cur_match_dist --;
                  *(pLZ_code_buf + 0) = (mz_uint8)(cur_match_len - (mz_uint)TDEFL_MIN_MATCH_LEN);
                  memcpy((void *)(pLZ_code_buf + 1),
                         (void const *)(& cur_match_dist),
                         sizeof(cur_match_dist));
                  pLZ_code_buf += 3;
                  *pLZ_flags = (mz_uint8)(((int)*pLZ_flags >> 1) | 0x80);
                  s0 = (mz_uint32)s_tdefl_small_dist_sym[cur_match_dist & (unsigned int)511];
                  s1 = (mz_uint32)s_tdefl_large_dist_sym[cur_match_dist >> 8];
                  if (cur_match_dist < (mz_uint)512) tmp_13 = s0;
                  else tmp_13 = s1;
                  d->m_huff_count[1][tmp_13] = (mz_uint16)((int)d->m_huff_count[1][tmp_13] + 1);
                  d->m_huff_count[0][s_tdefl_len_sym[cur_match_len - (mz_uint)TDEFL_MIN_MATCH_LEN]] = (mz_uint16)(
                  (int)d->m_huff_count[0][s_tdefl_len_sym[cur_match_len - (mz_uint)TDEFL_MIN_MATCH_LEN]] + 1);
                }
              }
          }
          else goto _LAND_0;
        }
        else {
          _LAND_0:
          {
            mz_uint8 *tmp_14;
            tmp_14 = pLZ_code_buf;
            pLZ_code_buf ++;
            *tmp_14 = (mz_uint8)first_trigram;
            *pLZ_flags = (mz_uint8)((int)*pLZ_flags >> 1);
            d->m_huff_count[0][(mz_uint8)first_trigram] = (mz_uint16)(
            (int)d->m_huff_count[0][(mz_uint8)first_trigram] + 1);
          }
        }
        num_flags_left --;
        if (num_flags_left == (mz_uint)0) {
          mz_uint8 *tmp_16;
          num_flags_left = (mz_uint)8;
          tmp_16 = pLZ_code_buf;
          pLZ_code_buf ++;
          pLZ_flags = tmp_16;
        }
        total_lz_bytes += cur_match_len;
        lookahead_pos += cur_match_len;
        if (dict_size + cur_match_len < (mz_uint)TDEFL_LZ_DICT_SIZE) 
          dict_size += cur_match_len;
        else dict_size = (mz_uint)TDEFL_LZ_DICT_SIZE;
        cur_pos = (cur_pos + cur_match_len) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
        __FC_assert((lookahead_size >= cur_match_len) != 0,"miniz_tdef.c",
                    966,"lookahead_size >= cur_match_len");
        lookahead_size -= cur_match_len;
        if (pLZ_code_buf > & d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) {
          int n_0;
          d->m_lookahead_pos = lookahead_pos;
          d->m_lookahead_size = lookahead_size;
          d->m_dict_size = dict_size;
          d->m_total_lz_bytes = total_lz_bytes;
          d->m_pLZ_code_buf = pLZ_code_buf;
          d->m_pLZ_flags = pLZ_flags;
          d->m_num_flags_left = num_flags_left;
          n_0 = tdefl_flush_block(d,0);
          if (n_0 != 0) {
            int tmp_17;
            if (n_0 < 0) tmp_17 = 0; else tmp_17 = 1;
            __retres = tmp_17;
            goto return_label;
          }
          total_lz_bytes = d->m_total_lz_bytes;
          pLZ_code_buf = d->m_pLZ_code_buf;
          pLZ_flags = d->m_pLZ_flags;
          num_flags_left = d->m_num_flags_left;
        }
      }
      while (lookahead_size) {
        mz_uint8 *tmp_18;
        mz_uint8 lit = d->m_dict[cur_pos];
        total_lz_bytes ++;
        tmp_18 = pLZ_code_buf;
        pLZ_code_buf ++;
        *tmp_18 = lit;
        *pLZ_flags = (mz_uint8)((int)*pLZ_flags >> 1);
        num_flags_left --;
        if (num_flags_left == (mz_uint)0) {
          mz_uint8 *tmp_19;
          num_flags_left = (mz_uint)8;
          tmp_19 = pLZ_code_buf;
          pLZ_code_buf ++;
          pLZ_flags = tmp_19;
        }
        d->m_huff_count[0][lit] = (mz_uint16)((int)d->m_huff_count[0][lit] + 1);
        lookahead_pos ++;
        if (dict_size + (mz_uint)1 < (mz_uint)TDEFL_LZ_DICT_SIZE) dict_size += (mz_uint)1;
        else dict_size = (mz_uint)TDEFL_LZ_DICT_SIZE;
        cur_pos = (cur_pos + (mz_uint)1) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
        lookahead_size --;
        if (pLZ_code_buf > & d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) {
          int n_1;
          d->m_lookahead_pos = lookahead_pos;
          d->m_lookahead_size = lookahead_size;
          d->m_dict_size = dict_size;
          d->m_total_lz_bytes = total_lz_bytes;
          d->m_pLZ_code_buf = pLZ_code_buf;
          d->m_pLZ_flags = pLZ_flags;
          d->m_num_flags_left = num_flags_left;
          n_1 = tdefl_flush_block(d,0);
          if (n_1 != 0) {
            int tmp_20;
            if (n_1 < 0) tmp_20 = 0; else tmp_20 = 1;
            __retres = tmp_20;
            goto return_label;
          }
          total_lz_bytes = d->m_total_lz_bytes;
          pLZ_code_buf = d->m_pLZ_code_buf;
          pLZ_flags = d->m_pLZ_flags;
          num_flags_left = d->m_num_flags_left;
        }
      }
    }
  }
  d->m_lookahead_pos = lookahead_pos;
  d->m_lookahead_size = lookahead_size;
  d->m_dict_size = dict_size;
  d->m_total_lz_bytes = total_lz_bytes;
  d->m_pLZ_code_buf = pLZ_code_buf;
  d->m_pLZ_flags = pLZ_flags;
  d->m_num_flags_left = num_flags_left;
  __retres = 1;
  return_label: return __retres;
}

__inline static void ( __attribute__((__always_inline__)) tdefl_record_literal)
(tdefl_compressor *d, mz_uint8 lit)
{
  mz_uint8 *tmp;
  (d->m_total_lz_bytes) ++;
  tmp = d->m_pLZ_code_buf;
  (d->m_pLZ_code_buf) ++;
  *tmp = lit;
  *(d->m_pLZ_flags) = (mz_uint8)((int)*(d->m_pLZ_flags) >> 1);
  (d->m_num_flags_left) --;
  if (d->m_num_flags_left == (mz_uint)0) {
    mz_uint8 *tmp_0;
    d->m_num_flags_left = (mz_uint)8;
    tmp_0 = d->m_pLZ_code_buf;
    (d->m_pLZ_code_buf) ++;
    d->m_pLZ_flags = tmp_0;
  }
  d->m_huff_count[0][lit] = (mz_uint16)((int)d->m_huff_count[0][lit] + 1);
  return;
}

__inline static void ( __attribute__((__always_inline__)) tdefl_record_match)
(tdefl_compressor *d, mz_uint match_len, mz_uint match_dist)
{
  mz_uint32 s0;
  mz_uint32 s1;
  int tmp;
  mz_uint32 tmp_1;
  if (match_len >= (mz_uint)TDEFL_MIN_MATCH_LEN) 
    if (match_dist >= (mz_uint)1) 
      if (match_dist <= (mz_uint)TDEFL_LZ_DICT_SIZE) tmp = 1; else tmp = 0;
    else tmp = 0;
  else tmp = 0;
  __FC_assert(tmp != 0,"miniz_tdef.c",1056,
              "(match_len >= TDEFL_MIN_MATCH_LEN) && (match_dist >= 1) && (match_dist <= TDEFL_LZ_DICT_SIZE)");
  d->m_total_lz_bytes += match_len;
  *(d->m_pLZ_code_buf + 0) = (mz_uint8)(match_len - (mz_uint)TDEFL_MIN_MATCH_LEN);
  match_dist -= (mz_uint)1;
  *(d->m_pLZ_code_buf + 1) = (mz_uint8)(match_dist & (unsigned int)0xFF);
  *(d->m_pLZ_code_buf + 2) = (mz_uint8)(match_dist >> 8);
  d->m_pLZ_code_buf += 3;
  *(d->m_pLZ_flags) = (mz_uint8)(((int)*(d->m_pLZ_flags) >> 1) | 0x80);
  (d->m_num_flags_left) --;
  if (d->m_num_flags_left == (mz_uint)0) {
    mz_uint8 *tmp_0;
    d->m_num_flags_left = (mz_uint)8;
    tmp_0 = d->m_pLZ_code_buf;
    (d->m_pLZ_code_buf) ++;
    d->m_pLZ_flags = tmp_0;
  }
  s0 = (mz_uint32)s_tdefl_small_dist_sym[match_dist & (unsigned int)511];
  s1 = (mz_uint32)s_tdefl_large_dist_sym[(match_dist >> 8) & (unsigned int)127];
  if (match_dist < (mz_uint)512) tmp_1 = s0; else tmp_1 = s1;
  d->m_huff_count[1][tmp_1] = (mz_uint16)((int)d->m_huff_count[1][tmp_1] + 1);
  if (match_len >= (mz_uint)TDEFL_MIN_MATCH_LEN) d->m_huff_count[0][s_tdefl_len_sym[
                                                 match_len - (mz_uint)TDEFL_MIN_MATCH_LEN]] = (mz_uint16)(
                                                 (int)d->m_huff_count[0][s_tdefl_len_sym[
                                                 match_len - (mz_uint)TDEFL_MIN_MATCH_LEN]] + 1);
  return;
}

static mz_bool tdefl_compress_normal(tdefl_compressor *d)
{
  mz_bool __retres;
  mz_uint8 const *pSrc = d->m_pSrc;
  size_t src_buf_left = d->m_src_buf_left;
  tdefl_flush flush = d->m_flush;
  while (1) {
    if (! src_buf_left) 
      if (flush) {
        if (! d->m_lookahead_size) break;
      }
      else break;
    {
      mz_uint len_to_move;
      mz_uint cur_match_dist;
      mz_uint cur_match_len;
      mz_uint cur_pos;
      if (d->m_lookahead_size + d->m_dict_size >= (mz_uint)(TDEFL_MIN_MATCH_LEN - 1)) {
        size_t tmp;
        mz_uint dst_pos =
          (d->m_lookahead_pos + d->m_lookahead_size) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
        mz_uint ins_pos =
          (d->m_lookahead_pos + d->m_lookahead_size) - (mz_uint)2;
        mz_uint hash =
          (mz_uint)(((int)d->m_dict[ins_pos & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT) ^ (int)d->m_dict[
                    (ins_pos + (mz_uint)1) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK]);
        if (src_buf_left < (size_t)((mz_uint)TDEFL_MAX_MATCH_LEN - d->m_lookahead_size)) 
          tmp = src_buf_left;
        else tmp = (size_t)((mz_uint)TDEFL_MAX_MATCH_LEN - d->m_lookahead_size);
        mz_uint num_bytes_to_process = (mz_uint)tmp;
        mz_uint8 const *pSrc_end = pSrc + num_bytes_to_process;
        src_buf_left -= (size_t)num_bytes_to_process;
        d->m_lookahead_size += num_bytes_to_process;
        while (pSrc != pSrc_end) {
          mz_uint8 const *tmp_0;
          tmp_0 = pSrc;
          pSrc ++;
          mz_uint8 c = *tmp_0;
          d->m_dict[dst_pos] = c;
          if (dst_pos < (mz_uint)(TDEFL_MAX_MATCH_LEN - 1)) d->m_dict[
                                                            (mz_uint)TDEFL_LZ_DICT_SIZE + dst_pos] = c;
          hash = ((hash << TDEFL_LZ_HASH_SHIFT) ^ (unsigned int)c) & (unsigned int)(
                 TDEFL_LZ_HASH_SIZE - 1);
          d->m_next[ins_pos & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash];
          d->m_hash[hash] = (mz_uint16)ins_pos;
          dst_pos = (dst_pos + (mz_uint)1) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
          ins_pos ++;
        }
      }
      else 
        while (1) {
          if (src_buf_left) {
            if (! (d->m_lookahead_size < (mz_uint)TDEFL_MAX_MATCH_LEN)) 
              break;
          }
          else break;
          {
            mz_uint8 const *tmp_1;
            tmp_1 = pSrc;
            pSrc ++;
            mz_uint8 c_0 = *tmp_1;
            mz_uint dst_pos_0 =
              (d->m_lookahead_pos + d->m_lookahead_size) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
            src_buf_left --;
            d->m_dict[dst_pos_0] = c_0;
            if (dst_pos_0 < (mz_uint)(TDEFL_MAX_MATCH_LEN - 1)) d->m_dict[
                                                                (mz_uint)TDEFL_LZ_DICT_SIZE + dst_pos_0] = c_0;
            (d->m_lookahead_size) ++;
            ;
            if (d->m_lookahead_size + d->m_dict_size >= (mz_uint)TDEFL_MIN_MATCH_LEN) {
              mz_uint ins_pos_0 =
                (d->m_lookahead_pos + (d->m_lookahead_size - (mz_uint)1)) - (mz_uint)2;
              mz_uint hash_0 =
                (mz_uint)(((((int)d->m_dict[ins_pos_0 & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK] << 
                             TDEFL_LZ_HASH_SHIFT * 2) ^ ((int)d->m_dict[
                                                         (ins_pos_0 + (mz_uint)1) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT)) ^ (int)c_0) & (
                          TDEFL_LZ_HASH_SIZE - 1));
              d->m_next[ins_pos_0 & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash_0];
              d->m_hash[hash_0] = (mz_uint16)ins_pos_0;
            }
          }
        }
      if ((mz_uint)TDEFL_LZ_DICT_SIZE - d->m_lookahead_size < d->m_dict_size) 
        d->m_dict_size = (mz_uint)TDEFL_LZ_DICT_SIZE - d->m_lookahead_size;
      else d->m_dict_size = d->m_dict_size;
      if (! flush) 
        if (d->m_lookahead_size < (mz_uint)TDEFL_MAX_MATCH_LEN) break;
      len_to_move = (mz_uint)1;
      cur_match_dist = (mz_uint)0;
      if (d->m_saved_match_len) cur_match_len = d->m_saved_match_len;
      else cur_match_len = (mz_uint)(TDEFL_MIN_MATCH_LEN - 1);
      cur_pos = d->m_lookahead_pos & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK;
      if (d->m_flags & (unsigned int)(TDEFL_RLE_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS)) {
        if (d->m_dict_size) 
          if (! (d->m_flags & (unsigned int)TDEFL_FORCE_ALL_RAW_BLOCKS)) {
            mz_uint8 c_1 =
              d->m_dict[(cur_pos - (mz_uint)1) & (unsigned int)TDEFL_LZ_DICT_SIZE_MASK];
            cur_match_len = (mz_uint)0;
            while (cur_match_len < d->m_lookahead_size) {
              if ((int)d->m_dict[cur_pos + cur_match_len] != (int)c_1) 
                break;
              cur_match_len ++;
            }
            if (cur_match_len < (mz_uint)TDEFL_MIN_MATCH_LEN) cur_match_len = (mz_uint)0;
            else cur_match_dist = (mz_uint)1;
          }
      }
      else tdefl_find_match(d,d->m_lookahead_pos,d->m_dict_size,
                            d->m_lookahead_size,& cur_match_dist,
                            & cur_match_len);
      if (cur_match_len == (mz_uint)TDEFL_MIN_MATCH_LEN) {
        if (cur_match_dist >= 8U * 1024U) goto _LOR; else goto _LAND;
      }
      else {
        _LAND: ;
        if (cur_pos == cur_match_dist) goto _LOR;
        else 
          if (d->m_flags & (unsigned int)TDEFL_FILTER_MATCHES) 
            if (cur_match_len <= (mz_uint)5) {
              _LOR:
              {
                cur_match_len = (mz_uint)0;
                cur_match_dist = cur_match_len;
              }
            }
      }
      if (d->m_saved_match_len) 
        if (cur_match_len > d->m_saved_match_len) {
          tdefl_record_literal(d,(mz_uint8)d->m_saved_lit);
          if (cur_match_len >= (mz_uint)128) {
            tdefl_record_match(d,cur_match_len,cur_match_dist);
            d->m_saved_match_len = (mz_uint)0;
            len_to_move = cur_match_len;
          }
          else {
            d->m_saved_lit = (mz_uint)d->m_dict[cur_pos];
            d->m_saved_match_dist = cur_match_dist;
            d->m_saved_match_len = cur_match_len;
          }
        }
        else {
          tdefl_record_match(d,d->m_saved_match_len,d->m_saved_match_dist);
          len_to_move = d->m_saved_match_len - (mz_uint)1;
          d->m_saved_match_len = (mz_uint)0;
        }
      else 
        if (! cur_match_dist) {
          unsigned long tmp_2;
          if ((unsigned long)cur_pos < sizeof(d->m_dict) - (unsigned long)1) 
            tmp_2 = (unsigned long)cur_pos;
          else tmp_2 = sizeof(d->m_dict) - (unsigned long)1;
          ;
          ;
          tdefl_record_literal(d,d->m_dict[tmp_2]);
        }
        else 
          if (d->m_greedy_parsing) goto _LOR_0;
          else 
            if (d->m_flags & (unsigned int)TDEFL_RLE_MATCHES) goto _LOR_0;
            else 
              if (cur_match_len >= (mz_uint)128) {
                _LOR_0:
                {
                  tdefl_record_match(d,cur_match_len,cur_match_dist);
                  len_to_move = cur_match_len;
                }
              }
              else {
                unsigned long tmp_3;
                if ((unsigned long)cur_pos < sizeof(d->m_dict) - (unsigned long)1) 
                  tmp_3 = (unsigned long)cur_pos;
                else tmp_3 = sizeof(d->m_dict) - (unsigned long)1;
                d->m_saved_lit = (mz_uint)d->m_dict[tmp_3];
                d->m_saved_match_dist = cur_match_dist;
                d->m_saved_match_len = cur_match_len;
              }
      d->m_lookahead_pos += len_to_move;
      __FC_assert((d->m_lookahead_size >= len_to_move) != 0,"miniz_tdef.c",
                  1207,"d->m_lookahead_size >= len_to_move");
      d->m_lookahead_size -= len_to_move;
      if (d->m_dict_size + len_to_move < (mz_uint)TDEFL_LZ_DICT_SIZE) 
        d->m_dict_size += len_to_move;
      else d->m_dict_size = (mz_uint)TDEFL_LZ_DICT_SIZE;
      if (d->m_pLZ_code_buf > & d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) 
        goto _LOR_2;
      else 
        if (d->m_total_lz_bytes > (mz_uint)(31 * 1024)) 
          if ((mz_uint)(d->m_pLZ_code_buf - d->m_lz_code_buf) * (mz_uint)115 >> 7 >= d->m_total_lz_bytes) 
            goto _LOR_2;
          else 
            if (d->m_flags & (unsigned int)TDEFL_FORCE_ALL_RAW_BLOCKS) {
              _LOR_2:
              {
                int n;
                d->m_pSrc = pSrc;
                d->m_src_buf_left = src_buf_left;
                n = tdefl_flush_block(d,0);
                if (n != 0) {
                  int tmp_4;
                  if (n < 0) tmp_4 = 0; else tmp_4 = 1;
                  __retres = tmp_4;
                  goto return_label;
                }
              }
            }
    }
  }
  d->m_pSrc = pSrc;
  d->m_src_buf_left = src_buf_left;
  __retres = 1;
  return_label: return __retres;
}

static tdefl_status tdefl_flush_output_buffer(tdefl_compressor *d)
{
  int tmp_0;
  if (d->m_pIn_buf_size) *(d->m_pIn_buf_size) = (size_t)(d->m_pSrc - (mz_uint8 const *)d->m_pIn_buf);
  if (d->m_pOut_buf_size) {
    size_t tmp;
    if (*(d->m_pOut_buf_size) - d->m_out_buf_ofs < (size_t)d->m_output_flush_remaining) 
      tmp = *(d->m_pOut_buf_size) - d->m_out_buf_ofs;
    else tmp = (size_t)d->m_output_flush_remaining;
    size_t n = tmp;
    memcpy((void *)((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs),
           (void const *)(& d->m_output_buf[d->m_output_flush_ofs]),n);
    d->m_output_flush_ofs += (mz_uint)n;
    d->m_output_flush_remaining -= (mz_uint)n;
    d->m_out_buf_ofs += n;
    *(d->m_pOut_buf_size) = d->m_out_buf_ofs;
  }
  if (d->m_finished) 
    if (! d->m_output_flush_remaining) tmp_0 = TDEFL_STATUS_DONE;
    else tmp_0 = TDEFL_STATUS_OKAY;
  else tmp_0 = TDEFL_STATUS_OKAY;
  return tmp_0;
}

tdefl_status __attribute__((__visibility__("default"))) tdefl_compress
(tdefl_compressor *d, void const *pIn_buf, size_t *pIn_buf_size,
 void *pOut_buf, size_t *pOut_buf_size, tdefl_flush flush)
{
  tdefl_status __attribute__((__visibility__("default"))) __retres;
  int tmp_0;
  tdefl_status tmp_6;
  if (! d) {
    if (pIn_buf_size) *pIn_buf_size = (size_t)0;
    if (pOut_buf_size) *pOut_buf_size = (size_t)0;
    __retres = TDEFL_STATUS_BAD_PARAM;
    goto return_label;
  }
  d->m_pIn_buf = pIn_buf;
  d->m_pIn_buf_size = pIn_buf_size;
  d->m_pOut_buf = pOut_buf;
  d->m_pOut_buf_size = pOut_buf_size;
  d->m_pSrc = (mz_uint8 const *)pIn_buf;
  if (pIn_buf_size) d->m_src_buf_left = *pIn_buf_size;
  else d->m_src_buf_left = (size_t)0;
  d->m_out_buf_ofs = (size_t)0;
  d->m_flush = flush;
  if (pOut_buf != (void *)0) tmp_0 = 1;
  else 
    if (pOut_buf_size != (size_t *)0) tmp_0 = 1; else tmp_0 = 0;
  ;
  if ((d->m_pPut_buf_func != (mz_bool (*)(void const *pBuf, int len,
                                          void *pUser))0) == tmp_0) goto _LOR;
  else 
    if (d->m_prev_return_status != TDEFL_STATUS_OKAY) goto _LOR;
    else 
      if (d->m_wants_to_finish) {
        if (flush != (unsigned int)TDEFL_FINISH) goto _LOR;
        else goto _LAND_1;
      }
      else {
        _LAND_1: ;
        if (pIn_buf_size) {
          if (*pIn_buf_size) {
            if (! pIn_buf) goto _LOR; else goto _LAND_0;
          }
          else goto _LAND_0;
        }
        else {
          _LAND_0: ;
          if (pOut_buf_size) 
            if (*pOut_buf_size) 
              if (! pOut_buf) {
                _LOR:
                {
                  tdefl_status tmp;
                  if (pIn_buf_size) *pIn_buf_size = (size_t)0;
                  if (pOut_buf_size) *pOut_buf_size = (size_t)0;
                  tmp = TDEFL_STATUS_BAD_PARAM;
                  d->m_prev_return_status = tmp;
                  __retres = (tdefl_status __attribute__((__visibility__("default"))))tmp;
                  goto return_label;
                }
              }
        }
      }
  d->m_wants_to_finish |= (unsigned int)(flush == (unsigned int)TDEFL_FINISH);
  if (d->m_output_flush_remaining) goto _LOR_0;
  else 
    if (d->m_finished) {
      tdefl_status tmp_1;
      _LOR_0: tmp_1 = tdefl_flush_output_buffer(d);
      d->m_prev_return_status = tmp_1;
      __retres = (tdefl_status __attribute__((__visibility__("default"))))tmp_1;
      goto return_label;
    }
  if ((d->m_flags & (unsigned int)TDEFL_MAX_PROBES_MASK) == (unsigned int)1) {
    if ((d->m_flags & (unsigned int)TDEFL_GREEDY_PARSING_FLAG) != (unsigned int)0) {
      if ((d->m_flags & (unsigned int)((TDEFL_FILTER_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS) | TDEFL_RLE_MATCHES)) == (unsigned int)0) {
        mz_bool tmp_2;
        tmp_2 = tdefl_compress_fast(d);
        if (! tmp_2) {
          __retres = (tdefl_status __attribute__((__visibility__("default"))))d->m_prev_return_status;
          goto return_label;
        }
      }
      else goto _LAND_3;
    }
    else goto _LAND_3;
  }
  else {
    _LAND_3:
    {
      mz_bool tmp_3;
      tmp_3 = tdefl_compress_normal(d);
      if (! tmp_3) {
        __retres = (tdefl_status __attribute__((__visibility__("default"))))d->m_prev_return_status;
        goto return_label;
      }
    }
  }
  if (d->m_flags & (unsigned int)(TDEFL_WRITE_ZLIB_HEADER | TDEFL_COMPUTE_ADLER32)) 
    if (pIn_buf) {
      mz_ulong __attribute__((__visibility__("default"))) tmp_4;
      tmp_4 = mz_adler32((mz_ulong)d->m_adler32,(mz_uint8 const *)pIn_buf,
                         (size_t)(d->m_pSrc - (mz_uint8 const *)pIn_buf));
      d->m_adler32 = (mz_uint32)tmp_4;
    }
  if (flush) 
    if (! d->m_lookahead_size) 
      if (! d->m_src_buf_left) 
        if (! d->m_output_flush_remaining) {
          int tmp_5;
          tmp_5 = tdefl_flush_block(d,(int)flush);
          if (tmp_5 < 0) {
            __retres = (tdefl_status __attribute__((__visibility__("default"))))d->m_prev_return_status;
            goto return_label;
          }
          d->m_finished = (mz_uint)(flush == (unsigned int)TDEFL_FINISH);
          if (flush == (unsigned int)TDEFL_FULL_FLUSH) {
            memset((void *)(& d->m_hash),0,sizeof(d->m_hash));
            memset((void *)(& d->m_next),0,sizeof(d->m_next));
            d->m_dict_size = (mz_uint)0;
          }
        }
  tmp_6 = tdefl_flush_output_buffer(d);
  d->m_prev_return_status = tmp_6;
  __retres = (tdefl_status __attribute__((__visibility__("default"))))tmp_6;
  return_label: return __retres;
}

tdefl_status __attribute__((__visibility__("default"))) tdefl_compress_buffer
(tdefl_compressor *d, void const *pIn_buf, size_t in_buf_size,
 tdefl_flush flush)
{
  tdefl_status __attribute__((__visibility__("default"))) tmp;
  __FC_assert(d->m_pPut_buf_func != (mz_bool (*)(void const *pBuf, int len,
                                                 void *pUser))0,
              "miniz_tdef.c",1318,"d->m_pPut_buf_func");
  tmp = tdefl_compress(d,pIn_buf,& in_buf_size,(void *)0,(size_t *)0,flush);
  return tmp;
}

tdefl_status __attribute__((__visibility__("default"))) tdefl_init(tdefl_compressor *d,
                                                                   mz_bool (*pPut_buf_func)
                                                                   (void const *pBuf,
                                                                    int len,
                                                                    void *pUser),
                                                                   void *pPut_buf_user,
                                                                   int flags)
{
  tdefl_status __attribute__((__visibility__("default"))) __retres;
  mz_uint tmp_3;
  mz_uint tmp_2;
  mz_uint tmp_1;
  mz_uint tmp_0;
  mz_uint tmp;
  mz_uint tmp_8;
  mz_uint tmp_7;
  mz_uint tmp_6;
  mz_uint tmp_5;
  mz_uint tmp_4;
  mz_uint tmp_10;
  mz_uint tmp_9;
  d->m_pPut_buf_func = pPut_buf_func;
  d->m_pPut_buf_user = pPut_buf_user;
  d->m_flags = (mz_uint)flags;
  d->m_max_probes[0] = (mz_uint)(1 + ((flags & 0xFFF) + 2) / 3);
  d->m_greedy_parsing = (flags & TDEFL_GREEDY_PARSING_FLAG) != 0;
  d->m_max_probes[1] = (mz_uint)(1 + (((flags & 0xFFF) >> 2) + 2) / 3);
  if (! (flags & TDEFL_NONDETERMINISTIC_PARSING_FLAG)) memset((void *)(& d->m_hash),
                                                              0,
                                                              sizeof(d->m_hash));
  tmp_3 = (mz_uint)0;
  d->m_bits_in = tmp_3;
  tmp_2 = tmp_3;
  d->m_lz_code_buf_dict_pos = tmp_2;
  tmp_1 = tmp_2;
  d->m_total_lz_bytes = tmp_1;
  tmp_0 = tmp_1;
  d->m_dict_size = tmp_0;
  tmp = tmp_0;
  d->m_lookahead_size = tmp;
  d->m_lookahead_pos = tmp;
  tmp_8 = (mz_uint)0;
  d->m_wants_to_finish = tmp_8;
  tmp_7 = tmp_8;
  d->m_bit_buffer = tmp_7;
  tmp_6 = tmp_7;
  d->m_block_index = tmp_6;
  tmp_5 = tmp_6;
  d->m_finished = tmp_5;
  tmp_4 = tmp_5;
  d->m_output_flush_remaining = tmp_4;
  d->m_output_flush_ofs = tmp_4;
  d->m_pLZ_code_buf = & d->m_lz_code_buf[1];
  d->m_pLZ_flags = d->m_lz_code_buf;
  *(d->m_pLZ_flags) = (mz_uint8)0;
  d->m_num_flags_left = (mz_uint)8;
  d->m_pOutput_buf = d->m_output_buf;
  d->m_pOutput_buf_end = d->m_output_buf;
  d->m_prev_return_status = TDEFL_STATUS_OKAY;
  tmp_10 = (mz_uint)0;
  d->m_saved_lit = tmp_10;
  tmp_9 = tmp_10;
  d->m_saved_match_len = tmp_9;
  d->m_saved_match_dist = tmp_9;
  d->m_adler32 = (mz_uint)1;
  d->m_pIn_buf = (void const *)0;
  d->m_pOut_buf = (void *)0;
  d->m_pIn_buf_size = (size_t *)0;
  d->m_pOut_buf_size = (size_t *)0;
  d->m_flush = TDEFL_NO_FLUSH;
  d->m_pSrc = (mz_uint8 const *)0;
  d->m_src_buf_left = (size_t)0;
  d->m_out_buf_ofs = (size_t)0;
  if (! (flags & TDEFL_NONDETERMINISTIC_PARSING_FLAG)) memset((void *)(& d->m_dict),
                                                              0,
                                                              sizeof(d->m_dict));
  memset((void *)(& d->m_huff_count[0][0]),0,
         sizeof(d->m_huff_count[0][0]) * (unsigned long)TDEFL_MAX_HUFF_SYMBOLS_0);
  memset((void *)(& d->m_huff_count[1][0]),0,
         sizeof(d->m_huff_count[1][0]) * (unsigned long)TDEFL_MAX_HUFF_SYMBOLS_1);
  __retres = TDEFL_STATUS_OKAY;
  return __retres;
}

tdefl_status __attribute__((__visibility__("default"))) tdefl_get_prev_return_status
(tdefl_compressor *d)
{
  tdefl_status __attribute__((__visibility__("default"))) __retres;
  __retres = (tdefl_status __attribute__((__visibility__("default"))))d->m_prev_return_status;
  return __retres;
}

mz_uint32 __attribute__((__visibility__("default"))) tdefl_get_adler32
(tdefl_compressor *d)
{
  mz_uint32 __attribute__((__visibility__("default"))) __retres;
  __retres = (mz_uint32 __attribute__((__visibility__("default"))))d->m_adler32;
  return __retres;
}

mz_bool __attribute__((__visibility__("default"))) tdefl_compress_mem_to_output
(void const *pBuf, size_t buf_len,
 mz_bool (*pPut_buf_func)(void const *pBuf, int len, void *pUser),
 void *pPut_buf_user, int flags)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  tdefl_compressor *pComp;
  mz_bool succeeded;
  tdefl_status __attribute__((__visibility__("default"))) tmp_0;
  int tmp_2;
  if (buf_len) {
    if (! pBuf) {
      __retres = (mz_bool __attribute__((__visibility__("default"))))0;
      goto return_label;
    }
    else goto _LAND;
  }
  else 
    _LAND:
    if (! pPut_buf_func) {
      __retres = (mz_bool __attribute__((__visibility__("default"))))0;
      goto return_label;
    }
  pComp = (tdefl_compressor *)malloc(sizeof(tdefl_compressor));
  if (! pComp) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  tmp_0 = tdefl_init(pComp,pPut_buf_func,pPut_buf_user,flags);
  succeeded = tmp_0 == (int __attribute__((__visibility__("default"))))TDEFL_STATUS_OKAY;
  if (succeeded) {
    tdefl_status __attribute__((__visibility__("default"))) tmp_1;
    tmp_1 = tdefl_compress_buffer(pComp,pBuf,buf_len,TDEFL_FINISH);
    if (tmp_1 == (int __attribute__((__visibility__("default"))))TDEFL_STATUS_DONE) 
      tmp_2 = 1;
    else tmp_2 = 0;
  }
  else tmp_2 = 0;
  succeeded = tmp_2;
  free((void *)pComp);
  __retres = (mz_bool __attribute__((__visibility__("default"))))succeeded;
  return_label: return __retres;
}

static mz_bool tdefl_output_buffer_putter(void const *pBuf, int len,
                                          void *pUser)
{
  mz_bool __retres;
  tdefl_output_buffer *p = (tdefl_output_buffer *)pUser;
  size_t new_size = p->m_size + (size_t)len;
  if (new_size > p->m_capacity) {
    mz_uint8 *pNew_buf;
    size_t new_capacity = p->m_capacity;
    if (! p->m_expandable) {
      __retres = 0;
      goto return_label;
    }
    while (1) {
      if ((size_t)128U > new_capacity << 1U) new_capacity = (size_t)128U;
      else new_capacity <<= 1U;
      if (! (new_size > new_capacity)) break;
    }
    pNew_buf = (mz_uint8 *)realloc((void *)p->m_pBuf,new_capacity);
    if (! pNew_buf) {
      __retres = 0;
      goto return_label;
    }
    p->m_pBuf = pNew_buf;
    p->m_capacity = new_capacity;
  }
  memcpy((void *)(p->m_pBuf + p->m_size),pBuf,(size_t)len);
  p->m_size = new_size;
  __retres = 1;
  return_label: return __retres;
}

void __attribute__((__visibility__("default"))) *tdefl_compress_mem_to_heap
(void const *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)
{
  void __attribute__((__visibility__("default"))) *__retres;
  tdefl_output_buffer out_buf;
  mz_bool __attribute__((__visibility__("default"))) tmp;
  memset((void *)(& out_buf),0,sizeof(out_buf));
  if (! pOut_len) {
    __retres = (void __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  else *pOut_len = (size_t)0;
  out_buf.m_expandable = 1;
  tmp = tdefl_compress_mem_to_output(pSrc_buf,src_buf_len,
                                     & tdefl_output_buffer_putter,
                                     (void *)(& out_buf),flags);
  if (! tmp) {
    __retres = (void __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  *pOut_len = out_buf.m_size;
  __retres = (void __attribute__((__visibility__("default"))) *)out_buf.m_pBuf;
  return_label: return __retres;
}

size_t __attribute__((__visibility__("default"))) tdefl_compress_mem_to_mem
(void *pOut_buf, size_t out_buf_len, void const *pSrc_buf,
 size_t src_buf_len, int flags)
{
  size_t __attribute__((__visibility__("default"))) __retres;
  tdefl_output_buffer out_buf;
  mz_bool __attribute__((__visibility__("default"))) tmp;
  memset((void *)(& out_buf),0,sizeof(out_buf));
  if (! pOut_buf) {
    __retres = (size_t __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  out_buf.m_pBuf = (mz_uint8 *)pOut_buf;
  out_buf.m_capacity = out_buf_len;
  tmp = tdefl_compress_mem_to_output(pSrc_buf,src_buf_len,
                                     & tdefl_output_buffer_putter,
                                     (void *)(& out_buf),flags);
  if (! tmp) {
    __retres = (size_t __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  __retres = (size_t __attribute__((__visibility__("default"))))out_buf.m_size;
  return_label: return __retres;
}

static mz_uint const s_tdefl_num_probes[11] =
  {(mz_uint)0,
   (mz_uint)1,
   (mz_uint)6,
   (mz_uint)32,
   (mz_uint)16,
   (mz_uint)32,
   (mz_uint)128,
   (mz_uint)256,
   (mz_uint)512,
   (mz_uint)768,
   (mz_uint)1500};
mz_uint __attribute__((__visibility__("default"))) tdefl_create_comp_flags_from_zip_params
(int level, int window_bits, int strategy)
{
  mz_uint __attribute__((__visibility__("default"))) __retres;
  int tmp_0;
  int tmp_1;
  if (level >= 0) {
    int tmp;
    if (10 < level) tmp = 10; else tmp = level;
    tmp_0 = tmp;
  }
  else tmp_0 = MZ_DEFAULT_LEVEL;
  if (level <= 3) tmp_1 = TDEFL_GREEDY_PARSING_FLAG; else tmp_1 = 0;
  mz_uint comp_flags = s_tdefl_num_probes[tmp_0] | (unsigned int)tmp_1;
  if (window_bits > 0) comp_flags |= (unsigned int)TDEFL_WRITE_ZLIB_HEADER;
  if (! level) comp_flags |= (unsigned int)TDEFL_FORCE_ALL_RAW_BLOCKS;
  else 
    if (strategy == MZ_FILTERED) comp_flags |= (unsigned int)TDEFL_FILTER_MATCHES;
    else 
      if (strategy == MZ_HUFFMAN_ONLY) comp_flags &= (unsigned int)(~ TDEFL_MAX_PROBES_MASK);
      else 
        if (strategy == MZ_FIXED) comp_flags |= (unsigned int)TDEFL_FORCE_ALL_STATIC_BLOCKS;
        else 
          if (strategy == MZ_RLE) comp_flags |= (unsigned int)TDEFL_RLE_MATCHES;
  __retres = (mz_uint __attribute__((__visibility__("default"))))comp_flags;
  return __retres;
}

static mz_uint const tdefl_write_image_to_png_file_in_memory_ex_s_tdefl_png_num_probes[11] =
  {(mz_uint)0,
   (mz_uint)1,
   (mz_uint)6,
   (mz_uint)32,
   (mz_uint)16,
   (mz_uint)32,
   (mz_uint)128,
   (mz_uint)256,
   (mz_uint)512,
   (mz_uint)768,
   (mz_uint)1500};
static mz_uint8 const tdefl_write_image_to_png_file_in_memory_ex_chans[5] =
  {(mz_uint8)0x00,
   (mz_uint8)0x00,
   (mz_uint8)0x04,
   (mz_uint8)0x02,
   (mz_uint8)0x06};
void __attribute__((__visibility__("default"))) *tdefl_write_image_to_png_file_in_memory_ex
(void const *pImage, int w, int h, int num_chans, size_t *pLen_out,
 mz_uint level, mz_bool flip)
{
  void __attribute__((__visibility__("default"))) *__retres;
  tdefl_output_buffer out_buf;
  int i;
  int y;
  int z;
  mz_uint32 c;
  int tmp_0;
  mz_uint tmp_2;
  tdefl_status __attribute__((__visibility__("default"))) tmp_4;
  mz_bool tmp_6;
  mz_ulong __attribute__((__visibility__("default"))) tmp_7;
  tdefl_compressor *pComp = malloc(sizeof(tdefl_compressor));
  int bpl = w * num_chans;
  *pLen_out = (size_t)0;
  if (! pComp) {
    __retres = (void __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  memset((void *)(& out_buf),0,sizeof(out_buf));
  out_buf.m_expandable = 1;
  if (64 > (1 + bpl) * h) tmp_0 = 64; else tmp_0 = (1 + bpl) * h;
  out_buf.m_capacity = (size_t)(57 + tmp_0);
  out_buf.m_pBuf = (mz_uint8 *)malloc(out_buf.m_capacity);
  if ((mz_uint8 *)0 == out_buf.m_pBuf) {
    free((void *)pComp);
    __retres = (void __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  z = 41;
  while (z) {
    tdefl_output_buffer_putter((void const *)(& z),1,(void *)(& out_buf));
    z --;
  }
  if ((mz_uint)10 < level) tmp_2 = (mz_uint)10; else tmp_2 = level;
  ;
  ;
  tdefl_init(pComp,& tdefl_output_buffer_putter,(void *)(& out_buf),
             (int)(tdefl_write_image_to_png_file_in_memory_ex_s_tdefl_png_num_probes[tmp_2] | (unsigned int)TDEFL_WRITE_ZLIB_HEADER));
  y = 0;
  while (y < h) {
    {
      int tmp_3;
      tdefl_compress_buffer(pComp,(void const *)(& z),(size_t)1,
                            TDEFL_NO_FLUSH);
      ;
      if (flip) tmp_3 = (h - 1) - y; else tmp_3 = y;
      ;
      ;
      tdefl_compress_buffer(pComp,
                            (void const *)((mz_uint8 *)pImage + tmp_3 * bpl),
                            (size_t)bpl,TDEFL_NO_FLUSH);
    }
    y ++;
  }
  tmp_4 = tdefl_compress_buffer(pComp,(void const *)0,(size_t)0,TDEFL_FINISH);
  if (tmp_4 != (int __attribute__((__visibility__("default"))))TDEFL_STATUS_DONE) {
    free((void *)pComp);
    free((void *)out_buf.m_pBuf);
    __retres = (void __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  *pLen_out = out_buf.m_size - (size_t)41;
  {
    mz_ulong __attribute__((__visibility__("default"))) tmp_5;
    mz_uint8 pnghdr[41] =
      {(mz_uint8)0x89,
       (mz_uint8)0x50,
       (mz_uint8)0x4e,
       (mz_uint8)0x47,
       (mz_uint8)0x0d,
       (mz_uint8)0x0a,
       (mz_uint8)0x1a,
       (mz_uint8)0x0a,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x0d,
       (mz_uint8)0x49,
       (mz_uint8)0x48,
       (mz_uint8)0x44,
       (mz_uint8)0x52,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x08,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x00,
       (mz_uint8)0x49,
       (mz_uint8)0x44,
       (mz_uint8)0x41,
       (mz_uint8)0x54};
    pnghdr[18] = (mz_uint8)(w >> 8);
    pnghdr[19] = (mz_uint8)w;
    pnghdr[22] = (mz_uint8)(h >> 8);
    pnghdr[23] = (mz_uint8)h;
    pnghdr[25] = tdefl_write_image_to_png_file_in_memory_ex_chans[num_chans];
    pnghdr[33] = (mz_uint8)(*pLen_out >> 24);
    pnghdr[34] = (mz_uint8)(*pLen_out >> 16);
    pnghdr[35] = (mz_uint8)(*pLen_out >> 8);
    pnghdr[36] = (mz_uint8)*pLen_out;
    tmp_5 = mz_crc32((mz_ulong)0,(unsigned char const *)(& pnghdr[12]),
                     (size_t)17);
    c = (mz_uint32)tmp_5;
    i = 0;
    while (i < 4) {
      *(& pnghdr[29] + i) = (mz_uint8)(c >> 24);
      i ++;
      c <<= 8;
    }
    memcpy((void *)out_buf.m_pBuf,(void const *)(pnghdr),(size_t)41);
  }
  tmp_6 = tdefl_output_buffer_putter((void const *)"\000\000\000\000\000\000\000\000IEND\256B`\202",
                                     16,(void *)(& out_buf));
  if (! tmp_6) {
    *pLen_out = (size_t)0;
    free((void *)pComp);
    free((void *)out_buf.m_pBuf);
    __retres = (void __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  tmp_7 = mz_crc32((mz_ulong)0,
                   (unsigned char const *)((out_buf.m_pBuf + 41) - 4),
                   *pLen_out + (size_t)4);
  c = (mz_uint32)tmp_7;
  i = 0;
  while (i < 4) {
    *(((out_buf.m_pBuf + out_buf.m_size) - 16) + i) = (mz_uint8)(c >> 24);
    i ++;
    c <<= 8;
  }
  *pLen_out += (size_t)57;
  free((void *)pComp);
  __retres = (void __attribute__((__visibility__("default"))) *)out_buf.m_pBuf;
  return_label: return __retres;
}

void __attribute__((__visibility__("default"))) *tdefl_write_image_to_png_file_in_memory
(void const *pImage, int w, int h, int num_chans, size_t *pLen_out)
{
  void __attribute__((__visibility__("default"))) *tmp;
  tmp = tdefl_write_image_to_png_file_in_memory_ex(pImage,w,h,num_chans,
                                                   pLen_out,(mz_uint)6,0);
  return tmp;
}

tdefl_compressor __attribute__((__visibility__("default"))) *tdefl_compressor_alloc
(void)
{
  tdefl_compressor __attribute__((__visibility__("default"))) *__retres;
  tdefl_compressor *tmp;
  tmp = (tdefl_compressor *)malloc(sizeof(tdefl_compressor));
  __retres = (tdefl_compressor __attribute__((__visibility__("default"))) *)tmp;
  return __retres;
}

void __attribute__((__visibility__("default"))) tdefl_compressor_free
(tdefl_compressor *pComp)
{
  free((void *)pComp);
  return;
}

static int const tinfl_decompress_s_length_base[31] =
  {3,
   4,
   5,
   6,
   7,
   8,
   9,
   10,
   11,
   13,
   15,
   17,
   19,
   23,
   27,
   31,
   35,
   43,
   51,
   59,
   67,
   83,
   99,
   115,
   131,
   163,
   195,
   227,
   258,
   0,
   0};
static int const tinfl_decompress_s_length_extra[31] =
  {0,
   0,
   0,
   0,
   0,
   0,
   0,
   0,
   1,
   1,
   1,
   1,
   2,
   2,
   2,
   2,
   3,
   3,
   3,
   3,
   4,
   4,
   4,
   4,
   5,
   5,
   5,
   5,
   0,
   0,
   0};
static int const tinfl_decompress_s_dist_base[32] =
  {1,
   2,
   3,
   4,
   5,
   7,
   9,
   13,
   17,
   25,
   33,
   49,
   65,
   97,
   129,
   193,
   257,
   385,
   513,
   769,
   1025,
   1537,
   2049,
   3073,
   4097,
   6145,
   8193,
   12289,
   16385,
   24577,
   0,
   0};
static int const tinfl_decompress_s_dist_extra[32] =
  {0,
   0,
   0,
   0,
   1,
   1,
   2,
   2,
   3,
   3,
   4,
   4,
   5,
   5,
   6,
   6,
   7,
   7,
   8,
   8,
   9,
   9,
   10,
   10,
   11,
   11,
   12,
   12,
   13,
   13};
static mz_uint8 const tinfl_decompress_s_length_dezigzag[19] =
  {(mz_uint8)16,
   (mz_uint8)17,
   (mz_uint8)18,
   (mz_uint8)0,
   (mz_uint8)8,
   (mz_uint8)7,
   (mz_uint8)9,
   (mz_uint8)6,
   (mz_uint8)10,
   (mz_uint8)5,
   (mz_uint8)11,
   (mz_uint8)4,
   (mz_uint8)12,
   (mz_uint8)3,
   (mz_uint8)13,
   (mz_uint8)2,
   (mz_uint8)14,
   (mz_uint8)1,
   (mz_uint8)15};
static int const tinfl_decompress_s_min_table_sizes[3] = {257, 1, 4};
tinfl_status __attribute__((__visibility__("default"))) tinfl_decompress
(tinfl_decompressor *r, mz_uint8 const *pIn_buf_next, size_t *pIn_buf_size,
 mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size,
 mz_uint32 const decomp_flags)
{
  tinfl_status __attribute__((__visibility__("default"))) __retres;
  mz_uint32 num_bits;
  mz_uint32 dist;
  mz_uint32 counter;
  mz_uint32 num_extra;
  tinfl_bit_buf_t bit_buf;
  size_t tmp;
  size_t dist_from_out_buf_start;
  tinfl_status status = TINFL_STATUS_FAILED;
  mz_uint8 const *pIn_buf_cur = pIn_buf_next;
  mz_uint8 const * const pIn_buf_end = pIn_buf_next + *pIn_buf_size;
  mz_uint8 *pOut_buf_cur = pOut_buf_next;
  mz_uint8 * const pOut_buf_end = pOut_buf_next + *pOut_buf_size;
  if (decomp_flags & (unsigned int)TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF) 
    tmp = (size_t)(-1);
  else tmp = ((size_t)(pOut_buf_next - pOut_buf_start) + *pOut_buf_size) - (size_t)1;
  size_t out_buf_size_mask = tmp;
  if ((out_buf_size_mask + (size_t)1) & out_buf_size_mask) goto _LOR;
  else 
    if (pOut_buf_next < pOut_buf_start) {
      _LOR:
      {
        size_t tmp_0;
        tmp_0 = (size_t)0;
        *pOut_buf_size = tmp_0;
        *pIn_buf_size = tmp_0;
        __retres = TINFL_STATUS_BAD_PARAM;
        goto return_label;
      }
    }
  num_bits = r->m_num_bits;
  bit_buf = r->m_bit_buf;
  dist = r->m_dist;
  counter = r->m_counter;
  num_extra = r->m_num_extra;
  dist_from_out_buf_start = r->m_dist_from_out_buf_start;
  switch (r->m_state) {
    mz_uint32 tmp_2;
    mz_uint32 tmp_1;
    mz_uint32 tmp_3;
    case (mz_uint32)0:
    { /* sequence */
      tmp_2 = (mz_uint32)0;
      r->m_zhdr1 = tmp_2;
      tmp_1 = tmp_2;
      r->m_zhdr0 = tmp_1;
      num_extra = tmp_1;
      counter = num_extra;
      dist = counter;
      num_bits = dist;
      bit_buf = (tinfl_bit_buf_t)num_bits;
    }
    tmp_3 = (mz_uint32)1;
    r->m_check_adler32 = tmp_3;
    r->m_z_adler32 = tmp_3;
    if (decomp_flags & (unsigned int)TINFL_FLAG_PARSE_ZLIB_HEADER) {
      int tmp_6;
      {
        mz_uint8 const *tmp_4;
        while (pIn_buf_cur >= pIn_buf_end) {
          if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
            status = TINFL_STATUS_NEEDS_MORE_INPUT;
          else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
          r->m_state = (mz_uint32)1;
          goto common_exit;
          case (mz_uint32)1: ;
        }
        tmp_4 = pIn_buf_cur;
        pIn_buf_cur ++;
        r->m_zhdr0 = (mz_uint32)*tmp_4;
      }
      {
        mz_uint8 const *tmp_5;
        while (pIn_buf_cur >= pIn_buf_end) {
          if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
            status = TINFL_STATUS_NEEDS_MORE_INPUT;
          else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
          r->m_state = (mz_uint32)2;
          goto common_exit;
          case (mz_uint32)2: ;
        }
        tmp_5 = pIn_buf_cur;
        pIn_buf_cur ++;
        r->m_zhdr1 = (mz_uint32)*tmp_5;
      }
      if ((r->m_zhdr0 * (mz_uint32)256 + r->m_zhdr1) % (unsigned int)31 != (unsigned int)0) 
        tmp_6 = 1;
      else 
        if (r->m_zhdr1 & (unsigned int)32) tmp_6 = 1;
        else 
          if ((r->m_zhdr0 & (unsigned int)15) != (unsigned int)8) tmp_6 = 1;
          else tmp_6 = 0;
      counter = (mz_uint32)tmp_6;
      if (! (decomp_flags & (unsigned int)TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)) {
        int tmp_7;
        if (1U << (8U + (r->m_zhdr0 >> 4)) > 32768U) tmp_7 = 1;
        else 
          if (out_buf_size_mask + (size_t)1 < (size_t)(1U << (8U + (r->m_zhdr0 >> 4)))) 
            tmp_7 = 1;
          else tmp_7 = 0;
        counter |= (unsigned int)tmp_7;
      }
      if (counter) 
        while (1) {
          status = TINFL_STATUS_FAILED;
          r->m_state = (mz_uint32)36;
          goto common_exit;
          case (mz_uint32)36: ;
        }
    }
    while (1) {
      if (num_bits < (mz_uint)3) 
        while (1) {
          {
            mz_uint c;
            {
              mz_uint8 const *tmp_8;
              while (pIn_buf_cur >= pIn_buf_end) {
                if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                  status = TINFL_STATUS_NEEDS_MORE_INPUT;
                else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                r->m_state = (mz_uint32)3;
                goto common_exit;
                case (mz_uint32)3: ;
              }
              tmp_8 = pIn_buf_cur;
              pIn_buf_cur ++;
              c = (mz_uint)*tmp_8;
            }
            bit_buf |= (tinfl_bit_buf_t)c << num_bits;
            num_bits += (mz_uint32)8;
          }
          if (! (num_bits < (mz_uint)3)) break;
        }
      r->m_final = (mz_uint32)(bit_buf & (unsigned long)((1 << 3) - 1));
      bit_buf >>= 3;
      num_bits -= (mz_uint32)3;
      r->m_type = r->m_final >> 1;
      if (r->m_type == (mz_uint32)0) {
        if (num_bits < (num_bits & (unsigned int)7)) 
          while (1) {
            {
              mz_uint c_0;
              {
                mz_uint8 const *tmp_9;
                while (pIn_buf_cur >= pIn_buf_end) {
                  if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                    status = TINFL_STATUS_NEEDS_MORE_INPUT;
                  else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                  r->m_state = (mz_uint32)5;
                  goto common_exit;
                  case (mz_uint32)5: ;
                }
                tmp_9 = pIn_buf_cur;
                pIn_buf_cur ++;
                c_0 = (mz_uint)*tmp_9;
              }
              bit_buf |= (tinfl_bit_buf_t)c_0 << num_bits;
              num_bits += (mz_uint32)8;
            }
            if (! (num_bits < (num_bits & (unsigned int)7))) break;
          }
        bit_buf >>= num_bits & (unsigned int)7;
        num_bits -= num_bits & (unsigned int)7;
        counter = (mz_uint32)0;
        while (counter < (mz_uint32)4) {
          if (num_bits) {
            if (num_bits < (mz_uint)8) 
              while (1) {
                {
                  mz_uint c_1;
                  {
                    mz_uint8 const *tmp_10;
                    while (pIn_buf_cur >= pIn_buf_end) {
                      if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                        status = TINFL_STATUS_NEEDS_MORE_INPUT;
                      else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                      r->m_state = (mz_uint32)6;
                      goto common_exit;
                      case (mz_uint32)6: ;
                    }
                    tmp_10 = pIn_buf_cur;
                    pIn_buf_cur ++;
                    c_1 = (mz_uint)*tmp_10;
                  }
                  bit_buf |= (tinfl_bit_buf_t)c_1 << num_bits;
                  num_bits += (mz_uint32)8;
                }
                if (! (num_bits < (mz_uint)8)) break;
              }
            r->m_raw_header[counter] = (mz_uint8)(bit_buf & (unsigned long)(
                                                  (1 << 8) - 1));
            bit_buf >>= 8;
            num_bits -= (mz_uint32)8;
          }
          else {
            mz_uint8 const *tmp_11;
            while (pIn_buf_cur >= pIn_buf_end) {
              if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                status = TINFL_STATUS_NEEDS_MORE_INPUT;
              else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
              r->m_state = (mz_uint32)7;
              goto common_exit;
              case (mz_uint32)7: ;
            }
            tmp_11 = pIn_buf_cur;
            pIn_buf_cur ++;
            r->m_raw_header[counter] = *tmp_11;
          }
          counter ++;
        }
        counter = (mz_uint32)((int)r->m_raw_header[0] | ((int)r->m_raw_header[1] << 8));
        ;
        if (counter != (mz_uint)(0xFFFF ^ ((int)r->m_raw_header[2] | (
                                           (int)r->m_raw_header[3] << 8)))) 
          while (1) {
            status = TINFL_STATUS_FAILED;
            r->m_state = (mz_uint32)39;
            goto common_exit;
            case (mz_uint32)39: ;
          }
        while (1) {
          if (counter) {
            if (! num_bits) break;
          }
          else break;
          {
            mz_uint8 *tmp_13;
            if (num_bits < (mz_uint)8) 
              while (1) {
                {
                  mz_uint c_2;
                  {
                    mz_uint8 const *tmp_12;
                    while (pIn_buf_cur >= pIn_buf_end) {
                      if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                        status = TINFL_STATUS_NEEDS_MORE_INPUT;
                      else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                      r->m_state = (mz_uint32)51;
                      goto common_exit;
                      case (mz_uint32)51: ;
                    }
                    tmp_12 = pIn_buf_cur;
                    pIn_buf_cur ++;
                    c_2 = (mz_uint)*tmp_12;
                  }
                  bit_buf |= (tinfl_bit_buf_t)c_2 << num_bits;
                  num_bits += (mz_uint32)8;
                }
                if (! (num_bits < (mz_uint)8)) break;
              }
            dist = (mz_uint32)(bit_buf & (unsigned long)((1 << 8) - 1));
            bit_buf >>= 8;
            num_bits -= (mz_uint32)8;
            while (pOut_buf_cur >= pOut_buf_end) {
              status = TINFL_STATUS_HAS_MORE_OUTPUT;
              r->m_state = (mz_uint32)52;
              goto common_exit;
              case (mz_uint32)52: ;
            }
            tmp_13 = pOut_buf_cur;
            pOut_buf_cur ++;
            *tmp_13 = (mz_uint8)dist;
            counter --;
          }
        }
        while (counter) {
          size_t n;
          size_t tmp_14;
          while (pOut_buf_cur >= pOut_buf_end) {
            status = TINFL_STATUS_HAS_MORE_OUTPUT;
            r->m_state = (mz_uint32)9;
            goto common_exit;
            case (mz_uint32)9: ;
          }
          while (pIn_buf_cur >= pIn_buf_end) {
            if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
              status = TINFL_STATUS_NEEDS_MORE_INPUT;
            else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
            r->m_state = (mz_uint32)38;
            goto common_exit;
            case (mz_uint32)38: ;
          }
          if ((size_t)(pOut_buf_end - pOut_buf_cur) < (size_t)(pIn_buf_end - pIn_buf_cur)) 
            tmp_14 = (size_t)(pOut_buf_end - pOut_buf_cur);
          else tmp_14 = (size_t)(pIn_buf_end - pIn_buf_cur);
          ;
          if (tmp_14 < (size_t)counter) {
            size_t tmp_15;
            if ((size_t)(pOut_buf_end - pOut_buf_cur) < (size_t)(pIn_buf_end - pIn_buf_cur)) 
              tmp_15 = (size_t)(pOut_buf_end - pOut_buf_cur);
            else tmp_15 = (size_t)(pIn_buf_end - pIn_buf_cur);
            n = tmp_15;
          }
          else n = (size_t)counter;
          memcpy((void *)pOut_buf_cur,(void const *)pIn_buf_cur,n);
          pIn_buf_cur += n;
          pOut_buf_cur += n;
          counter -= (mz_uint)n;
        }
      }
      else 
        if (r->m_type == (mz_uint32)3) 
          while (1) {
            status = TINFL_STATUS_FAILED;
            r->m_state = (mz_uint32)10;
            goto common_exit;
            case (mz_uint32)10: ;
          }
        else {
          if (r->m_type == (mz_uint32)1) {
            mz_uint i;
            mz_uint8 *p = r->m_tables[0].m_code_size;
            r->m_table_sizes[0] = (mz_uint32)288;
            r->m_table_sizes[1] = (mz_uint32)32;
            memset((void *)(r->m_tables[1].m_code_size),5,(size_t)32);
            i = (mz_uint)0;
            while (i <= (mz_uint)143) {
              mz_uint8 *tmp_16;
              tmp_16 = p;
              p ++;
              *tmp_16 = (mz_uint8)8;
              i ++;
            }
            while (i <= (mz_uint)255) {
              mz_uint8 *tmp_17;
              tmp_17 = p;
              p ++;
              *tmp_17 = (mz_uint8)9;
              i ++;
            }
            while (i <= (mz_uint)279) {
              mz_uint8 *tmp_18;
              tmp_18 = p;
              p ++;
              *tmp_18 = (mz_uint8)7;
              i ++;
            }
            while (i <= (mz_uint)287) {
              mz_uint8 *tmp_19;
              tmp_19 = p;
              p ++;
              *tmp_19 = (mz_uint8)8;
              i ++;
            }
          }
          else {
            counter = (mz_uint32)0;
            while (counter < (mz_uint32)3) {
              if (num_bits < (mz_uint)*("\005\005\004" + counter)) 
                while (1) {
                  {
                    mz_uint c_3;
                    {
                      mz_uint8 const *tmp_20;
                      while (pIn_buf_cur >= pIn_buf_end) {
                        if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                          status = TINFL_STATUS_NEEDS_MORE_INPUT;
                        else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                        r->m_state = (mz_uint32)11;
                        goto common_exit;
                        case (mz_uint32)11: ;
                      }
                      tmp_20 = pIn_buf_cur;
                      pIn_buf_cur ++;
                      c_3 = (mz_uint)*tmp_20;
                    }
                    bit_buf |= (tinfl_bit_buf_t)c_3 << num_bits;
                    num_bits += (mz_uint32)8;
                  }
                  if (! (num_bits < (mz_uint)*("\005\005\004" + counter))) 
                    break;
                }
              r->m_table_sizes[counter] = (mz_uint32)(bit_buf & (unsigned long)(
                                                      (1 << (int)*("\005\005\004" + counter)) - 1));
              bit_buf >>= (int)*("\005\005\004" + counter);
              num_bits -= (mz_uint32)*("\005\005\004" + counter);
              r->m_table_sizes[counter] += (mz_uint32)tinfl_decompress_s_min_table_sizes[counter];
              counter ++;
            }
            memset((void *)(& r->m_tables[2].m_code_size),0,
                   sizeof(r->m_tables[2].m_code_size));
            counter = (mz_uint32)0;
            while (counter < r->m_table_sizes[2]) {
              {
                mz_uint s;
                if (num_bits < (mz_uint)3) 
                  while (1) {
                    {
                      mz_uint c_4;
                      {
                        mz_uint8 const *tmp_21;
                        while (pIn_buf_cur >= pIn_buf_end) {
                          if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                            status = TINFL_STATUS_NEEDS_MORE_INPUT;
                          else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                          r->m_state = (mz_uint32)14;
                          goto common_exit;
                          case (mz_uint32)14: ;
                        }
                        tmp_21 = pIn_buf_cur;
                        pIn_buf_cur ++;
                        c_4 = (mz_uint)*tmp_21;
                      }
                      bit_buf |= (tinfl_bit_buf_t)c_4 << num_bits;
                      num_bits += (mz_uint32)8;
                    }
                    if (! (num_bits < (mz_uint)3)) break;
                  }
                s = (mz_uint)(bit_buf & (unsigned long)((1 << 3) - 1));
                bit_buf >>= 3;
                num_bits -= (mz_uint32)3;
                r->m_tables[2].m_code_size[tinfl_decompress_s_length_dezigzag[counter]] = (mz_uint8)s;
              }
              counter ++;
            }
            r->m_table_sizes[2] = (mz_uint32)19;
          }
          while ((int)r->m_type >= 0) {
            {
              int tree_next;
              int tree_cur;
              tinfl_huff_table *pTable;
              mz_uint i_0;
              mz_uint j;
              mz_uint used_syms;
              mz_uint total;
              mz_uint sym_index;
              mz_uint next_code[17];
              mz_uint total_syms[16];
              pTable = & r->m_tables[r->m_type];
              memset((void *)(& total_syms),0,sizeof(total_syms));
              memset((void *)(& pTable->m_look_up),0,
                     sizeof(pTable->m_look_up));
              memset((void *)(& pTable->m_tree),0,sizeof(pTable->m_tree));
              i_0 = (mz_uint)0;
              while (i_0 < r->m_table_sizes[r->m_type]) {
                (total_syms[pTable->m_code_size[i_0]]) ++;
                i_0 ++;
              }
              used_syms = (mz_uint)0;
              total = (mz_uint)0;
              next_code[1] = (mz_uint)0;
              next_code[0] = next_code[1];
              i_0 = (mz_uint)1;
              while (i_0 <= (mz_uint)15) {
                used_syms += total_syms[i_0];
                total = (total + total_syms[i_0]) << 1;
                next_code[i_0 + (mz_uint)1] = total;
                i_0 ++;
              }
              if ((mz_uint)65536 != total) 
                if (used_syms > (mz_uint)1) 
                  while (1) {
                    status = TINFL_STATUS_FAILED;
                    r->m_state = (mz_uint32)35;
                    goto common_exit;
                    case (mz_uint32)35: ;
                  }
              tree_next = -1;
              sym_index = (mz_uint)0;
              while (sym_index < r->m_table_sizes[r->m_type]) {
                {
                  mz_uint l;
                  mz_uint cur_code;
                  mz_uint tmp_22;
                  mz_uint rev_code = (mz_uint)0;
                  mz_uint code_size =
                    (mz_uint)pTable->m_code_size[sym_index];
                  if (! code_size) goto __Cont;
                  tmp_22 = next_code[code_size];
                  (next_code[code_size]) ++;
                  cur_code = tmp_22;
                  l = code_size;
                  while (l > (mz_uint)0) {
                    rev_code = (rev_code << 1) | (cur_code & (unsigned int)1);
                    l --;
                    cur_code >>= 1;
                  }
                  if (code_size <= (mz_uint)TINFL_FAST_LOOKUP_BITS) {
                    mz_int16 k = (mz_int16)((code_size << 9) | sym_index);
                    while (rev_code < (mz_uint)TINFL_FAST_LOOKUP_SIZE) {
                      pTable->m_look_up[rev_code] = k;
                      rev_code += (mz_uint)(1 << code_size);
                    }
                    goto __Cont;
                  }
                  tree_cur = (int)pTable->m_look_up[rev_code & (unsigned int)(
                                                    TINFL_FAST_LOOKUP_SIZE - 1)];
                  if (0 == tree_cur) {
                    pTable->m_look_up[rev_code & (unsigned int)(TINFL_FAST_LOOKUP_SIZE - 1)] = (mz_int16)tree_next;
                    tree_cur = tree_next;
                    tree_next -= 2;
                  }
                  rev_code >>= TINFL_FAST_LOOKUP_BITS - 1;
                  j = code_size;
                  while (j > (mz_uint)(TINFL_FAST_LOOKUP_BITS + 1)) {
                    rev_code >>= 1;
                    tree_cur = (int)((unsigned int)tree_cur - (rev_code & (unsigned int)1));
                    if (! pTable->m_tree[- tree_cur - 1]) {
                      pTable->m_tree[- tree_cur - 1] = (mz_int16)tree_next;
                      tree_cur = tree_next;
                      tree_next -= 2;
                    }
                    else tree_cur = (int)pTable->m_tree[- tree_cur - 1];
                    j --;
                  }
                  rev_code >>= 1;
                  tree_cur = (int)((unsigned int)tree_cur - (rev_code & (unsigned int)1));
                  pTable->m_tree[- tree_cur - 1] = (mz_int16)sym_index;
                }
                __Cont: sym_index ++;
              }
              if (r->m_type == (mz_uint32)2) {
                counter = (mz_uint32)0;
                while (counter < r->m_table_sizes[0] + r->m_table_sizes[1]) {
                  {
                    mz_uint s_0;
                    int tmp_28;
                    {
                      int temp;
                      mz_uint code_len;
                      mz_uint c_5;
                      if (num_bits < (mz_uint32)15) 
                        if (pIn_buf_end - pIn_buf_cur < (long)2) 
                          while (1) {
                            temp = (int)r->m_tables[2].m_look_up[bit_buf & (unsigned long)(
                                                                 TINFL_FAST_LOOKUP_SIZE - 1)];
                            if (temp >= 0) {
                              code_len = (mz_uint)(temp >> 9);
                              if (code_len) 
                                if (num_bits >= code_len) break;
                            }
                            else 
                              if (num_bits > (mz_uint32)TINFL_FAST_LOOKUP_BITS) {
                                code_len = (mz_uint)TINFL_FAST_LOOKUP_BITS;
                                while (1) {
                                  {
                                    mz_uint tmp_23;
                                    tmp_23 = code_len;
                                    code_len ++;
                                    temp = (int)r->m_tables[2].m_tree[
                                    (unsigned long)(~ temp) + ((bit_buf >> tmp_23) & (unsigned long)1)];
                                  }
                                  if (temp < 0) {
                                    if (! (num_bits >= code_len + (mz_uint)1)) 
                                      break;
                                  }
                                  else break;
                                }
                                if (temp >= 0) break;
                              }
                            {
                              mz_uint8 const *tmp_24;
                              while (pIn_buf_cur >= pIn_buf_end) {
                                if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                                  status = TINFL_STATUS_NEEDS_MORE_INPUT;
                                else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                                r->m_state = (mz_uint32)16;
                                goto common_exit;
                                case (mz_uint32)16: ;
                              }
                              tmp_24 = pIn_buf_cur;
                              pIn_buf_cur ++;
                              c_5 = (mz_uint)*tmp_24;
                            }
                            bit_buf |= (tinfl_bit_buf_t)c_5 << num_bits;
                            num_bits += (mz_uint32)8;
                            if (! (num_bits < (mz_uint32)15)) break;
                          }
                        else {
                          bit_buf |= ((tinfl_bit_buf_t)*(pIn_buf_cur + 0) << num_bits) | (
                                     (tinfl_bit_buf_t)*(pIn_buf_cur + 1) << (
                                     num_bits + (mz_uint32)8));
                          pIn_buf_cur += 2;
                          num_bits += (mz_uint32)16;
                        }
                      temp = (int)r->m_tables[2].m_look_up[bit_buf & (unsigned long)(
                                                           TINFL_FAST_LOOKUP_SIZE - 1)];
                      if (temp >= 0) {
                        code_len = (mz_uint)(temp >> 9);
                        temp &= 511;
                      }
                      else {
                        code_len = (mz_uint)TINFL_FAST_LOOKUP_BITS;
                        while (1) {
                          {
                            mz_uint tmp_25;
                            tmp_25 = code_len;
                            code_len ++;
                            temp = (int)r->m_tables[2].m_tree[(unsigned long)(~ temp) + (
                                                              (bit_buf >> tmp_25) & (unsigned long)1)];
                          }
                          if (! (temp < 0)) break;
                        }
                      }
                      dist = (mz_uint32)temp;
                      bit_buf >>= code_len;
                      num_bits -= code_len;
                    }
                    if (dist < (mz_uint32)16) {
                      mz_uint32 tmp_26;
                      tmp_26 = counter;
                      counter ++;
                      r->m_len_codes[tmp_26] = (mz_uint8)dist;
                      goto __Cont_0;
                    }
                    if (dist == (mz_uint32)16) 
                      if (! counter) 
                        while (1) {
                          status = TINFL_STATUS_FAILED;
                          r->m_state = (mz_uint32)17;
                          goto common_exit;
                          case (mz_uint32)17: ;
                        }
                    num_extra = (mz_uint32)*("\002\003\a" + (dist - (mz_uint32)16));
                    if (num_bits < num_extra) 
                      while (1) {
                        {
                          mz_uint c_6;
                          {
                            mz_uint8 const *tmp_27;
                            while (pIn_buf_cur >= pIn_buf_end) {
                              if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                                status = TINFL_STATUS_NEEDS_MORE_INPUT;
                              else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                              r->m_state = (mz_uint32)18;
                              goto common_exit;
                              case (mz_uint32)18: ;
                            }
                            tmp_27 = pIn_buf_cur;
                            pIn_buf_cur ++;
                            c_6 = (mz_uint)*tmp_27;
                          }
                          bit_buf |= (tinfl_bit_buf_t)c_6 << num_bits;
                          num_bits += (mz_uint32)8;
                        }
                        if (! (num_bits < num_extra)) break;
                      }
                    s_0 = (mz_uint)(bit_buf & (unsigned long)((1 << num_extra) - 1));
                    bit_buf >>= num_extra;
                    num_bits -= num_extra;
                    s_0 += (mz_uint)*("\003\003\v" + (dist - (mz_uint32)16));
                    ;
                    if (dist == (mz_uint32)16) tmp_28 = (int)r->m_len_codes[
                                               counter - (mz_uint32)1];
                    else tmp_28 = 0;
                    ;
                    memset((void *)(& r->m_len_codes[counter]),tmp_28,
                           (size_t)s_0);
                    counter += s_0;
                  }
                  __Cont_0: ;
                }
                if (r->m_table_sizes[0] + r->m_table_sizes[1] != counter) 
                  while (1) {
                    status = TINFL_STATUS_FAILED;
                    r->m_state = (mz_uint32)21;
                    goto common_exit;
                    case (mz_uint32)21: ;
                  }
                memcpy((void *)(r->m_tables[0].m_code_size),
                       (void const *)(r->m_len_codes),
                       (size_t)r->m_table_sizes[0]);
                memcpy((void *)(r->m_tables[1].m_code_size),
                       (void const *)(& r->m_len_codes[r->m_table_sizes[0]]),
                       (size_t)r->m_table_sizes[1]);
              }
            }
            (r->m_type) --;
          }
          while (1) {
            {
              mz_uint8 *pSrc;
              mz_uint8 *tmp_43;
              while (1) 
                if (pIn_buf_end - pIn_buf_cur < (long)4) goto _LOR_0;
                else 
                  if (pOut_buf_end - pOut_buf_cur < (long)2) {
                    _LOR_0:
                    {
                      mz_uint8 *tmp_32;
                      {
                        int temp_0;
                        mz_uint code_len_0;
                        mz_uint c_7;
                        if (num_bits < (mz_uint32)15) 
                          if (pIn_buf_end - pIn_buf_cur < (long)2) 
                            while (1) {
                              temp_0 = (int)r->m_tables[0].m_look_up[
                              bit_buf & (unsigned long)(TINFL_FAST_LOOKUP_SIZE - 1)];
                              if (temp_0 >= 0) {
                                code_len_0 = (mz_uint)(temp_0 >> 9);
                                if (code_len_0) 
                                  if (num_bits >= code_len_0) break;
                              }
                              else 
                                if (num_bits > (mz_uint32)TINFL_FAST_LOOKUP_BITS) {
                                  code_len_0 = (mz_uint)TINFL_FAST_LOOKUP_BITS;
                                  while (1) {
                                    {
                                      mz_uint tmp_29;
                                      tmp_29 = code_len_0;
                                      code_len_0 ++;
                                      temp_0 = (int)r->m_tables[0].m_tree[
                                      (unsigned long)(~ temp_0) + ((bit_buf >> tmp_29) & (unsigned long)1)];
                                    }
                                    if (temp_0 < 0) {
                                      if (! (num_bits >= code_len_0 + (mz_uint)1)) 
                                        break;
                                    }
                                    else break;
                                  }
                                  if (temp_0 >= 0) break;
                                }
                              {
                                mz_uint8 const *tmp_30;
                                while (pIn_buf_cur >= pIn_buf_end) {
                                  if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                                    status = TINFL_STATUS_NEEDS_MORE_INPUT;
                                  else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                                  r->m_state = (mz_uint32)23;
                                  goto common_exit;
                                  case (mz_uint32)23: ;
                                }
                                tmp_30 = pIn_buf_cur;
                                pIn_buf_cur ++;
                                c_7 = (mz_uint)*tmp_30;
                              }
                              bit_buf |= (tinfl_bit_buf_t)c_7 << num_bits;
                              num_bits += (mz_uint32)8;
                              if (! (num_bits < (mz_uint32)15)) break;
                            }
                          else {
                            bit_buf |= ((tinfl_bit_buf_t)*(pIn_buf_cur + 0) << num_bits) | (
                                       (tinfl_bit_buf_t)*(pIn_buf_cur + 1) << (
                                       num_bits + (mz_uint32)8));
                            pIn_buf_cur += 2;
                            num_bits += (mz_uint32)16;
                          }
                        temp_0 = (int)r->m_tables[0].m_look_up[bit_buf & (unsigned long)(
                                                               TINFL_FAST_LOOKUP_SIZE - 1)];
                        if (temp_0 >= 0) {
                          code_len_0 = (mz_uint)(temp_0 >> 9);
                          temp_0 &= 511;
                        }
                        else {
                          code_len_0 = (mz_uint)TINFL_FAST_LOOKUP_BITS;
                          while (1) {
                            {
                              mz_uint tmp_31;
                              tmp_31 = code_len_0;
                              code_len_0 ++;
                              temp_0 = (int)r->m_tables[0].m_tree[(unsigned long)(~ temp_0) + (
                                                                  (bit_buf >> tmp_31) & (unsigned long)1)];
                            }
                            if (! (temp_0 < 0)) break;
                          }
                        }
                        counter = (mz_uint32)temp_0;
                        bit_buf >>= code_len_0;
                        num_bits -= code_len_0;
                      }
                      if (counter >= (mz_uint32)256) break;
                      while (pOut_buf_cur >= pOut_buf_end) {
                        status = TINFL_STATUS_HAS_MORE_OUTPUT;
                        r->m_state = (mz_uint32)24;
                        goto common_exit;
                        case (mz_uint32)24: ;
                      }
                      tmp_32 = pOut_buf_cur;
                      pOut_buf_cur ++;
                      *tmp_32 = (mz_uint8)counter;
                    }
                  }
                  else {
                    int sym2;
                    mz_uint code_len_1;
                    if (num_bits < (mz_uint32)30) {
                      bit_buf |= (tinfl_bit_buf_t)*((mz_uint32 const *)pIn_buf_cur) << num_bits;
                      pIn_buf_cur += 4;
                      num_bits += (mz_uint32)32;
                    }
                    sym2 = (int)r->m_tables[0].m_look_up[bit_buf & (unsigned long)(
                                                         TINFL_FAST_LOOKUP_SIZE - 1)];
                    if (sym2 >= 0) code_len_1 = (mz_uint)(sym2 >> 9);
                    else {
                      code_len_1 = (mz_uint)TINFL_FAST_LOOKUP_BITS;
                      while (1) {
                        {
                          mz_uint tmp_33;
                          tmp_33 = code_len_1;
                          code_len_1 ++;
                          sym2 = (int)r->m_tables[0].m_tree[(unsigned long)(~ sym2) + (
                                                            (bit_buf >> tmp_33) & (unsigned long)1)];
                        }
                        if (! (sym2 < 0)) break;
                      }
                    }
                    counter = (mz_uint32)sym2;
                    bit_buf >>= code_len_1;
                    num_bits -= code_len_1;
                    if (counter & (unsigned int)256) break;
                    sym2 = (int)r->m_tables[0].m_look_up[bit_buf & (unsigned long)(
                                                         TINFL_FAST_LOOKUP_SIZE - 1)];
                    if (sym2 >= 0) code_len_1 = (mz_uint)(sym2 >> 9);
                    else {
                      code_len_1 = (mz_uint)TINFL_FAST_LOOKUP_BITS;
                      while (1) {
                        {
                          mz_uint tmp_34;
                          tmp_34 = code_len_1;
                          code_len_1 ++;
                          sym2 = (int)r->m_tables[0].m_tree[(unsigned long)(~ sym2) + (
                                                            (bit_buf >> tmp_34) & (unsigned long)1)];
                        }
                        if (! (sym2 < 0)) break;
                      }
                    }
                    bit_buf >>= code_len_1;
                    num_bits -= code_len_1;
                    *(pOut_buf_cur + 0) = (mz_uint8)counter;
                    if (sym2 & 256) {
                      pOut_buf_cur ++;
                      counter = (mz_uint32)sym2;
                      break;
                    }
                    *(pOut_buf_cur + 1) = (mz_uint8)sym2;
                    pOut_buf_cur += 2;
                  }
              counter &= (unsigned int)511;
              if (counter == (mz_uint32)256) break;
              num_extra = (mz_uint32)tinfl_decompress_s_length_extra[
              counter - (mz_uint32)257];
              counter = (mz_uint32)tinfl_decompress_s_length_base[counter - (mz_uint32)257];
              if (num_extra) {
                mz_uint extra_bits;
                if (num_bits < num_extra) 
                  while (1) {
                    {
                      mz_uint c_8;
                      {
                        mz_uint8 const *tmp_35;
                        while (pIn_buf_cur >= pIn_buf_end) {
                          if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                            status = TINFL_STATUS_NEEDS_MORE_INPUT;
                          else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                          r->m_state = (mz_uint32)25;
                          goto common_exit;
                          case (mz_uint32)25: ;
                        }
                        tmp_35 = pIn_buf_cur;
                        pIn_buf_cur ++;
                        c_8 = (mz_uint)*tmp_35;
                      }
                      bit_buf |= (tinfl_bit_buf_t)c_8 << num_bits;
                      num_bits += (mz_uint32)8;
                    }
                    if (! (num_bits < num_extra)) break;
                  }
                extra_bits = (mz_uint)(bit_buf & (unsigned long)((1 << num_extra) - 1));
                bit_buf >>= num_extra;
                num_bits -= num_extra;
                counter += extra_bits;
              }
              {
                int temp_1;
                mz_uint code_len_2;
                mz_uint c_9;
                if (num_bits < (mz_uint32)15) 
                  if (pIn_buf_end - pIn_buf_cur < (long)2) 
                    while (1) {
                      temp_1 = (int)r->m_tables[1].m_look_up[bit_buf & (unsigned long)(
                                                             TINFL_FAST_LOOKUP_SIZE - 1)];
                      if (temp_1 >= 0) {
                        code_len_2 = (mz_uint)(temp_1 >> 9);
                        if (code_len_2) 
                          if (num_bits >= code_len_2) break;
                      }
                      else 
                        if (num_bits > (mz_uint32)TINFL_FAST_LOOKUP_BITS) {
                          code_len_2 = (mz_uint)TINFL_FAST_LOOKUP_BITS;
                          while (1) {
                            {
                              mz_uint tmp_36;
                              tmp_36 = code_len_2;
                              code_len_2 ++;
                              temp_1 = (int)r->m_tables[1].m_tree[(unsigned long)(~ temp_1) + (
                                                                  (bit_buf >> tmp_36) & (unsigned long)1)];
                            }
                            if (temp_1 < 0) {
                              if (! (num_bits >= code_len_2 + (mz_uint)1)) 
                                break;
                            }
                            else break;
                          }
                          if (temp_1 >= 0) break;
                        }
                      {
                        mz_uint8 const *tmp_37;
                        while (pIn_buf_cur >= pIn_buf_end) {
                          if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                            status = TINFL_STATUS_NEEDS_MORE_INPUT;
                          else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                          r->m_state = (mz_uint32)26;
                          goto common_exit;
                          case (mz_uint32)26: ;
                        }
                        tmp_37 = pIn_buf_cur;
                        pIn_buf_cur ++;
                        c_9 = (mz_uint)*tmp_37;
                      }
                      bit_buf |= (tinfl_bit_buf_t)c_9 << num_bits;
                      num_bits += (mz_uint32)8;
                      if (! (num_bits < (mz_uint32)15)) break;
                    }
                  else {
                    bit_buf |= ((tinfl_bit_buf_t)*(pIn_buf_cur + 0) << num_bits) | (
                               (tinfl_bit_buf_t)*(pIn_buf_cur + 1) << (
                               num_bits + (mz_uint32)8));
                    pIn_buf_cur += 2;
                    num_bits += (mz_uint32)16;
                  }
                temp_1 = (int)r->m_tables[1].m_look_up[bit_buf & (unsigned long)(
                                                       TINFL_FAST_LOOKUP_SIZE - 1)];
                if (temp_1 >= 0) {
                  code_len_2 = (mz_uint)(temp_1 >> 9);
                  temp_1 &= 511;
                }
                else {
                  code_len_2 = (mz_uint)TINFL_FAST_LOOKUP_BITS;
                  while (1) {
                    {
                      mz_uint tmp_38;
                      tmp_38 = code_len_2;
                      code_len_2 ++;
                      temp_1 = (int)r->m_tables[1].m_tree[(unsigned long)(~ temp_1) + (
                                                          (bit_buf >> tmp_38) & (unsigned long)1)];
                    }
                    if (! (temp_1 < 0)) break;
                  }
                }
                dist = (mz_uint32)temp_1;
                bit_buf >>= code_len_2;
                num_bits -= code_len_2;
              }
              num_extra = (mz_uint32)tinfl_decompress_s_dist_extra[dist];
              dist = (mz_uint32)tinfl_decompress_s_dist_base[dist];
              if (num_extra) {
                mz_uint extra_bits_0;
                if (num_bits < num_extra) 
                  while (1) {
                    {
                      mz_uint c_10;
                      {
                        mz_uint8 const *tmp_39;
                        while (pIn_buf_cur >= pIn_buf_end) {
                          if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                            status = TINFL_STATUS_NEEDS_MORE_INPUT;
                          else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                          r->m_state = (mz_uint32)27;
                          goto common_exit;
                          case (mz_uint32)27: ;
                        }
                        tmp_39 = pIn_buf_cur;
                        pIn_buf_cur ++;
                        c_10 = (mz_uint)*tmp_39;
                      }
                      bit_buf |= (tinfl_bit_buf_t)c_10 << num_bits;
                      num_bits += (mz_uint32)8;
                    }
                    if (! (num_bits < num_extra)) break;
                  }
                extra_bits_0 = (mz_uint)(bit_buf & (unsigned long)((1 << num_extra) - 1));
                bit_buf >>= num_extra;
                num_bits -= num_extra;
                dist += extra_bits_0;
              }
              dist_from_out_buf_start = (size_t)(pOut_buf_cur - pOut_buf_start);
              if (dist == (mz_uint32)0) goto _LOR_1;
              else 
                if ((size_t)dist > dist_from_out_buf_start) goto _LOR_1;
                else 
                  if (dist_from_out_buf_start == (size_t)0) {
                    _LOR_1: ;
                    if (decomp_flags & (unsigned int)TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF) 
                      while (1) {
                        status = TINFL_STATUS_FAILED;
                        r->m_state = (mz_uint32)37;
                        goto common_exit;
                        case (mz_uint32)37: ;
                      }
                  }
              pSrc = pOut_buf_start + ((dist_from_out_buf_start - (size_t)dist) & out_buf_size_mask);
              if (pOut_buf_cur > pSrc) tmp_43 = pOut_buf_cur;
              else tmp_43 = pSrc;
              ;
              if (tmp_43 + counter > pOut_buf_end) {
                while (1) {
                  mz_uint32 tmp_42;
                  tmp_42 = counter;
                  counter --;
                  ;
                  if (! tmp_42) break;
                  {
                    mz_uint8 *tmp_40;
                    size_t tmp_41;
                    while (pOut_buf_cur >= pOut_buf_end) {
                      status = TINFL_STATUS_HAS_MORE_OUTPUT;
                      r->m_state = (mz_uint32)53;
                      goto common_exit;
                      case (mz_uint32)53: ;
                    }
                    tmp_40 = pOut_buf_cur;
                    pOut_buf_cur ++;
                    tmp_41 = dist_from_out_buf_start;
                    dist_from_out_buf_start ++;
                    *tmp_40 = *(pOut_buf_start + ((tmp_41 - (size_t)dist) & out_buf_size_mask));
                  }
                }
                goto __Cont_1;
              }
              else 
                if (counter >= (mz_uint32)9) 
                  if (counter <= dist) {
                    mz_uint8 const *pSrc_end =
                      (mz_uint8 const *)(pSrc + (counter & (unsigned int)(~ 7)));
                    while (1) {
                      memcpy((void *)pOut_buf_cur,(void const *)pSrc,
                             sizeof(mz_uint32) * (unsigned long)2);
                      pOut_buf_cur += 8;
                      pSrc += 8;
                      ;
                      if (! ((void *)pSrc < (void *)pSrc_end)) break;
                    }
                    counter &= (unsigned int)7;
                    if (counter < (mz_uint32)3) {
                      if (counter) {
                        *(pOut_buf_cur + 0) = *(pSrc + 0);
                        if (counter > (mz_uint32)1) *(pOut_buf_cur + 1) = *(
                                                    pSrc + 1);
                        pOut_buf_cur += counter;
                      }
                      goto __Cont_1;
                    }
                  }
              while (counter > (mz_uint32)2) {
                *(pOut_buf_cur + 0) = *(pSrc + 0);
                *(pOut_buf_cur + 1) = *(pSrc + 1);
                *(pOut_buf_cur + 2) = *(pSrc + 2);
                pOut_buf_cur += 3;
                pSrc += 3;
                counter -= (mz_uint32)3;
              }
              if (counter > (mz_uint32)0) {
                *(pOut_buf_cur + 0) = *(pSrc + 0);
                if (counter > (mz_uint32)1) *(pOut_buf_cur + 1) = *(pSrc + 1);
                pOut_buf_cur += counter;
              }
            }
            __Cont_1: ;
          }
        }
      if (! (! (r->m_final & (unsigned int)1))) break;
    }
    if (num_bits < (num_bits & (unsigned int)7)) 
      while (1) {
        {
          mz_uint c_11;
          {
            mz_uint8 const *tmp_44;
            while (pIn_buf_cur >= pIn_buf_end) {
              if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                status = TINFL_STATUS_NEEDS_MORE_INPUT;
              else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
              r->m_state = (mz_uint32)32;
              goto common_exit;
              case (mz_uint32)32: ;
            }
            tmp_44 = pIn_buf_cur;
            pIn_buf_cur ++;
            c_11 = (mz_uint)*tmp_44;
          }
          bit_buf |= (tinfl_bit_buf_t)c_11 << num_bits;
          num_bits += (mz_uint32)8;
        }
        if (! (num_bits < (num_bits & (unsigned int)7))) break;
      }
    bit_buf >>= num_bits & (unsigned int)7;
    num_bits -= num_bits & (unsigned int)7;
    while (1) {
      if (pIn_buf_cur > pIn_buf_next) {
        if (! (num_bits >= (mz_uint32)8)) break;
      }
      else break;
      pIn_buf_cur --;
      num_bits -= (mz_uint32)8;
    }
    bit_buf &= ((mz_uint64)1 << num_bits) - (mz_uint64)1;
    __FC_assert(! num_bits != 0,"miniz_tinfl.c",576,"!num_bits");
    if (decomp_flags & (unsigned int)TINFL_FLAG_PARSE_ZLIB_HEADER) {
      counter = (mz_uint32)0;
      while (counter < (mz_uint32)4) {
        {
          mz_uint s_1;
          if (num_bits) {
            if (num_bits < (mz_uint)8) 
              while (1) {
                {
                  mz_uint c_12;
                  {
                    mz_uint8 const *tmp_45;
                    while (pIn_buf_cur >= pIn_buf_end) {
                      if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                        status = TINFL_STATUS_NEEDS_MORE_INPUT;
                      else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
                      r->m_state = (mz_uint32)41;
                      goto common_exit;
                      case (mz_uint32)41: ;
                    }
                    tmp_45 = pIn_buf_cur;
                    pIn_buf_cur ++;
                    c_12 = (mz_uint)*tmp_45;
                  }
                  bit_buf |= (tinfl_bit_buf_t)c_12 << num_bits;
                  num_bits += (mz_uint32)8;
                }
                if (! (num_bits < (mz_uint)8)) break;
              }
            s_1 = (mz_uint)(bit_buf & (unsigned long)((1 << 8) - 1));
            bit_buf >>= 8;
            num_bits -= (mz_uint32)8;
          }
          else {
            mz_uint8 const *tmp_46;
            while (pIn_buf_cur >= pIn_buf_end) {
              if (decomp_flags & (unsigned int)TINFL_FLAG_HAS_MORE_INPUT) 
                status = TINFL_STATUS_NEEDS_MORE_INPUT;
              else status = TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS;
              r->m_state = (mz_uint32)42;
              goto common_exit;
              case (mz_uint32)42: ;
            }
            tmp_46 = pIn_buf_cur;
            pIn_buf_cur ++;
            s_1 = (mz_uint)*tmp_46;
          }
          r->m_z_adler32 = (r->m_z_adler32 << 8) | s_1;
        }
        counter ++;
      }
    }
    while (1) {
      status = TINFL_STATUS_DONE;
      r->m_state = (mz_uint32)34;
      goto common_exit;
      case (mz_uint32)34: ;
    }
  }
  common_exit: ;
  if (status != TINFL_STATUS_NEEDS_MORE_INPUT) 
    if (status != TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS) 
      while (1) {
        if (pIn_buf_cur > pIn_buf_next) {
          if (! (num_bits >= (mz_uint32)8)) break;
        }
        else break;
        pIn_buf_cur --;
        num_bits -= (mz_uint32)8;
      }
  r->m_num_bits = num_bits;
  r->m_bit_buf = bit_buf & (((mz_uint64)1 << num_bits) - (mz_uint64)1);
  r->m_dist = dist;
  r->m_counter = counter;
  r->m_num_extra = num_extra;
  r->m_dist_from_out_buf_start = dist_from_out_buf_start;
  *pIn_buf_size = (size_t)(pIn_buf_cur - pIn_buf_next);
  *pOut_buf_size = (size_t)(pOut_buf_cur - pOut_buf_next);
  if (decomp_flags & (unsigned int)(TINFL_FLAG_PARSE_ZLIB_HEADER | TINFL_FLAG_COMPUTE_ADLER32)) 
    if (status >= 0) {
      mz_uint32 i_1;
      mz_uint8 const *ptr = (mz_uint8 const *)pOut_buf_next;
      size_t buf_len = *pOut_buf_size;
      mz_uint32 s1 = r->m_check_adler32 & (unsigned int)0xffff;
      mz_uint32 s2 = r->m_check_adler32 >> 16;
      size_t block_len = buf_len % (unsigned long)5552;
      while (buf_len) {
        i_1 = (mz_uint32)0;
        while ((size_t)(i_1 + (mz_uint32)7) < block_len) {
          s1 += (mz_uint32)*(ptr + 0);
          s2 += s1;
          s1 += (mz_uint32)*(ptr + 1);
          s2 += s1;
          s1 += (mz_uint32)*(ptr + 2);
          s2 += s1;
          s1 += (mz_uint32)*(ptr + 3);
          s2 += s1;
          s1 += (mz_uint32)*(ptr + 4);
          s2 += s1;
          s1 += (mz_uint32)*(ptr + 5);
          s2 += s1;
          s1 += (mz_uint32)*(ptr + 6);
          s2 += s1;
          s1 += (mz_uint32)*(ptr + 7);
          s2 += s1;
          i_1 += (mz_uint32)8;
          ptr += 8;
        }
        while ((size_t)i_1 < block_len) {
          mz_uint8 const *tmp_47;
          tmp_47 = ptr;
          ptr ++;
          s1 += (mz_uint32)*tmp_47;
          s2 += s1;
          i_1 ++;
        }
        s1 %= 65521U;
        s2 %= 65521U;
        buf_len -= block_len;
        block_len = (size_t)5552;
      }
      r->m_check_adler32 = (s2 << 16) + s1;
      if (status == TINFL_STATUS_DONE) 
        if (decomp_flags & (unsigned int)TINFL_FLAG_PARSE_ZLIB_HEADER) 
          if (r->m_check_adler32 != r->m_z_adler32) status = TINFL_STATUS_ADLER32_MISMATCH;
    }
  __retres = (tinfl_status __attribute__((__visibility__("default"))))status;
  return_label: return __retres;
}

void __attribute__((__visibility__("default"))) *tinfl_decompress_mem_to_heap
(void const *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)
{
  void __attribute__((__visibility__("default"))) *__retres;
  tinfl_decompressor decomp;
  void *pNew_buf;
  void *pBuf = (void *)0;
  size_t src_buf_ofs = (size_t)0;
  size_t out_buf_capacity = (size_t)0;
  *pOut_len = (size_t)0;
  decomp.m_state = (mz_uint32)0;
  decomp.m_num_bits = (mz_uint32)0;
  decomp.m_bit_buf = (tinfl_bit_buf_t)0;
  decomp.m_dist = (mz_uint32)0;
  decomp.m_counter = (mz_uint32)0;
  decomp.m_num_extra = (mz_uint32)0;
  decomp.m_dist_from_out_buf_start = (size_t)0;
  while (1) {
    size_t new_out_buf_capacity;
    tinfl_status __attribute__((__visibility__("default"))) tmp_0;
    mz_uint8 *tmp;
    size_t src_buf_size = src_buf_len - src_buf_ofs;
    size_t dst_buf_size = out_buf_capacity - *pOut_len;
    ;
    if (pBuf) tmp = (mz_uint8 *)pBuf + *pOut_len; else tmp = (mz_uint8 *)0;
    ;
    ;
    tmp_0 = tinfl_decompress(& decomp,
                             (mz_uint8 const *)pSrc_buf + src_buf_ofs,
                             & src_buf_size,(mz_uint8 *)pBuf,tmp,
                             & dst_buf_size,
                             (mz_uint32)((flags & ~ TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF));
    tinfl_status status = (tinfl_status)tmp_0;
    if (status < 0) goto _LOR;
    else 
      if (status == TINFL_STATUS_NEEDS_MORE_INPUT) {
        _LOR:
        {
          free(pBuf);
          *pOut_len = (size_t)0;
          __retres = (void __attribute__((__visibility__("default"))) *)0;
          goto return_label;
        }
      }
    src_buf_ofs += src_buf_size;
    *pOut_len += dst_buf_size;
    if (status == TINFL_STATUS_DONE) break;
    new_out_buf_capacity = out_buf_capacity * (size_t)2;
    if (new_out_buf_capacity < (size_t)128) new_out_buf_capacity = (size_t)128;
    pNew_buf = realloc(pBuf,new_out_buf_capacity);
    if (! pNew_buf) {
      free(pBuf);
      *pOut_len = (size_t)0;
      __retres = (void __attribute__((__visibility__("default"))) *)0;
      goto return_label;
    }
    pBuf = pNew_buf;
    out_buf_capacity = new_out_buf_capacity;
  }
  __retres = (void __attribute__((__visibility__("default"))) *)pBuf;
  return_label: return __retres;
}

size_t __attribute__((__visibility__("default"))) tinfl_decompress_mem_to_mem
(void *pOut_buf, size_t out_buf_len, void const *pSrc_buf,
 size_t src_buf_len, int flags)
{
  size_t __attribute__((__visibility__("default"))) __retres;
  tinfl_decompressor decomp;
  tinfl_status status;
  tinfl_status __attribute__((__visibility__("default"))) tmp;
  size_t tmp_0;
  decomp.m_state = (mz_uint32)0;
  decomp.m_num_bits = (mz_uint32)0;
  decomp.m_bit_buf = (tinfl_bit_buf_t)0;
  decomp.m_dist = (mz_uint32)0;
  decomp.m_counter = (mz_uint32)0;
  decomp.m_num_extra = (mz_uint32)0;
  decomp.m_dist_from_out_buf_start = (size_t)0;
  tmp = tinfl_decompress(& decomp,(mz_uint8 const *)pSrc_buf,& src_buf_len,
                         (mz_uint8 *)pOut_buf,(mz_uint8 *)pOut_buf,
                         & out_buf_len,
                         (mz_uint32)((flags & ~ TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF));
  status = (tinfl_status)tmp;
  if (status != TINFL_STATUS_DONE) tmp_0 = (size_t)(-1);
  else tmp_0 = out_buf_len;
  __retres = (size_t __attribute__((__visibility__("default"))))tmp_0;
  return __retres;
}

int __attribute__((__visibility__("default"))) tinfl_decompress_mem_to_callback
(void const *pIn_buf, size_t *pIn_buf_size,
 int (*pPut_buf_func)(void const *pBuf, int len, void *pUser),
 void *pPut_buf_user, int flags)
{
  int __attribute__((__visibility__("default"))) __retres;
  tinfl_decompressor decomp;
  int result = 0;
  mz_uint8 *pDict = malloc((size_t)32768);
  size_t in_buf_ofs = (size_t)0;
  size_t dict_ofs = (size_t)0;
  if (! pDict) {
    __retres = (int __attribute__((__visibility__("default"))))TINFL_STATUS_FAILED;
    goto return_label;
  }
  decomp.m_state = (mz_uint32)0;
  decomp.m_num_bits = (mz_uint32)0;
  decomp.m_bit_buf = (tinfl_bit_buf_t)0;
  decomp.m_dist = (mz_uint32)0;
  decomp.m_counter = (mz_uint32)0;
  decomp.m_num_extra = (mz_uint32)0;
  decomp.m_dist_from_out_buf_start = (size_t)0;
  while (1) {
    tinfl_status __attribute__((__visibility__("default"))) tmp_0;
    size_t in_buf_size = *pIn_buf_size - in_buf_ofs;
    size_t dst_buf_size = (size_t)32768 - dict_ofs;
    tmp_0 = tinfl_decompress(& decomp,(mz_uint8 const *)pIn_buf + in_buf_ofs,
                             & in_buf_size,pDict,pDict + dict_ofs,
                             & dst_buf_size,
                             (mz_uint32)(flags & ~ (TINFL_FLAG_HAS_MORE_INPUT | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)));
    tinfl_status status = (tinfl_status)tmp_0;
    in_buf_ofs += in_buf_size;
    if (dst_buf_size) {
      int tmp_1;
      tmp_1 = (*pPut_buf_func)((void const *)(pDict + dict_ofs),
                               (int)dst_buf_size,pPut_buf_user);
      if (! tmp_1) break;
    }
    if (status != TINFL_STATUS_HAS_MORE_OUTPUT) {
      result = status == TINFL_STATUS_DONE;
      break;
    }
    dict_ofs = (dict_ofs + dst_buf_size) & (unsigned long)(32768 - 1);
  }
  free((void *)pDict);
  *pIn_buf_size = in_buf_ofs;
  __retres = (int __attribute__((__visibility__("default"))))result;
  return_label: return __retres;
}

tinfl_decompressor __attribute__((__visibility__("default"))) *tinfl_decompressor_alloc
(void)
{
  tinfl_decompressor __attribute__((__visibility__("default"))) *__retres;
  tinfl_decompressor *pDecomp = malloc(sizeof(tinfl_decompressor));
  if (pDecomp) {
    pDecomp->m_state = (mz_uint32)0;
    pDecomp->m_num_bits = (mz_uint32)0;
    pDecomp->m_bit_buf = (tinfl_bit_buf_t)0;
    pDecomp->m_dist = (mz_uint32)0;
    pDecomp->m_counter = (mz_uint32)0;
    pDecomp->m_num_extra = (mz_uint32)0;
    pDecomp->m_dist_from_out_buf_start = (size_t)0;
  }
  __retres = (tinfl_decompressor __attribute__((__visibility__("default"))) *)pDecomp;
  return __retres;
}

void __attribute__((__visibility__("default"))) tinfl_decompressor_free
(tinfl_decompressor *pDecomp)
{
  free((void *)pDecomp);
  return;
}

#pragma message("Using fopen, ftello, fseeko, stat() etc. path for file I/O - this path may not support large files.")
__inline static void ( __attribute__((__always_inline__)) mz_zip_array_init)
(mz_zip_array *pArray, mz_uint32 element_size)
{
  memset((void *)pArray,0,sizeof(mz_zip_array));
  pArray->m_element_size = element_size;
  return;
}

__inline static void ( __attribute__((__always_inline__)) mz_zip_array_clear)
(mz_zip_archive *pZip, mz_zip_array *pArray)
{
  (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,pArray->m_p);
  memset((void *)pArray,0,sizeof(mz_zip_array));
  return;
}

static mz_bool mz_zip_array_ensure_capacity(mz_zip_archive *pZip,
                                            mz_zip_array *pArray,
                                            size_t min_new_capacity,
                                            mz_uint growing)
{
  mz_bool __retres;
  void *pNew_p;
  size_t new_capacity = min_new_capacity;
  __FC_assert(pArray->m_element_size != (mz_uint)0,"miniz_zip.c",307,
              "pArray->m_element_size");
  if (pArray->m_capacity >= min_new_capacity) {
    __retres = 1;
    goto return_label;
  }
  if (growing) {
    if ((size_t)1 > pArray->m_capacity) new_capacity = (size_t)1;
    else new_capacity = pArray->m_capacity;
    while (new_capacity < min_new_capacity) new_capacity *= (size_t)2;
  }
  pNew_p = (*(pZip->m_pRealloc))(pZip->m_pAlloc_opaque,pArray->m_p,
                                 (size_t)pArray->m_element_size,new_capacity);
  if ((void *)0 == pNew_p) {
    __retres = 0;
    goto return_label;
  }
  pArray->m_p = pNew_p;
  pArray->m_capacity = new_capacity;
  __retres = 1;
  return_label: return __retres;
}

__inline static mz_bool ( __attribute__((__always_inline__)) mz_zip_array_reserve)
(mz_zip_archive *pZip, mz_zip_array *pArray, size_t new_capacity,
 mz_uint growing)
{
  mz_bool __retres;
  if (new_capacity > pArray->m_capacity) {
    mz_bool tmp;
    tmp = mz_zip_array_ensure_capacity(pZip,pArray,new_capacity,growing);
    if (! tmp) {
      __retres = 0;
      goto return_label;
    }
  }
  __retres = 1;
  return_label: return __retres;
}

__inline static mz_bool ( __attribute__((__always_inline__)) mz_zip_array_resize)
(mz_zip_archive *pZip, mz_zip_array *pArray, size_t new_size, mz_uint growing)
{
  mz_bool __retres;
  if (new_size > pArray->m_capacity) {
    mz_bool tmp;
    tmp = mz_zip_array_ensure_capacity(pZip,pArray,new_size,growing);
    if (! tmp) {
      __retres = 0;
      goto return_label;
    }
  }
  pArray->m_size = new_size;
  __retres = 1;
  return_label: return __retres;
}

__inline static mz_bool ( __attribute__((__always_inline__)) mz_zip_array_ensure_room)
(mz_zip_archive *pZip, mz_zip_array *pArray, size_t n)
{
  mz_bool tmp;
  tmp = mz_zip_array_reserve(pZip,pArray,pArray->m_size + n,(mz_uint)1);
  return tmp;
}

__inline static mz_bool ( __attribute__((__always_inline__)) mz_zip_array_push_back)
(mz_zip_archive *pZip, mz_zip_array *pArray, void const *pElements, size_t n)
{
  mz_bool __retres;
  mz_bool tmp;
  size_t orig_size = pArray->m_size;
  tmp = mz_zip_array_resize(pZip,pArray,orig_size + n,(mz_uint)1);
  if (! tmp) {
    __retres = 0;
    goto return_label;
  }
  if (n > (size_t)0) memcpy((void *)((mz_uint8 *)pArray->m_p + orig_size * (size_t)pArray->m_element_size),
                            pElements,n * (size_t)pArray->m_element_size);
  __retres = 1;
  return_label: return __retres;
}

static time_t mz_zip_dos_to_time_t(int dos_time, int dos_date)
{
  struct tm tm;
  time_t tmp;
  memset((void *)(& tm),0,sizeof(tm));
  tm.tm_isdst = -1;
  tm.tm_year = (((dos_date >> 9) & 127) + 1980) - 1900;
  tm.tm_mon = ((dos_date >> 5) & 15) - 1;
  tm.tm_mday = dos_date & 31;
  tm.tm_hour = (dos_time >> 11) & 31;
  tm.tm_min = (dos_time >> 5) & 63;
  tm.tm_sec = (dos_time << 1) & 62;
  tmp = mktime(& tm);
  return tmp;
}

static void mz_zip_time_t_to_dos_time(time_t time_0, mz_uint16 *pDOS_time,
                                      mz_uint16 *pDOS_date)
{
  struct tm *tm = localtime((time_t const *)(& time_0));
  *pDOS_time = (mz_uint16)(((tm->tm_hour << 11) + (tm->tm_min << 5)) + (
                           tm->tm_sec >> 1));
  *pDOS_date = (mz_uint16)(((((tm->tm_year + 1900) - 1980) << 9) + ((
                                                                    tm->tm_mon + 1) << 5)) + tm->tm_mday);
  return;
}

static mz_bool mz_zip_get_file_modified_time(char const *pFilename,
                                             time_t *pTime)
{
  mz_bool __retres;
  struct stat file_stat;
  int tmp;
  tmp = stat(pFilename,& file_stat);
  if (tmp != 0) {
    __retres = 0;
    goto return_label;
  }
  *pTime = file_stat.st_mtime;
  __retres = 1;
  return_label: return __retres;
}

static mz_bool mz_zip_set_file_times(char const *pFilename,
                                     time_t access_time, time_t modified_time)
{
  struct utimbuf t;
  int tmp_0;
  int tmp;
  memset((void *)(& t),0,sizeof(t));
  t.actime = access_time;
  t.modtime = modified_time;
  tmp = utime(pFilename,(struct utimbuf const *)(& t));
  if (tmp) tmp_0 = 0; else tmp_0 = 1;
  return tmp_0;
}

__inline static mz_bool ( __attribute__((__always_inline__)) mz_zip_set_error)
(mz_zip_archive *pZip, mz_zip_error err_num)
{
  mz_bool __retres;
  if (pZip) pZip->m_last_error = err_num;
  __retres = 0;
  return __retres;
}

static mz_bool mz_zip_reader_init_internal(mz_zip_archive *pZip,
                                           mz_uint flags)
{
  mz_bool __retres;
  mz_zip_internal_state *tmp_1;
  if (! pZip) goto _LOR;
  else 
    if (pZip->m_pState) goto _LOR;
    else 
      if (pZip->m_zip_mode != (unsigned int)MZ_ZIP_MODE_INVALID) {
        mz_bool tmp;
        _LOR: tmp = mz_zip_set_error(pZip,MZ_ZIP_INVALID_PARAMETER);
        __retres = tmp;
        goto return_label;
      }
  if (! pZip->m_pAlloc) pZip->m_pAlloc = (void *(*)(void *opaque,
                                                    size_t items, size_t size))(& miniz_def_alloc_func);
  if (! pZip->m_pFree) pZip->m_pFree = (void (*)(void *opaque, void *address))(& miniz_def_free_func);
  if (! pZip->m_pRealloc) pZip->m_pRealloc = (void *(*)(void *opaque,
                                                        void *address,
                                                        size_t items,
                                                        size_t size))(& miniz_def_realloc_func);
  pZip->m_archive_size = (mz_uint64)0;
  pZip->m_central_directory_file_ofs = (mz_uint64)0;
  pZip->m_total_files = (mz_uint32)0;
  pZip->m_last_error = MZ_ZIP_NO_ERROR;
  tmp_1 = (mz_zip_internal_state *)(*(pZip->m_pAlloc))(pZip->m_pAlloc_opaque,
                                                       (size_t)1,
                                                       sizeof(mz_zip_internal_state));
  pZip->m_pState = tmp_1;
  if ((mz_zip_internal_state *)0 == tmp_1) {
    mz_bool tmp_0;
    tmp_0 = mz_zip_set_error(pZip,MZ_ZIP_ALLOC_FAILED);
    __retres = tmp_0;
    goto return_label;
  }
  memset((void *)pZip->m_pState,0,sizeof(mz_zip_internal_state));
  (pZip->m_pState)->m_central_dir.m_element_size = (mz_uint)sizeof(mz_uint8);
  (pZip->m_pState)->m_central_dir_offsets.m_element_size = (mz_uint)sizeof(mz_uint32);
  (pZip->m_pState)->m_sorted_central_dir_offsets.m_element_size = (mz_uint)sizeof(mz_uint32);
  (pZip->m_pState)->m_init_flags = flags;
  (pZip->m_pState)->m_zip64 = 0;
  (pZip->m_pState)->m_zip64_has_extended_info_fields = 0;
  pZip->m_zip_mode = MZ_ZIP_MODE_READING;
  __retres = 1;
  return_label: return __retres;
}

__inline static mz_bool ( __attribute__((__always_inline__)) mz_zip_reader_filename_less)
(mz_zip_array const *pCentral_dir_array,
 mz_zip_array const *pCentral_dir_offsets, mz_uint l_index, mz_uint r_index)
{
  mz_uint8 const *pE;
  mz_uint tmp;
  int tmp_0;
  mz_uint8 const *pL =
    (mz_uint8 const *)((mz_uint8 *)pCentral_dir_array->m_p + *((mz_uint32 *)pCentral_dir_offsets->m_p + l_index));
  mz_uint8 const *pR =
    (mz_uint8 const *)((mz_uint8 *)pCentral_dir_array->m_p + *((mz_uint32 *)pCentral_dir_offsets->m_p + r_index));
  mz_uint l_len =
    (mz_uint)*((mz_uint16 const *)(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS));
  mz_uint r_len =
    (mz_uint)*((mz_uint16 const *)(pR + MZ_ZIP_CDH_FILENAME_LEN_OFS));
  mz_uint8 l = (mz_uint8)0;
  mz_uint8 r = (mz_uint8)0;
  pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
  pR += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
  if (l_len < r_len) tmp = l_len; else tmp = r_len;
  pE = pL + tmp;
  while (pL < pE) {
    if ((int)*pL >= 'A') 
      if ((int)*pL <= 'Z') l = (mz_uint8)(((int)*pL - 'A') + 'a');
      else l = *pL;
    else l = *pL;
    if ((int)*pR >= 'A') 
      if ((int)*pR <= 'Z') r = (mz_uint8)(((int)*pR - 'A') + 'a');
      else r = *pR;
    else r = *pR;
    if ((int)l != (int)r) break;
    pL ++;
    pR ++;
  }
  if (pL == pE) tmp_0 = l_len < r_len; else tmp_0 = (int)l < (int)r;
  return tmp_0;
}

static void mz_zip_reader_sort_central_dir_offsets_by_filename(mz_zip_archive *pZip)
{
  mz_uint32 *pIndices;
  mz_uint32 start;
  mz_uint32 end;
  mz_zip_internal_state *pState = pZip->m_pState;
  mz_zip_array const *pCentral_dir_offsets =
    (mz_zip_array const *)(& pState->m_central_dir_offsets);
  mz_zip_array const *pCentral_dir =
    (mz_zip_array const *)(& pState->m_central_dir);
  mz_uint32 const size = pZip->m_total_files;
  if (size <= 1U) goto return_label;
  pIndices = (mz_uint32 *)pState->m_sorted_central_dir_offsets.m_p + 0;
  start = (size - 2U) >> 1U;
  while (1) {
    mz_uint64 child;
    mz_uint64 root = (mz_uint64)start;
    while (1) {
      int tmp_0;
      mz_bool tmp_1;
      child = (root << 1U) + (mz_uint64)1U;
      ;
      if (child >= (mz_uint64)size) break;
      if (child + (mz_uint64)1U < (mz_uint64)size) {
        mz_bool tmp;
        tmp = mz_zip_reader_filename_less(pCentral_dir,pCentral_dir_offsets,
                                          *(pIndices + child),
                                          *(pIndices + (child + (mz_uint64)1U)));
        if (tmp) tmp_0 = 1; else tmp_0 = 0;
      }
      else tmp_0 = 0;
      child += (mz_uint64)tmp_0;
      tmp_1 = mz_zip_reader_filename_less(pCentral_dir,pCentral_dir_offsets,
                                          *(pIndices + root),
                                          *(pIndices + child));
      if (! tmp_1) break;
      {
        mz_uint32 t = *(pIndices + root);
        *(pIndices + root) = *(pIndices + child);
        *(pIndices + child) = t;
      }
      root = child;
    }
    if (! start) break;
    start --;
  }
  end = size - (mz_uint32)1;
  while (end > (mz_uint32)0) {
    mz_uint64 child_0;
    mz_uint64 root_0 = (mz_uint64)0;
    {
      mz_uint32 t_0 = *(pIndices + end);
      *(pIndices + end) = *(pIndices + 0);
      *(pIndices + 0) = t_0;
    }
    while (1) {
      int tmp_3;
      mz_bool tmp_4;
      child_0 = (root_0 << 1U) + (mz_uint64)1U;
      ;
      if (child_0 >= (mz_uint64)end) break;
      if (child_0 + (mz_uint64)1U < (mz_uint64)end) {
        mz_bool tmp_2;
        tmp_2 = mz_zip_reader_filename_less(pCentral_dir,
                                            pCentral_dir_offsets,
                                            *(pIndices + child_0),
                                            *(pIndices + (child_0 + (mz_uint64)1U)));
        if (tmp_2) tmp_3 = 1; else tmp_3 = 0;
      }
      else tmp_3 = 0;
      child_0 += (mz_uint64)tmp_3;
      tmp_4 = mz_zip_reader_filename_less(pCentral_dir,pCentral_dir_offsets,
                                          *(pIndices + root_0),
                                          *(pIndices + child_0));
      if (! tmp_4) break;
      {
        mz_uint32 t_1 = *(pIndices + root_0);
        *(pIndices + root_0) = *(pIndices + child_0);
        *(pIndices + child_0) = t_1;
      }
      root_0 = child_0;
    }
    end --;
  }
  return_label: return;
}

static mz_bool mz_zip_reader_locate_header_sig(mz_zip_archive *pZip,
                                               mz_uint32 record_sig,
                                               mz_uint32 record_size,
                                               mz_int64 *pOfs)
{
  mz_bool __retres;
  mz_int64 cur_file_ofs;
  mz_uint32 buf_u32[(unsigned long)4096 / sizeof(mz_uint32)];
  mz_uint8 *pBuf = (mz_uint8 *)(buf_u32);
  if (pZip->m_archive_size < (mz_uint64)record_size) {
    __retres = 0;
    goto return_label;
  }
  if ((mz_int64)pZip->m_archive_size - (mz_int64)sizeof(buf_u32) > (mz_int64)0) 
    cur_file_ofs = (mz_int64)pZip->m_archive_size - (mz_int64)sizeof(buf_u32);
  else cur_file_ofs = (mz_int64)0;
  while (1) {
    int i;
    unsigned long tmp;
    size_t tmp_0;
    if (sizeof(buf_u32) < pZip->m_archive_size - (mz_uint64)cur_file_ofs) 
      tmp = sizeof(buf_u32);
    else tmp = pZip->m_archive_size - (mz_uint64)cur_file_ofs;
    int n = (int)tmp;
    tmp_0 = (*(pZip->m_pRead))(pZip->m_pIO_opaque,(mz_uint64)cur_file_ofs,
                               (void *)pBuf,(size_t)n);
    ;
    if (tmp_0 != (size_t)((mz_uint)n)) {
      __retres = 0;
      goto return_label;
    }
    i = n - 4;
    while (i >= 0) {
      {
        mz_uint s = *((mz_uint32 const *)(pBuf + i));
        if (s == record_sig) 
          if (pZip->m_archive_size - (mz_uint64)(cur_file_ofs + (mz_int64)i) >= (mz_uint64)record_size) 
            break;
      }
      i --;
    }
    if (i >= 0) {
      cur_file_ofs += (mz_int64)i;
      break;
    }
    if (! cur_file_ofs) {
      __retres = 0;
      goto return_label;
    }
    else 
      if (pZip->m_archive_size - (mz_uint64)cur_file_ofs >= (mz_uint64)(
          0xFFFFU + record_size)) {
        __retres = 0;
        goto return_label;
      }
    if ((unsigned long)cur_file_ofs - (sizeof(buf_u32) - (unsigned long)3) > (unsigned long)0) 
      cur_file_ofs = (mz_int64)((unsigned long)cur_file_ofs - (sizeof(buf_u32) - (unsigned long)3));
    else cur_file_ofs = (mz_int64)0;
  }
  *pOfs = cur_file_ofs;
  __retres = 1;
  return_label: return __retres;
}

static mz_bool mz_zip_reader_read_central_dir(mz_zip_archive *pZip,
                                              mz_uint flags)
{
  mz_bool __retres;
  mz_uint8 const *p;
  mz_uint32 buf_u32[(unsigned long)4096 / sizeof(mz_uint32)];
  mz_uint32 zip64_end_of_central_dir_locator_u32[(((unsigned long)MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE + sizeof(mz_uint32)) - (unsigned long)1) / sizeof(mz_uint32)];
  mz_uint32 zip64_end_of_central_dir_header_u32[(((unsigned long)MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE + sizeof(mz_uint32)) - (unsigned long)1) / sizeof(mz_uint32)];
  mz_bool tmp_1;
  size_t tmp_3;
  mz_uint cdir_size = (mz_uint)0;
  mz_uint cdir_entries_on_this_disk = (mz_uint)0;
  mz_uint num_this_disk = (mz_uint)0;
  mz_uint cdir_disk_index = (mz_uint)0;
  mz_uint64 cdir_ofs = (mz_uint64)0;
  mz_int64 cur_file_ofs = (mz_int64)0;
  mz_uint8 *pBuf = (mz_uint8 *)(buf_u32);
  mz_bool sort_central_dir =
    (flags & (unsigned int)MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY) == (unsigned int)0;
  mz_uint8 *pZip64_locator =
    (mz_uint8 *)(zip64_end_of_central_dir_locator_u32);
  mz_uint8 *pZip64_end_of_central_dir =
    (mz_uint8 *)(zip64_end_of_central_dir_header_u32);
  mz_uint64 zip64_end_of_central_dir_ofs = (mz_uint64)0;
  if (pZip->m_archive_size < (mz_uint64)MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) {
    mz_bool tmp;
    tmp = mz_zip_set_error(pZip,MZ_ZIP_NOT_AN_ARCHIVE);
    __retres = tmp;
    goto return_label;
  }
  tmp_1 = mz_zip_reader_locate_header_sig(pZip,
                                          (mz_uint32)MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG,
                                          (mz_uint32)MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE,
                                          & cur_file_ofs);
  if (! tmp_1) {
    mz_bool tmp_0;
    tmp_0 = mz_zip_set_error(pZip,MZ_ZIP_FAILED_FINDING_CENTRAL_DIR);
    __retres = tmp_0;
    goto return_label;
  }
  tmp_3 = (*(pZip->m_pRead))(pZip->m_pIO_opaque,(mz_uint64)cur_file_ofs,
                             (void *)pBuf,
                             (size_t)MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE);
  if (tmp_3 != (size_t)MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) {
    mz_bool tmp_2;
    tmp_2 = mz_zip_set_error(pZip,MZ_ZIP_FILE_READ_FAILED);
    __retres = tmp_2;
    goto return_label;
  }
  if (*((mz_uint32 const *)(pBuf + MZ_ZIP_ECDH_SIG_OFS)) != (mz_uint32)MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG) {
    mz_bool tmp_4;
    tmp_4 = mz_zip_set_error(pZip,MZ_ZIP_NOT_AN_ARCHIVE);
    __retres = tmp_4;
    goto return_label;
  }
  if (cur_file_ofs >= (mz_int64)(MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE + MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE)) {
    size_t tmp_7;
    tmp_7 = (*(pZip->m_pRead))(pZip->m_pIO_opaque,
                               (mz_uint64)(cur_file_ofs - (mz_int64)MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE),
                               (void *)pZip64_locator,
                               (size_t)MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE);
    if (tmp_7 == (size_t)MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE) 
      if (*((mz_uint32 const *)(pZip64_locator + MZ_ZIP64_ECDL_SIG_OFS)) == (mz_uint32)MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIG) {
        size_t tmp_6;
        zip64_end_of_central_dir_ofs = (mz_uint64)*((mz_uint32 const *)(
                                       pZip64_locator + MZ_ZIP64_ECDL_REL_OFS_TO_ZIP64_ECDR_OFS)) | (
                                       (mz_uint64)*((mz_uint32 const *)(
                                       (mz_uint8 const *)(pZip64_locator + MZ_ZIP64_ECDL_REL_OFS_TO_ZIP64_ECDR_OFS) + sizeof(mz_uint32))) << 32U);
        if (zip64_end_of_central_dir_ofs > pZip->m_archive_size - (mz_uint64)MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE) {
          mz_bool tmp_5;
          tmp_5 = mz_zip_set_error(pZip,MZ_ZIP_NOT_AN_ARCHIVE);
          __retres = tmp_5;
          goto return_label;
        }
        tmp_6 = (*(pZip->m_pRead))(pZip->m_pIO_opaque,
                                   zip64_end_of_central_dir_ofs,
                                   (void *)pZip64_end_of_central_dir,
                                   (size_t)MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE);
        if (tmp_6 == (size_t)MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE) 
          if (*((mz_uint32 const *)(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_SIG_OFS)) == (mz_uint32)MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIG) 
            (pZip->m_pState)->m_zip64 = 1;
      }
  }
  pZip->m_total_files = (mz_uint32)*((mz_uint16 const *)(pBuf + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS));
  cdir_entries_on_this_disk = (mz_uint)*((mz_uint16 const *)(pBuf + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS));
  num_this_disk = (mz_uint)*((mz_uint16 const *)(pBuf + MZ_ZIP_ECDH_NUM_THIS_DISK_OFS));
  cdir_disk_index = (mz_uint)*((mz_uint16 const *)(pBuf + MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS));
  cdir_size = *((mz_uint32 const *)(pBuf + MZ_ZIP_ECDH_CDIR_SIZE_OFS));
  cdir_ofs = (mz_uint64)*((mz_uint32 const *)(pBuf + MZ_ZIP_ECDH_CDIR_OFS_OFS));
  if ((pZip->m_pState)->m_zip64) {
    mz_uint32 zip64_total_num_of_disks =
      *((mz_uint32 const *)(pZip64_locator + MZ_ZIP64_ECDL_TOTAL_NUMBER_OF_DISKS_OFS));
    mz_uint64 zip64_cdir_total_entries =
      (mz_uint64)*((mz_uint32 const *)(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_TOTAL_ENTRIES_OFS)) | (
      (mz_uint64)*((mz_uint32 const *)((mz_uint8 const *)(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_TOTAL_ENTRIES_OFS) + sizeof(mz_uint32))) << 32U);
    mz_uint64 zip64_cdir_total_entries_on_this_disk =
      (mz_uint64)*((mz_uint32 const *)(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS)) | (
      (mz_uint64)*((mz_uint32 const *)((mz_uint8 const *)(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS) + sizeof(mz_uint32))) << 32U);
    mz_uint64 zip64_size_of_end_of_central_dir_record =
      (mz_uint64)*((mz_uint32 const *)(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_SIZE_OF_RECORD_OFS)) | (
      (mz_uint64)*((mz_uint32 const *)((mz_uint8 const *)(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_SIZE_OF_RECORD_OFS) + sizeof(mz_uint32))) << 32U);
    mz_uint64 zip64_size_of_central_directory =
      (mz_uint64)*((mz_uint32 const *)(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_SIZE_OFS)) | (
      (mz_uint64)*((mz_uint32 const *)((mz_uint8 const *)(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_SIZE_OFS) + sizeof(mz_uint32))) << 32U);
    if (zip64_size_of_end_of_central_dir_record < (mz_uint64)(MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE - 12)) {
      mz_bool tmp_8;
      tmp_8 = mz_zip_set_error(pZip,MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
      __retres = tmp_8;
      goto return_label;
    }
    if (zip64_total_num_of_disks != 1U) {
      mz_bool tmp_9;
      tmp_9 = mz_zip_set_error(pZip,MZ_ZIP_UNSUPPORTED_MULTIDISK);
      __retres = tmp_9;
      goto return_label;
    }
    if (zip64_cdir_total_entries > (mz_uint64)0xFFFFFFFFU) {
      mz_bool tmp_10;
      tmp_10 = mz_zip_set_error(pZip,MZ_ZIP_TOO_MANY_FILES);
      __retres = tmp_10;
      goto return_label;
    }
    pZip->m_total_files = (mz_uint32)zip64_cdir_total_entries;
    if (zip64_cdir_total_entries_on_this_disk > (mz_uint64)0xFFFFFFFFU) {
      mz_bool tmp_11;
      tmp_11 = mz_zip_set_error(pZip,MZ_ZIP_TOO_MANY_FILES);
      __retres = tmp_11;
      goto return_label;
    }
    cdir_entries_on_this_disk = (mz_uint32)zip64_cdir_total_entries_on_this_disk;
    if (zip64_size_of_central_directory > (mz_uint64)0xFFFFFFFFU) {
      mz_bool tmp_12;
      tmp_12 = mz_zip_set_error(pZip,MZ_ZIP_UNSUPPORTED_CDIR_SIZE);
      __retres = tmp_12;
      goto return_label;
    }
    cdir_size = (mz_uint32)zip64_size_of_central_directory;
    num_this_disk = *((mz_uint32 const *)(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_NUM_THIS_DISK_OFS));
    cdir_disk_index = *((mz_uint32 const *)(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_NUM_DISK_CDIR_OFS));
    cdir_ofs = (mz_uint64)*((mz_uint32 const *)(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_OFS_OFS)) | (
               (mz_uint64)*((mz_uint32 const *)((mz_uint8 const *)(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_OFS_OFS) + sizeof(mz_uint32))) << 32U);
  }
  if (pZip->m_total_files != cdir_entries_on_this_disk) {
    mz_bool tmp_13;
    tmp_13 = mz_zip_set_error(pZip,MZ_ZIP_UNSUPPORTED_MULTIDISK);
    __retres = tmp_13;
    goto return_label;
  }
  if ((num_this_disk | cdir_disk_index) != (unsigned int)0) 
    if (num_this_disk != (mz_uint)1) goto _LOR;
    else 
      if (cdir_disk_index != (mz_uint)1) {
        mz_bool tmp_14;
        _LOR: tmp_14 = mz_zip_set_error(pZip,MZ_ZIP_UNSUPPORTED_MULTIDISK);
        __retres = tmp_14;
        goto return_label;
      }
  if (cdir_size < pZip->m_total_files * (mz_uint32)MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) {
    mz_bool tmp_15;
    tmp_15 = mz_zip_set_error(pZip,MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
    __retres = tmp_15;
    goto return_label;
  }
  if (cdir_ofs + (mz_uint64)cdir_size > pZip->m_archive_size) {
    mz_bool tmp_16;
    tmp_16 = mz_zip_set_error(pZip,MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
    __retres = tmp_16;
    goto return_label;
  }
  pZip->m_central_directory_file_ofs = cdir_ofs;
  if (pZip->m_total_files) {
    mz_uint i;
    mz_uint n;
    mz_bool tmp_18;
    size_t tmp_23;
    tmp_18 = mz_zip_array_resize(pZip,& (pZip->m_pState)->m_central_dir,
                                 (size_t)cdir_size,(mz_uint)0);
    if (tmp_18) {
      mz_bool tmp_19;
      tmp_19 = mz_zip_array_resize(pZip,
                                   & (pZip->m_pState)->m_central_dir_offsets,
                                   (size_t)pZip->m_total_files,(mz_uint)0);
      if (! tmp_19) {
        mz_bool tmp_17;
        _LOR_0: tmp_17 = mz_zip_set_error(pZip,MZ_ZIP_ALLOC_FAILED);
        __retres = tmp_17;
        goto return_label;
      }
    }
    else goto _LOR_0;
    if (sort_central_dir) {
      mz_bool tmp_21;
      tmp_21 = mz_zip_array_resize(pZip,
                                   & (pZip->m_pState)->m_sorted_central_dir_offsets,
                                   (size_t)pZip->m_total_files,(mz_uint)0);
      if (! tmp_21) {
        mz_bool tmp_20;
        tmp_20 = mz_zip_set_error(pZip,MZ_ZIP_ALLOC_FAILED);
        __retres = tmp_20;
        goto return_label;
      }
    }
    tmp_23 = (*(pZip->m_pRead))(pZip->m_pIO_opaque,cdir_ofs,
                                (pZip->m_pState)->m_central_dir.m_p,
                                (size_t)cdir_size);
    ;
    if (tmp_23 != (size_t)cdir_size) {
      mz_bool tmp_22;
      tmp_22 = mz_zip_set_error(pZip,MZ_ZIP_FILE_READ_FAILED);
      __retres = tmp_22;
      goto return_label;
    }
    p = (mz_uint8 const *)(pZip->m_pState)->m_central_dir.m_p;
    n = cdir_size;
    i = (mz_uint)0;
    while (i < pZip->m_total_files) {
      {
        mz_uint total_header_size;
        mz_uint disk_index;
        mz_uint bit_flags;
        mz_uint filename_size;
        mz_uint ext_data_size;
        mz_uint64 comp_size;
        mz_uint64 decomp_size;
        mz_uint64 local_header_ofs;
        if (n < (mz_uint)MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) goto _LOR_1;
        else 
          if (*((mz_uint32 const *)p) != (mz_uint32)MZ_ZIP_CENTRAL_DIR_HEADER_SIG) {
            mz_bool tmp_24;
            _LOR_1:
            tmp_24 = mz_zip_set_error(pZip,
                                      MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
            __retres = tmp_24;
            goto return_label;
          }
        *((mz_uint32 *)(pZip->m_pState)->m_central_dir_offsets.m_p + i) = (mz_uint32)(
        p - (mz_uint8 const *)(pZip->m_pState)->m_central_dir.m_p);
        if (sort_central_dir) *((mz_uint32 *)(pZip->m_pState)->m_sorted_central_dir_offsets.m_p + i) = i;
        comp_size = (mz_uint64)*((mz_uint32 const *)(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS));
        decomp_size = (mz_uint64)*((mz_uint32 const *)(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS));
        local_header_ofs = (mz_uint64)*((mz_uint32 const *)(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS));
        filename_size = (mz_uint)*((mz_uint16 const *)(p + MZ_ZIP_CDH_FILENAME_LEN_OFS));
        ext_data_size = (mz_uint)*((mz_uint16 const *)(p + MZ_ZIP_CDH_EXTRA_LEN_OFS));
        if (! (pZip->m_pState)->m_zip64_has_extended_info_fields) 
          if (ext_data_size) {
            mz_uint64 tmp_32;
            mz_uint64 tmp_30;
            if (comp_size > decomp_size) tmp_30 = comp_size;
            else tmp_30 = decomp_size;
            ;
            if (tmp_30 > local_header_ofs) {
              mz_uint64 tmp_31;
              if (comp_size > decomp_size) tmp_31 = comp_size;
              else tmp_31 = decomp_size;
              tmp_32 = tmp_31;
            }
            else tmp_32 = local_header_ofs;
            if (tmp_32 == (mz_uint64)0xFFFFFFFFU) {
              mz_uint32 extra_size_remaining = ext_data_size;
              if (extra_size_remaining) {
                mz_uint8 const *pExtra_data;
                void *buf = (void *)0;
                if (((mz_uint)MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size) + ext_data_size > n) {
                  size_t tmp_27;
                  buf = malloc((size_t)ext_data_size);
                  if (buf == (void *)0) {
                    mz_bool tmp_25;
                    tmp_25 = mz_zip_set_error(pZip,MZ_ZIP_ALLOC_FAILED);
                    __retres = tmp_25;
                    goto return_label;
                  }
                  tmp_27 = (*(pZip->m_pRead))(pZip->m_pIO_opaque,
                                              (cdir_ofs + (mz_uint64)MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) + (mz_uint64)filename_size,
                                              buf,(size_t)ext_data_size);
                  ;
                  if (tmp_27 != (size_t)ext_data_size) {
                    mz_bool tmp_26;
                    free(buf);
                    tmp_26 = mz_zip_set_error(pZip,MZ_ZIP_FILE_READ_FAILED);
                    __retres = tmp_26;
                    goto return_label;
                  }
                  pExtra_data = (mz_uint8 const *)buf;
                }
                else pExtra_data = (p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) + filename_size;
                while (1) {
                  {
                    mz_uint32 field_id;
                    mz_uint32 field_data_size;
                    if ((unsigned long)extra_size_remaining < sizeof(mz_uint16) * (unsigned long)2) {
                      mz_bool tmp_28;
                      free(buf);
                      tmp_28 = mz_zip_set_error(pZip,
                                                MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                      __retres = tmp_28;
                      goto return_label;
                    }
                    field_id = (mz_uint32)*((mz_uint16 const *)pExtra_data);
                    field_data_size = (mz_uint32)*((mz_uint16 const *)(
                    pExtra_data + sizeof(mz_uint16)));
                    if ((unsigned long)field_data_size + sizeof(mz_uint16) * (unsigned long)2 > (unsigned long)extra_size_remaining) {
                      mz_bool tmp_29;
                      free(buf);
                      tmp_29 = mz_zip_set_error(pZip,
                                                MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                      __retres = tmp_29;
                      goto return_label;
                    }
                    if (field_id == (mz_uint32)MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID) {
                      (pZip->m_pState)->m_zip64 = 1;
                      (pZip->m_pState)->m_zip64_has_extended_info_fields = 1;
                      break;
                    }
                    pExtra_data += sizeof(mz_uint16) * (unsigned long)2 + (unsigned long)field_data_size;
                    extra_size_remaining = (mz_uint32)(((unsigned long)extra_size_remaining - 
                                                        sizeof(mz_uint16) * (unsigned long)2) - (unsigned long)field_data_size);
                  }
                  if (! extra_size_remaining) break;
                }
                free(buf);
              }
            }
          }
        if (comp_size != (mz_uint64)0xFFFFFFFFU) 
          if (decomp_size != (mz_uint64)0xFFFFFFFFU) 
            if (! *((mz_uint32 const *)(p + MZ_ZIP_CDH_METHOD_OFS))) {
              if (decomp_size != comp_size) goto _LOR_2; else goto _LAND;
            }
            else {
              _LAND: ;
              if (decomp_size) 
                if (! comp_size) {
                  mz_bool tmp_33;
                  _LOR_2:
                  tmp_33 = mz_zip_set_error(pZip,
                                            MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                  __retres = tmp_33;
                  goto return_label;
                }
            }
        disk_index = (mz_uint)*((mz_uint16 const *)(p + MZ_ZIP_CDH_DISK_START_OFS));
        if (disk_index == 0xFFFFU) goto _LOR_3;
        else 
          if (disk_index != num_this_disk) 
            if (disk_index != (mz_uint)1) {
              mz_bool tmp_34;
              _LOR_3:
              tmp_34 = mz_zip_set_error(pZip,MZ_ZIP_UNSUPPORTED_MULTIDISK);
              __retres = tmp_34;
              goto return_label;
            }
        if (comp_size != (mz_uint64)0xFFFFFFFFU) 
          if (((mz_uint64)*((mz_uint32 const *)(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS)) + (mz_uint64)MZ_ZIP_LOCAL_DIR_HEADER_SIZE) + comp_size > pZip->m_archive_size) {
            mz_bool tmp_35;
            tmp_35 = mz_zip_set_error(pZip,
                                      MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
            __retres = tmp_35;
            goto return_label;
          }
        bit_flags = (mz_uint)*((mz_uint16 const *)(p + MZ_ZIP_CDH_BIT_FLAG_OFS));
        if (bit_flags & (unsigned int)MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_LOCAL_DIR_IS_MASKED) {
          mz_bool tmp_36;
          tmp_36 = mz_zip_set_error(pZip,MZ_ZIP_UNSUPPORTED_ENCRYPTION);
          __retres = tmp_36;
          goto return_label;
        }
        total_header_size = (mz_uint)(((MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + (int)*((mz_uint16 const *)(
                                        p + MZ_ZIP_CDH_FILENAME_LEN_OFS))) + (int)*((mz_uint16 const *)(
                                       p + MZ_ZIP_CDH_EXTRA_LEN_OFS))) + (int)*((mz_uint16 const *)(
                                      p + MZ_ZIP_CDH_COMMENT_LEN_OFS)));
        ;
        if (total_header_size > n) {
          mz_bool tmp_37;
          tmp_37 = mz_zip_set_error(pZip,MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
          __retres = tmp_37;
          goto return_label;
        }
        n -= total_header_size;
        p += total_header_size;
      }
      i ++;
    }
  }
  if (sort_central_dir) mz_zip_reader_sort_central_dir_offsets_by_filename
                        (pZip);
  __retres = 1;
  return_label: return __retres;
}

void __attribute__((__visibility__("default"))) mz_zip_zero_struct(mz_zip_archive *pZip)
{
  if (pZip) memset((void *)pZip,0,sizeof(*pZip));
  return;
}

static mz_bool mz_zip_reader_end_internal(mz_zip_archive *pZip,
                                          mz_bool set_last_error)
{
  mz_bool __retres;
  mz_bool status = 1;
  if (! pZip) {
    __retres = 0;
    goto return_label;
  }
  if (! pZip->m_pState) goto _LOR;
  else 
    if (! pZip->m_pAlloc) goto _LOR;
    else 
      if (! pZip->m_pFree) goto _LOR;
      else 
        if (pZip->m_zip_mode != (unsigned int)MZ_ZIP_MODE_READING) {
          _LOR:
          {
            if (set_last_error) pZip->m_last_error = MZ_ZIP_INVALID_PARAMETER;
            __retres = 0;
            goto return_label;
          }
        }
  if (pZip->m_pState) {
    mz_zip_internal_state *pState = pZip->m_pState;
    pZip->m_pState = (mz_zip_internal_state *)0;
    mz_zip_array_clear(pZip,& pState->m_central_dir);
    mz_zip_array_clear(pZip,& pState->m_central_dir_offsets);
    mz_zip_array_clear(pZip,& pState->m_sorted_central_dir_offsets);
    if (pState->m_pFile) {
      if (pZip->m_zip_type == (unsigned int)MZ_ZIP_TYPE_FILE) {
        int tmp;
        tmp = fclose(pState->m_pFile);
        if (tmp == -1) {
          if (set_last_error) pZip->m_last_error = MZ_ZIP_FILE_CLOSE_FAILED;
          status = 0;
        }
      }
      pState->m_pFile = (FILE *)0;
    }
    (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,(void *)pState);
  }
  pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;
  __retres = status;
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_end(
                                                                    mz_zip_archive *pZip)
{
  mz_bool __attribute__((__visibility__("default"))) tmp;
  tmp = (mz_bool __attribute__((__visibility__("default"))))mz_zip_reader_end_internal
  (pZip,1);
  return tmp;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_init
(mz_zip_archive *pZip, mz_uint64 size, mz_uint flags)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_bool tmp_0;
  mz_bool tmp_1;
  if (! pZip) goto _LOR;
  else 
    if (! pZip->m_pRead) {
      mz_bool __attribute__((__visibility__("default"))) tmp;
      _LOR:
      tmp = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_INVALID_PARAMETER);
      __retres = tmp;
      goto return_label;
    }
  tmp_0 = mz_zip_reader_init_internal(pZip,flags);
  if (! tmp_0) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  pZip->m_zip_type = MZ_ZIP_TYPE_USER;
  pZip->m_archive_size = size;
  tmp_1 = mz_zip_reader_read_central_dir(pZip,flags);
  if (! tmp_1) {
    mz_zip_reader_end_internal(pZip,0);
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  __retres = (mz_bool __attribute__((__visibility__("default"))))1;
  return_label: return __retres;
}

static size_t mz_zip_mem_read_func(void *pOpaque, mz_uint64 file_ofs,
                                   void *pBuf, size_t n)
{
  size_t tmp_0;
  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
  if (file_ofs >= pZip->m_archive_size) tmp_0 = (size_t)0;
  else {
    mz_uint64 tmp;
    if (pZip->m_archive_size - file_ofs < n) tmp = pZip->m_archive_size - file_ofs;
    else tmp = n;
    tmp_0 = tmp;
  }
  size_t s = tmp_0;
  memcpy(pBuf,
         (void const *)((mz_uint8 const *)(pZip->m_pState)->m_pMem + file_ofs),
         s);
  return s;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_init_mem
(mz_zip_archive *pZip, void const *pMem, size_t size, mz_uint flags)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_bool tmp_1;
  mz_bool tmp_2;
  if (! pMem) {
    mz_bool __attribute__((__visibility__("default"))) tmp;
    tmp = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_INVALID_PARAMETER);
    __retres = tmp;
    goto return_label;
  }
  if (size < (size_t)MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) {
    mz_bool __attribute__((__visibility__("default"))) tmp_0;
    tmp_0 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_NOT_AN_ARCHIVE);
    __retres = tmp_0;
    goto return_label;
  }
  tmp_1 = mz_zip_reader_init_internal(pZip,flags);
  if (! tmp_1) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  pZip->m_zip_type = MZ_ZIP_TYPE_MEMORY;
  pZip->m_archive_size = size;
  pZip->m_pRead = & mz_zip_mem_read_func;
  pZip->m_pIO_opaque = (void *)pZip;
  pZip->m_pNeeds_keepalive = (mz_bool (*)(void *pOpaque))0;
  (pZip->m_pState)->m_pMem = (void *)pMem;
  (pZip->m_pState)->m_mem_size = size;
  tmp_2 = mz_zip_reader_read_central_dir(pZip,flags);
  if (! tmp_2) {
    mz_zip_reader_end_internal(pZip,0);
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  __retres = (mz_bool __attribute__((__visibility__("default"))))1;
  return_label: return __retres;
}

static size_t mz_zip_file_read_func(void *pOpaque, mz_uint64 file_ofs,
                                    void *pBuf, size_t n)
{
  size_t __retres;
  size_t tmp_1;
  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
  mz_int64 cur_ofs = ftello((pZip->m_pState)->m_pFile);
  file_ofs += (pZip->m_pState)->m_file_archive_start_ofs;
  if ((mz_int64)file_ofs < (mz_int64)0) {
    __retres = (size_t)0;
    goto return_label;
  }
  else 
    if (cur_ofs != (mz_int64)file_ofs) {
      int tmp_0;
      tmp_0 = fseeko((pZip->m_pState)->m_pFile,(mz_int64)file_ofs,0);
      if (tmp_0) {
        __retres = (size_t)0;
        goto return_label;
      }
    }
  tmp_1 = fread(pBuf,(size_t)1,n,(pZip->m_pState)->m_pFile);
  __retres = tmp_1;
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_init_file
(mz_zip_archive *pZip, char const *pFilename, mz_uint32 flags)
{
  mz_bool __attribute__((__visibility__("default"))) tmp;
  tmp = mz_zip_reader_init_file_v2(pZip,pFilename,flags,(mz_uint64)0,
                                   (mz_uint64)0);
  return tmp;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_init_file_v2
(mz_zip_archive *pZip, char const *pFilename, mz_uint flags,
 mz_uint64 file_start_ofs, mz_uint64 archive_size)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_uint64 file_size;
  FILE *pFile;
  mz_bool tmp_5;
  mz_bool tmp_6;
  if (! pZip) goto _LOR;
  else 
    if (! pFilename) goto _LOR;
    else 
      if (archive_size) 
        if (archive_size < (mz_uint64)MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) {
          mz_bool __attribute__((__visibility__("default"))) tmp;
          _LOR:
          tmp = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
          (pZip,MZ_ZIP_INVALID_PARAMETER);
          __retres = tmp;
          goto return_label;
        }
  pFile = fopen(pFilename,"rb");
  if (! pFile) {
    mz_bool __attribute__((__visibility__("default"))) tmp_0;
    tmp_0 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_FILE_OPEN_FAILED);
    __retres = tmp_0;
    goto return_label;
  }
  file_size = archive_size;
  if (! file_size) {
    int tmp_2;
    off_t tmp_3;
    tmp_2 = fseeko(pFile,(off_t)0,2);
    if (tmp_2) {
      mz_bool __attribute__((__visibility__("default"))) tmp_1;
      fclose(pFile);
      tmp_1 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_FILE_SEEK_FAILED);
      __retres = tmp_1;
      goto return_label;
    }
    tmp_3 = ftello(pFile);
    file_size = (mz_uint64)tmp_3;
  }
  if (file_size < (mz_uint64)MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) {
    mz_bool __attribute__((__visibility__("default"))) tmp_4;
    fclose(pFile);
    tmp_4 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_NOT_AN_ARCHIVE);
    __retres = tmp_4;
    goto return_label;
  }
  tmp_5 = mz_zip_reader_init_internal(pZip,flags);
  if (! tmp_5) {
    fclose(pFile);
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  pZip->m_zip_type = MZ_ZIP_TYPE_FILE;
  pZip->m_pRead = & mz_zip_file_read_func;
  pZip->m_pIO_opaque = (void *)pZip;
  (pZip->m_pState)->m_pFile = pFile;
  pZip->m_archive_size = file_size;
  (pZip->m_pState)->m_file_archive_start_ofs = file_start_ofs;
  tmp_6 = mz_zip_reader_read_central_dir(pZip,flags);
  if (! tmp_6) {
    mz_zip_reader_end_internal(pZip,0);
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  __retres = (mz_bool __attribute__((__visibility__("default"))))1;
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_init_cfile
(mz_zip_archive *pZip, FILE *pFile, mz_uint64 archive_size, mz_uint flags)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_uint64 cur_file_ofs;
  off_t tmp_0;
  mz_bool tmp_5;
  mz_bool tmp_6;
  if (! pZip) goto _LOR;
  else 
    if (! pFile) {
      mz_bool __attribute__((__visibility__("default"))) tmp;
      _LOR:
      tmp = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_FILE_OPEN_FAILED);
      __retres = tmp;
      goto return_label;
    }
  tmp_0 = ftello(pFile);
  cur_file_ofs = (mz_uint64)tmp_0;
  if (! archive_size) {
    int tmp_2;
    off_t tmp_3;
    tmp_2 = fseeko(pFile,(off_t)0,2);
    if (tmp_2) {
      mz_bool __attribute__((__visibility__("default"))) tmp_1;
      tmp_1 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_FILE_SEEK_FAILED);
      __retres = tmp_1;
      goto return_label;
    }
    tmp_3 = ftello(pFile);
    archive_size = (mz_uint64)tmp_3 - cur_file_ofs;
    if (archive_size < (mz_uint64)MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) {
      mz_bool __attribute__((__visibility__("default"))) tmp_4;
      tmp_4 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_NOT_AN_ARCHIVE);
      __retres = tmp_4;
      goto return_label;
    }
  }
  tmp_5 = mz_zip_reader_init_internal(pZip,flags);
  if (! tmp_5) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  pZip->m_zip_type = MZ_ZIP_TYPE_CFILE;
  pZip->m_pRead = & mz_zip_file_read_func;
  pZip->m_pIO_opaque = (void *)pZip;
  (pZip->m_pState)->m_pFile = pFile;
  pZip->m_archive_size = archive_size;
  (pZip->m_pState)->m_file_archive_start_ofs = cur_file_ofs;
  tmp_6 = mz_zip_reader_read_central_dir(pZip,flags);
  if (! tmp_6) {
    mz_zip_reader_end_internal(pZip,0);
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  __retres = (mz_bool __attribute__((__visibility__("default"))))1;
  return_label: return __retres;
}

__inline static mz_uint8 const *( __attribute__((__always_inline__)) mz_zip_get_cdh)
(mz_zip_archive *pZip, mz_uint file_index)
{
  mz_uint8 const *__retres;
  if (! pZip) {
    __retres = (mz_uint8 const *)0;
    goto return_label;
  }
  else 
    if (! pZip->m_pState) {
      __retres = (mz_uint8 const *)0;
      goto return_label;
    }
    else 
      if (file_index >= pZip->m_total_files) {
        __retres = (mz_uint8 const *)0;
        goto return_label;
      }
  __retres = (mz_uint8 const *)((mz_uint8 *)(pZip->m_pState)->m_central_dir.m_p + *(
                                (mz_uint32 *)(pZip->m_pState)->m_central_dir_offsets.m_p + file_index));
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_is_file_encrypted
(mz_zip_archive *pZip, mz_uint file_index)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_uint m_bit_flag;
  mz_uint8 const *p = mz_zip_get_cdh(pZip,file_index);
  if (! p) {
    mz_zip_set_error(pZip,MZ_ZIP_INVALID_PARAMETER);
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  m_bit_flag = (mz_uint)*((mz_uint16 const *)(p + MZ_ZIP_CDH_BIT_FLAG_OFS));
  __retres = (mz_bool __attribute__((__visibility__("default"))))((m_bit_flag & (unsigned int)(
                                                                   MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION)) != (unsigned int)0);
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_is_file_supported
(mz_zip_archive *pZip, mz_uint file_index)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_uint bit_flag;
  mz_uint method;
  mz_uint8 const *p = mz_zip_get_cdh(pZip,file_index);
  if (! p) {
    mz_zip_set_error(pZip,MZ_ZIP_INVALID_PARAMETER);
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  method = (mz_uint)*((mz_uint16 const *)(p + MZ_ZIP_CDH_METHOD_OFS));
  bit_flag = (mz_uint)*((mz_uint16 const *)(p + MZ_ZIP_CDH_BIT_FLAG_OFS));
  if (method != (mz_uint)0) 
    if (method != (mz_uint)8) {
      mz_zip_set_error(pZip,MZ_ZIP_UNSUPPORTED_METHOD);
      __retres = (mz_bool __attribute__((__visibility__("default"))))0;
      goto return_label;
    }
  if (bit_flag & (unsigned int)(MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION)) {
    mz_zip_set_error(pZip,MZ_ZIP_UNSUPPORTED_ENCRYPTION);
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  if (bit_flag & (unsigned int)MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG) {
    mz_zip_set_error(pZip,MZ_ZIP_UNSUPPORTED_FEATURE);
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  __retres = (mz_bool __attribute__((__visibility__("default"))))1;
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_is_file_a_directory
(mz_zip_archive *pZip, mz_uint file_index)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_uint filename_len;
  mz_uint attribute_mapping_id;
  mz_uint external_attr;
  mz_uint8 const *p = mz_zip_get_cdh(pZip,file_index);
  if (! p) {
    mz_zip_set_error(pZip,MZ_ZIP_INVALID_PARAMETER);
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  filename_len = (mz_uint)*((mz_uint16 const *)(p + MZ_ZIP_CDH_FILENAME_LEN_OFS));
  if (filename_len) 
    if ((int)*(((p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) + filename_len) - 1) == '/') {
      __retres = (mz_bool __attribute__((__visibility__("default"))))1;
      goto return_label;
    }
  attribute_mapping_id = (mz_uint)((int)*((mz_uint16 const *)(p + MZ_ZIP_CDH_VERSION_MADE_BY_OFS)) >> 8);
  mz_uint tmp_2 = attribute_mapping_id;
  external_attr = *((mz_uint32 const *)(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS));
  if ((external_attr & (unsigned int)MZ_ZIP_DOS_DIR_ATTRIBUTE_BITFLAG) != (unsigned int)0) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))1;
    goto return_label;
  }
  __retres = (mz_bool __attribute__((__visibility__("default"))))0;
  return_label: return __retres;
}

static mz_bool mz_zip_file_stat_internal(mz_zip_archive *pZip,
                                         mz_uint file_index,
                                         mz_uint8 const *pCentral_dir_header,
                                         mz_zip_archive_file_stat *pStat,
                                         mz_bool *pFound_zip64_extra_data)
{
  mz_bool __retres;
  mz_uint n;
  mz_uint64 tmp_7;
  mz_uint64 tmp_5;
  mz_uint8 const *p = pCentral_dir_header;
  if (pFound_zip64_extra_data) *pFound_zip64_extra_data = 0;
  if (! p) goto _LOR;
  else 
    if (! pStat) {
      mz_bool tmp;
      _LOR: tmp = mz_zip_set_error(pZip,MZ_ZIP_INVALID_PARAMETER);
      __retres = tmp;
      goto return_label;
    }
  pStat->m_file_index = file_index;
  pStat->m_central_dir_ofs = (mz_uint64)*((mz_uint32 *)(pZip->m_pState)->m_central_dir_offsets.m_p + file_index);
  pStat->m_version_made_by = *((mz_uint16 const *)(p + MZ_ZIP_CDH_VERSION_MADE_BY_OFS));
  pStat->m_version_needed = *((mz_uint16 const *)(p + MZ_ZIP_CDH_VERSION_NEEDED_OFS));
  pStat->m_bit_flag = *((mz_uint16 const *)(p + MZ_ZIP_CDH_BIT_FLAG_OFS));
  pStat->m_method = *((mz_uint16 const *)(p + MZ_ZIP_CDH_METHOD_OFS));
  pStat->m_time = mz_zip_dos_to_time_t((int)*((mz_uint16 const *)(p + MZ_ZIP_CDH_FILE_TIME_OFS)),
                                       (int)*((mz_uint16 const *)(p + MZ_ZIP_CDH_FILE_DATE_OFS)));
  pStat->m_crc32 = *((mz_uint32 const *)(p + MZ_ZIP_CDH_CRC32_OFS));
  pStat->m_comp_size = (mz_uint64)*((mz_uint32 const *)(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS));
  pStat->m_uncomp_size = (mz_uint64)*((mz_uint32 const *)(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS));
  pStat->m_internal_attr = *((mz_uint16 const *)(p + MZ_ZIP_CDH_INTERNAL_ATTR_OFS));
  pStat->m_external_attr = *((mz_uint32 const *)(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS));
  pStat->m_local_header_ofs = (mz_uint64)*((mz_uint32 const *)(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS));
  n = (mz_uint)*((mz_uint16 const *)(p + MZ_ZIP_CDH_FILENAME_LEN_OFS));
  if (n < (mz_uint)(MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE - 1)) n = n;
  else n = (mz_uint)(MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE - 1);
  memcpy((void *)(pStat->m_filename),
         (void const *)(p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE),(size_t)n);
  pStat->m_filename[n] = (char)'\000';
  n = (mz_uint)*((mz_uint16 const *)(p + MZ_ZIP_CDH_COMMENT_LEN_OFS));
  if (n < (mz_uint)(MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE - 1)) n = n;
  else n = (mz_uint)(MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE - 1);
  pStat->m_comment_size = n;
  memcpy((void *)(pStat->m_comment),
         (void const *)(((p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) + (int)*((mz_uint16 const *)(
                         p + MZ_ZIP_CDH_FILENAME_LEN_OFS))) + (int)*((mz_uint16 const *)(
                        p + MZ_ZIP_CDH_EXTRA_LEN_OFS))),(size_t)n);
  pStat->m_comment[n] = (char)'\000';
  pStat->m_is_directory = (mz_bool)mz_zip_reader_is_file_a_directory(pZip,
                                                                    file_index);
  pStat->m_is_encrypted = (mz_bool)mz_zip_reader_is_file_encrypted(pZip,
                                                                   file_index);
  pStat->m_is_supported = (mz_bool)mz_zip_reader_is_file_supported(pZip,
                                                                   file_index);
  if (pStat->m_comp_size > pStat->m_uncomp_size) tmp_5 = pStat->m_comp_size;
  else tmp_5 = pStat->m_uncomp_size;
  ;
  if (tmp_5 > pStat->m_local_header_ofs) {
    mz_uint64 tmp_6;
    if (pStat->m_comp_size > pStat->m_uncomp_size) tmp_6 = pStat->m_comp_size;
    else tmp_6 = pStat->m_uncomp_size;
    tmp_7 = tmp_6;
  }
  else tmp_7 = pStat->m_local_header_ofs;
  if (tmp_7 == (mz_uint64)0xFFFFFFFFU) {
    mz_uint32 extra_size_remaining =
      (mz_uint32)*((mz_uint16 const *)(p + MZ_ZIP_CDH_EXTRA_LEN_OFS));
    if (extra_size_remaining) {
      mz_uint8 const *pExtra_data =
        (p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) + (int)*((mz_uint16 const *)(
        p + MZ_ZIP_CDH_FILENAME_LEN_OFS));
      while (1) {
        {
          mz_uint32 field_id;
          mz_uint32 field_data_size;
          if ((unsigned long)extra_size_remaining < sizeof(mz_uint16) * (unsigned long)2) {
            mz_bool tmp_0;
            tmp_0 = mz_zip_set_error(pZip,MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
            __retres = tmp_0;
            goto return_label;
          }
          field_id = (mz_uint32)*((mz_uint16 const *)pExtra_data);
          field_data_size = (mz_uint32)*((mz_uint16 const *)(pExtra_data + sizeof(mz_uint16)));
          if ((unsigned long)field_data_size + sizeof(mz_uint16) * (unsigned long)2 > (unsigned long)extra_size_remaining) {
            mz_bool tmp_1;
            tmp_1 = mz_zip_set_error(pZip,MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
            __retres = tmp_1;
            goto return_label;
          }
          if (field_id == (mz_uint32)MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID) {
            mz_uint8 const *pField_data =
              pExtra_data + sizeof(mz_uint16) * (unsigned long)2;
            mz_uint32 field_data_remaining = field_data_size;
            if (pFound_zip64_extra_data) *pFound_zip64_extra_data = 1;
            if (pStat->m_uncomp_size == (mz_uint64)0xFFFFFFFFU) {
              if ((unsigned long)field_data_remaining < sizeof(mz_uint64)) {
                mz_bool tmp_2;
                tmp_2 = mz_zip_set_error(pZip,
                                         MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                __retres = tmp_2;
                goto return_label;
              }
              pStat->m_uncomp_size = (mz_uint64)*((mz_uint32 const *)pField_data) | (
                                     (mz_uint64)*((mz_uint32 const *)(
                                     pField_data + sizeof(mz_uint32))) << 32U);
              pField_data += sizeof(mz_uint64);
              field_data_remaining = (mz_uint32)((unsigned long)field_data_remaining - sizeof(mz_uint64));
            }
            if (pStat->m_comp_size == (mz_uint64)0xFFFFFFFFU) {
              if ((unsigned long)field_data_remaining < sizeof(mz_uint64)) {
                mz_bool tmp_3;
                tmp_3 = mz_zip_set_error(pZip,
                                         MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                __retres = tmp_3;
                goto return_label;
              }
              pStat->m_comp_size = (mz_uint64)*((mz_uint32 const *)pField_data) | (
                                   (mz_uint64)*((mz_uint32 const *)(pField_data + sizeof(mz_uint32))) << 32U);
              pField_data += sizeof(mz_uint64);
              field_data_remaining = (mz_uint32)((unsigned long)field_data_remaining - sizeof(mz_uint64));
            }
            if (pStat->m_local_header_ofs == (mz_uint64)0xFFFFFFFFU) {
              if ((unsigned long)field_data_remaining < sizeof(mz_uint64)) {
                mz_bool tmp_4;
                tmp_4 = mz_zip_set_error(pZip,
                                         MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                __retres = tmp_4;
                goto return_label;
              }
              pStat->m_local_header_ofs = (mz_uint64)*((mz_uint32 const *)pField_data) | (
                                          (mz_uint64)*((mz_uint32 const *)(
                                          pField_data + sizeof(mz_uint32))) << 32U);
              pField_data += sizeof(mz_uint64);
              field_data_remaining = (mz_uint32)((unsigned long)field_data_remaining - sizeof(mz_uint64));
            }
            break;
          }
          pExtra_data += sizeof(mz_uint16) * (unsigned long)2 + (unsigned long)field_data_size;
          extra_size_remaining = (mz_uint32)(((unsigned long)extra_size_remaining - 
                                              sizeof(mz_uint16) * (unsigned long)2) - (unsigned long)field_data_size);
        }
        if (! extra_size_remaining) break;
      }
    }
  }
  __retres = 1;
  return_label: return __retres;
}

__inline static mz_bool ( __attribute__((__always_inline__)) mz_zip_string_equal)
(char const *pA, char const *pB, mz_uint len, mz_uint flags)
{
  mz_bool __retres;
  mz_uint i;
  if (flags & (unsigned int)MZ_ZIP_FLAG_CASE_SENSITIVE) {
    int tmp;
    tmp = memcmp((void const *)pA,(void const *)pB,(size_t)len);
    __retres = 0 == tmp;
    goto return_label;
  }
  i = (mz_uint)0;
  while (i < len) {
    int tmp_0;
    int tmp_1;
    if ((int)*(pA + i) >= 'A') 
      if ((int)*(pA + i) <= 'Z') tmp_0 = ((int)*(pA + i) - 'A') + 'a';
      else tmp_0 = (int)*(pA + i);
    else tmp_0 = (int)*(pA + i);
    if ((int)*(pB + i) >= 'A') 
      if ((int)*(pB + i) <= 'Z') tmp_1 = ((int)*(pB + i) - 'A') + 'a';
      else tmp_1 = (int)*(pB + i);
    else tmp_1 = (int)*(pB + i);
    if (tmp_0 != tmp_1) {
      __retres = 0;
      goto return_label;
    }
    i ++;
  }
  __retres = 1;
  return_label: return __retres;
}

__inline static int ( __attribute__((__always_inline__)) mz_zip_filename_compare)
(mz_zip_array const *pCentral_dir_array,
 mz_zip_array const *pCentral_dir_offsets, mz_uint l_index, char const *pR,
 mz_uint r_len)
{
  mz_uint8 const *pE;
  mz_uint tmp;
  int tmp_0;
  mz_uint8 const *pL =
    (mz_uint8 const *)((mz_uint8 *)pCentral_dir_array->m_p + *((mz_uint32 *)pCentral_dir_offsets->m_p + l_index));
  mz_uint l_len =
    (mz_uint)*((mz_uint16 const *)(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS));
  mz_uint8 l = (mz_uint8)0;
  mz_uint8 r = (mz_uint8)0;
  pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
  if (l_len < r_len) tmp = l_len; else tmp = r_len;
  pE = pL + tmp;
  while (pL < pE) {
    if ((int)*pL >= 'A') 
      if ((int)*pL <= 'Z') l = (mz_uint8)(((int)*pL - 'A') + 'a');
      else l = *pL;
    else l = *pL;
    if ((int)*pR >= 'A') 
      if ((int)*pR <= 'Z') r = (mz_uint8)(((int)*pR - 'A') + 'a');
      else r = (mz_uint8)*pR;
    else r = (mz_uint8)*pR;
    if ((int)l != (int)r) break;
    pL ++;
    pR ++;
  }
  if (pL == pE) tmp_0 = (int)(l_len - r_len); else tmp_0 = (int)l - (int)r;
  return tmp_0;
}

static mz_bool mz_zip_locate_file_binary_search(mz_zip_archive *pZip,
                                                char const *pFilename,
                                                mz_uint32 *pIndex)
{
  mz_bool __retres;
  size_t tmp;
  mz_bool tmp_1;
  mz_zip_internal_state *pState = pZip->m_pState;
  mz_zip_array const *pCentral_dir_offsets =
    (mz_zip_array const *)(& pState->m_central_dir_offsets);
  mz_zip_array const *pCentral_dir =
    (mz_zip_array const *)(& pState->m_central_dir);
  mz_uint32 *pIndices =
    (mz_uint32 *)pState->m_sorted_central_dir_offsets.m_p + 0;
  uint32_t const size = pZip->m_total_files;
  tmp = strlen(pFilename);
  mz_uint const filename_len = (mz_uint)tmp;
  if (pIndex) *pIndex = (mz_uint32)0;
  if (size) {
    mz_int64 l = (mz_int64)0;
    mz_int64 h = (mz_int64)size - (mz_int64)1;
    while (l <= h) {
      mz_int64 m = l + ((h - l) >> 1);
      uint32_t file_index = *(pIndices + (uint32_t)m);
      int comp =
        mz_zip_filename_compare(pCentral_dir,pCentral_dir_offsets,file_index,
                                pFilename,filename_len);
      if (! comp) {
        if (pIndex) *pIndex = file_index;
        __retres = 1;
        goto return_label;
      }
      else 
        if (comp < 0) l = m + (mz_int64)1; else h = m - (mz_int64)1;
    }
  }
  tmp_1 = mz_zip_set_error(pZip,MZ_ZIP_FILE_NOT_FOUND);
  __retres = tmp_1;
  return_label: return __retres;
}

int __attribute__((__visibility__("default"))) mz_zip_reader_locate_file
(mz_zip_archive *pZip, char const *pName, char const *pComment, mz_uint flags)
{
  int __attribute__((__visibility__("default"))) __retres;
  mz_uint32 index_0;
  mz_bool __attribute__((__visibility__("default"))) tmp;
  tmp = mz_zip_reader_locate_file_v2(pZip,pName,pComment,flags,& index_0);
  if (tmp) {
    __retres = (int __attribute__((__visibility__("default"))))((int)index_0);
    goto return_label;
  }
  else {
    __retres = (int __attribute__((__visibility__("default"))))(-1);
    goto return_label;
  }
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_locate_file_v2
(mz_zip_archive *pZip, char const *pName, char const *pComment,
 mz_uint flags, mz_uint32 *pIndex)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_uint file_index;
  size_t name_len;
  size_t comment_len;
  mz_bool __attribute__((__visibility__("default"))) tmp_6;
  if (pIndex) *pIndex = (mz_uint32)0;
  if (! pZip) goto _LOR;
  else 
    if (! pZip->m_pState) goto _LOR;
    else 
      if (! pName) {
        mz_bool __attribute__((__visibility__("default"))) tmp;
        _LOR:
        tmp = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
        (pZip,MZ_ZIP_INVALID_PARAMETER);
        __retres = tmp;
        goto return_label;
      }
  if (((pZip->m_pState)->m_init_flags & (unsigned int)MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY) == (unsigned int)0) 
    if (pZip->m_zip_mode == (unsigned int)MZ_ZIP_MODE_READING) 
      if ((flags & (unsigned int)(MZ_ZIP_FLAG_IGNORE_PATH | MZ_ZIP_FLAG_CASE_SENSITIVE)) == (unsigned int)0) 
        if (! pComment) 
          if ((pZip->m_pState)->m_sorted_central_dir_offsets.m_size) {
            mz_bool __attribute__((__visibility__("default"))) tmp_0;
            tmp_0 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_locate_file_binary_search
            (pZip,pName,pIndex);
            __retres = tmp_0;
            goto return_label;
          }
  name_len = strlen(pName);
  if (name_len > (size_t)0xFFFFU) {
    mz_bool __attribute__((__visibility__("default"))) tmp_1;
    tmp_1 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_INVALID_PARAMETER);
    __retres = tmp_1;
    goto return_label;
  }
  if (pComment) comment_len = strlen(pComment); else comment_len = (size_t)0;
  if (comment_len > (size_t)0xFFFFU) {
    mz_bool __attribute__((__visibility__("default"))) tmp_3;
    tmp_3 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_INVALID_PARAMETER);
    __retres = tmp_3;
    goto return_label;
  }
  file_index = (mz_uint)0;
  while (file_index < pZip->m_total_files) {
    {
      mz_uint8 const *pHeader =
        (mz_uint8 const *)((mz_uint8 *)(pZip->m_pState)->m_central_dir.m_p + *(
                           (mz_uint32 *)(pZip->m_pState)->m_central_dir_offsets.m_p + file_index));
      mz_uint filename_len =
        (mz_uint)*((mz_uint16 const *)(pHeader + MZ_ZIP_CDH_FILENAME_LEN_OFS));
      char const *pFilename =
        (char const *)pHeader + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
      if ((size_t)filename_len < name_len) goto __Cont;
      if (comment_len) {
        mz_uint file_extra_len =
          (mz_uint)*((mz_uint16 const *)(pHeader + MZ_ZIP_CDH_EXTRA_LEN_OFS));
        mz_uint file_comment_len =
          (mz_uint)*((mz_uint16 const *)(pHeader + MZ_ZIP_CDH_COMMENT_LEN_OFS));
        char const *pFile_comment =
          (pFilename + filename_len) + file_extra_len;
        if ((size_t)file_comment_len != comment_len) goto __Cont;
        else {
          mz_bool tmp_4;
          tmp_4 = mz_zip_string_equal(pComment,pFile_comment,
                                      file_comment_len,flags);
          if (! tmp_4) goto __Cont;
        }
      }
      if (flags & (unsigned int)MZ_ZIP_FLAG_IGNORE_PATH) 
        if (filename_len) {
          int ofs = (int)(filename_len - (mz_uint)1);
          while (1) {
            if ((int)*(pFilename + ofs) == '/') break;
            else 
              if ((int)*(pFilename + ofs) == '\\') break;
              else 
                if ((int)*(pFilename + ofs) == ':') break;
            ofs --;
            if (! (ofs >= 0)) break;
          }
          ofs ++;
          pFilename += ofs;
          filename_len -= (mz_uint)ofs;
        }
      if ((size_t)filename_len == name_len) {
        mz_bool tmp_5;
        tmp_5 = mz_zip_string_equal(pName,pFilename,filename_len,flags);
        if (tmp_5) {
          if (pIndex) *pIndex = file_index;
          __retres = (mz_bool __attribute__((__visibility__("default"))))1;
          goto return_label;
        }
      }
    }
    __Cont: file_index ++;
  }
  tmp_6 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
  (pZip,MZ_ZIP_FILE_NOT_FOUND);
  __retres = tmp_6;
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_extract_to_mem_no_alloc
(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size,
 mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_uint64 needed_size;
  mz_uint64 cur_file_ofs;
  mz_uint64 comp_remaining;
  mz_uint64 read_buf_size;
  mz_uint64 read_buf_avail;
  mz_zip_archive_file_stat file_stat;
  void *pRead_buf;
  mz_uint32 local_header_u32[(((unsigned long)MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32)) - (unsigned long)1) / sizeof(mz_uint32)];
  tinfl_decompressor inflator;
  mz_bool __attribute__((__visibility__("default"))) tmp_0;
  size_t tmp_5;
  int status = TINFL_STATUS_DONE;
  mz_uint64 out_buf_ofs = (mz_uint64)0;
  mz_uint64 read_buf_ofs = (mz_uint64)0;
  mz_uint8 *pLocal_header = (mz_uint8 *)(local_header_u32);
  if (! pZip) goto _LOR;
  else 
    if (! pZip->m_pState) goto _LOR;
    else 
      if (buf_size) {
        if (! pBuf) goto _LOR; else goto _LAND_0;
      }
      else {
        _LAND_0: ;
        if (user_read_buf_size) {
          if (! pUser_read_buf) goto _LOR; else goto _LAND;
        }
        else 
          _LAND:
          if (! pZip->m_pRead) {
            mz_bool __attribute__((__visibility__("default"))) tmp;
            _LOR:
            tmp = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
            (pZip,MZ_ZIP_INVALID_PARAMETER);
            __retres = tmp;
            goto return_label;
          }
      }
  tmp_0 = mz_zip_reader_file_stat(pZip,file_index,& file_stat);
  if (! tmp_0) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  if (file_stat.m_is_directory) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))1;
    goto return_label;
  }
  else 
    if (! file_stat.m_comp_size) {
      __retres = (mz_bool __attribute__((__visibility__("default"))))1;
      goto return_label;
    }
  if ((int)file_stat.m_bit_flag & ((MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION) | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG)) {
    mz_bool __attribute__((__visibility__("default"))) tmp_1;
    tmp_1 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_UNSUPPORTED_ENCRYPTION);
    __retres = tmp_1;
    goto return_label;
  }
  if (! (flags & (unsigned int)MZ_ZIP_FLAG_COMPRESSED_DATA)) 
    if ((int)file_stat.m_method != 0) 
      if ((int)file_stat.m_method != 8) {
        mz_bool __attribute__((__visibility__("default"))) tmp_2;
        tmp_2 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
        (pZip,MZ_ZIP_UNSUPPORTED_METHOD);
        __retres = tmp_2;
        goto return_label;
      }
  if (flags & (unsigned int)MZ_ZIP_FLAG_COMPRESSED_DATA) needed_size = file_stat.m_comp_size;
  else needed_size = file_stat.m_uncomp_size;
  if (buf_size < needed_size) {
    mz_bool __attribute__((__visibility__("default"))) tmp_3;
    tmp_3 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_BUF_TOO_SMALL);
    __retres = tmp_3;
    goto return_label;
  }
  cur_file_ofs = file_stat.m_local_header_ofs;
  tmp_5 = (*(pZip->m_pRead))(pZip->m_pIO_opaque,cur_file_ofs,
                             (void *)pLocal_header,
                             (size_t)MZ_ZIP_LOCAL_DIR_HEADER_SIZE);
  if (tmp_5 != (size_t)MZ_ZIP_LOCAL_DIR_HEADER_SIZE) {
    mz_bool __attribute__((__visibility__("default"))) tmp_4;
    tmp_4 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_FILE_READ_FAILED);
    __retres = tmp_4;
    goto return_label;
  }
  if (*((mz_uint32 const *)pLocal_header) != (mz_uint32)MZ_ZIP_LOCAL_DIR_HEADER_SIG) {
    mz_bool __attribute__((__visibility__("default"))) tmp_6;
    tmp_6 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
    __retres = tmp_6;
    goto return_label;
  }
  cur_file_ofs += (mz_uint64)((MZ_ZIP_LOCAL_DIR_HEADER_SIZE + (int)*((mz_uint16 const *)(
                               pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS))) + (int)*((mz_uint16 const *)(
                              pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS)));
  if (cur_file_ofs + file_stat.m_comp_size > pZip->m_archive_size) {
    mz_bool __attribute__((__visibility__("default"))) tmp_7;
    tmp_7 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
    __retres = tmp_7;
    goto return_label;
  }
  if (flags & (unsigned int)MZ_ZIP_FLAG_COMPRESSED_DATA) goto _LOR_0;
  else 
    if (! file_stat.m_method) {
      _LOR_0:
      {
        size_t tmp_9;
        tmp_9 = (*(pZip->m_pRead))(pZip->m_pIO_opaque,cur_file_ofs,pBuf,
                                   needed_size);
        ;
        if (tmp_9 != needed_size) {
          mz_bool __attribute__((__visibility__("default"))) tmp_8;
          tmp_8 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
          (pZip,MZ_ZIP_FILE_READ_FAILED);
          __retres = tmp_8;
          goto return_label;
        }
        if ((flags & (unsigned int)MZ_ZIP_FLAG_COMPRESSED_DATA) == (unsigned int)0) {
          mz_ulong __attribute__((__visibility__("default"))) tmp_11;
          tmp_11 = mz_crc32((mz_ulong)0,(mz_uint8 const *)pBuf,
                            file_stat.m_uncomp_size);
          ;
          if (tmp_11 != (mz_ulong __attribute__((__visibility__("default"))))file_stat.m_crc32) {
            mz_bool __attribute__((__visibility__("default"))) tmp_10;
            tmp_10 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
            (pZip,MZ_ZIP_CRC_CHECK_FAILED);
            __retres = tmp_10;
            goto return_label;
          }
        }
        __retres = (mz_bool __attribute__((__visibility__("default"))))1;
        goto return_label;
      }
    }
  inflator.m_state = (mz_uint32)0;
  inflator.m_num_bits = (mz_uint32)0;
  inflator.m_bit_buf = (tinfl_bit_buf_t)0;
  inflator.m_dist = (mz_uint32)0;
  inflator.m_counter = (mz_uint32)0;
  inflator.m_num_extra = (mz_uint32)0;
  inflator.m_dist_from_out_buf_start = (size_t)0;
  if ((pZip->m_pState)->m_pMem) {
    pRead_buf = (void *)((mz_uint8 *)(pZip->m_pState)->m_pMem + cur_file_ofs);
    read_buf_avail = file_stat.m_comp_size;
    read_buf_size = read_buf_avail;
    comp_remaining = (mz_uint64)0;
  }
  else 
    if (pUser_read_buf) {
      if (! user_read_buf_size) {
        __retres = (mz_bool __attribute__((__visibility__("default"))))0;
        goto return_label;
      }
      pRead_buf = pUser_read_buf;
      read_buf_size = user_read_buf_size;
      read_buf_avail = (mz_uint64)0;
      comp_remaining = file_stat.m_comp_size;
    }
    else {
      if (file_stat.m_comp_size < (mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE) 
        read_buf_size = file_stat.m_comp_size;
      else read_buf_size = (mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE;
      if (sizeof(size_t) == sizeof(mz_uint32)) 
        if (read_buf_size > (mz_uint64)0x7FFFFFFF) {
          mz_bool __attribute__((__visibility__("default"))) tmp_12;
          tmp_12 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
          (pZip,MZ_ZIP_INTERNAL_ERROR);
          __retres = tmp_12;
          goto return_label;
        }
      pRead_buf = (*(pZip->m_pAlloc))(pZip->m_pAlloc_opaque,(size_t)1,
                                      read_buf_size);
      if ((void *)0 == pRead_buf) {
        mz_bool __attribute__((__visibility__("default"))) tmp_13;
        tmp_13 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
        (pZip,MZ_ZIP_ALLOC_FAILED);
        __retres = tmp_13;
        goto return_label;
      }
      read_buf_avail = (mz_uint64)0;
      comp_remaining = file_stat.m_comp_size;
    }
  while (1) {
    {
      size_t in_buf_size;
      tinfl_status __attribute__((__visibility__("default"))) tmp_16;
      int tmp_15;
      size_t out_buf_size = file_stat.m_uncomp_size - out_buf_ofs;
      if (! read_buf_avail) 
        if (! (pZip->m_pState)->m_pMem) {
          size_t tmp_14;
          if (read_buf_size < comp_remaining) read_buf_avail = read_buf_size;
          else read_buf_avail = comp_remaining;
          tmp_14 = (*(pZip->m_pRead))(pZip->m_pIO_opaque,cur_file_ofs,
                                      pRead_buf,read_buf_avail);
          ;
          if (tmp_14 != read_buf_avail) {
            status = TINFL_STATUS_FAILED;
            mz_zip_set_error(pZip,MZ_ZIP_DECOMPRESSION_FAILED);
            break;
          }
          cur_file_ofs += read_buf_avail;
          comp_remaining -= read_buf_avail;
          read_buf_ofs = (mz_uint64)0;
        }
      in_buf_size = read_buf_avail;
      if (comp_remaining) tmp_15 = TINFL_FLAG_HAS_MORE_INPUT;
      else tmp_15 = 0;
      ;
      ;
      ;
      tmp_16 = tinfl_decompress(& inflator,
                                (mz_uint8 const *)((mz_uint8 *)pRead_buf + read_buf_ofs),
                                & in_buf_size,(mz_uint8 *)pBuf,
                                (mz_uint8 *)pBuf + out_buf_ofs,
                                & out_buf_size,
                                (mz_uint32)(TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF | tmp_15));
      status = (int)tmp_16;
      read_buf_avail -= in_buf_size;
      read_buf_ofs += in_buf_size;
      out_buf_ofs += out_buf_size;
    }
    if (! (status == TINFL_STATUS_NEEDS_MORE_INPUT)) break;
  }
  if (status == TINFL_STATUS_DONE) 
    if (out_buf_ofs != file_stat.m_uncomp_size) {
      mz_zip_set_error(pZip,MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE);
      status = TINFL_STATUS_FAILED;
    }
    else {
      mz_ulong __attribute__((__visibility__("default"))) tmp_17;
      tmp_17 = mz_crc32((mz_ulong)0,(mz_uint8 const *)pBuf,
                        file_stat.m_uncomp_size);
      ;
      if (tmp_17 != (mz_ulong __attribute__((__visibility__("default"))))file_stat.m_crc32) {
        mz_zip_set_error(pZip,MZ_ZIP_CRC_CHECK_FAILED);
        status = TINFL_STATUS_FAILED;
      }
    }
  if (! (pZip->m_pState)->m_pMem) 
    if (! pUser_read_buf) (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,pRead_buf);
  __retres = (mz_bool __attribute__((__visibility__("default"))))(status == TINFL_STATUS_DONE);
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_extract_file_to_mem_no_alloc
(mz_zip_archive *pZip, char const *pFilename, void *pBuf, size_t buf_size,
 mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_uint32 file_index;
  mz_bool __attribute__((__visibility__("default"))) tmp;
  mz_bool __attribute__((__visibility__("default"))) tmp_0;
  tmp = mz_zip_reader_locate_file_v2(pZip,pFilename,(char const *)0,flags,
                                     & file_index);
  if (! tmp) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  tmp_0 = mz_zip_reader_extract_to_mem_no_alloc(pZip,file_index,pBuf,
                                                buf_size,flags,
                                                pUser_read_buf,
                                                user_read_buf_size);
  __retres = tmp_0;
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_extract_to_mem
(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size,
 mz_uint flags)
{
  mz_bool __attribute__((__visibility__("default"))) tmp;
  tmp = mz_zip_reader_extract_to_mem_no_alloc(pZip,file_index,pBuf,buf_size,
                                              flags,(void *)0,(size_t)0);
  return tmp;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_extract_file_to_mem
(mz_zip_archive *pZip, char const *pFilename, void *pBuf, size_t buf_size,
 mz_uint flags)
{
  mz_bool __attribute__((__visibility__("default"))) tmp;
  tmp = mz_zip_reader_extract_file_to_mem_no_alloc(pZip,pFilename,pBuf,
                                                   buf_size,flags,(void *)0,
                                                   (size_t)0);
  return tmp;
}

void __attribute__((__visibility__("default"))) *mz_zip_reader_extract_to_heap
(mz_zip_archive *pZip, mz_uint file_index, size_t *pSize, mz_uint flags)
{
  void __attribute__((__visibility__("default"))) *__retres;
  mz_uint64 comp_size;
  mz_uint64 uncomp_size;
  mz_uint64 alloc_size;
  void *pBuf;
  mz_bool __attribute__((__visibility__("default"))) tmp_0;
  mz_uint8 const *p = mz_zip_get_cdh(pZip,file_index);
  if (pSize) *pSize = (size_t)0;
  if (! p) {
    mz_zip_set_error(pZip,MZ_ZIP_INVALID_PARAMETER);
    __retres = (void __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  comp_size = (mz_uint64)*((mz_uint32 const *)(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS));
  uncomp_size = (mz_uint64)*((mz_uint32 const *)(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS));
  if (flags & (unsigned int)MZ_ZIP_FLAG_COMPRESSED_DATA) alloc_size = comp_size;
  else alloc_size = uncomp_size;
  if (sizeof(size_t) == sizeof(mz_uint32)) 
    if (alloc_size > (mz_uint64)0x7FFFFFFF) {
      mz_zip_set_error(pZip,MZ_ZIP_INTERNAL_ERROR);
      __retres = (void __attribute__((__visibility__("default"))) *)0;
      goto return_label;
    }
  pBuf = (*(pZip->m_pAlloc))(pZip->m_pAlloc_opaque,(size_t)1,alloc_size);
  if ((void *)0 == pBuf) {
    mz_zip_set_error(pZip,MZ_ZIP_ALLOC_FAILED);
    __retres = (void __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  tmp_0 = mz_zip_reader_extract_to_mem(pZip,file_index,pBuf,alloc_size,flags);
  if (! tmp_0) {
    (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,pBuf);
    __retres = (void __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  if (pSize) *pSize = alloc_size;
  __retres = (void __attribute__((__visibility__("default"))) *)pBuf;
  return_label: return __retres;
}

void __attribute__((__visibility__("default"))) *mz_zip_reader_extract_file_to_heap
(mz_zip_archive *pZip, char const *pFilename, size_t *pSize, mz_uint flags)
{
  void __attribute__((__visibility__("default"))) *__retres;
  mz_uint32 file_index;
  mz_bool __attribute__((__visibility__("default"))) tmp;
  void __attribute__((__visibility__("default"))) *tmp_0;
  tmp = mz_zip_reader_locate_file_v2(pZip,pFilename,(char const *)0,flags,
                                     & file_index);
  if (! tmp) {
    if (pSize) *pSize = (size_t)0;
    __retres = (void __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  tmp_0 = mz_zip_reader_extract_to_heap(pZip,file_index,pSize,flags);
  __retres = tmp_0;
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_extract_to_callback
(mz_zip_archive *pZip, mz_uint file_index,
 size_t (*pCallback)(void *pOpaque, mz_uint64 file_ofs, void const *pBuf,
                     size_t n),
 void *pOpaque, mz_uint flags)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_uint64 read_buf_size;
  mz_uint64 read_buf_avail;
  mz_uint64 comp_remaining;
  mz_uint64 cur_file_ofs;
  mz_zip_archive_file_stat file_stat;
  mz_uint32 local_header_u32[(((unsigned long)MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32)) - (unsigned long)1) / sizeof(mz_uint32)];
  mz_bool __attribute__((__visibility__("default"))) tmp_0;
  size_t tmp_4;
  int status = TINFL_STATUS_DONE;
  mz_uint file_crc32 = (mz_uint)0;
  mz_uint64 read_buf_ofs = (mz_uint64)0;
  mz_uint64 out_buf_ofs = (mz_uint64)0;
  void *pRead_buf = (void *)0;
  void *pWrite_buf = (void *)0;
  mz_uint8 *pLocal_header = (mz_uint8 *)(local_header_u32);
  if (! pZip) goto _LOR;
  else 
    if (! pZip->m_pState) goto _LOR;
    else 
      if (! pCallback) goto _LOR;
      else 
        if (! pZip->m_pRead) {
          mz_bool __attribute__((__visibility__("default"))) tmp;
          _LOR:
          tmp = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
          (pZip,MZ_ZIP_INVALID_PARAMETER);
          __retres = tmp;
          goto return_label;
        }
  tmp_0 = mz_zip_reader_file_stat(pZip,file_index,& file_stat);
  if (! tmp_0) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  if (file_stat.m_is_directory) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))1;
    goto return_label;
  }
  else 
    if (! file_stat.m_comp_size) {
      __retres = (mz_bool __attribute__((__visibility__("default"))))1;
      goto return_label;
    }
  if ((int)file_stat.m_bit_flag & ((MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION) | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG)) {
    mz_bool __attribute__((__visibility__("default"))) tmp_1;
    tmp_1 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_UNSUPPORTED_ENCRYPTION);
    __retres = tmp_1;
    goto return_label;
  }
  if (! (flags & (unsigned int)MZ_ZIP_FLAG_COMPRESSED_DATA)) 
    if ((int)file_stat.m_method != 0) 
      if ((int)file_stat.m_method != 8) {
        mz_bool __attribute__((__visibility__("default"))) tmp_2;
        tmp_2 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
        (pZip,MZ_ZIP_UNSUPPORTED_METHOD);
        __retres = tmp_2;
        goto return_label;
      }
  cur_file_ofs = file_stat.m_local_header_ofs;
  tmp_4 = (*(pZip->m_pRead))(pZip->m_pIO_opaque,cur_file_ofs,
                             (void *)pLocal_header,
                             (size_t)MZ_ZIP_LOCAL_DIR_HEADER_SIZE);
  if (tmp_4 != (size_t)MZ_ZIP_LOCAL_DIR_HEADER_SIZE) {
    mz_bool __attribute__((__visibility__("default"))) tmp_3;
    tmp_3 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_FILE_READ_FAILED);
    __retres = tmp_3;
    goto return_label;
  }
  if (*((mz_uint32 const *)pLocal_header) != (mz_uint32)MZ_ZIP_LOCAL_DIR_HEADER_SIG) {
    mz_bool __attribute__((__visibility__("default"))) tmp_5;
    tmp_5 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
    __retres = tmp_5;
    goto return_label;
  }
  cur_file_ofs += (mz_uint64)((MZ_ZIP_LOCAL_DIR_HEADER_SIZE + (int)*((mz_uint16 const *)(
                               pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS))) + (int)*((mz_uint16 const *)(
                              pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS)));
  if (cur_file_ofs + file_stat.m_comp_size > pZip->m_archive_size) {
    mz_bool __attribute__((__visibility__("default"))) tmp_6;
    tmp_6 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
    __retres = tmp_6;
    goto return_label;
  }
  if ((pZip->m_pState)->m_pMem) {
    pRead_buf = (void *)((mz_uint8 *)(pZip->m_pState)->m_pMem + cur_file_ofs);
    read_buf_avail = file_stat.m_comp_size;
    read_buf_size = read_buf_avail;
    comp_remaining = (mz_uint64)0;
  }
  else {
    if (file_stat.m_comp_size < (mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE) read_buf_size = file_stat.m_comp_size;
    else read_buf_size = (mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE;
    pRead_buf = (*(pZip->m_pAlloc))(pZip->m_pAlloc_opaque,(size_t)1,
                                    read_buf_size);
    if ((void *)0 == pRead_buf) {
      mz_bool __attribute__((__visibility__("default"))) tmp_7;
      tmp_7 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_ALLOC_FAILED);
      __retres = tmp_7;
      goto return_label;
    }
    read_buf_avail = (mz_uint64)0;
    comp_remaining = file_stat.m_comp_size;
  }
  if (flags & (unsigned int)MZ_ZIP_FLAG_COMPRESSED_DATA) goto _LOR_0;
  else 
    if (! file_stat.m_method) 
      _LOR_0:
      if ((pZip->m_pState)->m_pMem) {
        size_t tmp_10;
        if (sizeof(size_t) == sizeof(mz_uint32)) 
          if (file_stat.m_comp_size > (mz_uint64)0xFFFFFFFFU) {
            mz_bool __attribute__((__visibility__("default"))) tmp_8;
            tmp_8 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
            (pZip,MZ_ZIP_INTERNAL_ERROR);
            __retres = tmp_8;
            goto return_label;
          }
        tmp_10 = (*pCallback)(pOpaque,out_buf_ofs,(void const *)pRead_buf,
                              file_stat.m_comp_size);
        ;
        if (tmp_10 != file_stat.m_comp_size) {
          mz_zip_set_error(pZip,MZ_ZIP_WRITE_CALLBACK_FAILED);
          status = TINFL_STATUS_FAILED;
        }
        else 
          if (! (flags & (unsigned int)MZ_ZIP_FLAG_COMPRESSED_DATA)) {
            mz_ulong __attribute__((__visibility__("default"))) tmp_9;
            tmp_9 = mz_crc32((mz_ulong)file_crc32,
                             (mz_uint8 const *)pRead_buf,
                             file_stat.m_comp_size);
            file_crc32 = (mz_uint32)tmp_9;
          }
        cur_file_ofs += file_stat.m_comp_size;
        out_buf_ofs += file_stat.m_comp_size;
        comp_remaining = (mz_uint64)0;
      }
      else 
        while (comp_remaining) {
          size_t tmp_11;
          size_t tmp_13;
          if (read_buf_size < comp_remaining) read_buf_avail = read_buf_size;
          else read_buf_avail = comp_remaining;
          tmp_11 = (*(pZip->m_pRead))(pZip->m_pIO_opaque,cur_file_ofs,
                                      pRead_buf,read_buf_avail);
          ;
          if (tmp_11 != read_buf_avail) {
            mz_zip_set_error(pZip,MZ_ZIP_FILE_READ_FAILED);
            status = TINFL_STATUS_FAILED;
            break;
          }
          if (! (flags & (unsigned int)MZ_ZIP_FLAG_COMPRESSED_DATA)) {
            mz_ulong __attribute__((__visibility__("default"))) tmp_12;
            tmp_12 = mz_crc32((mz_ulong)file_crc32,
                              (mz_uint8 const *)pRead_buf,read_buf_avail);
            file_crc32 = (mz_uint32)tmp_12;
          }
          tmp_13 = (*pCallback)(pOpaque,out_buf_ofs,(void const *)pRead_buf,
                                read_buf_avail);
          ;
          if (tmp_13 != read_buf_avail) {
            mz_zip_set_error(pZip,MZ_ZIP_WRITE_CALLBACK_FAILED);
            status = TINFL_STATUS_FAILED;
            break;
          }
          cur_file_ofs += read_buf_avail;
          out_buf_ofs += read_buf_avail;
          comp_remaining -= read_buf_avail;
        }
    else {
      tinfl_decompressor inflator;
      inflator.m_state = (mz_uint32)0;
      inflator.m_num_bits = (mz_uint32)0;
      inflator.m_bit_buf = (tinfl_bit_buf_t)0;
      inflator.m_dist = (mz_uint32)0;
      inflator.m_counter = (mz_uint32)0;
      inflator.m_num_extra = (mz_uint32)0;
      inflator.m_dist_from_out_buf_start = (size_t)0;
      pWrite_buf = (*(pZip->m_pAlloc))(pZip->m_pAlloc_opaque,(size_t)1,
                                       (size_t)32768);
      if ((void *)0 == pWrite_buf) {
        mz_zip_set_error(pZip,MZ_ZIP_ALLOC_FAILED);
        status = TINFL_STATUS_FAILED;
      }
      else 
        while (1) {
          {
            size_t in_buf_size;
            tinfl_status __attribute__((__visibility__("default"))) tmp_16;
            int tmp_15;
            mz_uint8 *pWrite_buf_cur =
              (mz_uint8 *)pWrite_buf + (out_buf_ofs & (unsigned long)(
                                        32768 - 1));
            size_t out_buf_size =
              (unsigned long)32768 - (out_buf_ofs & (unsigned long)(32768 - 1));
            if (! read_buf_avail) 
              if (! (pZip->m_pState)->m_pMem) {
                size_t tmp_14;
                if (read_buf_size < comp_remaining) read_buf_avail = read_buf_size;
                else read_buf_avail = comp_remaining;
                tmp_14 = (*(pZip->m_pRead))(pZip->m_pIO_opaque,cur_file_ofs,
                                            pRead_buf,read_buf_avail);
                ;
                if (tmp_14 != read_buf_avail) {
                  mz_zip_set_error(pZip,MZ_ZIP_FILE_READ_FAILED);
                  status = TINFL_STATUS_FAILED;
                  break;
                }
                cur_file_ofs += read_buf_avail;
                comp_remaining -= read_buf_avail;
                read_buf_ofs = (mz_uint64)0;
              }
            in_buf_size = read_buf_avail;
            if (comp_remaining) tmp_15 = TINFL_FLAG_HAS_MORE_INPUT;
            else tmp_15 = 0;
            ;
            ;
            ;
            tmp_16 = tinfl_decompress(& inflator,
                                      (mz_uint8 const *)pRead_buf + read_buf_ofs,
                                      & in_buf_size,(mz_uint8 *)pWrite_buf,
                                      pWrite_buf_cur,& out_buf_size,
                                      (mz_uint32)tmp_15);
            status = (int)tmp_16;
            read_buf_avail -= in_buf_size;
            read_buf_ofs += in_buf_size;
            if (out_buf_size) {
              size_t tmp_17;
              mz_ulong __attribute__((__visibility__("default"))) tmp_18;
              tmp_17 = (*pCallback)(pOpaque,out_buf_ofs,
                                    (void const *)pWrite_buf_cur,
                                    out_buf_size);
              ;
              if (tmp_17 != out_buf_size) {
                mz_zip_set_error(pZip,MZ_ZIP_WRITE_CALLBACK_FAILED);
                status = TINFL_STATUS_FAILED;
                break;
              }
              tmp_18 = mz_crc32((mz_ulong)file_crc32,
                                (unsigned char const *)pWrite_buf_cur,
                                out_buf_size);
              file_crc32 = (mz_uint32)tmp_18;
              out_buf_ofs += out_buf_size;
              ;
              if (out_buf_ofs > file_stat.m_uncomp_size) {
                mz_zip_set_error(pZip,MZ_ZIP_DECOMPRESSION_FAILED);
                status = TINFL_STATUS_FAILED;
                break;
              }
            }
          }
          if (! (status == TINFL_STATUS_NEEDS_MORE_INPUT)) 
            if (! (status == TINFL_STATUS_HAS_MORE_OUTPUT)) break;
        }
    }
  if (status == TINFL_STATUS_DONE) 
    if (! (flags & (unsigned int)MZ_ZIP_FLAG_COMPRESSED_DATA)) 
      if (out_buf_ofs != file_stat.m_uncomp_size) {
        mz_zip_set_error(pZip,MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE);
        status = TINFL_STATUS_FAILED;
      }
      else 
        if (file_crc32 != file_stat.m_crc32) {
          mz_zip_set_error(pZip,MZ_ZIP_DECOMPRESSION_FAILED);
          status = TINFL_STATUS_FAILED;
        }
  if (! (pZip->m_pState)->m_pMem) (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,
                                                     pRead_buf);
  if (pWrite_buf) (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,pWrite_buf);
  __retres = (mz_bool __attribute__((__visibility__("default"))))(status == TINFL_STATUS_DONE);
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_extract_file_to_callback
(mz_zip_archive *pZip, char const *pFilename,
 size_t (*pCallback)(void *pOpaque, mz_uint64 file_ofs, void const *pBuf,
                     size_t n),
 void *pOpaque, mz_uint flags)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_uint32 file_index;
  mz_bool __attribute__((__visibility__("default"))) tmp;
  mz_bool __attribute__((__visibility__("default"))) tmp_0;
  tmp = mz_zip_reader_locate_file_v2(pZip,pFilename,(char const *)0,flags,
                                     & file_index);
  if (! tmp) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  tmp_0 = mz_zip_reader_extract_to_callback(pZip,file_index,pCallback,
                                            pOpaque,flags);
  __retres = tmp_0;
  return_label: return __retres;
}

mz_zip_reader_extract_iter_state __attribute__((__visibility__("default"))) *mz_zip_reader_extract_iter_new
(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags)
{
  mz_zip_reader_extract_iter_state __attribute__((__visibility__("default"))) *__retres;
  mz_zip_reader_extract_iter_state *pState;
  mz_uint32 local_header_u32[(((unsigned long)MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32)) - (unsigned long)1) / sizeof(mz_uint32)];
  mz_bool __attribute__((__visibility__("default"))) tmp_0;
  size_t tmp_1;
  mz_uint8 *pLocal_header = (mz_uint8 *)(local_header_u32);
  if (! pZip) {
    __retres = (mz_zip_reader_extract_iter_state __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  else 
    if (! pZip->m_pState) {
      __retres = (mz_zip_reader_extract_iter_state __attribute__((__visibility__("default"))) *)0;
      goto return_label;
    }
  pState = (mz_zip_reader_extract_iter_state *)(*(pZip->m_pAlloc))(pZip->m_pAlloc_opaque,
                                                                   (size_t)1,
                                                                   sizeof(mz_zip_reader_extract_iter_state));
  if (! pState) {
    mz_zip_set_error(pZip,MZ_ZIP_ALLOC_FAILED);
    __retres = (mz_zip_reader_extract_iter_state __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  tmp_0 = mz_zip_reader_file_stat(pZip,file_index,& pState->file_stat);
  if (! tmp_0) {
    (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,(void *)pState);
    __retres = (mz_zip_reader_extract_iter_state __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  if ((int)pState->file_stat.m_bit_flag & ((MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION) | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG)) {
    mz_zip_set_error(pZip,MZ_ZIP_UNSUPPORTED_ENCRYPTION);
    (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,(void *)pState);
    __retres = (mz_zip_reader_extract_iter_state __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  if (! (flags & (unsigned int)MZ_ZIP_FLAG_COMPRESSED_DATA)) 
    if ((int)pState->file_stat.m_method != 0) 
      if ((int)pState->file_stat.m_method != 8) {
        mz_zip_set_error(pZip,MZ_ZIP_UNSUPPORTED_METHOD);
        (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,(void *)pState);
        __retres = (mz_zip_reader_extract_iter_state __attribute__((__visibility__("default"))) *)0;
        goto return_label;
      }
  pState->pZip = pZip;
  pState->flags = flags;
  pState->status = TINFL_STATUS_DONE;
  pState->file_crc32 = (mz_uint)0;
  pState->read_buf_ofs = (mz_uint64)0;
  pState->out_buf_ofs = (mz_uint64)0;
  pState->pRead_buf = (void *)0;
  pState->pWrite_buf = (void *)0;
  pState->out_blk_remain = (size_t)0;
  pState->cur_file_ofs = pState->file_stat.m_local_header_ofs;
  tmp_1 = (*(pZip->m_pRead))(pZip->m_pIO_opaque,pState->cur_file_ofs,
                             (void *)pLocal_header,
                             (size_t)MZ_ZIP_LOCAL_DIR_HEADER_SIZE);
  if (tmp_1 != (size_t)MZ_ZIP_LOCAL_DIR_HEADER_SIZE) {
    mz_zip_set_error(pZip,MZ_ZIP_FILE_READ_FAILED);
    (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,(void *)pState);
    __retres = (mz_zip_reader_extract_iter_state __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  if (*((mz_uint32 const *)pLocal_header) != (mz_uint32)MZ_ZIP_LOCAL_DIR_HEADER_SIG) {
    mz_zip_set_error(pZip,MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
    (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,(void *)pState);
    __retres = (mz_zip_reader_extract_iter_state __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  pState->cur_file_ofs += (mz_uint64)((MZ_ZIP_LOCAL_DIR_HEADER_SIZE + (int)*((mz_uint16 const *)(
                                       pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS))) + (int)*((mz_uint16 const *)(
                                      pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS)));
  if (pState->cur_file_ofs + pState->file_stat.m_comp_size > pZip->m_archive_size) {
    mz_zip_set_error(pZip,MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
    (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,(void *)pState);
    __retres = (mz_zip_reader_extract_iter_state __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  if ((pZip->m_pState)->m_pMem) {
    mz_uint64 tmp_2;
    pState->pRead_buf = (void *)((mz_uint8 *)(pZip->m_pState)->m_pMem + pState->cur_file_ofs);
    tmp_2 = pState->file_stat.m_comp_size;
    pState->read_buf_avail = tmp_2;
    pState->read_buf_size = tmp_2;
    pState->comp_remaining = pState->file_stat.m_comp_size;
  }
  else {
    if (flags & (unsigned int)MZ_ZIP_FLAG_COMPRESSED_DATA) goto _LOR;
    else 
      if (! pState->file_stat.m_method) _LOR:
                                        pState->read_buf_size = (mz_uint64)0;
      else {
        void *tmp_3;
        if (pState->file_stat.m_comp_size < (mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE) 
          pState->read_buf_size = pState->file_stat.m_comp_size;
        else pState->read_buf_size = (mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE;
        tmp_3 = (*(pZip->m_pAlloc))(pZip->m_pAlloc_opaque,(size_t)1,
                                    pState->read_buf_size);
        pState->pRead_buf = tmp_3;
        if ((void *)0 == tmp_3) {
          mz_zip_set_error(pZip,MZ_ZIP_ALLOC_FAILED);
          (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,(void *)pState);
          __retres = (mz_zip_reader_extract_iter_state __attribute__((
          __visibility__("default"))) *)0;
          goto return_label;
        }
      }
    pState->read_buf_avail = (mz_uint64)0;
    pState->comp_remaining = pState->file_stat.m_comp_size;
  }
  if (! (flags & (unsigned int)MZ_ZIP_FLAG_COMPRESSED_DATA)) 
    if (! (! pState->file_stat.m_method)) {
      void *tmp_4;
      pState->inflator.m_state = (mz_uint32)0;
      pState->inflator.m_num_bits = (mz_uint32)0;
      pState->inflator.m_bit_buf = (tinfl_bit_buf_t)0;
      pState->inflator.m_dist = (mz_uint32)0;
      pState->inflator.m_counter = (mz_uint32)0;
      pState->inflator.m_num_extra = (mz_uint32)0;
      pState->inflator.m_dist_from_out_buf_start = (size_t)0;
      tmp_4 = (*(pZip->m_pAlloc))(pZip->m_pAlloc_opaque,(size_t)1,
                                  (size_t)32768);
      pState->pWrite_buf = tmp_4;
      if ((void *)0 == tmp_4) {
        mz_zip_set_error(pZip,MZ_ZIP_ALLOC_FAILED);
        if (pState->pRead_buf) (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,
                                                  pState->pRead_buf);
        (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,(void *)pState);
        __retres = (mz_zip_reader_extract_iter_state __attribute__((__visibility__("default"))) *)0;
        goto return_label;
      }
    }
  __retres = (mz_zip_reader_extract_iter_state __attribute__((__visibility__("default"))) *)pState;
  return_label: return __retres;
}

mz_zip_reader_extract_iter_state __attribute__((__visibility__("default"))) *mz_zip_reader_extract_file_iter_new
(mz_zip_archive *pZip, char const *pFilename, mz_uint flags)
{
  mz_zip_reader_extract_iter_state __attribute__((__visibility__("default"))) *__retres;
  mz_uint32 file_index;
  mz_bool __attribute__((__visibility__("default"))) tmp;
  mz_zip_reader_extract_iter_state __attribute__((__visibility__("default"))) *tmp_0;
  tmp = mz_zip_reader_locate_file_v2(pZip,pFilename,(char const *)0,flags,
                                     & file_index);
  if (! tmp) {
    __retres = (mz_zip_reader_extract_iter_state __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  tmp_0 = mz_zip_reader_extract_iter_new(pZip,file_index,flags);
  __retres = tmp_0;
  return_label: return __retres;
}

size_t __attribute__((__visibility__("default"))) mz_zip_reader_extract_iter_read
(mz_zip_reader_extract_iter_state *pState, void *pvBuf, size_t buf_size)
{
  size_t __attribute__((__visibility__("default"))) __retres;
  size_t copied_to_caller = (size_t)0;
  if (! pState) {
    __retres = (size_t __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  else 
    if (! pState->pZip) {
      __retres = (size_t __attribute__((__visibility__("default"))))0;
      goto return_label;
    }
    else 
      if (! (pState->pZip)->m_pState) {
        __retres = (size_t __attribute__((__visibility__("default"))))0;
        goto return_label;
      }
      else 
        if (! pvBuf) {
          __retres = (size_t __attribute__((__visibility__("default"))))0;
          goto return_label;
        }
  if (pState->flags & (unsigned int)MZ_ZIP_FLAG_COMPRESSED_DATA) goto _LOR;
  else 
    if (! pState->file_stat.m_method) {
      _LOR:
      {
        size_t tmp;
        if (buf_size < pState->comp_remaining) tmp = buf_size;
        else tmp = pState->comp_remaining;
        copied_to_caller = tmp;
        if (((pState->pZip)->m_pState)->m_pMem) {
          memcpy(pvBuf,(void const *)pState->pRead_buf,copied_to_caller);
          pState->pRead_buf = (void *)((mz_uint8 *)pState->pRead_buf + copied_to_caller);
        }
        else {
          size_t tmp_0;
          tmp_0 = (*((pState->pZip)->m_pRead))((pState->pZip)->m_pIO_opaque,
                                               pState->cur_file_ofs,pvBuf,
                                               copied_to_caller);
          ;
          if (tmp_0 != copied_to_caller) {
            mz_zip_set_error(pState->pZip,MZ_ZIP_FILE_READ_FAILED);
            pState->status = TINFL_STATUS_FAILED;
            copied_to_caller = (size_t)0;
          }
        }
        if (! (pState->flags & (unsigned int)MZ_ZIP_FLAG_COMPRESSED_DATA)) {
          mz_ulong __attribute__((__visibility__("default"))) tmp_1;
          tmp_1 = mz_crc32((mz_ulong)pState->file_crc32,
                           (mz_uint8 const *)pvBuf,copied_to_caller);
          pState->file_crc32 = (mz_uint32)tmp_1;
        }
        pState->cur_file_ofs += copied_to_caller;
        pState->out_buf_ofs += copied_to_caller;
        pState->comp_remaining -= copied_to_caller;
      }
    }
    else 
      while (1) {
        {
          size_t in_buf_size;
          mz_uint8 *pWrite_buf_cur =
            (mz_uint8 *)pState->pWrite_buf + (pState->out_buf_ofs & (unsigned long)(
                                              32768 - 1));
          size_t out_buf_size =
            (unsigned long)32768 - (pState->out_buf_ofs & (unsigned long)(
                                    32768 - 1));
          if (! pState->out_blk_remain) {
            tinfl_status __attribute__((__visibility__("default"))) tmp_4;
            int tmp_3;
            if (! pState->read_buf_avail) 
              if (! ((pState->pZip)->m_pState)->m_pMem) {
                size_t tmp_2;
                if (pState->read_buf_size < pState->comp_remaining) pState->read_buf_avail = pState->read_buf_size;
                else pState->read_buf_avail = pState->comp_remaining;
                tmp_2 = (*((pState->pZip)->m_pRead))((pState->pZip)->m_pIO_opaque,
                                                     pState->cur_file_ofs,
                                                     pState->pRead_buf,
                                                     pState->read_buf_avail);
                ;
                if (tmp_2 != pState->read_buf_avail) {
                  mz_zip_set_error(pState->pZip,MZ_ZIP_FILE_READ_FAILED);
                  pState->status = TINFL_STATUS_FAILED;
                  break;
                }
                pState->cur_file_ofs += pState->read_buf_avail;
                pState->comp_remaining -= pState->read_buf_avail;
                pState->read_buf_ofs = (mz_uint64)0;
              }
            in_buf_size = pState->read_buf_avail;
            if (pState->comp_remaining) tmp_3 = TINFL_FLAG_HAS_MORE_INPUT;
            else tmp_3 = 0;
            ;
            ;
            ;
            ;
            tmp_4 = tinfl_decompress(& pState->inflator,
                                     (mz_uint8 const *)pState->pRead_buf + pState->read_buf_ofs,
                                     & in_buf_size,
                                     (mz_uint8 *)pState->pWrite_buf,
                                     pWrite_buf_cur,& out_buf_size,
                                     (mz_uint32)tmp_3);
            pState->status = (int)tmp_4;
            pState->read_buf_avail -= in_buf_size;
            pState->read_buf_ofs += in_buf_size;
            pState->out_blk_remain = out_buf_size;
          }
          if (pState->out_blk_remain) {
            size_t tmp_5;
            mz_ulong __attribute__((__visibility__("default"))) tmp_6;
            if (buf_size - copied_to_caller < pState->out_blk_remain) 
              tmp_5 = buf_size - copied_to_caller;
            else tmp_5 = pState->out_blk_remain;
            size_t to_copy = tmp_5;
            memcpy((void *)((uint8_t *)pvBuf + copied_to_caller),
                   (void const *)pWrite_buf_cur,to_copy);
            tmp_6 = mz_crc32((mz_ulong)pState->file_crc32,
                             (unsigned char const *)pWrite_buf_cur,to_copy);
            pState->file_crc32 = (mz_uint32)tmp_6;
            pState->out_blk_remain -= to_copy;
            pState->out_buf_ofs += to_copy;
            ;
            if (pState->out_buf_ofs > pState->file_stat.m_uncomp_size) {
              mz_zip_set_error(pState->pZip,MZ_ZIP_DECOMPRESSION_FAILED);
              pState->status = TINFL_STATUS_FAILED;
              break;
            }
            copied_to_caller += to_copy;
          }
        }
        if (copied_to_caller < buf_size) {
          if (! (pState->status == TINFL_STATUS_NEEDS_MORE_INPUT)) 
            if (! (pState->status == TINFL_STATUS_HAS_MORE_OUTPUT)) break;
        }
        else break;
      }
  __retres = (size_t __attribute__((__visibility__("default"))))copied_to_caller;
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_extract_iter_free
(mz_zip_reader_extract_iter_state *pState)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  int status;
  if (! pState) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  else 
    if (! pState->pZip) {
      __retres = (mz_bool __attribute__((__visibility__("default"))))0;
      goto return_label;
    }
    else 
      if (! (pState->pZip)->m_pState) {
        __retres = (mz_bool __attribute__((__visibility__("default"))))0;
        goto return_label;
      }
  if (pState->status == TINFL_STATUS_DONE) 
    if (! (pState->flags & (unsigned int)MZ_ZIP_FLAG_COMPRESSED_DATA)) 
      if (pState->out_buf_ofs != pState->file_stat.m_uncomp_size) {
        mz_zip_set_error(pState->pZip,MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE);
        pState->status = TINFL_STATUS_FAILED;
      }
      else 
        if (pState->file_crc32 != pState->file_stat.m_crc32) {
          mz_zip_set_error(pState->pZip,MZ_ZIP_DECOMPRESSION_FAILED);
          pState->status = TINFL_STATUS_FAILED;
        }
  if (! ((pState->pZip)->m_pState)->m_pMem) (*((pState->pZip)->m_pFree))
                                            ((pState->pZip)->m_pAlloc_opaque,
                                             pState->pRead_buf);
  if (pState->pWrite_buf) (*((pState->pZip)->m_pFree))((pState->pZip)->m_pAlloc_opaque,
                                                       pState->pWrite_buf);
  status = pState->status;
  (*((pState->pZip)->m_pFree))((pState->pZip)->m_pAlloc_opaque,
                               (void *)pState);
  __retres = (mz_bool __attribute__((__visibility__("default"))))(status == TINFL_STATUS_DONE);
  return_label: return __retres;
}

static size_t mz_zip_file_write_callback(void *pOpaque, mz_uint64 ofs,
                                         void const *pBuf, size_t n)
{
  size_t tmp;
  tmp = fwrite(pBuf,(size_t)1,n,(FILE *)pOpaque);
  return tmp;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_extract_to_file
(mz_zip_archive *pZip, mz_uint file_index, char const *pDst_filename,
 mz_uint flags)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_bool status;
  mz_zip_archive_file_stat file_stat;
  FILE *pFile;
  mz_bool __attribute__((__visibility__("default"))) tmp;
  int tmp_2;
  tmp = mz_zip_reader_file_stat(pZip,file_index,& file_stat);
  if (! tmp) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  if (file_stat.m_is_directory) goto _LOR;
  else 
    if (! file_stat.m_is_supported) {
      mz_bool __attribute__((__visibility__("default"))) tmp_0;
      _LOR:
      tmp_0 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_UNSUPPORTED_FEATURE);
      __retres = tmp_0;
      goto return_label;
    }
  pFile = fopen(pDst_filename,"wb");
  if (! pFile) {
    mz_bool __attribute__((__visibility__("default"))) tmp_1;
    tmp_1 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_FILE_OPEN_FAILED);
    __retres = tmp_1;
    goto return_label;
  }
  status = (mz_bool)mz_zip_reader_extract_to_callback(pZip,file_index,
                                                      & mz_zip_file_write_callback,
                                                      (void *)pFile,flags);
  tmp_2 = fclose(pFile);
  if (tmp_2 == -1) {
    if (status) mz_zip_set_error(pZip,MZ_ZIP_FILE_CLOSE_FAILED);
    status = 0;
  }
  if (status) mz_zip_set_file_times(pDst_filename,file_stat.m_time,
                                    file_stat.m_time);
  __retres = (mz_bool __attribute__((__visibility__("default"))))status;
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_extract_file_to_file
(mz_zip_archive *pZip, char const *pArchive_filename,
 char const *pDst_filename, mz_uint flags)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_uint32 file_index;
  mz_bool __attribute__((__visibility__("default"))) tmp;
  mz_bool __attribute__((__visibility__("default"))) tmp_0;
  tmp = mz_zip_reader_locate_file_v2(pZip,pArchive_filename,(char const *)0,
                                     flags,& file_index);
  if (! tmp) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  tmp_0 = mz_zip_reader_extract_to_file(pZip,file_index,pDst_filename,flags);
  __retres = tmp_0;
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_extract_to_cfile
(mz_zip_archive *pZip, mz_uint file_index, FILE *pFile, mz_uint flags)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_zip_archive_file_stat file_stat;
  mz_bool __attribute__((__visibility__("default"))) tmp;
  mz_bool __attribute__((__visibility__("default"))) tmp_1;
  tmp = mz_zip_reader_file_stat(pZip,file_index,& file_stat);
  if (! tmp) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  if (file_stat.m_is_directory) goto _LOR;
  else 
    if (! file_stat.m_is_supported) {
      mz_bool __attribute__((__visibility__("default"))) tmp_0;
      _LOR:
      tmp_0 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_UNSUPPORTED_FEATURE);
      __retres = tmp_0;
      goto return_label;
    }
  tmp_1 = mz_zip_reader_extract_to_callback(pZip,file_index,
                                            & mz_zip_file_write_callback,
                                            (void *)pFile,flags);
  __retres = tmp_1;
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_extract_file_to_cfile
(mz_zip_archive *pZip, char const *pArchive_filename, FILE *pFile,
 mz_uint flags)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_uint32 file_index;
  mz_bool __attribute__((__visibility__("default"))) tmp;
  mz_bool __attribute__((__visibility__("default"))) tmp_0;
  tmp = mz_zip_reader_locate_file_v2(pZip,pArchive_filename,(char const *)0,
                                     flags,& file_index);
  if (! tmp) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  tmp_0 = mz_zip_reader_extract_to_cfile(pZip,file_index,pFile,flags);
  __retres = tmp_0;
  return_label: return __retres;
}

static size_t mz_zip_compute_crc32_callback(void *pOpaque,
                                            mz_uint64 file_ofs,
                                            void const *pBuf, size_t n)
{
  mz_ulong __attribute__((__visibility__("default"))) tmp;
  mz_uint32 *p = (mz_uint32 *)pOpaque;
  tmp = mz_crc32((mz_ulong)*p,(mz_uint8 const *)pBuf,n);
  *p = (mz_uint32)tmp;
  return n;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_validate_file
(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_zip_archive_file_stat file_stat;
  mz_zip_internal_state *pState;
  mz_uint8 const *pCentral_dir_header;
  mz_uint32 local_header_u32[(((unsigned long)MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32)) - (unsigned long)1) / sizeof(mz_uint32)];
  mz_uint32 local_header_filename_len;
  mz_uint32 local_header_extra_len;
  mz_uint32 local_header_crc32;
  mz_uint64 local_header_comp_size;
  mz_uint64 local_header_uncomp_size;
  mz_bool has_data_descriptor;
  mz_uint32 local_header_bit_flags;
  mz_zip_array file_data_array;
  mz_bool tmp_1;
  size_t tmp_6;
  size_t tmp_9;
  mz_bool tmp_12;
  mz_uint32 tmp_11;
  mz_bool found_zip64_ext_data_in_cdir = 0;
  mz_bool found_zip64_ext_data_in_ldir = 0;
  mz_uint8 *pLocal_header = (mz_uint8 *)(local_header_u32);
  mz_uint64 local_header_ofs = (mz_uint64)0;
  mz_uint32 uncomp_crc32 = (mz_uint32)0;
  mz_zip_array_init(& file_data_array,(mz_uint32)1);
  if (! pZip) goto _LOR;
  else 
    if (! pZip->m_pState) goto _LOR;
    else 
      if (! pZip->m_pAlloc) goto _LOR;
      else 
        if (! pZip->m_pFree) goto _LOR;
        else 
          if (! pZip->m_pRead) {
            mz_bool __attribute__((__visibility__("default"))) tmp;
            _LOR:
            tmp = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
            (pZip,MZ_ZIP_INVALID_PARAMETER);
            __retres = tmp;
            goto return_label;
          }
  if (file_index > pZip->m_total_files) {
    mz_bool __attribute__((__visibility__("default"))) tmp_0;
    tmp_0 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_INVALID_PARAMETER);
    __retres = tmp_0;
    goto return_label;
  }
  pState = pZip->m_pState;
  pCentral_dir_header = mz_zip_get_cdh(pZip,file_index);
  tmp_1 = mz_zip_file_stat_internal(pZip,file_index,pCentral_dir_header,
                                    & file_stat,
                                    & found_zip64_ext_data_in_cdir);
  if (! tmp_1) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  if (file_stat.m_is_directory) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))1;
    goto return_label;
  }
  else 
    if (! file_stat.m_uncomp_size) {
      __retres = (mz_bool __attribute__((__visibility__("default"))))1;
      goto return_label;
    }
  if (file_stat.m_is_encrypted) {
    mz_bool __attribute__((__visibility__("default"))) tmp_2;
    tmp_2 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_UNSUPPORTED_ENCRYPTION);
    __retres = tmp_2;
    goto return_label;
  }
  if ((int)file_stat.m_method != 0) 
    if ((int)file_stat.m_method != 8) {
      mz_bool __attribute__((__visibility__("default"))) tmp_3;
      tmp_3 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_UNSUPPORTED_METHOD);
      __retres = tmp_3;
      goto return_label;
    }
  if (! file_stat.m_is_supported) {
    mz_bool __attribute__((__visibility__("default"))) tmp_4;
    tmp_4 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_UNSUPPORTED_FEATURE);
    __retres = tmp_4;
    goto return_label;
  }
  local_header_ofs = file_stat.m_local_header_ofs;
  tmp_6 = (*(pZip->m_pRead))(pZip->m_pIO_opaque,local_header_ofs,
                             (void *)pLocal_header,
                             (size_t)MZ_ZIP_LOCAL_DIR_HEADER_SIZE);
  if (tmp_6 != (size_t)MZ_ZIP_LOCAL_DIR_HEADER_SIZE) {
    mz_bool __attribute__((__visibility__("default"))) tmp_5;
    tmp_5 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_FILE_READ_FAILED);
    __retres = tmp_5;
    goto return_label;
  }
  if (*((mz_uint32 const *)pLocal_header) != (mz_uint32)MZ_ZIP_LOCAL_DIR_HEADER_SIG) {
    mz_bool __attribute__((__visibility__("default"))) tmp_7;
    tmp_7 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
    __retres = tmp_7;
    goto return_label;
  }
  local_header_filename_len = (mz_uint32)*((mz_uint16 const *)(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS));
  local_header_extra_len = (mz_uint32)*((mz_uint16 const *)(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS));
  local_header_comp_size = (mz_uint64)*((mz_uint32 const *)(pLocal_header + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS));
  local_header_uncomp_size = (mz_uint64)*((mz_uint32 const *)(pLocal_header + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS));
  local_header_crc32 = *((mz_uint32 const *)(pLocal_header + MZ_ZIP_LDH_CRC32_OFS));
  local_header_bit_flags = (mz_uint32)*((mz_uint16 const *)(pLocal_header + MZ_ZIP_LDH_BIT_FLAG_OFS));
  has_data_descriptor = (local_header_bit_flags & (unsigned int)8) != (unsigned int)0;
  tmp_9 = strlen((char const *)(file_stat.m_filename));
  ;
  if ((size_t)local_header_filename_len != tmp_9) {
    mz_bool __attribute__((__visibility__("default"))) tmp_8;
    tmp_8 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
    __retres = tmp_8;
    goto return_label;
  }
  if ((((local_header_ofs + (mz_uint64)MZ_ZIP_LOCAL_DIR_HEADER_SIZE) + (mz_uint64)local_header_filename_len) + (mz_uint64)local_header_extra_len) + file_stat.m_comp_size > pZip->m_archive_size) {
    mz_bool __attribute__((__visibility__("default"))) tmp_10;
    tmp_10 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
    __retres = tmp_10;
    goto return_label;
  }
  if (local_header_filename_len > local_header_extra_len) tmp_11 = local_header_filename_len;
  else tmp_11 = local_header_extra_len;
  ;
  tmp_12 = mz_zip_array_resize(pZip,& file_data_array,(size_t)tmp_11,
                               (mz_uint)0);
  if (! tmp_12) {
    mz_zip_set_error(pZip,MZ_ZIP_ALLOC_FAILED);
    goto handle_failure;
  }
  if (local_header_filename_len) {
    size_t tmp_13;
    int tmp_14;
    tmp_13 = (*(pZip->m_pRead))(pZip->m_pIO_opaque,
                                local_header_ofs + (mz_uint64)MZ_ZIP_LOCAL_DIR_HEADER_SIZE,
                                file_data_array.m_p,
                                (size_t)local_header_filename_len);
    ;
    if (tmp_13 != (size_t)local_header_filename_len) {
      mz_zip_set_error(pZip,MZ_ZIP_FILE_READ_FAILED);
      goto handle_failure;
    }
    tmp_14 = memcmp((void const *)(file_stat.m_filename),
                    (void const *)file_data_array.m_p,
                    (size_t)local_header_filename_len);
    if (tmp_14 != 0) {
      mz_zip_set_error(pZip,MZ_ZIP_VALIDATION_FAILED);
      goto handle_failure;
    }
  }
  if (local_header_extra_len) 
    if (local_header_comp_size == (mz_uint64)0xFFFFFFFFU) goto _LOR_0;
    else 
      if (local_header_uncomp_size == (mz_uint64)0xFFFFFFFFU) {
        _LOR_0:
        {
          size_t tmp_15;
          mz_uint32 extra_size_remaining = local_header_extra_len;
          mz_uint8 const *pExtra_data =
            (mz_uint8 const *)file_data_array.m_p;
          tmp_15 = (*(pZip->m_pRead))(pZip->m_pIO_opaque,
                                      (local_header_ofs + (mz_uint64)MZ_ZIP_LOCAL_DIR_HEADER_SIZE) + (mz_uint64)local_header_filename_len,
                                      file_data_array.m_p,
                                      (size_t)local_header_extra_len);
          ;
          if (tmp_15 != (size_t)local_header_extra_len) {
            mz_zip_set_error(pZip,MZ_ZIP_FILE_READ_FAILED);
            goto handle_failure;
          }
          while (1) {
            {
              mz_uint32 field_id;
              mz_uint32 field_data_size;
              mz_uint32 field_total_size;
              if ((unsigned long)extra_size_remaining < sizeof(mz_uint16) * (unsigned long)2) {
                mz_zip_set_error(pZip,MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                goto handle_failure;
              }
              field_id = (mz_uint32)*((mz_uint16 const *)pExtra_data);
              field_data_size = (mz_uint32)*((mz_uint16 const *)(pExtra_data + sizeof(mz_uint16)));
              field_total_size = (mz_uint32)((unsigned long)field_data_size + 
                                             sizeof(mz_uint16) * (unsigned long)2);
              if (field_total_size > extra_size_remaining) {
                mz_zip_set_error(pZip,MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                goto handle_failure;
              }
              if (field_id == (mz_uint32)MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID) {
                mz_uint8 const *pSrc_field_data =
                  pExtra_data + sizeof(mz_uint32);
                if ((unsigned long)field_data_size < sizeof(mz_uint64) * (unsigned long)2) {
                  mz_zip_set_error(pZip,MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                  goto handle_failure;
                }
                local_header_uncomp_size = (mz_uint64)*((mz_uint32 const *)pSrc_field_data) | (
                                           (mz_uint64)*((mz_uint32 const *)(
                                           pSrc_field_data + sizeof(mz_uint32))) << 32U);
                local_header_comp_size = (mz_uint64)*((mz_uint32 const *)(
                                         pSrc_field_data + sizeof(mz_uint64))) | (
                                         (mz_uint64)*((mz_uint32 const *)(
                                         (pSrc_field_data + sizeof(mz_uint64)) + sizeof(mz_uint32))) << 32U);
                found_zip64_ext_data_in_ldir = 1;
                break;
              }
              pExtra_data += field_total_size;
              extra_size_remaining -= field_total_size;
            }
            if (! extra_size_remaining) break;
          }
        }
      }
  if (has_data_descriptor) {
    if (! local_header_comp_size) {
      if (! local_header_crc32) {
        mz_uint8 descriptor_buf[32];
        mz_bool has_id;
        mz_uint8 const *pSrc;
        mz_uint32 file_crc32;
        int tmp_16;
        size_t tmp_17;
        mz_uint64 comp_size = (mz_uint64)0;
        mz_uint64 uncomp_size = (mz_uint64)0;
        if (pState->m_zip64) tmp_16 = 6;
        else 
          if (found_zip64_ext_data_in_ldir) tmp_16 = 6; else tmp_16 = 4;
        mz_uint32 num_descriptor_uint32s = (mz_uint32)tmp_16;
        tmp_17 = (*(pZip->m_pRead))(pZip->m_pIO_opaque,
                                    (((local_header_ofs + (mz_uint64)MZ_ZIP_LOCAL_DIR_HEADER_SIZE) + (mz_uint64)local_header_filename_len) + (mz_uint64)local_header_extra_len) + file_stat.m_comp_size,
                                    (void *)(descriptor_buf),
                                    sizeof(mz_uint32) * (unsigned long)num_descriptor_uint32s);
        ;
        if (tmp_17 != sizeof(mz_uint32) * (unsigned long)num_descriptor_uint32s) {
          mz_zip_set_error(pZip,MZ_ZIP_FILE_READ_FAILED);
          goto handle_failure;
        }
        has_id = *((mz_uint32 const *)(descriptor_buf)) == (mz_uint32)MZ_ZIP_DATA_DESCRIPTOR_ID;
        if (has_id) pSrc = (mz_uint8 const *)(& descriptor_buf[sizeof(mz_uint32)]);
        else pSrc = (mz_uint8 const *)(descriptor_buf);
        file_crc32 = *((mz_uint32 const *)pSrc);
        if (pState->m_zip64) goto _LOR_1;
        else 
          if (found_zip64_ext_data_in_ldir) {
            _LOR_1:
            {
              comp_size = (mz_uint64)*((mz_uint32 const *)(pSrc + sizeof(mz_uint32))) | (
                          (mz_uint64)*((mz_uint32 const *)((pSrc + sizeof(mz_uint32)) + sizeof(mz_uint32))) << 32U);
              uncomp_size = (mz_uint64)*((mz_uint32 const *)((pSrc + sizeof(mz_uint32)) + sizeof(mz_uint64))) | (
                            (mz_uint64)*((mz_uint32 const *)(((pSrc + sizeof(mz_uint32)) + sizeof(mz_uint64)) + sizeof(mz_uint32))) << 32U);
            }
          }
          else {
            comp_size = (mz_uint64)*((mz_uint32 const *)(pSrc + sizeof(mz_uint32)));
            uncomp_size = (mz_uint64)*((mz_uint32 const *)((pSrc + sizeof(mz_uint32)) + sizeof(mz_uint32)));
          }
        if (file_crc32 != file_stat.m_crc32) goto _LOR_2;
        else 
          if (comp_size != file_stat.m_comp_size) goto _LOR_2;
          else 
            if (uncomp_size != file_stat.m_uncomp_size) {
              _LOR_2:
              {
                mz_zip_set_error(pZip,MZ_ZIP_VALIDATION_FAILED);
                goto handle_failure;
              }
            }
      }
      else goto _LAND_0;
    }
    else goto _LAND_0;
  }
  else 
    _LAND_0:
    if (local_header_crc32 != file_stat.m_crc32) goto _LOR_3;
    else 
      if (local_header_comp_size != file_stat.m_comp_size) goto _LOR_3;
      else 
        if (local_header_uncomp_size != file_stat.m_uncomp_size) {
          _LOR_3:
          {
            mz_zip_set_error(pZip,MZ_ZIP_VALIDATION_FAILED);
            goto handle_failure;
          }
        }
  mz_zip_array_clear(pZip,& file_data_array);
  if ((flags & (unsigned int)MZ_ZIP_FLAG_VALIDATE_HEADERS_ONLY) == (unsigned int)0) {
    mz_bool __attribute__((__visibility__("default"))) tmp_18;
    tmp_18 = mz_zip_reader_extract_to_callback(pZip,file_index,
                                               & mz_zip_compute_crc32_callback,
                                               (void *)(& uncomp_crc32),
                                               (mz_uint)0);
    if (! tmp_18) {
      __retres = (mz_bool __attribute__((__visibility__("default"))))0;
      goto return_label;
    }
    if (uncomp_crc32 != file_stat.m_crc32) {
      mz_zip_set_error(pZip,MZ_ZIP_VALIDATION_FAILED);
      __retres = (mz_bool __attribute__((__visibility__("default"))))0;
      goto return_label;
    }
  }
  __retres = (mz_bool __attribute__((__visibility__("default"))))1;
  goto return_label;
  handle_failure: mz_zip_array_clear(pZip,& file_data_array);
  __retres = (mz_bool __attribute__((__visibility__("default"))))0;
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_validate_archive
(mz_zip_archive *pZip, mz_uint flags)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_zip_internal_state *pState;
  uint32_t i;
  if (! pZip) goto _LOR;
  else 
    if (! pZip->m_pState) goto _LOR;
    else 
      if (! pZip->m_pAlloc) goto _LOR;
      else 
        if (! pZip->m_pFree) goto _LOR;
        else 
          if (! pZip->m_pRead) {
            mz_bool __attribute__((__visibility__("default"))) tmp;
            _LOR:
            tmp = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
            (pZip,MZ_ZIP_INVALID_PARAMETER);
            __retres = tmp;
            goto return_label;
          }
  pState = pZip->m_pState;
  if (! pState->m_zip64) {
    if (pZip->m_total_files > 0xFFFFU) {
      mz_bool __attribute__((__visibility__("default"))) tmp_0;
      tmp_0 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_ARCHIVE_TOO_LARGE);
      __retres = tmp_0;
      goto return_label;
    }
    if (pZip->m_archive_size > (mz_uint64)0xFFFFFFFFU) {
      mz_bool __attribute__((__visibility__("default"))) tmp_1;
      tmp_1 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_ARCHIVE_TOO_LARGE);
      __retres = tmp_1;
      goto return_label;
    }
  }
  else {
    if (pZip->m_total_files >= 0xFFFFFFFFU) {
      mz_bool __attribute__((__visibility__("default"))) tmp_2;
      tmp_2 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_ARCHIVE_TOO_LARGE);
      __retres = tmp_2;
      goto return_label;
    }
    if (pState->m_central_dir.m_size >= (size_t)0xFFFFFFFFU) {
      mz_bool __attribute__((__visibility__("default"))) tmp_3;
      tmp_3 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_ARCHIVE_TOO_LARGE);
      __retres = tmp_3;
      goto return_label;
    }
  }
  i = (uint32_t)0;
  while (i < pZip->m_total_files) {
    {
      mz_bool __attribute__((__visibility__("default"))) tmp_7;
      if ((unsigned int)MZ_ZIP_FLAG_VALIDATE_LOCATE_FILE_FLAG & flags) {
        mz_uint32 found_index;
        mz_zip_archive_file_stat stat_0;
        mz_bool __attribute__((__visibility__("default"))) tmp_4;
        mz_bool __attribute__((__visibility__("default"))) tmp_5;
        tmp_4 = mz_zip_reader_file_stat(pZip,i,& stat_0);
        if (! tmp_4) {
          __retres = (mz_bool __attribute__((__visibility__("default"))))0;
          goto return_label;
        }
        tmp_5 = mz_zip_reader_locate_file_v2(pZip,
                                             (char const *)(stat_0.m_filename),
                                             (char const *)0,(mz_uint)0,
                                             & found_index);
        if (! tmp_5) {
          __retres = (mz_bool __attribute__((__visibility__("default"))))0;
          goto return_label;
        }
        if (found_index != i) {
          mz_bool __attribute__((__visibility__("default"))) tmp_6;
          tmp_6 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
          (pZip,MZ_ZIP_VALIDATION_FAILED);
          __retres = tmp_6;
          goto return_label;
        }
      }
      tmp_7 = mz_zip_validate_file(pZip,i,flags);
      if (! tmp_7) {
        __retres = (mz_bool __attribute__((__visibility__("default"))))0;
        goto return_label;
      }
    }
    i ++;
  }
  __retres = (mz_bool __attribute__((__visibility__("default"))))1;
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_validate_mem_archive
(void const *pMem, size_t size, mz_uint flags, mz_zip_error *pErr)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_zip_archive zip;
  mz_bool __attribute__((__visibility__("default"))) tmp;
  mz_bool __attribute__((__visibility__("default"))) tmp_0;
  mz_bool tmp_1;
  mz_bool success = 1;
  mz_zip_error actual_err = MZ_ZIP_NO_ERROR;
  if (! pMem) goto _LOR;
  else 
    if (! size) {
      _LOR:
      {
        if (pErr) *pErr = MZ_ZIP_INVALID_PARAMETER;
        __retres = (mz_bool __attribute__((__visibility__("default"))))0;
        goto return_label;
      }
    }
  mz_zip_zero_struct(& zip);
  tmp = mz_zip_reader_init_mem(& zip,pMem,size,flags);
  if (! tmp) {
    if (pErr) *pErr = zip.m_last_error;
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  tmp_0 = mz_zip_validate_archive(& zip,flags);
  if (! tmp_0) {
    actual_err = zip.m_last_error;
    success = 0;
  }
  tmp_1 = mz_zip_reader_end_internal(& zip,success);
  if (! tmp_1) {
    if (! actual_err) actual_err = zip.m_last_error;
    success = 0;
  }
  if (pErr) *pErr = actual_err;
  __retres = (mz_bool __attribute__((__visibility__("default"))))success;
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_validate_file_archive
(char const *pFilename, mz_uint flags, mz_zip_error *pErr)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_zip_archive zip;
  mz_bool __attribute__((__visibility__("default"))) tmp;
  mz_bool __attribute__((__visibility__("default"))) tmp_0;
  mz_bool tmp_1;
  mz_bool success = 1;
  mz_zip_error actual_err = MZ_ZIP_NO_ERROR;
  if (! pFilename) {
    if (pErr) *pErr = MZ_ZIP_INVALID_PARAMETER;
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  mz_zip_zero_struct(& zip);
  tmp = mz_zip_reader_init_file_v2(& zip,pFilename,flags,(mz_uint64)0,
                                   (mz_uint64)0);
  if (! tmp) {
    if (pErr) *pErr = zip.m_last_error;
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  tmp_0 = mz_zip_validate_archive(& zip,flags);
  if (! tmp_0) {
    actual_err = zip.m_last_error;
    success = 0;
  }
  tmp_1 = mz_zip_reader_end_internal(& zip,success);
  if (! tmp_1) {
    if (! actual_err) actual_err = zip.m_last_error;
    success = 0;
  }
  if (pErr) *pErr = actual_err;
  __retres = (mz_bool __attribute__((__visibility__("default"))))success;
  return_label: return __retres;
}

__inline static void ( __attribute__((__always_inline__)) mz_write_le16)
(mz_uint8 *p, mz_uint16 v)
{
  *(p + 0) = (mz_uint8)v;
  *(p + 1) = (mz_uint8)((int)v >> 8);
  return;
}

__inline static void ( __attribute__((__always_inline__)) mz_write_le32)
(mz_uint8 *p, mz_uint32 v)
{
  *(p + 0) = (mz_uint8)v;
  *(p + 1) = (mz_uint8)(v >> 8);
  *(p + 2) = (mz_uint8)(v >> 16);
  *(p + 3) = (mz_uint8)(v >> 24);
  return;
}

__inline static void ( __attribute__((__always_inline__)) mz_write_le64)
(mz_uint8 *p, mz_uint64 v)
{
  mz_write_le32(p,(mz_uint32)v);
  mz_write_le32(p + sizeof(mz_uint32),(mz_uint32)(v >> 32));
  return;
}

static size_t mz_zip_heap_write_func(void *pOpaque, mz_uint64 file_ofs,
                                     void const *pBuf, size_t n)
{
  size_t __retres;
  mz_uint64 tmp;
  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
  mz_zip_internal_state *pState = pZip->m_pState;
  if (file_ofs + n > pState->m_mem_size) tmp = file_ofs + n;
  else tmp = pState->m_mem_size;
  mz_uint64 new_size = tmp;
  if (! n) {
    __retres = (size_t)0;
    goto return_label;
  }
  if (sizeof(size_t) == sizeof(mz_uint32)) 
    if (new_size > (mz_uint64)0x7FFFFFFF) {
      mz_zip_set_error(pZip,MZ_ZIP_FILE_TOO_LARGE);
      __retres = (size_t)0;
      goto return_label;
    }
  if (new_size > pState->m_mem_capacity) {
    void *pNew_block;
    size_t tmp_0;
    if ((size_t)64 > pState->m_mem_capacity) tmp_0 = (size_t)64;
    else tmp_0 = pState->m_mem_capacity;
    size_t new_capacity = tmp_0;
    while (new_capacity < new_size) new_capacity *= (size_t)2;
    pNew_block = (*(pZip->m_pRealloc))(pZip->m_pAlloc_opaque,pState->m_pMem,
                                       (size_t)1,new_capacity);
    if ((void *)0 == pNew_block) {
      mz_zip_set_error(pZip,MZ_ZIP_ALLOC_FAILED);
      __retres = (size_t)0;
      goto return_label;
    }
    pState->m_pMem = pNew_block;
    pState->m_mem_capacity = new_capacity;
  }
  memcpy((void *)((mz_uint8 *)pState->m_pMem + file_ofs),pBuf,n);
  pState->m_mem_size = new_size;
  __retres = n;
  return_label: return __retres;
}

static mz_bool mz_zip_writer_end_internal(mz_zip_archive *pZip,
                                          mz_bool set_last_error)
{
  mz_bool __retres;
  mz_zip_internal_state *pState;
  mz_bool status = 1;
  if (! pZip) goto _LOR;
  else 
    if (! pZip->m_pState) goto _LOR;
    else 
      if (! pZip->m_pAlloc) goto _LOR;
      else 
        if (! pZip->m_pFree) goto _LOR;
        else 
          if (pZip->m_zip_mode != (unsigned int)MZ_ZIP_MODE_WRITING) 
            if (pZip->m_zip_mode != (unsigned int)MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED) {
              _LOR:
              {
                if (set_last_error) mz_zip_set_error(pZip,
                                                     MZ_ZIP_INVALID_PARAMETER);
                __retres = 0;
                goto return_label;
              }
            }
  pState = pZip->m_pState;
  pZip->m_pState = (mz_zip_internal_state *)0;
  mz_zip_array_clear(pZip,& pState->m_central_dir);
  mz_zip_array_clear(pZip,& pState->m_central_dir_offsets);
  mz_zip_array_clear(pZip,& pState->m_sorted_central_dir_offsets);
  if (pState->m_pFile) {
    if (pZip->m_zip_type == (unsigned int)MZ_ZIP_TYPE_FILE) {
      int tmp;
      tmp = fclose(pState->m_pFile);
      if (tmp == -1) {
        if (set_last_error) mz_zip_set_error(pZip,MZ_ZIP_FILE_CLOSE_FAILED);
        status = 0;
      }
    }
    pState->m_pFile = (FILE *)0;
  }
  if (pZip->m_pWrite == & mz_zip_heap_write_func) 
    if (pState->m_pMem) {
      (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,pState->m_pMem);
      pState->m_pMem = (void *)0;
    }
  (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,(void *)pState);
  pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;
  __retres = status;
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_init_v2
(mz_zip_archive *pZip, mz_uint64 existing_size, mz_uint flags)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_zip_internal_state *tmp_3;
  mz_bool zip64 =
    (flags & (unsigned int)MZ_ZIP_FLAG_WRITE_ZIP64) != (unsigned int)0;
  if (! pZip) goto _LOR;
  else 
    if (pZip->m_pState) goto _LOR;
    else 
      if (! pZip->m_pWrite) goto _LOR;
      else 
        if (pZip->m_zip_mode != (unsigned int)MZ_ZIP_MODE_INVALID) {
          mz_bool __attribute__((__visibility__("default"))) tmp;
          _LOR:
          tmp = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
          (pZip,MZ_ZIP_INVALID_PARAMETER);
          __retres = tmp;
          goto return_label;
        }
  if (flags & (unsigned int)MZ_ZIP_FLAG_WRITE_ALLOW_READING) 
    if (! pZip->m_pRead) {
      mz_bool __attribute__((__visibility__("default"))) tmp_0;
      tmp_0 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_INVALID_PARAMETER);
      __retres = tmp_0;
      goto return_label;
    }
  if (pZip->m_file_offset_alignment) 
    if (pZip->m_file_offset_alignment & (pZip->m_file_offset_alignment - (mz_uint64)1)) {
      mz_bool __attribute__((__visibility__("default"))) tmp_1;
      tmp_1 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_INVALID_PARAMETER);
      __retres = tmp_1;
      goto return_label;
    }
  if (! pZip->m_pAlloc) pZip->m_pAlloc = (void *(*)(void *opaque,
                                                    size_t items, size_t size))(& miniz_def_alloc_func);
  if (! pZip->m_pFree) pZip->m_pFree = (void (*)(void *opaque, void *address))(& miniz_def_free_func);
  if (! pZip->m_pRealloc) pZip->m_pRealloc = (void *(*)(void *opaque,
                                                        void *address,
                                                        size_t items,
                                                        size_t size))(& miniz_def_realloc_func);
  pZip->m_archive_size = existing_size;
  pZip->m_central_directory_file_ofs = (mz_uint64)0;
  pZip->m_total_files = (mz_uint32)0;
  tmp_3 = (mz_zip_internal_state *)(*(pZip->m_pAlloc))(pZip->m_pAlloc_opaque,
                                                       (size_t)1,
                                                       sizeof(mz_zip_internal_state));
  pZip->m_pState = tmp_3;
  if ((mz_zip_internal_state *)0 == tmp_3) {
    mz_bool __attribute__((__visibility__("default"))) tmp_2;
    tmp_2 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_ALLOC_FAILED);
    __retres = tmp_2;
    goto return_label;
  }
  memset((void *)pZip->m_pState,0,sizeof(mz_zip_internal_state));
  (pZip->m_pState)->m_central_dir.m_element_size = (mz_uint)sizeof(mz_uint8);
  (pZip->m_pState)->m_central_dir_offsets.m_element_size = (mz_uint)sizeof(mz_uint32);
  (pZip->m_pState)->m_sorted_central_dir_offsets.m_element_size = (mz_uint)sizeof(mz_uint32);
  (pZip->m_pState)->m_zip64 = zip64;
  (pZip->m_pState)->m_zip64_has_extended_info_fields = zip64;
  pZip->m_zip_type = MZ_ZIP_TYPE_USER;
  pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;
  __retres = (mz_bool __attribute__((__visibility__("default"))))1;
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_init
(mz_zip_archive *pZip, mz_uint64 existing_size)
{
  mz_bool __attribute__((__visibility__("default"))) tmp;
  tmp = mz_zip_writer_init_v2(pZip,existing_size,(mz_uint)0);
  return tmp;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_init_heap_v2
(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning,
 size_t initial_allocation_size, mz_uint flags)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_bool __attribute__((__visibility__("default"))) tmp;
  pZip->m_pWrite = & mz_zip_heap_write_func;
  pZip->m_pNeeds_keepalive = (mz_bool (*)(void *pOpaque))0;
  if (flags & (unsigned int)MZ_ZIP_FLAG_WRITE_ALLOW_READING) pZip->m_pRead = & mz_zip_mem_read_func;
  pZip->m_pIO_opaque = (void *)pZip;
  tmp = mz_zip_writer_init_v2(pZip,size_to_reserve_at_beginning,flags);
  if (! tmp) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  pZip->m_zip_type = MZ_ZIP_TYPE_HEAP;
  if (initial_allocation_size > size_to_reserve_at_beginning) initial_allocation_size = initial_allocation_size;
  else initial_allocation_size = size_to_reserve_at_beginning;
  if ((size_t)0 != initial_allocation_size) {
    void *tmp_1;
    tmp_1 = (*(pZip->m_pAlloc))(pZip->m_pAlloc_opaque,(size_t)1,
                                initial_allocation_size);
    (pZip->m_pState)->m_pMem = tmp_1;
    if ((void *)0 == tmp_1) {
      mz_bool __attribute__((__visibility__("default"))) tmp_0;
      mz_zip_writer_end_internal(pZip,0);
      tmp_0 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_ALLOC_FAILED);
      __retres = tmp_0;
      goto return_label;
    }
    (pZip->m_pState)->m_mem_capacity = initial_allocation_size;
  }
  __retres = (mz_bool __attribute__((__visibility__("default"))))1;
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_init_heap
(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning,
 size_t initial_allocation_size)
{
  mz_bool __attribute__((__visibility__("default"))) tmp;
  tmp = mz_zip_writer_init_heap_v2(pZip,size_to_reserve_at_beginning,
                                   initial_allocation_size,(mz_uint)0);
  return tmp;
}

static size_t mz_zip_file_write_func(void *pOpaque, mz_uint64 file_ofs,
                                     void const *pBuf, size_t n)
{
  size_t __retres;
  size_t tmp_1;
  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
  mz_int64 cur_ofs = ftello((pZip->m_pState)->m_pFile);
  file_ofs += (pZip->m_pState)->m_file_archive_start_ofs;
  if ((mz_int64)file_ofs < (mz_int64)0) goto _LOR;
  else 
    if (cur_ofs != (mz_int64)file_ofs) {
      int tmp_0;
      tmp_0 = fseeko((pZip->m_pState)->m_pFile,(mz_int64)file_ofs,0);
      if (tmp_0) {
        _LOR:
        {
          mz_zip_set_error(pZip,MZ_ZIP_FILE_SEEK_FAILED);
          __retres = (size_t)0;
          goto return_label;
        }
      }
    }
  tmp_1 = fwrite(pBuf,(size_t)1,n,(pZip->m_pState)->m_pFile);
  __retres = tmp_1;
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_init_file
(mz_zip_archive *pZip, char const *pFilename,
 mz_uint64 size_to_reserve_at_beginning)
{
  mz_bool __attribute__((__visibility__("default"))) tmp;
  tmp = mz_zip_writer_init_file_v2(pZip,pFilename,
                                   size_to_reserve_at_beginning,(mz_uint)0);
  return tmp;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_init_file_v2
(mz_zip_archive *pZip, char const *pFilename,
 mz_uint64 size_to_reserve_at_beginning, mz_uint flags)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  FILE *pFile;
  mz_bool __attribute__((__visibility__("default"))) tmp;
  char const *tmp_1;
  pZip->m_pWrite = & mz_zip_file_write_func;
  pZip->m_pNeeds_keepalive = (mz_bool (*)(void *pOpaque))0;
  if (flags & (unsigned int)MZ_ZIP_FLAG_WRITE_ALLOW_READING) pZip->m_pRead = & mz_zip_file_read_func;
  pZip->m_pIO_opaque = (void *)pZip;
  tmp = mz_zip_writer_init_v2(pZip,size_to_reserve_at_beginning,flags);
  if (! tmp) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  if (flags & (unsigned int)MZ_ZIP_FLAG_WRITE_ALLOW_READING) tmp_1 = "w+b";
  else tmp_1 = "wb";
  ;
  pFile = fopen(pFilename,tmp_1);
  if ((FILE *)0 == pFile) {
    mz_bool __attribute__((__visibility__("default"))) tmp_0;
    mz_zip_writer_end(pZip);
    tmp_0 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_FILE_OPEN_FAILED);
    __retres = tmp_0;
    goto return_label;
  }
  (pZip->m_pState)->m_pFile = pFile;
  pZip->m_zip_type = MZ_ZIP_TYPE_FILE;
  if (size_to_reserve_at_beginning) {
    char buf[4096];
    mz_uint64 cur_ofs = (mz_uint64)0;
    memset((void *)(& buf),0,sizeof(buf));
    while (1) {
      {
        unsigned long tmp_2;
        size_t tmp_4;
        if (sizeof(buf) < size_to_reserve_at_beginning) tmp_2 = sizeof(buf);
        else tmp_2 = size_to_reserve_at_beginning;
        size_t n = tmp_2;
        tmp_4 = (*(pZip->m_pWrite))(pZip->m_pIO_opaque,cur_ofs,
                                    (void const *)(buf),n);
        ;
        if (tmp_4 != n) {
          mz_bool __attribute__((__visibility__("default"))) tmp_3;
          mz_zip_writer_end(pZip);
          tmp_3 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
          (pZip,MZ_ZIP_FILE_WRITE_FAILED);
          __retres = tmp_3;
          goto return_label;
        }
        cur_ofs += n;
        size_to_reserve_at_beginning -= n;
      }
      if (! size_to_reserve_at_beginning) break;
    }
  }
  __retres = (mz_bool __attribute__((__visibility__("default"))))1;
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_init_cfile
(mz_zip_archive *pZip, FILE *pFile, mz_uint flags)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_bool __attribute__((__visibility__("default"))) tmp;
  off_t tmp_0;
  pZip->m_pWrite = & mz_zip_file_write_func;
  pZip->m_pNeeds_keepalive = (mz_bool (*)(void *pOpaque))0;
  if (flags & (unsigned int)MZ_ZIP_FLAG_WRITE_ALLOW_READING) pZip->m_pRead = & mz_zip_file_read_func;
  pZip->m_pIO_opaque = (void *)pZip;
  tmp = mz_zip_writer_init_v2(pZip,(mz_uint64)0,flags);
  if (! tmp) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  (pZip->m_pState)->m_pFile = pFile;
  tmp_0 = ftello((pZip->m_pState)->m_pFile);
  (pZip->m_pState)->m_file_archive_start_ofs = (mz_uint64)tmp_0;
  pZip->m_zip_type = MZ_ZIP_TYPE_CFILE;
  __retres = (mz_bool __attribute__((__visibility__("default"))))1;
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_init_from_reader_v2
(mz_zip_archive *pZip, char const *pFilename, mz_uint flags)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_zip_internal_state *pState;
  if (! pZip) goto _LOR;
  else 
    if (! pZip->m_pState) goto _LOR;
    else 
      if (pZip->m_zip_mode != (unsigned int)MZ_ZIP_MODE_READING) {
        mz_bool __attribute__((__visibility__("default"))) tmp;
        _LOR:
        tmp = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
        (pZip,MZ_ZIP_INVALID_PARAMETER);
        __retres = tmp;
        goto return_label;
      }
  if (flags & (unsigned int)MZ_ZIP_FLAG_WRITE_ZIP64) 
    if (! (pZip->m_pState)->m_zip64) {
      mz_bool __attribute__((__visibility__("default"))) tmp_0;
      tmp_0 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_INVALID_PARAMETER);
      __retres = tmp_0;
      goto return_label;
    }
  if ((pZip->m_pState)->m_zip64) {
    if (pZip->m_total_files == 0xFFFFFFFFU) {
      mz_bool __attribute__((__visibility__("default"))) tmp_1;
      tmp_1 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_TOO_MANY_FILES);
      __retres = tmp_1;
      goto return_label;
    }
  }
  else {
    if (pZip->m_total_files == 0xFFFFU) {
      mz_bool __attribute__((__visibility__("default"))) tmp_2;
      tmp_2 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_TOO_MANY_FILES);
      __retres = tmp_2;
      goto return_label;
    }
    if ((pZip->m_archive_size + (mz_uint64)MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) + (mz_uint64)MZ_ZIP_LOCAL_DIR_HEADER_SIZE > (mz_uint64)0xFFFFFFFFU) {
      mz_bool __attribute__((__visibility__("default"))) tmp_3;
      tmp_3 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_FILE_TOO_LARGE);
      __retres = tmp_3;
      goto return_label;
    }
  }
  pState = pZip->m_pState;
  if (pState->m_pFile) {
    if (pZip->m_pIO_opaque != (void *)pZip) {
      mz_bool __attribute__((__visibility__("default"))) tmp_4;
      tmp_4 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_INVALID_PARAMETER);
      __retres = tmp_4;
      goto return_label;
    }
    if (pZip->m_zip_type == (unsigned int)MZ_ZIP_TYPE_FILE) {
      FILE *tmp_7;
      if (! pFilename) {
        mz_bool __attribute__((__visibility__("default"))) tmp_5;
        tmp_5 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
        (pZip,MZ_ZIP_INVALID_PARAMETER);
        __retres = tmp_5;
        goto return_label;
      }
      tmp_7 = freopen(pFilename,"r+b",pState->m_pFile);
      pState->m_pFile = tmp_7;
      if ((FILE *)0 == tmp_7) {
        mz_bool __attribute__((__visibility__("default"))) tmp_6;
        mz_zip_reader_end_internal(pZip,0);
        tmp_6 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
        (pZip,MZ_ZIP_FILE_OPEN_FAILED);
        __retres = tmp_6;
        goto return_label;
      }
    }
    pZip->m_pWrite = & mz_zip_file_write_func;
    pZip->m_pNeeds_keepalive = (mz_bool (*)(void *pOpaque))0;
  }
  else 
    if (pState->m_pMem) {
      if (pZip->m_pIO_opaque != (void *)pZip) {
        mz_bool __attribute__((__visibility__("default"))) tmp_8;
        tmp_8 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
        (pZip,MZ_ZIP_INVALID_PARAMETER);
        __retres = tmp_8;
        goto return_label;
      }
      pState->m_mem_capacity = pState->m_mem_size;
      pZip->m_pWrite = & mz_zip_heap_write_func;
      pZip->m_pNeeds_keepalive = (mz_bool (*)(void *pOpaque))0;
    }
    else 
      if (! pZip->m_pWrite) {
        mz_bool __attribute__((__visibility__("default"))) tmp_9;
        tmp_9 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
        (pZip,MZ_ZIP_INVALID_PARAMETER);
        __retres = tmp_9;
        goto return_label;
      }
  pZip->m_archive_size = pZip->m_central_directory_file_ofs;
  pZip->m_central_directory_file_ofs = (mz_uint64)0;
  mz_zip_array_clear(pZip,& (pZip->m_pState)->m_sorted_central_dir_offsets);
  pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;
  __retres = (mz_bool __attribute__((__visibility__("default"))))1;
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_init_from_reader
(mz_zip_archive *pZip, char const *pFilename)
{
  mz_bool __attribute__((__visibility__("default"))) tmp;
  tmp = mz_zip_writer_init_from_reader_v2(pZip,pFilename,(mz_uint)0);
  return tmp;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_add_mem
(mz_zip_archive *pZip, char const *pArchive_name, void const *pBuf,
 size_t buf_size, mz_uint level_and_flags)
{
  mz_bool __attribute__((__visibility__("default"))) tmp;
  tmp = mz_zip_writer_add_mem_ex(pZip,pArchive_name,pBuf,buf_size,
                                 (void const *)0,(mz_uint16)0,
                                 level_and_flags,(mz_uint64)0,(mz_uint32)0);
  return tmp;
}

static mz_bool mz_zip_writer_add_put_buf_callback(void const *pBuf, int len,
                                                  void *pUser)
{
  mz_bool __retres;
  size_t tmp;
  mz_zip_writer_add_state *pState = (mz_zip_writer_add_state *)pUser;
  tmp = (*((pState->m_pZip)->m_pWrite))((pState->m_pZip)->m_pIO_opaque,
                                        pState->m_cur_archive_file_ofs,pBuf,
                                        (size_t)len);
  ;
  if ((int)tmp != len) {
    __retres = 0;
    goto return_label;
  }
  pState->m_cur_archive_file_ofs += (mz_uint64)len;
  pState->m_comp_size += (mz_uint64)len;
  __retres = 1;
  return_label: return __retres;
}

static mz_uint32 mz_zip_writer_create_zip64_extra_data(mz_uint8 *pBuf,
                                                       mz_uint64 *pUncomp_size,
                                                       mz_uint64 *pComp_size,
                                                       mz_uint64 *pLocal_header_ofs)
{
  mz_uint32 __retres;
  mz_uint8 *pDst = pBuf;
  mz_uint32 field_size = (mz_uint32)0;
  mz_write_le16(pDst + 0,
                (mz_uint16)MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID);
  mz_write_le16(pDst + 2,(mz_uint16)0);
  pDst += sizeof(mz_uint16) * (unsigned long)2;
  if (pUncomp_size) {
    mz_write_le64(pDst,*pUncomp_size);
    pDst += sizeof(mz_uint64);
    field_size = (mz_uint32)((unsigned long)field_size + sizeof(mz_uint64));
  }
  if (pComp_size) {
    mz_write_le64(pDst,*pComp_size);
    pDst += sizeof(mz_uint64);
    field_size = (mz_uint32)((unsigned long)field_size + sizeof(mz_uint64));
  }
  if (pLocal_header_ofs) {
    mz_write_le64(pDst,*pLocal_header_ofs);
    pDst += sizeof(mz_uint64);
    field_size = (mz_uint32)((unsigned long)field_size + sizeof(mz_uint64));
  }
  mz_write_le16(pBuf + 2,(mz_uint16)field_size);
  __retres = (mz_uint32)(pDst - pBuf);
  return __retres;
}

static mz_bool mz_zip_writer_create_local_dir_header(mz_zip_archive *pZip,
                                                     mz_uint8 *pDst,
                                                     mz_uint16 filename_size,
                                                     mz_uint16 extra_size,
                                                     mz_uint64 uncomp_size,
                                                     mz_uint64 comp_size,
                                                     mz_uint32 uncomp_crc32,
                                                     mz_uint16 method,
                                                     mz_uint16 bit_flags,
                                                     mz_uint16 dos_time,
                                                     mz_uint16 dos_date)
{
  mz_bool __retres;
  int tmp;
  mz_uint64 tmp_0;
  mz_uint64 tmp_1;
  memset((void *)pDst,0,(size_t)MZ_ZIP_LOCAL_DIR_HEADER_SIZE);
  mz_write_le32(pDst + MZ_ZIP_LDH_SIG_OFS,
                (mz_uint32)MZ_ZIP_LOCAL_DIR_HEADER_SIG);
  if (method) tmp = 20; else tmp = 0;
  ;
  mz_write_le16(pDst + MZ_ZIP_LDH_VERSION_NEEDED_OFS,(mz_uint16)tmp);
  mz_write_le16(pDst + MZ_ZIP_LDH_BIT_FLAG_OFS,bit_flags);
  mz_write_le16(pDst + MZ_ZIP_LDH_METHOD_OFS,method);
  mz_write_le16(pDst + MZ_ZIP_LDH_FILE_TIME_OFS,dos_time);
  mz_write_le16(pDst + MZ_ZIP_LDH_FILE_DATE_OFS,dos_date);
  mz_write_le32(pDst + MZ_ZIP_LDH_CRC32_OFS,uncomp_crc32);
  if (comp_size < (mz_uint64)0xFFFFFFFFU) tmp_0 = comp_size;
  else tmp_0 = (mz_uint64)0xFFFFFFFFU;
  ;
  mz_write_le32(pDst + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS,(mz_uint32)tmp_0);
  if (uncomp_size < (mz_uint64)0xFFFFFFFFU) tmp_1 = uncomp_size;
  else tmp_1 = (mz_uint64)0xFFFFFFFFU;
  ;
  mz_write_le32(pDst + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS,(mz_uint32)tmp_1);
  mz_write_le16(pDst + MZ_ZIP_LDH_FILENAME_LEN_OFS,filename_size);
  mz_write_le16(pDst + MZ_ZIP_LDH_EXTRA_LEN_OFS,extra_size);
  __retres = 1;
  return __retres;
}

static mz_bool mz_zip_writer_create_central_dir_header(mz_zip_archive *pZip,
                                                       mz_uint8 *pDst,
                                                       mz_uint16 filename_size,
                                                       mz_uint16 extra_size,
                                                       mz_uint16 comment_size,
                                                       mz_uint64 uncomp_size,
                                                       mz_uint64 comp_size,
                                                       mz_uint32 uncomp_crc32,
                                                       mz_uint16 method,
                                                       mz_uint16 bit_flags,
                                                       mz_uint16 dos_time,
                                                       mz_uint16 dos_date,
                                                       mz_uint64 local_header_ofs,
                                                       mz_uint32 ext_attributes)
{
  mz_bool __retres;
  int tmp;
  mz_uint64 tmp_0;
  mz_uint64 tmp_1;
  mz_uint64 tmp_2;
  memset((void *)pDst,0,(size_t)MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);
  mz_write_le32(pDst + MZ_ZIP_CDH_SIG_OFS,
                (mz_uint32)MZ_ZIP_CENTRAL_DIR_HEADER_SIG);
  if (method) tmp = 20; else tmp = 0;
  ;
  mz_write_le16(pDst + MZ_ZIP_CDH_VERSION_NEEDED_OFS,(mz_uint16)tmp);
  mz_write_le16(pDst + MZ_ZIP_CDH_BIT_FLAG_OFS,bit_flags);
  mz_write_le16(pDst + MZ_ZIP_CDH_METHOD_OFS,method);
  mz_write_le16(pDst + MZ_ZIP_CDH_FILE_TIME_OFS,dos_time);
  mz_write_le16(pDst + MZ_ZIP_CDH_FILE_DATE_OFS,dos_date);
  mz_write_le32(pDst + MZ_ZIP_CDH_CRC32_OFS,uncomp_crc32);
  if (comp_size < (mz_uint64)0xFFFFFFFFU) tmp_0 = comp_size;
  else tmp_0 = (mz_uint64)0xFFFFFFFFU;
  ;
  mz_write_le32(pDst + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS,(mz_uint32)tmp_0);
  if (uncomp_size < (mz_uint64)0xFFFFFFFFU) tmp_1 = uncomp_size;
  else tmp_1 = (mz_uint64)0xFFFFFFFFU;
  ;
  mz_write_le32(pDst + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS,(mz_uint32)tmp_1);
  mz_write_le16(pDst + MZ_ZIP_CDH_FILENAME_LEN_OFS,filename_size);
  mz_write_le16(pDst + MZ_ZIP_CDH_EXTRA_LEN_OFS,extra_size);
  mz_write_le16(pDst + MZ_ZIP_CDH_COMMENT_LEN_OFS,comment_size);
  mz_write_le32(pDst + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS,ext_attributes);
  if (local_header_ofs < (mz_uint64)0xFFFFFFFFU) tmp_2 = local_header_ofs;
  else tmp_2 = (mz_uint64)0xFFFFFFFFU;
  ;
  mz_write_le32(pDst + MZ_ZIP_CDH_LOCAL_HEADER_OFS,(mz_uint32)tmp_2);
  __retres = 1;
  return __retres;
}

static mz_bool mz_zip_writer_add_to_central_dir(mz_zip_archive *pZip,
                                                char const *pFilename,
                                                mz_uint16 filename_size,
                                                void const *pExtra,
                                                mz_uint16 extra_size,
                                                void const *pComment,
                                                mz_uint16 comment_size,
                                                mz_uint64 uncomp_size,
                                                mz_uint64 comp_size,
                                                mz_uint32 uncomp_crc32,
                                                mz_uint16 method,
                                                mz_uint16 bit_flags,
                                                mz_uint16 dos_time,
                                                mz_uint16 dos_date,
                                                mz_uint64 local_header_ofs,
                                                mz_uint32 ext_attributes,
                                                char const *user_extra_data,
                                                mz_uint user_extra_data_len)
{
  mz_bool __retres;
  mz_uint8 central_dir_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];
  mz_bool tmp_2;
  mz_bool tmp_4;
  mz_zip_internal_state *pState = pZip->m_pState;
  mz_uint32 central_dir_ofs = (mz_uint32)pState->m_central_dir.m_size;
  size_t orig_central_dir_size = pState->m_central_dir.m_size;
  if (! (pZip->m_pState)->m_zip64) 
    if (local_header_ofs > (mz_uint64)0xFFFFFFFF) {
      mz_bool tmp;
      tmp = mz_zip_set_error(pZip,MZ_ZIP_FILE_TOO_LARGE);
      __retres = tmp;
      goto return_label;
    }
  if (((((pState->m_central_dir.m_size + (mz_uint64)MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) + (mz_uint64)filename_size) + (mz_uint64)extra_size) + (mz_uint64)user_extra_data_len) + (mz_uint64)comment_size >= (mz_uint64)0xFFFFFFFFU) {
    mz_bool tmp_0;
    tmp_0 = mz_zip_set_error(pZip,MZ_ZIP_UNSUPPORTED_CDIR_SIZE);
    __retres = tmp_0;
    goto return_label;
  }
  tmp_2 = mz_zip_writer_create_central_dir_header(pZip,central_dir_header,
                                                  filename_size,
                                                  (mz_uint16)((mz_uint)extra_size + user_extra_data_len),
                                                  comment_size,uncomp_size,
                                                  comp_size,uncomp_crc32,
                                                  method,bit_flags,dos_time,
                                                  dos_date,local_header_ofs,
                                                  ext_attributes);
  if (! tmp_2) {
    mz_bool tmp_1;
    tmp_1 = mz_zip_set_error(pZip,MZ_ZIP_INTERNAL_ERROR);
    __retres = tmp_1;
    goto return_label;
  }
  tmp_4 = mz_zip_array_push_back(pZip,& pState->m_central_dir,
                                 (void const *)(central_dir_header),
                                 (size_t)MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);
  if (tmp_4) {
    mz_bool tmp_5;
    tmp_5 = mz_zip_array_push_back(pZip,& pState->m_central_dir,
                                   (void const *)pFilename,
                                   (size_t)filename_size);
    if (tmp_5) {
      mz_bool tmp_6;
      tmp_6 = mz_zip_array_push_back(pZip,& pState->m_central_dir,pExtra,
                                     (size_t)extra_size);
      if (tmp_6) {
        mz_bool tmp_7;
        tmp_7 = mz_zip_array_push_back(pZip,& pState->m_central_dir,
                                       (void const *)user_extra_data,
                                       (size_t)user_extra_data_len);
        if (tmp_7) {
          mz_bool tmp_8;
          tmp_8 = mz_zip_array_push_back(pZip,& pState->m_central_dir,
                                         pComment,(size_t)comment_size);
          if (tmp_8) {
            mz_bool tmp_9;
            tmp_9 = mz_zip_array_push_back(pZip,
                                           & pState->m_central_dir_offsets,
                                           (void const *)(& central_dir_ofs),
                                           (size_t)1);
            if (! tmp_9) {
              _LOR:
              {
                mz_bool tmp_3;
                mz_zip_array_resize(pZip,& pState->m_central_dir,
                                    orig_central_dir_size,(mz_uint)0);
                tmp_3 = mz_zip_set_error(pZip,MZ_ZIP_ALLOC_FAILED);
                __retres = tmp_3;
                goto return_label;
              }
            }
          }
          else goto _LOR;
        }
        else goto _LOR;
      }
      else goto _LOR;
    }
    else goto _LOR;
  }
  else goto _LOR;
  __retres = 1;
  return_label: return __retres;
}

static mz_bool mz_zip_writer_validate_archive_name(char const *pArchive_name)
{
  mz_bool __retres;
  if ((int)*pArchive_name == '/') {
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static mz_uint mz_zip_writer_compute_padding_needed_for_file_alignment
(mz_zip_archive *pZip)
{
  mz_uint __retres;
  mz_uint32 n;
  if (! pZip->m_file_offset_alignment) {
    __retres = (mz_uint)0;
    goto return_label;
  }
  n = (mz_uint32)(pZip->m_archive_size & (pZip->m_file_offset_alignment - (mz_uint64)1));
  __retres = (mz_uint)((pZip->m_file_offset_alignment - (mz_uint64)n) & (
                       pZip->m_file_offset_alignment - (mz_uint64)1));
  return_label: return __retres;
}

static mz_bool mz_zip_writer_write_zeros(mz_zip_archive *pZip,
                                         mz_uint64 cur_file_ofs, mz_uint32 n)
{
  mz_bool __retres;
  char buf[4096];
  unsigned long tmp;
  if (sizeof(buf) < (unsigned long)n) tmp = sizeof(buf);
  else tmp = (unsigned long)n;
  memset((void *)(buf),0,tmp);
  while (n) {
    unsigned long tmp_0;
    size_t tmp_2;
    if (sizeof(buf) < (unsigned long)n) tmp_0 = sizeof(buf);
    else tmp_0 = (unsigned long)n;
    mz_uint32 s = (mz_uint32)tmp_0;
    tmp_2 = (*(pZip->m_pWrite))(pZip->m_pIO_opaque,cur_file_ofs,
                                (void const *)(buf),(size_t)s);
    ;
    if (tmp_2 != (size_t)s) {
      mz_bool tmp_1;
      tmp_1 = mz_zip_set_error(pZip,MZ_ZIP_FILE_WRITE_FAILED);
      __retres = tmp_1;
      goto return_label;
    }
    cur_file_ofs += (mz_uint64)s;
    n -= s;
  }
  __retres = 1;
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_add_mem_ex
(mz_zip_archive *pZip, char const *pArchive_name, void const *pBuf,
 size_t buf_size, void const *pComment, mz_uint16 comment_size,
 mz_uint level_and_flags, mz_uint64 uncomp_size, mz_uint32 uncomp_crc32)
{
  mz_bool __attribute__((__visibility__("default"))) tmp;
  tmp = mz_zip_writer_add_mem_ex_v2(pZip,pArchive_name,pBuf,buf_size,
                                    pComment,comment_size,level_and_flags,
                                    uncomp_size,uncomp_crc32,(time_t *)0,
                                    (char const *)0,(mz_uint)0,
                                    (char const *)0,(mz_uint)0);
  return tmp;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_add_mem_ex_v2
(mz_zip_archive *pZip, char const *pArchive_name, void const *pBuf,
 size_t buf_size, void const *pComment, mz_uint16 comment_size,
 mz_uint level_and_flags, mz_uint64 uncomp_size, mz_uint32 uncomp_crc32,
 time_t *last_modified, char const *user_extra_data,
 mz_uint user_extra_data_len, char const *user_extra_data_central,
 mz_uint user_extra_data_central_len)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_uint level;
  mz_uint num_alignment_padding_bytes;
  size_t archive_name_size;
  mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];
  mz_bool store_data_uncompressed;
  mz_zip_internal_state *pState;
  mz_uint8 extra_data[sizeof(mz_uint16) * (unsigned long)2 + sizeof(mz_uint64) * (unsigned long)3];
  int tmp;
  mz_bool tmp_4;
  mz_bool tmp_11;
  unsigned long tmp_10;
  mz_bool tmp_15;
  mz_bool tmp_47;
  mz_uint16 method = (mz_uint16)0;
  mz_uint16 dos_time = (mz_uint16)0;
  mz_uint16 dos_date = (mz_uint16)0;
  mz_uint ext_attributes = (mz_uint)0;
  mz_uint64 local_dir_header_ofs = pZip->m_archive_size;
  mz_uint64 cur_archive_file_ofs = pZip->m_archive_size;
  mz_uint64 comp_size = (mz_uint64)0;
  tdefl_compressor *pComp = (tdefl_compressor *)0;
  mz_uint8 *pExtra_data = (mz_uint8 *)0;
  mz_uint32 extra_size = (mz_uint32)0;
  mz_uint16 bit_flags = (mz_uint16)0;
  if ((int)level_and_flags < 0) level_and_flags = (mz_uint)MZ_DEFAULT_LEVEL;
  if (uncomp_size) bit_flags = (mz_uint16)((int)bit_flags | MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR);
  else 
    if (buf_size) 
      if (! (level_and_flags & (unsigned int)MZ_ZIP_FLAG_COMPRESSED_DATA)) 
        bit_flags = (mz_uint16)((int)bit_flags | MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR);
  if (! (level_and_flags & (unsigned int)MZ_ZIP_FLAG_ASCII_FILENAME)) 
    bit_flags = (mz_uint16)((int)bit_flags | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_UTF8);
  level = level_and_flags & (unsigned int)0xF;
  if (! level) tmp = 1;
  else 
    if (level_and_flags & (unsigned int)MZ_ZIP_FLAG_COMPRESSED_DATA) 
      tmp = 1;
    else tmp = 0;
  store_data_uncompressed = tmp;
  if (! pZip) goto _LOR;
  else 
    if (! pZip->m_pState) goto _LOR;
    else 
      if (pZip->m_zip_mode != (unsigned int)MZ_ZIP_MODE_WRITING) goto _LOR;
      else 
        if (buf_size) {
          if (! pBuf) goto _LOR; else goto _LAND_0;
        }
        else 
          _LAND_0:
          if (! pArchive_name) goto _LOR;
          else 
            if (comment_size) {
              if (! pComment) goto _LOR; else goto _LAND;
            }
            else {
              _LAND: ;
              if (level > (mz_uint)MZ_UBER_COMPRESSION) {
                mz_bool __attribute__((__visibility__("default"))) tmp_0;
                _LOR:
                tmp_0 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
                (pZip,MZ_ZIP_INVALID_PARAMETER);
                __retres = tmp_0;
                goto return_label;
              }
            }
  pState = pZip->m_pState;
  if (pState->m_zip64) {
    if (pZip->m_total_files == 0xFFFFFFFFU) {
      mz_bool __attribute__((__visibility__("default"))) tmp_1;
      tmp_1 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_TOO_MANY_FILES);
      __retres = tmp_1;
      goto return_label;
    }
  }
  else {
    if (pZip->m_total_files == 0xFFFFU) pState->m_zip64 = 1;
    if (buf_size > (size_t)0xFFFFFFFF) goto _LOR_0;
    else 
      if (uncomp_size > (mz_uint64)0xFFFFFFFF) _LOR_0: pState->m_zip64 = 1;
  }
  if (! (level_and_flags & (unsigned int)MZ_ZIP_FLAG_COMPRESSED_DATA)) 
    if (uncomp_size) {
      mz_bool __attribute__((__visibility__("default"))) tmp_2;
      tmp_2 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_INVALID_PARAMETER);
      __retres = tmp_2;
      goto return_label;
    }
  tmp_4 = mz_zip_writer_validate_archive_name(pArchive_name);
  if (! tmp_4) {
    mz_bool __attribute__((__visibility__("default"))) tmp_3;
    tmp_3 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_INVALID_FILENAME);
    __retres = tmp_3;
    goto return_label;
  }
  if (last_modified != (time_t *)0) mz_zip_time_t_to_dos_time(*last_modified,
                                                              & dos_time,
                                                              & dos_date);
  else {
    time_t cur_time;
    time(& cur_time);
    mz_zip_time_t_to_dos_time(cur_time,& dos_time,& dos_date);
  }
  if (! (level_and_flags & (unsigned int)MZ_ZIP_FLAG_COMPRESSED_DATA)) {
    mz_ulong __attribute__((__visibility__("default"))) tmp_5;
    tmp_5 = mz_crc32((mz_ulong)0,(mz_uint8 const *)pBuf,buf_size);
    uncomp_crc32 = (mz_uint32)tmp_5;
    uncomp_size = buf_size;
    if (uncomp_size <= (mz_uint64)3) {
      level = (mz_uint)0;
      store_data_uncompressed = 1;
    }
  }
  archive_name_size = strlen(pArchive_name);
  if (archive_name_size > (size_t)0xFFFFU) {
    mz_bool __attribute__((__visibility__("default"))) tmp_6;
    tmp_6 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_INVALID_FILENAME);
    __retres = tmp_6;
    goto return_label;
  }
  num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment
  (pZip);
  if ((((pState->m_central_dir.m_size + (mz_uint64)MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) + archive_name_size) + (
       sizeof(mz_uint16) * (unsigned long)2 + sizeof(mz_uint64) * (unsigned long)3)) + (mz_uint64)comment_size >= (mz_uint64)0xFFFFFFFFU) {
    mz_bool __attribute__((__visibility__("default"))) tmp_7;
    tmp_7 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_UNSUPPORTED_CDIR_SIZE);
    __retres = tmp_7;
    goto return_label;
  }
  if (! pState->m_zip64) 
    if (((((((((((pZip->m_archive_size + (mz_uint64)num_alignment_padding_bytes) + (mz_uint64)MZ_ZIP_LOCAL_DIR_HEADER_SIZE) + archive_name_size) + (mz_uint64)MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) + archive_name_size) + (mz_uint64)comment_size) + (mz_uint64)user_extra_data_len) + pState->m_central_dir.m_size) + (mz_uint64)MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) + (mz_uint64)user_extra_data_central_len) + (mz_uint64)MZ_ZIP_DATA_DESCRIPTER_SIZE32 > (mz_uint64)0xFFFFFFFF) 
      pState->m_zip64 = 1;
  if (archive_name_size) 
    if ((int)*(pArchive_name + (archive_name_size - (size_t)1)) == '/') {
      ext_attributes |= (unsigned int)MZ_ZIP_DOS_DIR_ATTRIBUTE_BITFLAG;
      if (buf_size) goto _LOR_1;
      else 
        if (uncomp_size) {
          mz_bool __attribute__((__visibility__("default"))) tmp_8;
          _LOR_1:
          tmp_8 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
          (pZip,MZ_ZIP_INVALID_PARAMETER);
          __retres = tmp_8;
          goto return_label;
        }
    }
  if (pState->m_zip64) tmp_10 = sizeof(mz_uint16) * (unsigned long)2 + 
                                sizeof(mz_uint64) * (unsigned long)3;
  else tmp_10 = (unsigned long)0;
  ;
  ;
  ;
  tmp_11 = mz_zip_array_ensure_room(pZip,& pState->m_central_dir,
                                    (((size_t)MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size) + (size_t)comment_size) + tmp_10);
  if (tmp_11) {
    mz_bool tmp_12;
    tmp_12 = mz_zip_array_ensure_room(pZip,& pState->m_central_dir_offsets,
                                      (size_t)1);
    if (! tmp_12) {
      mz_bool __attribute__((__visibility__("default"))) tmp_9;
      _LOR_2:
      tmp_9 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_ALLOC_FAILED);
      __retres = tmp_9;
      goto return_label;
    }
  }
  else goto _LOR_2;
  if (! store_data_uncompressed) 
    if (buf_size) {
      pComp = (tdefl_compressor *)(*(pZip->m_pAlloc))(pZip->m_pAlloc_opaque,
                                                      (size_t)1,
                                                      sizeof(tdefl_compressor));
      if ((tdefl_compressor *)0 == pComp) {
        mz_bool __attribute__((__visibility__("default"))) tmp_13;
        tmp_13 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
        (pZip,MZ_ZIP_ALLOC_FAILED);
        __retres = tmp_13;
        goto return_label;
      }
    }
  tmp_15 = mz_zip_writer_write_zeros(pZip,cur_archive_file_ofs,
                                     num_alignment_padding_bytes);
  if (! tmp_15) {
    (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,(void *)pComp);
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  local_dir_header_ofs += (mz_uint64)num_alignment_padding_bytes;
  if (pZip->m_file_offset_alignment) __FC_assert(((local_dir_header_ofs & (
                                                   pZip->m_file_offset_alignment - (mz_uint64)1)) == (unsigned long)0) != 0,
                                                 "miniz_zip.c",3286,
                                                 "(local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0");
  cur_archive_file_ofs += (mz_uint64)num_alignment_padding_bytes;
  memset((void *)(& local_dir_header),0,sizeof(local_dir_header));
  if (! store_data_uncompressed) goto _LOR_3;
  else 
    if (level_and_flags & (unsigned int)MZ_ZIP_FLAG_COMPRESSED_DATA) 
      _LOR_3:
      method = (mz_uint16)8;
  if (pState->m_zip64) {
    mz_bool tmp_20;
    size_t tmp_22;
    size_t tmp_24;
    if (uncomp_size >= (mz_uint64)0xFFFFFFFFU) goto _LOR_4;
    else 
      if (local_dir_header_ofs >= (mz_uint64)0xFFFFFFFFU) {
        _LOR_4:
        {
          mz_uint64 *tmp_16;
          mz_uint64 *tmp_17;
          mz_uint64 *tmp_18;
          pExtra_data = extra_data;
          if (local_dir_header_ofs >= (mz_uint64)0xFFFFFFFFU) tmp_16 = & local_dir_header_ofs;
          else tmp_16 = (mz_uint64 *)0;
          if (uncomp_size >= (mz_uint64)0xFFFFFFFFU) tmp_17 = & comp_size;
          else tmp_17 = (mz_uint64 *)0;
          if (uncomp_size >= (mz_uint64)0xFFFFFFFFU) tmp_18 = & uncomp_size;
          else tmp_18 = (mz_uint64 *)0;
          extra_size = mz_zip_writer_create_zip64_extra_data(extra_data,
                                                             tmp_18,tmp_17,
                                                             tmp_16);
        }
      }
    tmp_20 = mz_zip_writer_create_local_dir_header(pZip,local_dir_header,
                                                   (mz_uint16)archive_name_size,
                                                   (mz_uint16)(extra_size + user_extra_data_len),
                                                   (mz_uint64)0,(mz_uint64)0,
                                                   (mz_uint32)0,method,
                                                   bit_flags,dos_time,
                                                   dos_date);
    if (! tmp_20) {
      mz_bool __attribute__((__visibility__("default"))) tmp_19;
      tmp_19 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_INTERNAL_ERROR);
      __retres = tmp_19;
      goto return_label;
    }
    tmp_22 = (*(pZip->m_pWrite))(pZip->m_pIO_opaque,local_dir_header_ofs,
                                 (void const *)(local_dir_header),
                                 sizeof(local_dir_header));
    if (tmp_22 != sizeof(local_dir_header)) {
      mz_bool __attribute__((__visibility__("default"))) tmp_21;
      tmp_21 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_FILE_WRITE_FAILED);
      __retres = tmp_21;
      goto return_label;
    }
    cur_archive_file_ofs += sizeof(local_dir_header);
    tmp_24 = (*(pZip->m_pWrite))(pZip->m_pIO_opaque,cur_archive_file_ofs,
                                 (void const *)pArchive_name,
                                 archive_name_size);
    ;
    if (tmp_24 != archive_name_size) {
      mz_bool __attribute__((__visibility__("default"))) tmp_23;
      (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,(void *)pComp);
      tmp_23 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_FILE_WRITE_FAILED);
      __retres = tmp_23;
      goto return_label;
    }
    cur_archive_file_ofs += archive_name_size;
    if (pExtra_data != (mz_uint8 *)0) {
      size_t tmp_26;
      tmp_26 = (*(pZip->m_pWrite))(pZip->m_pIO_opaque,cur_archive_file_ofs,
                                   (void const *)(extra_data),
                                   (size_t)extra_size);
      ;
      if (tmp_26 != (size_t)extra_size) {
        mz_bool __attribute__((__visibility__("default"))) tmp_25;
        tmp_25 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
        (pZip,MZ_ZIP_FILE_WRITE_FAILED);
        __retres = tmp_25;
        goto return_label;
      }
      cur_archive_file_ofs += (mz_uint64)extra_size;
    }
  }
  else {
    mz_bool tmp_29;
    size_t tmp_31;
    size_t tmp_33;
    if (comp_size > (mz_uint64)0xFFFFFFFFU) goto _LOR_5;
    else 
      if (cur_archive_file_ofs > (mz_uint64)0xFFFFFFFFU) {
        mz_bool __attribute__((__visibility__("default"))) tmp_27;
        _LOR_5:
        tmp_27 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
        (pZip,MZ_ZIP_ARCHIVE_TOO_LARGE);
        __retres = tmp_27;
        goto return_label;
      }
    tmp_29 = mz_zip_writer_create_local_dir_header(pZip,local_dir_header,
                                                   (mz_uint16)archive_name_size,
                                                   (mz_uint16)user_extra_data_len,
                                                   (mz_uint64)0,(mz_uint64)0,
                                                   (mz_uint32)0,method,
                                                   bit_flags,dos_time,
                                                   dos_date);
    if (! tmp_29) {
      mz_bool __attribute__((__visibility__("default"))) tmp_28;
      tmp_28 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_INTERNAL_ERROR);
      __retres = tmp_28;
      goto return_label;
    }
    tmp_31 = (*(pZip->m_pWrite))(pZip->m_pIO_opaque,local_dir_header_ofs,
                                 (void const *)(local_dir_header),
                                 sizeof(local_dir_header));
    if (tmp_31 != sizeof(local_dir_header)) {
      mz_bool __attribute__((__visibility__("default"))) tmp_30;
      tmp_30 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_FILE_WRITE_FAILED);
      __retres = tmp_30;
      goto return_label;
    }
    cur_archive_file_ofs += sizeof(local_dir_header);
    tmp_33 = (*(pZip->m_pWrite))(pZip->m_pIO_opaque,cur_archive_file_ofs,
                                 (void const *)pArchive_name,
                                 archive_name_size);
    ;
    if (tmp_33 != archive_name_size) {
      mz_bool __attribute__((__visibility__("default"))) tmp_32;
      (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,(void *)pComp);
      tmp_32 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_FILE_WRITE_FAILED);
      __retres = tmp_32;
      goto return_label;
    }
    cur_archive_file_ofs += archive_name_size;
  }
  if (user_extra_data_len > (mz_uint)0) {
    size_t tmp_35;
    tmp_35 = (*(pZip->m_pWrite))(pZip->m_pIO_opaque,cur_archive_file_ofs,
                                 (void const *)user_extra_data,
                                 (size_t)user_extra_data_len);
    ;
    if (tmp_35 != (size_t)user_extra_data_len) {
      mz_bool __attribute__((__visibility__("default"))) tmp_34;
      tmp_34 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_FILE_WRITE_FAILED);
      __retres = tmp_34;
      goto return_label;
    }
    cur_archive_file_ofs += (mz_uint64)user_extra_data_len;
  }
  if (store_data_uncompressed) {
    size_t tmp_37;
    tmp_37 = (*(pZip->m_pWrite))(pZip->m_pIO_opaque,cur_archive_file_ofs,
                                 pBuf,buf_size);
    ;
    if (tmp_37 != buf_size) {
      mz_bool __attribute__((__visibility__("default"))) tmp_36;
      (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,(void *)pComp);
      tmp_36 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_FILE_WRITE_FAILED);
      __retres = tmp_36;
      goto return_label;
    }
    cur_archive_file_ofs += buf_size;
    comp_size = buf_size;
  }
  else 
    if (buf_size) {
      mz_zip_writer_add_state state;
      tdefl_status __attribute__((__visibility__("default"))) tmp_40;
      mz_uint __attribute__((__visibility__("default"))) tmp_39;
      state.m_pZip = pZip;
      state.m_cur_archive_file_ofs = cur_archive_file_ofs;
      state.m_comp_size = (mz_uint64)0;
      tmp_39 = tdefl_create_comp_flags_from_zip_params((int)level,-15,
                                                       MZ_DEFAULT_STRATEGY);
      ;
      tmp_40 = tdefl_init(pComp,& mz_zip_writer_add_put_buf_callback,
                          (void *)(& state),(int)tmp_39);
      if (tmp_40 != (int __attribute__((__visibility__("default"))))TDEFL_STATUS_OKAY) 
        goto _LOR_6;
      else {
        tdefl_status __attribute__((__visibility__("default"))) tmp_41;
        tmp_41 = tdefl_compress_buffer(pComp,pBuf,buf_size,TDEFL_FINISH);
        if (tmp_41 != (int __attribute__((__visibility__("default"))))TDEFL_STATUS_DONE) {
          _LOR_6:
          {
            mz_bool __attribute__((__visibility__("default"))) tmp_38;
            (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,(void *)pComp);
            tmp_38 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
            (pZip,MZ_ZIP_COMPRESSION_FAILED);
            __retres = tmp_38;
            goto return_label;
          }
        }
      }
      comp_size = state.m_comp_size;
      cur_archive_file_ofs = state.m_cur_archive_file_ofs;
    }
  (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,(void *)pComp);
  pComp = (tdefl_compressor *)0;
  if (uncomp_size) {
    mz_uint8 local_dir_footer[MZ_ZIP_DATA_DESCRIPTER_SIZE64];
    size_t tmp_43;
    mz_uint32 local_dir_footer_size =
      (mz_uint32)MZ_ZIP_DATA_DESCRIPTER_SIZE32;
    __FC_assert(((int)bit_flags & MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR) != 0,
                "miniz_zip.c",3395,
                "bit_flags & MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR");
    mz_write_le32(& local_dir_footer[0],(mz_uint32)MZ_ZIP_DATA_DESCRIPTOR_ID);
    mz_write_le32(& local_dir_footer[4],uncomp_crc32);
    if (pExtra_data == (mz_uint8 *)0) {
      if (comp_size > (mz_uint64)0xFFFFFFFFU) {
        mz_bool __attribute__((__visibility__("default"))) tmp_42;
        tmp_42 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
        (pZip,MZ_ZIP_ARCHIVE_TOO_LARGE);
        __retres = tmp_42;
        goto return_label;
      }
      mz_write_le32(& local_dir_footer[8],(mz_uint32)comp_size);
      mz_write_le32(& local_dir_footer[12],(mz_uint32)uncomp_size);
    }
    else {
      mz_write_le64(& local_dir_footer[8],comp_size);
      mz_write_le64(& local_dir_footer[16],uncomp_size);
      local_dir_footer_size = (mz_uint32)MZ_ZIP_DATA_DESCRIPTER_SIZE64;
    }
    tmp_43 = (*(pZip->m_pWrite))(pZip->m_pIO_opaque,cur_archive_file_ofs,
                                 (void const *)(local_dir_footer),
                                 (size_t)local_dir_footer_size);
    ;
    if (tmp_43 != (size_t)local_dir_footer_size) {
      __retres = (mz_bool __attribute__((__visibility__("default"))))0;
      goto return_label;
    }
    cur_archive_file_ofs += (mz_uint64)local_dir_footer_size;
  }
  if (pExtra_data != (mz_uint8 *)0) {
    mz_uint64 *tmp_44;
    mz_uint64 *tmp_45;
    mz_uint64 *tmp_46;
    if (local_dir_header_ofs >= (mz_uint64)0xFFFFFFFFU) tmp_44 = & local_dir_header_ofs;
    else tmp_44 = (mz_uint64 *)0;
    if (uncomp_size >= (mz_uint64)0xFFFFFFFFU) tmp_45 = & comp_size;
    else tmp_45 = (mz_uint64 *)0;
    if (uncomp_size >= (mz_uint64)0xFFFFFFFFU) tmp_46 = & uncomp_size;
    else tmp_46 = (mz_uint64 *)0;
    extra_size = mz_zip_writer_create_zip64_extra_data(extra_data,tmp_46,
                                                       tmp_45,tmp_44);
  }
  tmp_47 = mz_zip_writer_add_to_central_dir(pZip,pArchive_name,
                                            (mz_uint16)archive_name_size,
                                            (void const *)pExtra_data,
                                            (mz_uint16)extra_size,pComment,
                                            comment_size,uncomp_size,
                                            comp_size,uncomp_crc32,method,
                                            bit_flags,dos_time,dos_date,
                                            local_dir_header_ofs,
                                            ext_attributes,
                                            user_extra_data_central,
                                            user_extra_data_central_len);
  if (! tmp_47) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  (pZip->m_total_files) ++;
  pZip->m_archive_size = cur_archive_file_ofs;
  __retres = (mz_bool __attribute__((__visibility__("default"))))1;
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_add_read_buf_callback
(mz_zip_archive *pZip, char const *pArchive_name,
 size_t (*read_callback)(void *pOpaque, mz_uint64 file_ofs, void *pBuf,
                         size_t n),
 void *callback_opaque, mz_uint64 max_size, time_t const *pFile_time,
 void const *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
 char const *user_extra_data, mz_uint user_extra_data_len,
 char const *user_extra_data_central, mz_uint user_extra_data_central_len)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_uint level;
  mz_uint num_alignment_padding_bytes;
  mz_uint64 local_dir_header_ofs;
  size_t archive_name_size;
  mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];
  mz_uint8 extra_data[sizeof(mz_uint16) * (unsigned long)2 + sizeof(mz_uint64) * (unsigned long)3];
  mz_zip_internal_state *pState;
  mz_bool tmp_2;
  mz_bool tmp_7;
  mz_bool tmp_49;
  mz_uint16 gen_flags = (mz_uint16)MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR;
  mz_uint uncomp_crc32 = (mz_uint)0;
  mz_uint16 method = (mz_uint16)0;
  mz_uint16 dos_time = (mz_uint16)0;
  mz_uint16 dos_date = (mz_uint16)0;
  mz_uint16 ext_attributes = (mz_uint16)0;
  mz_uint64 cur_archive_file_ofs = pZip->m_archive_size;
  mz_uint64 uncomp_size = (mz_uint64)0;
  mz_uint64 comp_size = (mz_uint64)0;
  mz_uint8 *pExtra_data = (mz_uint8 *)0;
  mz_uint32 extra_size = (mz_uint32)0;
  mz_uint64 file_ofs = (mz_uint64)0;
  if (! (level_and_flags & (unsigned int)MZ_ZIP_FLAG_ASCII_FILENAME)) 
    gen_flags = (mz_uint16)((int)gen_flags | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_UTF8);
  if ((int)level_and_flags < 0) level_and_flags = (mz_uint)MZ_DEFAULT_LEVEL;
  level = level_and_flags & (unsigned int)0xF;
  if (! pZip) goto _LOR;
  else 
    if (! pZip->m_pState) goto _LOR;
    else 
      if (pZip->m_zip_mode != (unsigned int)MZ_ZIP_MODE_WRITING) goto _LOR;
      else 
        if (! pArchive_name) goto _LOR;
        else 
          if (comment_size) {
            if (! pComment) goto _LOR; else goto _LAND;
          }
          else {
            _LAND: ;
            if (level > (mz_uint)MZ_UBER_COMPRESSION) {
              mz_bool __attribute__((__visibility__("default"))) tmp;
              _LOR:
              tmp = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
              (pZip,MZ_ZIP_INVALID_PARAMETER);
              __retres = tmp;
              goto return_label;
            }
          }
  pState = pZip->m_pState;
  if (! pState->m_zip64) 
    if (max_size > (mz_uint64)0xFFFFFFFFU) pState->m_zip64 = 1;
  if (level_and_flags & (unsigned int)MZ_ZIP_FLAG_COMPRESSED_DATA) {
    mz_bool __attribute__((__visibility__("default"))) tmp_0;
    tmp_0 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_INVALID_PARAMETER);
    __retres = tmp_0;
    goto return_label;
  }
  tmp_2 = mz_zip_writer_validate_archive_name(pArchive_name);
  if (! tmp_2) {
    mz_bool __attribute__((__visibility__("default"))) tmp_1;
    tmp_1 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_INVALID_FILENAME);
    __retres = tmp_1;
    goto return_label;
  }
  if (pState->m_zip64) {
    if (pZip->m_total_files == 0xFFFFFFFFU) {
      mz_bool __attribute__((__visibility__("default"))) tmp_3;
      tmp_3 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_TOO_MANY_FILES);
      __retres = tmp_3;
      goto return_label;
    }
  }
  else 
    if (pZip->m_total_files == 0xFFFFU) pState->m_zip64 = 1;
  archive_name_size = strlen(pArchive_name);
  if (archive_name_size > (size_t)0xFFFFU) {
    mz_bool __attribute__((__visibility__("default"))) tmp_4;
    tmp_4 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_INVALID_FILENAME);
    __retres = tmp_4;
    goto return_label;
  }
  num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment
  (pZip);
  if ((((pState->m_central_dir.m_size + (mz_uint64)MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) + archive_name_size) + (
       sizeof(mz_uint16) * (unsigned long)2 + sizeof(mz_uint64) * (unsigned long)3)) + (mz_uint64)comment_size >= (mz_uint64)0xFFFFFFFFU) {
    mz_bool __attribute__((__visibility__("default"))) tmp_5;
    tmp_5 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_UNSUPPORTED_CDIR_SIZE);
    __retres = tmp_5;
    goto return_label;
  }
  if (! pState->m_zip64) 
    if ((((((((((((pZip->m_archive_size + (mz_uint64)num_alignment_padding_bytes) + (mz_uint64)MZ_ZIP_LOCAL_DIR_HEADER_SIZE) + archive_name_size) + (mz_uint64)MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) + archive_name_size) + (mz_uint64)comment_size) + (mz_uint64)user_extra_data_len) + pState->m_central_dir.m_size) + (mz_uint64)MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) + (mz_uint64)1024) + (mz_uint64)MZ_ZIP_DATA_DESCRIPTER_SIZE32) + (mz_uint64)user_extra_data_central_len > (mz_uint64)0xFFFFFFFF) 
      pState->m_zip64 = 1;
  if (pFile_time) mz_zip_time_t_to_dos_time(*pFile_time,& dos_time,
                                            & dos_date);
  if (max_size <= (mz_uint64)3) level = (mz_uint)0;
  tmp_7 = mz_zip_writer_write_zeros(pZip,cur_archive_file_ofs,
                                    num_alignment_padding_bytes);
  if (! tmp_7) {
    mz_bool __attribute__((__visibility__("default"))) tmp_6;
    tmp_6 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_FILE_WRITE_FAILED);
    __retres = tmp_6;
    goto return_label;
  }
  cur_archive_file_ofs += (mz_uint64)num_alignment_padding_bytes;
  local_dir_header_ofs = cur_archive_file_ofs;
  if (pZip->m_file_offset_alignment) __FC_assert(((cur_archive_file_ofs & (
                                                   pZip->m_file_offset_alignment - (mz_uint64)1)) == (unsigned long)0) != 0,
                                                 "miniz_zip.c",3535,
                                                 "(cur_archive_file_ofs & (pZip->m_file_offset_alignment - 1)) == 0");
  if (max_size) 
    if (level) method = (mz_uint16)8;
  memset((void *)(& local_dir_header),0,sizeof(local_dir_header));
  if (pState->m_zip64) {
    mz_bool tmp_12;
    size_t tmp_14;
    size_t tmp_16;
    size_t tmp_18;
    if (max_size >= (mz_uint64)0xFFFFFFFFU) goto _LOR_0;
    else 
      if (local_dir_header_ofs >= (mz_uint64)0xFFFFFFFFU) {
        _LOR_0:
        {
          mz_uint64 *tmp_8;
          mz_uint64 *tmp_9;
          mz_uint64 *tmp_10;
          pExtra_data = extra_data;
          if (local_dir_header_ofs >= (mz_uint64)0xFFFFFFFFU) tmp_8 = & local_dir_header_ofs;
          else tmp_8 = (mz_uint64 *)0;
          if (max_size >= (mz_uint64)0xFFFFFFFFU) tmp_9 = & comp_size;
          else tmp_9 = (mz_uint64 *)0;
          if (max_size >= (mz_uint64)0xFFFFFFFFU) tmp_10 = & uncomp_size;
          else tmp_10 = (mz_uint64 *)0;
          extra_size = mz_zip_writer_create_zip64_extra_data(extra_data,
                                                             tmp_10,tmp_9,
                                                             tmp_8);
        }
      }
    tmp_12 = mz_zip_writer_create_local_dir_header(pZip,local_dir_header,
                                                   (mz_uint16)archive_name_size,
                                                   (mz_uint16)(extra_size + user_extra_data_len),
                                                   (mz_uint64)0,(mz_uint64)0,
                                                   (mz_uint32)0,method,
                                                   gen_flags,dos_time,
                                                   dos_date);
    if (! tmp_12) {
      mz_bool __attribute__((__visibility__("default"))) tmp_11;
      tmp_11 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_INTERNAL_ERROR);
      __retres = tmp_11;
      goto return_label;
    }
    tmp_14 = (*(pZip->m_pWrite))(pZip->m_pIO_opaque,cur_archive_file_ofs,
                                 (void const *)(local_dir_header),
                                 sizeof(local_dir_header));
    if (tmp_14 != sizeof(local_dir_header)) {
      mz_bool __attribute__((__visibility__("default"))) tmp_13;
      tmp_13 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_FILE_WRITE_FAILED);
      __retres = tmp_13;
      goto return_label;
    }
    cur_archive_file_ofs += sizeof(local_dir_header);
    tmp_16 = (*(pZip->m_pWrite))(pZip->m_pIO_opaque,cur_archive_file_ofs,
                                 (void const *)pArchive_name,
                                 archive_name_size);
    ;
    if (tmp_16 != archive_name_size) {
      mz_bool __attribute__((__visibility__("default"))) tmp_15;
      tmp_15 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_FILE_WRITE_FAILED);
      __retres = tmp_15;
      goto return_label;
    }
    cur_archive_file_ofs += archive_name_size;
    tmp_18 = (*(pZip->m_pWrite))(pZip->m_pIO_opaque,cur_archive_file_ofs,
                                 (void const *)(extra_data),
                                 (size_t)extra_size);
    ;
    if (tmp_18 != (size_t)extra_size) {
      mz_bool __attribute__((__visibility__("default"))) tmp_17;
      tmp_17 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_FILE_WRITE_FAILED);
      __retres = tmp_17;
      goto return_label;
    }
    cur_archive_file_ofs += (mz_uint64)extra_size;
  }
  else {
    mz_bool tmp_21;
    size_t tmp_23;
    size_t tmp_25;
    if (comp_size > (mz_uint64)0xFFFFFFFFU) goto _LOR_1;
    else 
      if (cur_archive_file_ofs > (mz_uint64)0xFFFFFFFFU) {
        mz_bool __attribute__((__visibility__("default"))) tmp_19;
        _LOR_1:
        tmp_19 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
        (pZip,MZ_ZIP_ARCHIVE_TOO_LARGE);
        __retres = tmp_19;
        goto return_label;
      }
    tmp_21 = mz_zip_writer_create_local_dir_header(pZip,local_dir_header,
                                                   (mz_uint16)archive_name_size,
                                                   (mz_uint16)user_extra_data_len,
                                                   (mz_uint64)0,(mz_uint64)0,
                                                   (mz_uint32)0,method,
                                                   gen_flags,dos_time,
                                                   dos_date);
    if (! tmp_21) {
      mz_bool __attribute__((__visibility__("default"))) tmp_20;
      tmp_20 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_INTERNAL_ERROR);
      __retres = tmp_20;
      goto return_label;
    }
    tmp_23 = (*(pZip->m_pWrite))(pZip->m_pIO_opaque,cur_archive_file_ofs,
                                 (void const *)(local_dir_header),
                                 sizeof(local_dir_header));
    if (tmp_23 != sizeof(local_dir_header)) {
      mz_bool __attribute__((__visibility__("default"))) tmp_22;
      tmp_22 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_FILE_WRITE_FAILED);
      __retres = tmp_22;
      goto return_label;
    }
    cur_archive_file_ofs += sizeof(local_dir_header);
    tmp_25 = (*(pZip->m_pWrite))(pZip->m_pIO_opaque,cur_archive_file_ofs,
                                 (void const *)pArchive_name,
                                 archive_name_size);
    ;
    if (tmp_25 != archive_name_size) {
      mz_bool __attribute__((__visibility__("default"))) tmp_24;
      tmp_24 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_FILE_WRITE_FAILED);
      __retres = tmp_24;
      goto return_label;
    }
    cur_archive_file_ofs += archive_name_size;
  }
  if (user_extra_data_len > (mz_uint)0) {
    size_t tmp_27;
    tmp_27 = (*(pZip->m_pWrite))(pZip->m_pIO_opaque,cur_archive_file_ofs,
                                 (void const *)user_extra_data,
                                 (size_t)user_extra_data_len);
    ;
    if (tmp_27 != (size_t)user_extra_data_len) {
      mz_bool __attribute__((__visibility__("default"))) tmp_26;
      tmp_26 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_FILE_WRITE_FAILED);
      __retres = tmp_26;
      goto return_label;
    }
    cur_archive_file_ofs += (mz_uint64)user_extra_data_len;
  }
  if (max_size) {
    void *tmp_28;
    tmp_28 = (*(pZip->m_pAlloc))(pZip->m_pAlloc_opaque,(size_t)1,
                                 (size_t)MZ_ZIP_MAX_IO_BUF_SIZE);
    void *pRead_buf = tmp_28;
    if (! pRead_buf) {
      mz_bool __attribute__((__visibility__("default"))) tmp_29;
      tmp_29 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_ALLOC_FAILED);
      __retres = tmp_29;
      goto return_label;
    }
    if (! level) {
      while (1) {
        {
          size_t tmp_30;
          size_t tmp_33;
          mz_ulong __attribute__((__visibility__("default"))) tmp_34;
          tmp_30 = (*read_callback)(callback_opaque,file_ofs,pRead_buf,
                                    (size_t)MZ_ZIP_MAX_IO_BUF_SIZE);
          size_t n = tmp_30;
          if (n == (size_t)0) break;
          if (n > (size_t)MZ_ZIP_MAX_IO_BUF_SIZE) goto _LOR_2;
          else 
            if (file_ofs + n > max_size) {
              _LOR_2:
              {
                mz_bool __attribute__((__visibility__("default"))) tmp_31;
                (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,pRead_buf);
                tmp_31 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
                (pZip,MZ_ZIP_FILE_READ_FAILED);
                __retres = tmp_31;
                goto return_label;
              }
            }
          tmp_33 = (*(pZip->m_pWrite))(pZip->m_pIO_opaque,
                                       cur_archive_file_ofs,
                                       (void const *)pRead_buf,n);
          ;
          if (tmp_33 != n) {
            mz_bool __attribute__((__visibility__("default"))) tmp_32;
            (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,pRead_buf);
            tmp_32 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
            (pZip,MZ_ZIP_FILE_WRITE_FAILED);
            __retres = tmp_32;
            goto return_label;
          }
          file_ofs += n;
          tmp_34 = mz_crc32((mz_ulong)uncomp_crc32,
                            (mz_uint8 const *)pRead_buf,n);
          uncomp_crc32 = (mz_uint32)tmp_34;
          cur_archive_file_ofs += n;
        }
      }
      uncomp_size = file_ofs;
      comp_size = uncomp_size;
    }
    else {
      mz_zip_writer_add_state state;
      tdefl_compressor *tmp_35;
      tdefl_status __attribute__((__visibility__("default"))) tmp_39;
      mz_uint __attribute__((__visibility__("default"))) tmp_38;
      mz_bool result = 0;
      tmp_35 = (tdefl_compressor *)(*(pZip->m_pAlloc))(pZip->m_pAlloc_opaque,
                                                       (size_t)1,
                                                       sizeof(tdefl_compressor));
      tdefl_compressor *pComp = tmp_35;
      if (! pComp) {
        mz_bool __attribute__((__visibility__("default"))) tmp_36;
        (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,pRead_buf);
        tmp_36 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
        (pZip,MZ_ZIP_ALLOC_FAILED);
        __retres = tmp_36;
        goto return_label;
      }
      state.m_pZip = pZip;
      state.m_cur_archive_file_ofs = cur_archive_file_ofs;
      state.m_comp_size = (mz_uint64)0;
      tmp_38 = tdefl_create_comp_flags_from_zip_params((int)level,-15,
                                                       MZ_DEFAULT_STRATEGY);
      ;
      tmp_39 = tdefl_init(pComp,& mz_zip_writer_add_put_buf_callback,
                          (void *)(& state),(int)tmp_38);
      if (tmp_39 != (int __attribute__((__visibility__("default"))))TDEFL_STATUS_OKAY) {
        mz_bool __attribute__((__visibility__("default"))) tmp_37;
        (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,(void *)pComp);
        (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,pRead_buf);
        tmp_37 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
        (pZip,MZ_ZIP_INTERNAL_ERROR);
        __retres = tmp_37;
        goto return_label;
      }
      while (1) {
        tdefl_status status;
        size_t tmp_40;
        mz_ulong __attribute__((__visibility__("default"))) tmp_41;
        tdefl_status __attribute__((__visibility__("default"))) tmp_43;
        tdefl_flush flush = TDEFL_NO_FLUSH;
        tmp_40 = (*read_callback)(callback_opaque,file_ofs,pRead_buf,
                                  (size_t)MZ_ZIP_MAX_IO_BUF_SIZE);
        size_t n_0 = tmp_40;
        if (n_0 > (size_t)MZ_ZIP_MAX_IO_BUF_SIZE) goto _LOR_3;
        else 
          if (file_ofs + n_0 > max_size) {
            _LOR_3:
            {
              mz_zip_set_error(pZip,MZ_ZIP_FILE_READ_FAILED);
              break;
            }
          }
        file_ofs += n_0;
        tmp_41 = mz_crc32((mz_ulong)uncomp_crc32,(mz_uint8 const *)pRead_buf,
                          n_0);
        uncomp_crc32 = (mz_uint32)tmp_41;
        if (pZip->m_pNeeds_keepalive != (mz_bool (*)(void *pOpaque))0) {
          mz_bool tmp_42;
          tmp_42 = (*(pZip->m_pNeeds_keepalive))(pZip->m_pIO_opaque);
          if (tmp_42) flush = TDEFL_FULL_FLUSH;
        }
        if (n_0 == (size_t)0) flush = TDEFL_FINISH;
        tmp_43 = tdefl_compress_buffer(pComp,(void const *)pRead_buf,n_0,
                                       flush);
        status = (tdefl_status)tmp_43;
        if (status == TDEFL_STATUS_DONE) {
          result = 1;
          break;
        }
        else 
          if (status != TDEFL_STATUS_OKAY) {
            mz_zip_set_error(pZip,MZ_ZIP_COMPRESSION_FAILED);
            break;
          }
      }
      (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,(void *)pComp);
      if (! result) {
        (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,pRead_buf);
        __retres = (mz_bool __attribute__((__visibility__("default"))))0;
        goto return_label;
      }
      uncomp_size = file_ofs;
      comp_size = state.m_comp_size;
      cur_archive_file_ofs = state.m_cur_archive_file_ofs;
    }
    (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,pRead_buf);
  }
  {
    mz_uint8 local_dir_footer[MZ_ZIP_DATA_DESCRIPTER_SIZE64];
    size_t tmp_45;
    mz_uint32 local_dir_footer_size =
      (mz_uint32)MZ_ZIP_DATA_DESCRIPTER_SIZE32;
    mz_write_le32(& local_dir_footer[0],(mz_uint32)MZ_ZIP_DATA_DESCRIPTOR_ID);
    mz_write_le32(& local_dir_footer[4],uncomp_crc32);
    if (pExtra_data == (mz_uint8 *)0) {
      if (comp_size > (mz_uint64)0xFFFFFFFFU) {
        mz_bool __attribute__((__visibility__("default"))) tmp_44;
        tmp_44 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
        (pZip,MZ_ZIP_ARCHIVE_TOO_LARGE);
        __retres = tmp_44;
        goto return_label;
      }
      mz_write_le32(& local_dir_footer[8],(mz_uint32)comp_size);
      mz_write_le32(& local_dir_footer[12],(mz_uint32)uncomp_size);
    }
    else {
      mz_write_le64(& local_dir_footer[8],comp_size);
      mz_write_le64(& local_dir_footer[16],uncomp_size);
      local_dir_footer_size = (mz_uint32)MZ_ZIP_DATA_DESCRIPTER_SIZE64;
    }
    tmp_45 = (*(pZip->m_pWrite))(pZip->m_pIO_opaque,cur_archive_file_ofs,
                                 (void const *)(local_dir_footer),
                                 (size_t)local_dir_footer_size);
    ;
    if (tmp_45 != (size_t)local_dir_footer_size) {
      __retres = (mz_bool __attribute__((__visibility__("default"))))0;
      goto return_label;
    }
    cur_archive_file_ofs += (mz_uint64)local_dir_footer_size;
  }
  if (pExtra_data != (mz_uint8 *)0) {
    mz_uint64 *tmp_46;
    mz_uint64 *tmp_47;
    mz_uint64 *tmp_48;
    if (local_dir_header_ofs >= (mz_uint64)0xFFFFFFFFU) tmp_46 = & local_dir_header_ofs;
    else tmp_46 = (mz_uint64 *)0;
    if (uncomp_size >= (mz_uint64)0xFFFFFFFFU) tmp_47 = & comp_size;
    else tmp_47 = (mz_uint64 *)0;
    if (uncomp_size >= (mz_uint64)0xFFFFFFFFU) tmp_48 = & uncomp_size;
    else tmp_48 = (mz_uint64 *)0;
    extra_size = mz_zip_writer_create_zip64_extra_data(extra_data,tmp_48,
                                                       tmp_47,tmp_46);
  }
  tmp_49 = mz_zip_writer_add_to_central_dir(pZip,pArchive_name,
                                            (mz_uint16)archive_name_size,
                                            (void const *)pExtra_data,
                                            (mz_uint16)extra_size,pComment,
                                            comment_size,uncomp_size,
                                            comp_size,uncomp_crc32,method,
                                            gen_flags,dos_time,dos_date,
                                            local_dir_header_ofs,
                                            (mz_uint32)ext_attributes,
                                            user_extra_data_central,
                                            user_extra_data_central_len);
  if (! tmp_49) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  (pZip->m_total_files) ++;
  pZip->m_archive_size = cur_archive_file_ofs;
  __retres = (mz_bool __attribute__((__visibility__("default"))))1;
  return_label: return __retres;
}

static size_t mz_file_read_func_stdio(void *pOpaque, mz_uint64 file_ofs,
                                      void *pBuf, size_t n)
{
  size_t __retres;
  size_t tmp_1;
  FILE *pSrc_file = (FILE *)pOpaque;
  mz_int64 cur_ofs = ftello(pSrc_file);
  if ((mz_int64)file_ofs < (mz_int64)0) {
    __retres = (size_t)0;
    goto return_label;
  }
  else 
    if (cur_ofs != (mz_int64)file_ofs) {
      int tmp_0;
      tmp_0 = fseeko(pSrc_file,(mz_int64)file_ofs,0);
      if (tmp_0) {
        __retres = (size_t)0;
        goto return_label;
      }
    }
  tmp_1 = fread(pBuf,(size_t)1,n,pSrc_file);
  __retres = tmp_1;
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_add_cfile
(mz_zip_archive *pZip, char const *pArchive_name, FILE *pSrc_file,
 mz_uint64 max_size, time_t const *pFile_time, void const *pComment,
 mz_uint16 comment_size, mz_uint level_and_flags,
 char const *user_extra_data, mz_uint user_extra_data_len,
 char const *user_extra_data_central, mz_uint user_extra_data_central_len)
{
  mz_bool __attribute__((__visibility__("default"))) tmp;
  tmp = mz_zip_writer_add_read_buf_callback(pZip,pArchive_name,
                                            & mz_file_read_func_stdio,
                                            (void *)pSrc_file,max_size,
                                            pFile_time,pComment,comment_size,
                                            level_and_flags,user_extra_data,
                                            user_extra_data_len,
                                            user_extra_data_central,
                                            user_extra_data_central_len);
  return tmp;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_add_file
(mz_zip_archive *pZip, char const *pArchive_name, char const *pSrc_filename,
 void const *pComment, mz_uint16 comment_size, mz_uint level_and_flags)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  time_t file_modified_time;
  mz_bool status;
  mz_bool tmp_0;
  off_t tmp_2;
  FILE *pSrc_file = (FILE *)0;
  mz_uint64 uncomp_size = (mz_uint64)0;
  time_t *pFile_time = (time_t *)0;
  memset((void *)(& file_modified_time),0,sizeof(file_modified_time));
  pFile_time = & file_modified_time;
  tmp_0 = mz_zip_get_file_modified_time(pSrc_filename,& file_modified_time);
  if (! tmp_0) {
    mz_bool __attribute__((__visibility__("default"))) tmp;
    tmp = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_FILE_STAT_FAILED);
    __retres = tmp;
    goto return_label;
  }
  pSrc_file = fopen(pSrc_filename,"rb");
  if (! pSrc_file) {
    mz_bool __attribute__((__visibility__("default"))) tmp_1;
    tmp_1 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_FILE_OPEN_FAILED);
    __retres = tmp_1;
    goto return_label;
  }
  fseeko(pSrc_file,(off_t)0,2);
  tmp_2 = ftello(pSrc_file);
  uncomp_size = (mz_uint64)tmp_2;
  fseeko(pSrc_file,(off_t)0,0);
  status = (mz_bool)mz_zip_writer_add_cfile(pZip,pArchive_name,pSrc_file,
                                            uncomp_size,
                                            (time_t const *)pFile_time,
                                            pComment,comment_size,
                                            level_and_flags,(char const *)0,
                                            (mz_uint)0,(char const *)0,
                                            (mz_uint)0);
  fclose(pSrc_file);
  __retres = (mz_bool __attribute__((__visibility__("default"))))status;
  return_label: return __retres;
}

static mz_bool mz_zip_writer_update_zip64_extension_block(mz_zip_array *pNew_ext,
                                                          mz_zip_archive *pZip,
                                                          mz_uint8 const *pExt,
                                                          uint32_t ext_len,
                                                          mz_uint64 *pComp_size,
                                                          mz_uint64 *pUncomp_size,
                                                          mz_uint64 *pLocal_header_ofs,
                                                          mz_uint32 *pDisk_start)
{
  mz_bool __retres;
  mz_bool tmp_0;
  tmp_0 = mz_zip_array_reserve(pZip,pNew_ext,
                               (size_t)(ext_len + (uint32_t)64),(mz_uint)0);
  if (! tmp_0) {
    mz_bool tmp;
    tmp = mz_zip_set_error(pZip,MZ_ZIP_ALLOC_FAILED);
    __retres = tmp;
    goto return_label;
  }
  mz_zip_array_resize(pZip,pNew_ext,(size_t)0,(mz_uint)0);
  if (pUncomp_size) goto _LOR;
  else 
    if (pComp_size) goto _LOR;
    else 
      if (pLocal_header_ofs) goto _LOR;
      else 
        if (pDisk_start) {
          _LOR:
          {
            mz_uint8 new_ext_block[64];
            mz_bool tmp_2;
            mz_uint8 *pDst = new_ext_block;
            mz_write_le16(pDst,
                          (mz_uint16)MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID);
            mz_write_le16(pDst + sizeof(mz_uint16),(mz_uint16)0);
            pDst += sizeof(mz_uint16) * (unsigned long)2;
            if (pUncomp_size) {
              mz_write_le64(pDst,*pUncomp_size);
              pDst += sizeof(mz_uint64);
            }
            if (pComp_size) {
              mz_write_le64(pDst,*pComp_size);
              pDst += sizeof(mz_uint64);
            }
            if (pLocal_header_ofs) {
              mz_write_le64(pDst,*pLocal_header_ofs);
              pDst += sizeof(mz_uint64);
            }
            if (pDisk_start) {
              mz_write_le32(pDst,*pDisk_start);
              pDst += sizeof(mz_uint32);
            }
            mz_write_le16(& new_ext_block[sizeof(mz_uint16)],
                          (mz_uint16)((unsigned long)(pDst - new_ext_block) - 
                                      sizeof(mz_uint16) * (unsigned long)2));
            tmp_2 = mz_zip_array_push_back(pZip,pNew_ext,
                                           (void const *)(new_ext_block),
                                           (size_t)(pDst - new_ext_block));
            if (! tmp_2) {
              mz_bool tmp_1;
              tmp_1 = mz_zip_set_error(pZip,MZ_ZIP_ALLOC_FAILED);
              __retres = tmp_1;
              goto return_label;
            }
          }
        }
  if (pExt) 
    if (ext_len) {
      mz_uint32 extra_size_remaining = ext_len;
      mz_uint8 const *pExtra_data = pExt;
      while (1) {
        {
          mz_uint32 field_id;
          mz_uint32 field_data_size;
          mz_uint32 field_total_size;
          if ((unsigned long)extra_size_remaining < sizeof(mz_uint16) * (unsigned long)2) {
            mz_bool tmp_3;
            tmp_3 = mz_zip_set_error(pZip,MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
            __retres = tmp_3;
            goto return_label;
          }
          field_id = (mz_uint32)*((mz_uint16 const *)pExtra_data);
          field_data_size = (mz_uint32)*((mz_uint16 const *)(pExtra_data + sizeof(mz_uint16)));
          field_total_size = (mz_uint32)((unsigned long)field_data_size + 
                                         sizeof(mz_uint16) * (unsigned long)2);
          if (field_total_size > extra_size_remaining) {
            mz_bool tmp_4;
            tmp_4 = mz_zip_set_error(pZip,MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
            __retres = tmp_4;
            goto return_label;
          }
          if (field_id != (mz_uint32)MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID) {
            mz_bool tmp_6;
            tmp_6 = mz_zip_array_push_back(pZip,pNew_ext,
                                           (void const *)pExtra_data,
                                           (size_t)field_total_size);
            if (! tmp_6) {
              mz_bool tmp_5;
              tmp_5 = mz_zip_set_error(pZip,MZ_ZIP_ALLOC_FAILED);
              __retres = tmp_5;
              goto return_label;
            }
          }
          pExtra_data += field_total_size;
          extra_size_remaining -= field_total_size;
        }
        if (! extra_size_remaining) break;
      }
    }
  __retres = 1;
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_add_from_zip_reader
(mz_zip_archive *pZip, mz_zip_archive *pSource_zip, mz_uint src_file_index)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_uint n;
  mz_uint bit_flags;
  mz_uint num_alignment_padding_bytes;
  mz_uint src_central_dir_following_data_size;
  mz_uint64 src_archive_bytes_remaining;
  mz_uint64 local_dir_header_ofs;
  mz_uint64 cur_src_file_ofs;
  mz_uint64 cur_dst_file_ofs;
  mz_uint32 local_header_u32[(((unsigned long)MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32)) - (unsigned long)1) / sizeof(mz_uint32)];
  mz_uint8 new_central_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];
  size_t orig_central_dir_size;
  mz_zip_internal_state *pState;
  void *pBuf;
  mz_uint8 const *pSrc_central_header;
  mz_zip_archive_file_stat src_file_stat;
  mz_uint32 src_filename_len;
  mz_uint32 src_comment_len;
  mz_uint32 src_ext_len;
  mz_uint32 local_header_filename_size;
  mz_uint32 local_header_extra_len;
  mz_uint64 local_header_comp_size;
  mz_uint64 local_header_uncomp_size;
  mz_bool tmp_6;
  size_t tmp_8;
  mz_bool tmp_18;
  size_t tmp_20;
  mz_uint64 tmp_24;
  mz_uint64 tmp_22;
  mz_bool tmp_56;
  mz_uint8 *pLocal_header = (mz_uint8 *)(local_header_u32);
  mz_bool found_zip64_ext_data_in_ldir = 0;
  if (! pZip) goto _LOR;
  else 
    if (! pZip->m_pState) goto _LOR;
    else 
      if (pZip->m_zip_mode != (unsigned int)MZ_ZIP_MODE_WRITING) goto _LOR;
      else 
        if (! pSource_zip->m_pRead) {
          mz_bool __attribute__((__visibility__("default"))) tmp;
          _LOR:
          tmp = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
          (pZip,MZ_ZIP_INVALID_PARAMETER);
          __retres = tmp;
          goto return_label;
        }
  pState = pZip->m_pState;
  if ((pSource_zip->m_pState)->m_zip64) 
    if (! (pZip->m_pState)->m_zip64) {
      mz_bool __attribute__((__visibility__("default"))) tmp_0;
      tmp_0 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_INVALID_PARAMETER);
      __retres = tmp_0;
      goto return_label;
    }
  pSrc_central_header = mz_zip_get_cdh(pSource_zip,src_file_index);
  if ((mz_uint8 const *)0 == pSrc_central_header) {
    mz_bool __attribute__((__visibility__("default"))) tmp_1;
    tmp_1 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_INVALID_PARAMETER);
    __retres = tmp_1;
    goto return_label;
  }
  if (*((mz_uint32 const *)(pSrc_central_header + MZ_ZIP_CDH_SIG_OFS)) != (mz_uint32)MZ_ZIP_CENTRAL_DIR_HEADER_SIG) {
    mz_bool __attribute__((__visibility__("default"))) tmp_2;
    tmp_2 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
    __retres = tmp_2;
    goto return_label;
  }
  src_filename_len = (mz_uint32)*((mz_uint16 const *)(pSrc_central_header + MZ_ZIP_CDH_FILENAME_LEN_OFS));
  src_comment_len = (mz_uint32)*((mz_uint16 const *)(pSrc_central_header + MZ_ZIP_CDH_COMMENT_LEN_OFS));
  src_ext_len = (mz_uint32)*((mz_uint16 const *)(pSrc_central_header + MZ_ZIP_CDH_EXTRA_LEN_OFS));
  src_central_dir_following_data_size = (src_filename_len + src_ext_len) + src_comment_len;
  if (((pState->m_central_dir.m_size + (size_t)MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) + (size_t)src_central_dir_following_data_size) + (size_t)32 >= (size_t)0xFFFFFFFFU) {
    mz_bool __attribute__((__visibility__("default"))) tmp_3;
    tmp_3 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_UNSUPPORTED_CDIR_SIZE);
    __retres = tmp_3;
    goto return_label;
  }
  num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment
  (pZip);
  if (! pState->m_zip64) {
    if (pZip->m_total_files == 0xFFFFU) {
      mz_bool __attribute__((__visibility__("default"))) tmp_4;
      tmp_4 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_TOO_MANY_FILES);
      __retres = tmp_4;
      goto return_label;
    }
  }
  else 
    if (pZip->m_total_files == 0xFFFFFFFFU) {
      mz_bool __attribute__((__visibility__("default"))) tmp_5;
      tmp_5 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_TOO_MANY_FILES);
      __retres = tmp_5;
      goto return_label;
    }
  tmp_6 = mz_zip_file_stat_internal(pSource_zip,src_file_index,
                                    pSrc_central_header,& src_file_stat,
                                    (mz_bool *)0);
  if (! tmp_6) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  cur_src_file_ofs = src_file_stat.m_local_header_ofs;
  cur_dst_file_ofs = pZip->m_archive_size;
  tmp_8 = (*(pSource_zip->m_pRead))(pSource_zip->m_pIO_opaque,
                                    cur_src_file_ofs,(void *)pLocal_header,
                                    (size_t)MZ_ZIP_LOCAL_DIR_HEADER_SIZE);
  if (tmp_8 != (size_t)MZ_ZIP_LOCAL_DIR_HEADER_SIZE) {
    mz_bool __attribute__((__visibility__("default"))) tmp_7;
    tmp_7 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_FILE_READ_FAILED);
    __retres = tmp_7;
    goto return_label;
  }
  if (*((mz_uint32 const *)pLocal_header) != (mz_uint32)MZ_ZIP_LOCAL_DIR_HEADER_SIG) {
    mz_bool __attribute__((__visibility__("default"))) tmp_9;
    tmp_9 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
    __retres = tmp_9;
    goto return_label;
  }
  cur_src_file_ofs += (mz_uint64)MZ_ZIP_LOCAL_DIR_HEADER_SIZE;
  local_header_filename_size = (mz_uint32)*((mz_uint16 const *)(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS));
  local_header_extra_len = (mz_uint32)*((mz_uint16 const *)(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS));
  local_header_comp_size = (mz_uint64)*((mz_uint32 const *)(pLocal_header + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS));
  local_header_uncomp_size = (mz_uint64)*((mz_uint32 const *)(pLocal_header + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS));
  src_archive_bytes_remaining = (mz_uint64)(local_header_filename_size + local_header_extra_len) + src_file_stat.m_comp_size;
  if (local_header_extra_len) 
    if (local_header_comp_size == (mz_uint64)0xFFFFFFFFU) goto _LOR_0;
    else 
      if (local_header_uncomp_size == (mz_uint64)0xFFFFFFFFU) {
        _LOR_0:
        {
          mz_zip_array file_data_array;
          mz_uint8 const *pExtra_data;
          mz_bool tmp_11;
          size_t tmp_13;
          mz_uint32 extra_size_remaining = local_header_extra_len;
          mz_zip_array_init(& file_data_array,(mz_uint32)1);
          tmp_11 = mz_zip_array_resize(pZip,& file_data_array,
                                       (size_t)local_header_extra_len,
                                       (mz_uint)0);
          if (! tmp_11) {
            mz_bool __attribute__((__visibility__("default"))) tmp_10;
            tmp_10 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
            (pZip,MZ_ZIP_ALLOC_FAILED);
            __retres = tmp_10;
            goto return_label;
          }
          tmp_13 = (*(pSource_zip->m_pRead))(pSource_zip->m_pIO_opaque,
                                             (src_file_stat.m_local_header_ofs + (mz_uint64)MZ_ZIP_LOCAL_DIR_HEADER_SIZE) + (mz_uint64)local_header_filename_size,
                                             file_data_array.m_p,
                                             (size_t)local_header_extra_len);
          ;
          if (tmp_13 != (size_t)local_header_extra_len) {
            mz_bool __attribute__((__visibility__("default"))) tmp_12;
            mz_zip_array_clear(pZip,& file_data_array);
            tmp_12 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
            (pZip,MZ_ZIP_FILE_READ_FAILED);
            __retres = tmp_12;
            goto return_label;
          }
          pExtra_data = (mz_uint8 const *)file_data_array.m_p;
          while (1) {
            {
              mz_uint32 field_id;
              mz_uint32 field_data_size;
              mz_uint32 field_total_size;
              if ((unsigned long)extra_size_remaining < sizeof(mz_uint16) * (unsigned long)2) {
                mz_bool __attribute__((__visibility__("default"))) tmp_14;
                mz_zip_array_clear(pZip,& file_data_array);
                tmp_14 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
                (pZip,MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                __retres = tmp_14;
                goto return_label;
              }
              field_id = (mz_uint32)*((mz_uint16 const *)pExtra_data);
              field_data_size = (mz_uint32)*((mz_uint16 const *)(pExtra_data + sizeof(mz_uint16)));
              field_total_size = (mz_uint32)((unsigned long)field_data_size + 
                                             sizeof(mz_uint16) * (unsigned long)2);
              if (field_total_size > extra_size_remaining) {
                mz_bool __attribute__((__visibility__("default"))) tmp_15;
                mz_zip_array_clear(pZip,& file_data_array);
                tmp_15 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
                (pZip,MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                __retres = tmp_15;
                goto return_label;
              }
              if (field_id == (mz_uint32)MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID) {
                mz_uint8 const *pSrc_field_data =
                  pExtra_data + sizeof(mz_uint32);
                if ((unsigned long)field_data_size < sizeof(mz_uint64) * (unsigned long)2) {
                  mz_bool __attribute__((__visibility__("default"))) tmp_16;
                  mz_zip_array_clear(pZip,& file_data_array);
                  tmp_16 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
                  (pZip,MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                  __retres = tmp_16;
                  goto return_label;
                }
                local_header_uncomp_size = (mz_uint64)*((mz_uint32 const *)pSrc_field_data) | (
                                           (mz_uint64)*((mz_uint32 const *)(
                                           pSrc_field_data + sizeof(mz_uint32))) << 32U);
                local_header_comp_size = (mz_uint64)*((mz_uint32 const *)(
                                         pSrc_field_data + sizeof(mz_uint64))) | (
                                         (mz_uint64)*((mz_uint32 const *)(
                                         (pSrc_field_data + sizeof(mz_uint64)) + sizeof(mz_uint32))) << 32U);
                found_zip64_ext_data_in_ldir = 1;
                break;
              }
              pExtra_data += field_total_size;
              extra_size_remaining -= field_total_size;
            }
            if (! extra_size_remaining) break;
          }
          mz_zip_array_clear(pZip,& file_data_array);
        }
      }
  if (! pState->m_zip64) {
    mz_uint64 approx_new_archive_size =
      ((((((((cur_dst_file_ofs + (mz_uint64)num_alignment_padding_bytes) + (mz_uint64)MZ_ZIP_LOCAL_DIR_HEADER_SIZE) + src_archive_bytes_remaining) + 
           sizeof(mz_uint32) * (unsigned long)4) + pState->m_central_dir.m_size) + (mz_uint64)MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) + (mz_uint64)src_central_dir_following_data_size) + (mz_uint64)MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) + (mz_uint64)64;
    if (approx_new_archive_size >= (mz_uint64)0xFFFFFFFFU) {
      mz_bool __attribute__((__visibility__("default"))) tmp_17;
      tmp_17 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_ARCHIVE_TOO_LARGE);
      __retres = tmp_17;
      goto return_label;
    }
  }
  tmp_18 = mz_zip_writer_write_zeros(pZip,cur_dst_file_ofs,
                                     num_alignment_padding_bytes);
  if (! tmp_18) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  cur_dst_file_ofs += (mz_uint64)num_alignment_padding_bytes;
  local_dir_header_ofs = cur_dst_file_ofs;
  if (pZip->m_file_offset_alignment) __FC_assert(((local_dir_header_ofs & (
                                                   pZip->m_file_offset_alignment - (mz_uint64)1)) == (unsigned long)0) != 0,
                                                 "miniz_zip.c",4047,
                                                 "(local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0");
  tmp_20 = (*(pZip->m_pWrite))(pZip->m_pIO_opaque,cur_dst_file_ofs,
                               (void const *)pLocal_header,
                               (size_t)MZ_ZIP_LOCAL_DIR_HEADER_SIZE);
  if (tmp_20 != (size_t)MZ_ZIP_LOCAL_DIR_HEADER_SIZE) {
    mz_bool __attribute__((__visibility__("default"))) tmp_19;
    tmp_19 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_FILE_WRITE_FAILED);
    __retres = tmp_19;
    goto return_label;
  }
  cur_dst_file_ofs += (mz_uint64)MZ_ZIP_LOCAL_DIR_HEADER_SIZE;
  if ((mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE < src_archive_bytes_remaining) 
    tmp_22 = (mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE;
  else tmp_22 = src_archive_bytes_remaining;
  if ((mz_uint64)32U > tmp_22) tmp_24 = (mz_uint64)32U;
  else {
    mz_uint64 tmp_23;
    if ((mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE < src_archive_bytes_remaining) 
      tmp_23 = (mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE;
    else tmp_23 = src_archive_bytes_remaining;
    tmp_24 = tmp_23;
  }
  ;
  pBuf = (*(pZip->m_pAlloc))(pZip->m_pAlloc_opaque,(size_t)1,tmp_24);
  if ((void *)0 == pBuf) {
    mz_bool __attribute__((__visibility__("default"))) tmp_21;
    tmp_21 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_ALLOC_FAILED);
    __retres = tmp_21;
    goto return_label;
  }
  while (src_archive_bytes_remaining) {
    mz_uint64 tmp_25;
    size_t tmp_27;
    size_t tmp_29;
    if ((mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE < src_archive_bytes_remaining) 
      tmp_25 = (mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE;
    else tmp_25 = src_archive_bytes_remaining;
    n = (mz_uint)tmp_25;
    tmp_27 = (*(pSource_zip->m_pRead))(pSource_zip->m_pIO_opaque,
                                       cur_src_file_ofs,pBuf,(size_t)n);
    ;
    if (tmp_27 != (size_t)n) {
      mz_bool __attribute__((__visibility__("default"))) tmp_26;
      (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,pBuf);
      tmp_26 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_FILE_READ_FAILED);
      __retres = tmp_26;
      goto return_label;
    }
    cur_src_file_ofs += (mz_uint64)n;
    tmp_29 = (*(pZip->m_pWrite))(pZip->m_pIO_opaque,cur_dst_file_ofs,
                                 (void const *)pBuf,(size_t)n);
    ;
    if (tmp_29 != (size_t)n) {
      mz_bool __attribute__((__visibility__("default"))) tmp_28;
      (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,pBuf);
      tmp_28 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_FILE_WRITE_FAILED);
      __retres = tmp_28;
      goto return_label;
    }
    cur_dst_file_ofs += (mz_uint64)n;
    src_archive_bytes_remaining -= (mz_uint64)n;
  }
  bit_flags = (mz_uint)*((mz_uint16 const *)(pLocal_header + MZ_ZIP_LDH_BIT_FLAG_OFS));
  if (bit_flags & (unsigned int)8) {
    size_t tmp_38;
    if ((pSource_zip->m_pState)->m_zip64) goto _LOR_1;
    else 
      if (found_zip64_ext_data_in_ldir) {
        _LOR_1:
        {
          size_t tmp_31;
          int tmp_32;
          tmp_31 = (*(pSource_zip->m_pRead))(pSource_zip->m_pIO_opaque,
                                             cur_src_file_ofs,pBuf,
                                             sizeof(mz_uint32) * (unsigned long)6);
          if (tmp_31 != sizeof(mz_uint32) * (unsigned long)6) {
            mz_bool __attribute__((__visibility__("default"))) tmp_30;
            (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,pBuf);
            tmp_30 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
            (pZip,MZ_ZIP_FILE_READ_FAILED);
            __retres = tmp_30;
            goto return_label;
          }
          if (*((mz_uint32 const *)pBuf) == (mz_uint32)MZ_ZIP_DATA_DESCRIPTOR_ID) 
            tmp_32 = 6;
          else tmp_32 = 5;
          n = (mz_uint)(sizeof(mz_uint32) * (unsigned long)tmp_32);
        }
      }
      else {
        mz_bool has_id;
        size_t tmp_34;
        tmp_34 = (*(pSource_zip->m_pRead))(pSource_zip->m_pIO_opaque,
                                           cur_src_file_ofs,pBuf,
                                           sizeof(mz_uint32) * (unsigned long)4);
        if (tmp_34 != sizeof(mz_uint32) * (unsigned long)4) {
          mz_bool __attribute__((__visibility__("default"))) tmp_33;
          (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,pBuf);
          tmp_33 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
          (pZip,MZ_ZIP_FILE_READ_FAILED);
          __retres = tmp_33;
          goto return_label;
        }
        has_id = *((mz_uint32 const *)pBuf) == (mz_uint32)MZ_ZIP_DATA_DESCRIPTOR_ID;
        if ((pZip->m_pState)->m_zip64) {
          unsigned long tmp_35;
          if (has_id) tmp_35 = sizeof(mz_uint32);
          else tmp_35 = (unsigned long)0;
          mz_uint32 const *pSrc_descriptor =
            (mz_uint32 const *)((mz_uint8 const *)pBuf + tmp_35);
          mz_uint32 const src_crc32 = *(pSrc_descriptor + 0);
          mz_uint64 const src_comp_size = (mz_uint64)*(pSrc_descriptor + 1);
          mz_uint64 const src_uncomp_size =
            (mz_uint64)*(pSrc_descriptor + 2);
          mz_write_le32((mz_uint8 *)pBuf,
                        (mz_uint32)MZ_ZIP_DATA_DESCRIPTOR_ID);
          mz_write_le32((mz_uint8 *)pBuf + sizeof(mz_uint32) * (unsigned long)1,
                        src_crc32);
          mz_write_le64((mz_uint8 *)pBuf + sizeof(mz_uint32) * (unsigned long)2,
                        src_comp_size);
          mz_write_le64((mz_uint8 *)pBuf + sizeof(mz_uint32) * (unsigned long)4,
                        src_uncomp_size);
          n = (mz_uint)(sizeof(mz_uint32) * (unsigned long)6);
        }
        else {
          int tmp_36;
          if (has_id) tmp_36 = 4; else tmp_36 = 3;
          n = (mz_uint)(sizeof(mz_uint32) * (unsigned long)tmp_36);
        }
      }
    tmp_38 = (*(pZip->m_pWrite))(pZip->m_pIO_opaque,cur_dst_file_ofs,
                                 (void const *)pBuf,(size_t)n);
    ;
    if (tmp_38 != (size_t)n) {
      mz_bool __attribute__((__visibility__("default"))) tmp_37;
      (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,pBuf);
      tmp_37 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_FILE_WRITE_FAILED);
      __retres = tmp_37;
      goto return_label;
    }
    cur_src_file_ofs += (mz_uint64)n;
    cur_dst_file_ofs += (mz_uint64)n;
  }
  (*(pZip->m_pFree))(pZip->m_pAlloc_opaque,pBuf);
  orig_central_dir_size = pState->m_central_dir.m_size;
  memcpy((void *)(new_central_header),(void const *)pSrc_central_header,
         (size_t)MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);
  if (pState->m_zip64) {
    mz_zip_array new_ext_block;
    mz_bool tmp_39;
    mz_bool tmp_41;
    mz_bool tmp_43;
    mz_bool tmp_45;
    mz_bool tmp_47;
    mz_uint8 const *pSrc_ext =
      (pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) + src_filename_len;
    mz_zip_array_init(& new_ext_block,(mz_uint32)sizeof(mz_uint8));
    mz_write_le32(& new_central_header[MZ_ZIP_CDH_COMPRESSED_SIZE_OFS],
                  0xFFFFFFFFU);
    mz_write_le32(& new_central_header[MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS],
                  0xFFFFFFFFU);
    mz_write_le32(& new_central_header[MZ_ZIP_CDH_LOCAL_HEADER_OFS],
                  0xFFFFFFFFU);
    tmp_39 = mz_zip_writer_update_zip64_extension_block(& new_ext_block,pZip,
                                                        pSrc_ext,src_ext_len,
                                                        & src_file_stat.m_comp_size,
                                                        & src_file_stat.m_uncomp_size,
                                                        & local_dir_header_ofs,
                                                        (mz_uint32 *)0);
    if (! tmp_39) {
      mz_zip_array_clear(pZip,& new_ext_block);
      __retres = (mz_bool __attribute__((__visibility__("default"))))0;
      goto return_label;
    }
    mz_write_le16(& new_central_header[MZ_ZIP_CDH_EXTRA_LEN_OFS],
                  (mz_uint16)new_ext_block.m_size);
    tmp_41 = mz_zip_array_push_back(pZip,& pState->m_central_dir,
                                    (void const *)(new_central_header),
                                    (size_t)MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);
    if (! tmp_41) {
      mz_bool __attribute__((__visibility__("default"))) tmp_40;
      mz_zip_array_clear(pZip,& new_ext_block);
      tmp_40 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_ALLOC_FAILED);
      __retres = tmp_40;
      goto return_label;
    }
    tmp_43 = mz_zip_array_push_back(pZip,& pState->m_central_dir,
                                    (void const *)(pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE),
                                    (size_t)src_filename_len);
    if (! tmp_43) {
      mz_bool __attribute__((__visibility__("default"))) tmp_42;
      mz_zip_array_clear(pZip,& new_ext_block);
      mz_zip_array_resize(pZip,& pState->m_central_dir,orig_central_dir_size,
                          (mz_uint)0);
      tmp_42 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_ALLOC_FAILED);
      __retres = tmp_42;
      goto return_label;
    }
    tmp_45 = mz_zip_array_push_back(pZip,& pState->m_central_dir,
                                    (void const *)new_ext_block.m_p,
                                    new_ext_block.m_size);
    if (! tmp_45) {
      mz_bool __attribute__((__visibility__("default"))) tmp_44;
      mz_zip_array_clear(pZip,& new_ext_block);
      mz_zip_array_resize(pZip,& pState->m_central_dir,orig_central_dir_size,
                          (mz_uint)0);
      tmp_44 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_ALLOC_FAILED);
      __retres = tmp_44;
      goto return_label;
    }
    tmp_47 = mz_zip_array_push_back(pZip,& pState->m_central_dir,
                                    (void const *)(((pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) + src_filename_len) + src_ext_len),
                                    (size_t)src_comment_len);
    if (! tmp_47) {
      mz_bool __attribute__((__visibility__("default"))) tmp_46;
      mz_zip_array_clear(pZip,& new_ext_block);
      mz_zip_array_resize(pZip,& pState->m_central_dir,orig_central_dir_size,
                          (mz_uint)0);
      tmp_46 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_ALLOC_FAILED);
      __retres = tmp_46;
      goto return_label;
    }
    mz_zip_array_clear(pZip,& new_ext_block);
  }
  else {
    mz_bool tmp_51;
    mz_bool tmp_53;
    if (cur_dst_file_ofs > (mz_uint64)0xFFFFFFFFU) {
      mz_bool __attribute__((__visibility__("default"))) tmp_48;
      tmp_48 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_ARCHIVE_TOO_LARGE);
      __retres = tmp_48;
      goto return_label;
    }
    if (local_dir_header_ofs >= (mz_uint64)0xFFFFFFFFU) {
      mz_bool __attribute__((__visibility__("default"))) tmp_49;
      tmp_49 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_ARCHIVE_TOO_LARGE);
      __retres = tmp_49;
      goto return_label;
    }
    mz_write_le32(& new_central_header[MZ_ZIP_CDH_LOCAL_HEADER_OFS],
                  (mz_uint32)local_dir_header_ofs);
    tmp_51 = mz_zip_array_push_back(pZip,& pState->m_central_dir,
                                    (void const *)(new_central_header),
                                    (size_t)MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);
    if (! tmp_51) {
      mz_bool __attribute__((__visibility__("default"))) tmp_50;
      tmp_50 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_ALLOC_FAILED);
      __retres = tmp_50;
      goto return_label;
    }
    tmp_53 = mz_zip_array_push_back(pZip,& pState->m_central_dir,
                                    (void const *)(pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE),
                                    (size_t)src_central_dir_following_data_size);
    if (! tmp_53) {
      mz_bool __attribute__((__visibility__("default"))) tmp_52;
      mz_zip_array_resize(pZip,& pState->m_central_dir,orig_central_dir_size,
                          (mz_uint)0);
      tmp_52 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_ALLOC_FAILED);
      __retres = tmp_52;
      goto return_label;
    }
  }
  if (pState->m_central_dir.m_size >= (size_t)0xFFFFFFFFU) {
    mz_bool __attribute__((__visibility__("default"))) tmp_54;
    mz_zip_array_resize(pZip,& pState->m_central_dir,orig_central_dir_size,
                        (mz_uint)0);
    tmp_54 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_UNSUPPORTED_CDIR_SIZE);
    __retres = tmp_54;
    goto return_label;
  }
  n = (mz_uint32)orig_central_dir_size;
  tmp_56 = mz_zip_array_push_back(pZip,& pState->m_central_dir_offsets,
                                  (void const *)(& n),(size_t)1);
  if (! tmp_56) {
    mz_bool __attribute__((__visibility__("default"))) tmp_55;
    mz_zip_array_resize(pZip,& pState->m_central_dir,orig_central_dir_size,
                        (mz_uint)0);
    tmp_55 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_ALLOC_FAILED);
    __retres = tmp_55;
    goto return_label;
  }
  (pZip->m_total_files) ++;
  pZip->m_archive_size = cur_dst_file_ofs;
  __retres = (mz_bool __attribute__((__visibility__("default"))))1;
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_finalize_archive
(mz_zip_archive *pZip)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_zip_internal_state *pState;
  mz_uint64 central_dir_ofs;
  mz_uint64 central_dir_size;
  mz_uint8 hdr[256];
  unsigned int tmp_8;
  unsigned int tmp_9;
  mz_uint64 tmp_10;
  mz_uint64 tmp_11;
  size_t tmp_13;
  if (! pZip) goto _LOR;
  else 
    if (! pZip->m_pState) goto _LOR;
    else 
      if (pZip->m_zip_mode != (unsigned int)MZ_ZIP_MODE_WRITING) {
        mz_bool __attribute__((__visibility__("default"))) tmp;
        _LOR:
        tmp = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
        (pZip,MZ_ZIP_INVALID_PARAMETER);
        __retres = tmp;
        goto return_label;
      }
  pState = pZip->m_pState;
  if (pState->m_zip64) {
    if (pZip->m_total_files > 0xFFFFFFFFU) goto _LOR_0;
    else 
      if (pState->m_central_dir.m_size >= (size_t)0xFFFFFFFFU) {
        mz_bool __attribute__((__visibility__("default"))) tmp_0;
        _LOR_0:
        tmp_0 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
        (pZip,MZ_ZIP_TOO_MANY_FILES);
        __retres = tmp_0;
        goto return_label;
      }
  }
  else 
    if (pZip->m_total_files > 0xFFFFU) goto _LOR_1;
    else 
      if ((pZip->m_archive_size + pState->m_central_dir.m_size) + (mz_uint64)MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE > (mz_uint64)0xFFFFFFFFU) {
        mz_bool __attribute__((__visibility__("default"))) tmp_1;
        _LOR_1:
        tmp_1 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
        (pZip,MZ_ZIP_TOO_MANY_FILES);
        __retres = tmp_1;
        goto return_label;
      }
  central_dir_ofs = (mz_uint64)0;
  central_dir_size = (mz_uint64)0;
  if (pZip->m_total_files) {
    size_t tmp_3;
    central_dir_ofs = pZip->m_archive_size;
    central_dir_size = pState->m_central_dir.m_size;
    pZip->m_central_directory_file_ofs = central_dir_ofs;
    tmp_3 = (*(pZip->m_pWrite))(pZip->m_pIO_opaque,central_dir_ofs,
                                (void const *)pState->m_central_dir.m_p,
                                central_dir_size);
    ;
    if (tmp_3 != central_dir_size) {
      mz_bool __attribute__((__visibility__("default"))) tmp_2;
      tmp_2 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_FILE_WRITE_FAILED);
      __retres = tmp_2;
      goto return_label;
    }
    pZip->m_archive_size += central_dir_size;
  }
  if (pState->m_zip64) {
    size_t tmp_5;
    size_t tmp_7;
    mz_uint64 rel_ofs_to_zip64_ecdr = pZip->m_archive_size;
    memset((void *)(& hdr),0,sizeof(hdr));
    mz_write_le32(& hdr[MZ_ZIP64_ECDH_SIG_OFS],
                  (mz_uint32)MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIG);
    mz_write_le64(& hdr[MZ_ZIP64_ECDH_SIZE_OF_RECORD_OFS],
                  ((unsigned long)MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE - sizeof(mz_uint32)) - sizeof(mz_uint64));
    mz_write_le16(& hdr[MZ_ZIP64_ECDH_VERSION_MADE_BY_OFS],(mz_uint16)0x031E);
    mz_write_le16(& hdr[MZ_ZIP64_ECDH_VERSION_NEEDED_OFS],(mz_uint16)0x002D);
    mz_write_le64(& hdr[MZ_ZIP64_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS],
                  (mz_uint64)pZip->m_total_files);
    mz_write_le64(& hdr[MZ_ZIP64_ECDH_CDIR_TOTAL_ENTRIES_OFS],
                  (mz_uint64)pZip->m_total_files);
    mz_write_le64(& hdr[MZ_ZIP64_ECDH_CDIR_SIZE_OFS],central_dir_size);
    mz_write_le64(& hdr[MZ_ZIP64_ECDH_CDIR_OFS_OFS],central_dir_ofs);
    tmp_5 = (*(pZip->m_pWrite))(pZip->m_pIO_opaque,pZip->m_archive_size,
                                (void const *)(hdr),
                                (size_t)MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE);
    if (tmp_5 != (size_t)MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE) {
      mz_bool __attribute__((__visibility__("default"))) tmp_4;
      tmp_4 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_FILE_WRITE_FAILED);
      __retres = tmp_4;
      goto return_label;
    }
    pZip->m_archive_size += (mz_uint64)MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE;
    memset((void *)(& hdr),0,sizeof(hdr));
    mz_write_le32(& hdr[MZ_ZIP64_ECDL_SIG_OFS],
                  (mz_uint32)MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIG);
    mz_write_le64(& hdr[MZ_ZIP64_ECDL_REL_OFS_TO_ZIP64_ECDR_OFS],
                  rel_ofs_to_zip64_ecdr);
    mz_write_le32(& hdr[MZ_ZIP64_ECDL_TOTAL_NUMBER_OF_DISKS_OFS],
                  (mz_uint32)1);
    tmp_7 = (*(pZip->m_pWrite))(pZip->m_pIO_opaque,pZip->m_archive_size,
                                (void const *)(hdr),
                                (size_t)MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE);
    if (tmp_7 != (size_t)MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE) {
      mz_bool __attribute__((__visibility__("default"))) tmp_6;
      tmp_6 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_FILE_WRITE_FAILED);
      __retres = tmp_6;
      goto return_label;
    }
    pZip->m_archive_size += (mz_uint64)MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE;
  }
  memset((void *)(& hdr),0,sizeof(hdr));
  mz_write_le32(& hdr[MZ_ZIP_ECDH_SIG_OFS],
                (mz_uint32)MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG);
  if (0xFFFFU < pZip->m_total_files) tmp_8 = 0xFFFFU;
  else tmp_8 = pZip->m_total_files;
  mz_write_le16(& hdr[MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS],
                (mz_uint16)tmp_8);
  if (0xFFFFU < pZip->m_total_files) tmp_9 = 0xFFFFU;
  else tmp_9 = pZip->m_total_files;
  mz_write_le16(& hdr[MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS],(mz_uint16)tmp_9);
  if ((mz_uint64)0xFFFFFFFFU < central_dir_size) tmp_10 = (mz_uint64)0xFFFFFFFFU;
  else tmp_10 = central_dir_size;
  mz_write_le32(& hdr[MZ_ZIP_ECDH_CDIR_SIZE_OFS],(mz_uint32)tmp_10);
  if ((mz_uint64)0xFFFFFFFFU < central_dir_ofs) tmp_11 = (mz_uint64)0xFFFFFFFFU;
  else tmp_11 = central_dir_ofs;
  mz_write_le32(& hdr[MZ_ZIP_ECDH_CDIR_OFS_OFS],(mz_uint32)tmp_11);
  tmp_13 = (*(pZip->m_pWrite))(pZip->m_pIO_opaque,pZip->m_archive_size,
                               (void const *)(hdr),
                               (size_t)MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE);
  if (tmp_13 != (size_t)MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) {
    mz_bool __attribute__((__visibility__("default"))) tmp_12;
    tmp_12 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_FILE_WRITE_FAILED);
    __retres = tmp_12;
    goto return_label;
  }
  if (pState->m_pFile) {
    int tmp_15;
    tmp_15 = fflush(pState->m_pFile);
    if (tmp_15 == -1) {
      mz_bool __attribute__((__visibility__("default"))) tmp_14;
      tmp_14 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_FILE_CLOSE_FAILED);
      __retres = tmp_14;
      goto return_label;
    }
  }
  pZip->m_archive_size += (mz_uint64)MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE;
  pZip->m_zip_mode = MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED;
  __retres = (mz_bool __attribute__((__visibility__("default"))))1;
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_finalize_heap_archive
(mz_zip_archive *pZip, void **ppBuf, size_t *pSize)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_bool __attribute__((__visibility__("default"))) tmp_2;
  size_t tmp_3;
  if (! ppBuf) goto _LOR;
  else 
    if (! pSize) {
      mz_bool __attribute__((__visibility__("default"))) tmp;
      _LOR:
      tmp = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_INVALID_PARAMETER);
      __retres = tmp;
      goto return_label;
    }
  *ppBuf = (void *)0;
  *pSize = (size_t)0;
  if (! pZip) goto _LOR_0;
  else 
    if (! pZip->m_pState) {
      mz_bool __attribute__((__visibility__("default"))) tmp_0;
      _LOR_0:
      tmp_0 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
      (pZip,MZ_ZIP_INVALID_PARAMETER);
      __retres = tmp_0;
      goto return_label;
    }
  if (pZip->m_pWrite != & mz_zip_heap_write_func) {
    mz_bool __attribute__((__visibility__("default"))) tmp_1;
    tmp_1 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_set_error
    (pZip,MZ_ZIP_INVALID_PARAMETER);
    __retres = tmp_1;
    goto return_label;
  }
  tmp_2 = mz_zip_writer_finalize_archive(pZip);
  if (! tmp_2) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  *ppBuf = (pZip->m_pState)->m_pMem;
  *pSize = (pZip->m_pState)->m_mem_size;
  (pZip->m_pState)->m_pMem = (void *)0;
  tmp_3 = (size_t)0;
  (pZip->m_pState)->m_mem_capacity = tmp_3;
  (pZip->m_pState)->m_mem_size = tmp_3;
  __retres = (mz_bool __attribute__((__visibility__("default"))))1;
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_writer_end(
                                                                    mz_zip_archive *pZip)
{
  mz_bool __attribute__((__visibility__("default"))) tmp;
  tmp = (mz_bool __attribute__((__visibility__("default"))))mz_zip_writer_end_internal
  (pZip,1);
  return tmp;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_add_mem_to_archive_file_in_place
(char const *pZip_filename, char const *pArchive_name, void const *pBuf,
 size_t buf_size, void const *pComment, mz_uint16 comment_size,
 mz_uint level_and_flags)
{
  mz_bool __attribute__((__visibility__("default"))) tmp;
  tmp = mz_zip_add_mem_to_archive_file_in_place_v2(pZip_filename,
                                                   pArchive_name,pBuf,
                                                   buf_size,pComment,
                                                   comment_size,
                                                   level_and_flags,
                                                   (mz_zip_error *)0);
  return tmp;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_add_mem_to_archive_file_in_place_v2
(char const *pZip_filename, char const *pArchive_name, void const *pBuf,
 size_t buf_size, void const *pComment, mz_uint16 comment_size,
 mz_uint level_and_flags, mz_zip_error *pErr)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  mz_bool status;
  mz_zip_archive zip_archive;
  struct stat file_stat;
  mz_bool tmp;
  int tmp_3;
  mz_bool __attribute__((__visibility__("default"))) tmp_4;
  mz_bool tmp_5;
  mz_bool created_new_archive = 0;
  mz_zip_error actual_err = MZ_ZIP_NO_ERROR;
  mz_zip_zero_struct(& zip_archive);
  if ((int)level_and_flags < 0) level_and_flags = (mz_uint)MZ_DEFAULT_LEVEL;
  if (! pZip_filename) goto _LOR;
  else 
    if (! pArchive_name) goto _LOR;
    else 
      if (buf_size) {
        if (! pBuf) goto _LOR; else goto _LAND_0;
      }
      else {
        _LAND_0: ;
        if (comment_size) {
          if (! pComment) goto _LOR; else goto _LAND;
        }
        else {
          _LAND: ;
          if ((level_and_flags & (unsigned int)0xF) > (unsigned int)MZ_UBER_COMPRESSION) {
            _LOR:
            {
              if (pErr) *pErr = MZ_ZIP_INVALID_PARAMETER;
              __retres = (mz_bool __attribute__((__visibility__("default"))))0;
              goto return_label;
            }
          }
        }
      }
  tmp = mz_zip_writer_validate_archive_name(pArchive_name);
  if (! tmp) {
    if (pErr) *pErr = MZ_ZIP_INVALID_FILENAME;
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  tmp_3 = stat(pZip_filename,& file_stat);
  if (tmp_3 != 0) {
    mz_bool __attribute__((__visibility__("default"))) tmp_0;
    tmp_0 = mz_zip_writer_init_file_v2(& zip_archive,pZip_filename,
                                       (mz_uint64)0,level_and_flags);
    if (! tmp_0) {
      if (pErr) *pErr = zip_archive.m_last_error;
      __retres = (mz_bool __attribute__((__visibility__("default"))))0;
      goto return_label;
    }
    created_new_archive = 1;
  }
  else {
    mz_bool __attribute__((__visibility__("default"))) tmp_1;
    mz_bool __attribute__((__visibility__("default"))) tmp_2;
    tmp_1 = mz_zip_reader_init_file_v2(& zip_archive,pZip_filename,
                                       level_and_flags | (unsigned int)MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY,
                                       (mz_uint64)0,(mz_uint64)0);
    if (! tmp_1) {
      if (pErr) *pErr = zip_archive.m_last_error;
      __retres = (mz_bool __attribute__((__visibility__("default"))))0;
      goto return_label;
    }
    tmp_2 = mz_zip_writer_init_from_reader_v2(& zip_archive,pZip_filename,
                                              level_and_flags);
    if (! tmp_2) {
      if (pErr) *pErr = zip_archive.m_last_error;
      mz_zip_reader_end_internal(& zip_archive,0);
      __retres = (mz_bool __attribute__((__visibility__("default"))))0;
      goto return_label;
    }
  }
  status = (mz_bool)mz_zip_writer_add_mem_ex(& zip_archive,pArchive_name,
                                             pBuf,buf_size,pComment,
                                             comment_size,level_and_flags,
                                             (mz_uint64)0,(mz_uint32)0);
  actual_err = zip_archive.m_last_error;
  tmp_4 = mz_zip_writer_finalize_archive(& zip_archive);
  if (! tmp_4) {
    if (! actual_err) actual_err = zip_archive.m_last_error;
    status = 0;
  }
  tmp_5 = mz_zip_writer_end_internal(& zip_archive,status);
  if (! tmp_5) {
    if (! actual_err) actual_err = zip_archive.m_last_error;
    status = 0;
  }
  if (! status) 
    if (created_new_archive) {
      int ignoredStatus = remove(pZip_filename);
      int tmp_7 = ignoredStatus;
    }
  if (pErr) *pErr = actual_err;
  __retres = (mz_bool __attribute__((__visibility__("default"))))status;
  return_label: return __retres;
}

void __attribute__((__visibility__("default"))) *mz_zip_extract_archive_file_to_heap_v2
(char const *pZip_filename, char const *pArchive_name, char const *pComment,
 size_t *pSize, mz_uint flags, mz_zip_error *pErr)
{
  void __attribute__((__visibility__("default"))) *__retres;
  mz_uint32 file_index;
  mz_zip_archive zip_archive;
  mz_bool __attribute__((__visibility__("default"))) tmp;
  mz_bool __attribute__((__visibility__("default"))) tmp_0;
  void *p = (void *)0;
  if (pSize) *pSize = (size_t)0;
  if (! pZip_filename) goto _LOR;
  else 
    if (! pArchive_name) {
      _LOR:
      {
        if (pErr) *pErr = MZ_ZIP_INVALID_PARAMETER;
        __retres = (void __attribute__((__visibility__("default"))) *)0;
        goto return_label;
      }
    }
  mz_zip_zero_struct(& zip_archive);
  tmp = mz_zip_reader_init_file_v2(& zip_archive,pZip_filename,
                                   flags | (unsigned int)MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY,
                                   (mz_uint64)0,(mz_uint64)0);
  if (! tmp) {
    if (pErr) *pErr = zip_archive.m_last_error;
    __retres = (void __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  tmp_0 = mz_zip_reader_locate_file_v2(& zip_archive,pArchive_name,pComment,
                                       flags,& file_index);
  if (tmp_0) p = (void *)mz_zip_reader_extract_to_heap(& zip_archive,
                                                       file_index,pSize,
                                                       flags);
  mz_zip_reader_end_internal(& zip_archive,p != (void *)0);
  if (pErr) *pErr = zip_archive.m_last_error;
  __retres = (void __attribute__((__visibility__("default"))) *)p;
  return_label: return __retres;
}

void __attribute__((__visibility__("default"))) *mz_zip_extract_archive_file_to_heap
(char const *pZip_filename, char const *pArchive_name, size_t *pSize,
 mz_uint flags)
{
  void __attribute__((__visibility__("default"))) *tmp;
  tmp = mz_zip_extract_archive_file_to_heap_v2(pZip_filename,pArchive_name,
                                               (char const *)0,pSize,flags,
                                               (mz_zip_error *)0);
  return tmp;
}

mz_zip_mode __attribute__((__visibility__("default"))) mz_zip_get_mode
(mz_zip_archive *pZip)
{
  mz_zip_mode __attribute__((__visibility__("default"))) __retres;
  unsigned int tmp;
  if (pZip) tmp = pZip->m_zip_mode;
  else tmp = (unsigned int)MZ_ZIP_MODE_INVALID;
  __retres = (mz_zip_mode __attribute__((__visibility__("default"))))tmp;
  return __retres;
}

mz_zip_type __attribute__((__visibility__("default"))) mz_zip_get_type
(mz_zip_archive *pZip)
{
  mz_zip_type __attribute__((__visibility__("default"))) __retres;
  unsigned int tmp;
  if (pZip) tmp = pZip->m_zip_type;
  else tmp = (unsigned int)MZ_ZIP_TYPE_INVALID;
  __retres = (mz_zip_type __attribute__((__visibility__("default"))))tmp;
  return __retres;
}

mz_zip_error __attribute__((__visibility__("default"))) mz_zip_set_last_error
(mz_zip_archive *pZip, mz_zip_error err_num)
{
  mz_zip_error __attribute__((__visibility__("default"))) __retres;
  mz_zip_error prev_err;
  if (! pZip) {
    __retres = MZ_ZIP_INVALID_PARAMETER;
    goto return_label;
  }
  prev_err = pZip->m_last_error;
  pZip->m_last_error = err_num;
  __retres = (mz_zip_error __attribute__((__visibility__("default"))))prev_err;
  return_label: return __retres;
}

mz_zip_error __attribute__((__visibility__("default"))) mz_zip_peek_last_error
(mz_zip_archive *pZip)
{
  mz_zip_error __attribute__((__visibility__("default"))) __retres;
  if (! pZip) {
    __retres = MZ_ZIP_INVALID_PARAMETER;
    goto return_label;
  }
  __retres = (mz_zip_error __attribute__((__visibility__("default"))))pZip->m_last_error;
  return_label: return __retres;
}

mz_zip_error __attribute__((__visibility__("default"))) mz_zip_clear_last_error
(mz_zip_archive *pZip)
{
  mz_zip_error __attribute__((__visibility__("default"))) tmp;
  tmp = mz_zip_set_last_error(pZip,MZ_ZIP_NO_ERROR);
  return tmp;
}

mz_zip_error __attribute__((__visibility__("default"))) mz_zip_get_last_error
(mz_zip_archive *pZip)
{
  mz_zip_error __attribute__((__visibility__("default"))) __retres;
  mz_zip_error prev_err;
  if (! pZip) {
    __retres = MZ_ZIP_INVALID_PARAMETER;
    goto return_label;
  }
  prev_err = pZip->m_last_error;
  pZip->m_last_error = MZ_ZIP_NO_ERROR;
  __retres = (mz_zip_error __attribute__((__visibility__("default"))))prev_err;
  return_label: return __retres;
}

char const __attribute__((__visibility__("default"))) *mz_zip_get_error_string
(mz_zip_error mz_err)
{
  char const __attribute__((__visibility__("default"))) *__retres;
  switch (mz_err) {
    case MZ_ZIP_NO_ERROR:
    __retres = (char const __attribute__((__visibility__("default"))) *)"no error";
    goto return_label;
    case MZ_ZIP_UNDEFINED_ERROR:
    __retres = (char const __attribute__((__visibility__("default"))) *)"undefined error";
    goto return_label;
    case MZ_ZIP_TOO_MANY_FILES:
    __retres = (char const __attribute__((__visibility__("default"))) *)"too many files";
    goto return_label;
    case MZ_ZIP_FILE_TOO_LARGE:
    __retres = (char const __attribute__((__visibility__("default"))) *)"file too large";
    goto return_label;
    case MZ_ZIP_UNSUPPORTED_METHOD:
    __retres = (char const __attribute__((__visibility__("default"))) *)"unsupported method";
    goto return_label;
    case MZ_ZIP_UNSUPPORTED_ENCRYPTION:
    __retres = (char const __attribute__((__visibility__("default"))) *)"unsupported encryption";
    goto return_label;
    case MZ_ZIP_UNSUPPORTED_FEATURE:
    __retres = (char const __attribute__((__visibility__("default"))) *)"unsupported feature";
    goto return_label;
    case MZ_ZIP_FAILED_FINDING_CENTRAL_DIR:
    __retres = (char const __attribute__((__visibility__("default"))) *)"failed finding central directory";
    goto return_label;
    case MZ_ZIP_NOT_AN_ARCHIVE:
    __retres = (char const __attribute__((__visibility__("default"))) *)"not a ZIP archive";
    goto return_label;
    case MZ_ZIP_INVALID_HEADER_OR_CORRUPTED:
    __retres = (char const __attribute__((__visibility__("default"))) *)"invalid header or archive is corrupted";
    goto return_label;
    case MZ_ZIP_UNSUPPORTED_MULTIDISK:
    __retres = (char const __attribute__((__visibility__("default"))) *)"unsupported multidisk archive";
    goto return_label;
    case MZ_ZIP_DECOMPRESSION_FAILED:
    __retres = (char const __attribute__((__visibility__("default"))) *)"decompression failed or archive is corrupted";
    goto return_label;
    case MZ_ZIP_COMPRESSION_FAILED:
    __retres = (char const __attribute__((__visibility__("default"))) *)"compression failed";
    goto return_label;
    case MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE:
    __retres = (char const __attribute__((__visibility__("default"))) *)"unexpected decompressed size";
    goto return_label;
    case MZ_ZIP_CRC_CHECK_FAILED:
    __retres = (char const __attribute__((__visibility__("default"))) *)"CRC-32 check failed";
    goto return_label;
    case MZ_ZIP_UNSUPPORTED_CDIR_SIZE:
    __retres = (char const __attribute__((__visibility__("default"))) *)"unsupported central directory size";
    goto return_label;
    case MZ_ZIP_ALLOC_FAILED:
    __retres = (char const __attribute__((__visibility__("default"))) *)"allocation failed";
    goto return_label;
    case MZ_ZIP_FILE_OPEN_FAILED:
    __retres = (char const __attribute__((__visibility__("default"))) *)"file open failed";
    goto return_label;
    case MZ_ZIP_FILE_CREATE_FAILED:
    __retres = (char const __attribute__((__visibility__("default"))) *)"file create failed";
    goto return_label;
    case MZ_ZIP_FILE_WRITE_FAILED:
    __retres = (char const __attribute__((__visibility__("default"))) *)"file write failed";
    goto return_label;
    case MZ_ZIP_FILE_READ_FAILED:
    __retres = (char const __attribute__((__visibility__("default"))) *)"file read failed";
    goto return_label;
    case MZ_ZIP_FILE_CLOSE_FAILED:
    __retres = (char const __attribute__((__visibility__("default"))) *)"file close failed";
    goto return_label;
    case MZ_ZIP_FILE_SEEK_FAILED:
    __retres = (char const __attribute__((__visibility__("default"))) *)"file seek failed";
    goto return_label;
    case MZ_ZIP_FILE_STAT_FAILED:
    __retres = (char const __attribute__((__visibility__("default"))) *)"file stat failed";
    goto return_label;
    case MZ_ZIP_INVALID_PARAMETER:
    __retres = (char const __attribute__((__visibility__("default"))) *)"invalid parameter";
    goto return_label;
    case MZ_ZIP_INVALID_FILENAME:
    __retres = (char const __attribute__((__visibility__("default"))) *)"invalid filename";
    goto return_label;
    case MZ_ZIP_BUF_TOO_SMALL:
    __retres = (char const __attribute__((__visibility__("default"))) *)"buffer too small";
    goto return_label;
    case MZ_ZIP_INTERNAL_ERROR:
    __retres = (char const __attribute__((__visibility__("default"))) *)"internal error";
    goto return_label;
    case MZ_ZIP_FILE_NOT_FOUND:
    __retres = (char const __attribute__((__visibility__("default"))) *)"file not found";
    goto return_label;
    case MZ_ZIP_ARCHIVE_TOO_LARGE:
    __retres = (char const __attribute__((__visibility__("default"))) *)"archive is too large";
    goto return_label;
    case MZ_ZIP_VALIDATION_FAILED:
    __retres = (char const __attribute__((__visibility__("default"))) *)"validation failed";
    goto return_label;
    case MZ_ZIP_WRITE_CALLBACK_FAILED:
    __retres = (char const __attribute__((__visibility__("default"))) *)"write calledback failed";
    goto return_label;
    default: break;
  }
  __retres = (char const __attribute__((__visibility__("default"))) *)"unknown error";
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_is_zip64(mz_zip_archive *pZip)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  if (! pZip) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  else 
    if (! pZip->m_pState) {
      __retres = (mz_bool __attribute__((__visibility__("default"))))0;
      goto return_label;
    }
  __retres = (mz_bool __attribute__((__visibility__("default"))))(pZip->m_pState)->m_zip64;
  return_label: return __retres;
}

size_t __attribute__((__visibility__("default"))) mz_zip_get_central_dir_size
(mz_zip_archive *pZip)
{
  size_t __attribute__((__visibility__("default"))) __retres;
  if (! pZip) {
    __retres = (size_t __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  else 
    if (! pZip->m_pState) {
      __retres = (size_t __attribute__((__visibility__("default"))))0;
      goto return_label;
    }
  __retres = (size_t __attribute__((__visibility__("default"))))(pZip->m_pState)->m_central_dir.m_size;
  return_label: return __retres;
}

mz_uint __attribute__((__visibility__("default"))) mz_zip_reader_get_num_files
(mz_zip_archive *pZip)
{
  mz_uint __attribute__((__visibility__("default"))) __retres;
  mz_uint32 tmp;
  if (pZip) tmp = pZip->m_total_files; else tmp = (mz_uint32)0;
  __retres = (mz_uint __attribute__((__visibility__("default"))))tmp;
  return __retres;
}

mz_uint64 __attribute__((__visibility__("default"))) mz_zip_get_archive_size
(mz_zip_archive *pZip)
{
  mz_uint64 __attribute__((__visibility__("default"))) __retres;
  if (! pZip) {
    __retres = (mz_uint64 __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  __retres = (mz_uint64 __attribute__((__visibility__("default"))))pZip->m_archive_size;
  return_label: return __retres;
}

mz_uint64 __attribute__((__visibility__("default"))) mz_zip_get_archive_file_start_offset
(mz_zip_archive *pZip)
{
  mz_uint64 __attribute__((__visibility__("default"))) __retres;
  if (! pZip) {
    __retres = (mz_uint64 __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  else 
    if (! pZip->m_pState) {
      __retres = (mz_uint64 __attribute__((__visibility__("default"))))0;
      goto return_label;
    }
  __retres = (mz_uint64 __attribute__((__visibility__("default"))))(pZip->m_pState)->m_file_archive_start_ofs;
  return_label: return __retres;
}

FILE __attribute__((__visibility__("default"))) *mz_zip_get_cfile(mz_zip_archive *pZip)
{
  FILE __attribute__((__visibility__("default"))) *__retres;
  if (! pZip) {
    __retres = (FILE __attribute__((__visibility__("default"))) *)0;
    goto return_label;
  }
  else 
    if (! pZip->m_pState) {
      __retres = (FILE __attribute__((__visibility__("default"))) *)0;
      goto return_label;
    }
  __retres = (FILE __attribute__((__visibility__("default"))) *)(pZip->m_pState)->m_pFile;
  return_label: return __retres;
}

size_t __attribute__((__visibility__("default"))) mz_zip_read_archive_data
(mz_zip_archive *pZip, mz_uint64 file_ofs, void *pBuf, size_t n)
{
  size_t __attribute__((__visibility__("default"))) __retres;
  size_t __attribute__((__visibility__("default"))) tmp_0;
  if (! pZip) goto _LOR;
  else 
    if (! pZip->m_pState) goto _LOR;
    else 
      if (! pBuf) goto _LOR;
      else 
        if (! pZip->m_pRead) {
          mz_bool tmp;
          _LOR: tmp = mz_zip_set_error(pZip,MZ_ZIP_INVALID_PARAMETER);
          __retres = (size_t __attribute__((__visibility__("default"))))tmp;
          goto return_label;
        }
  tmp_0 = (size_t __attribute__((__visibility__("default"))))(*(pZip->m_pRead))
  (pZip->m_pIO_opaque,file_ofs,pBuf,n);
  __retres = tmp_0;
  return_label: return __retres;
}

mz_uint __attribute__((__visibility__("default"))) mz_zip_reader_get_filename
(mz_zip_archive *pZip, mz_uint file_index, char *pFilename,
 mz_uint filename_buf_size)
{
  mz_uint __attribute__((__visibility__("default"))) __retres;
  mz_uint n;
  mz_uint8 const *p = mz_zip_get_cdh(pZip,file_index);
  if (! p) {
    if (filename_buf_size) *(pFilename + 0) = (char)'\000';
    mz_zip_set_error(pZip,MZ_ZIP_INVALID_PARAMETER);
    __retres = (mz_uint __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  n = (mz_uint)*((mz_uint16 const *)(p + MZ_ZIP_CDH_FILENAME_LEN_OFS));
  if (filename_buf_size) {
    if (n < filename_buf_size - (mz_uint)1) n = n;
    else n = filename_buf_size - (mz_uint)1;
    memcpy((void *)pFilename,
           (void const *)(p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE),(size_t)n);
    *(pFilename + n) = (char)'\000';
  }
  __retres = (mz_uint __attribute__((__visibility__("default"))))(n + (mz_uint)1);
  return_label: return __retres;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_reader_file_stat
(mz_zip_archive *pZip, mz_uint file_index, mz_zip_archive_file_stat *pStat)
{
  mz_bool __attribute__((__visibility__("default"))) tmp_0;
  mz_uint8 const *tmp;
  ;
  tmp = mz_zip_get_cdh(pZip,file_index);
  ;
  ;
  tmp_0 = (mz_bool __attribute__((__visibility__("default"))))mz_zip_file_stat_internal
  (pZip,file_index,tmp,pStat,(mz_bool *)0);
  return tmp_0;
}

mz_bool __attribute__((__visibility__("default"))) mz_zip_end(mz_zip_archive *pZip)
{
  mz_bool __attribute__((__visibility__("default"))) __retres;
  if (! pZip) {
    __retres = (mz_bool __attribute__((__visibility__("default"))))0;
    goto return_label;
  }
  if (pZip->m_zip_mode == (unsigned int)MZ_ZIP_MODE_READING) {
    mz_bool __attribute__((__visibility__("default"))) tmp;
    tmp = mz_zip_reader_end(pZip);
    __retres = tmp;
    goto return_label;
  }
  else 
    if (pZip->m_zip_mode == (unsigned int)MZ_ZIP_MODE_WRITING) goto _LOR;
    else 
      if (pZip->m_zip_mode == (unsigned int)MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED) {
        mz_bool __attribute__((__visibility__("default"))) tmp_0;
        _LOR: tmp_0 = mz_zip_writer_end(pZip);
        __retres = tmp_0;
        goto return_label;
      }
  __retres = (mz_bool __attribute__((__visibility__("default"))))0;
  return_label: return __retres;
}


