/* Generated by Frama-C */
#include "errno.h"
#include "stdarg.h"
#include "stddef.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "strings.h"
enum __anonenum_jsmntype_t_1 {
    JSMN_UNDEFINED = 0,
    JSMN_OBJECT = 1,
    JSMN_ARRAY = 2,
    JSMN_STRING = 3,
    JSMN_PRIMITIVE = 4
};
typedef enum __anonenum_jsmntype_t_1 jsmntype_t;
enum jsmnerr {
    JSMN_ERROR_NOMEM = -1,
    JSMN_ERROR_INVAL = -2,
    JSMN_ERROR_PART = -3
};
struct __anonstruct_jsmntok_t_2 {
   jsmntype_t type ;
   int start ;
   int end ;
   int size ;
};
typedef struct __anonstruct_jsmntok_t_2 jsmntok_t;
struct __anonstruct_jsmn_parser_3 {
   unsigned int pos ;
   unsigned int toknext ;
   int toksuper ;
};
typedef struct __anonstruct_jsmn_parser_3 jsmn_parser;
void jsmn_init(jsmn_parser *parser);

int jsmn_parse(jsmn_parser *parser, char const *js, size_t len,
               jsmntok_t *tokens, unsigned int num_tokens);

static jsmntok_t *jsmn_alloc_token(jsmn_parser *parser, jsmntok_t *tokens,
                                   size_t num_tokens)
{
  jsmntok_t *__retres;
  jsmntok_t *tok;
  unsigned int tmp;
  int tmp_0;
  if (parser->toknext >= num_tokens) {
    __retres = (jsmntok_t *)0;
    goto return_label;
  }
  tmp = parser->toknext;
  (parser->toknext) ++;
  tok = tokens + tmp;
  tmp_0 = -1;
  tok->end = tmp_0;
  tok->start = tmp_0;
  tok->size = 0;
  __retres = tok;
  return_label: return __retres;
}

static void jsmn_fill_token(jsmntok_t *token, jsmntype_t type, int start,
                            int end)
{
  token->type = type;
  token->start = start;
  token->end = end;
  token->size = 0;
  return;
}

static int jsmn_parse_primitive(jsmn_parser *parser, char const *js,
                                size_t len, jsmntok_t *tokens,
                                size_t num_tokens)
{
  int __retres;
  jsmntok_t *token;
  int start;
  start = (int)parser->pos;
  while (1) {
    if (parser->pos < len) {
      if (! ((int)*(js + parser->pos) != '\000')) break;
    }
    else break;
    switch ((int)*(js + parser->pos)) case ':': case '\t': case '\r':
                                      case '\n': case ' ': case ',':
                                      case ']': case '}':
                                      goto found;
    if ((int)*(js + parser->pos) < 32) goto _LOR;
    else 
      if ((int)*(js + parser->pos) >= 127) {
        _LOR:
        {
          parser->pos = (unsigned int)start;
          __retres = JSMN_ERROR_INVAL;
          goto return_label;
        }
      }
    (parser->pos) ++;
  }
  found: ;
  if (tokens == (jsmntok_t *)0) {
    (parser->pos) --;
    __retres = 0;
    goto return_label;
  }
  token = jsmn_alloc_token(parser,tokens,num_tokens);
  if (token == (jsmntok_t *)0) {
    parser->pos = (unsigned int)start;
    __retres = JSMN_ERROR_NOMEM;
    goto return_label;
  }
  jsmn_fill_token(token,JSMN_PRIMITIVE,start,(int)parser->pos);
  (parser->pos) --;
  __retres = 0;
  return_label: return __retres;
}

static int jsmn_parse_string(jsmn_parser *parser, char const *js, size_t len,
                             jsmntok_t *tokens, size_t num_tokens)
{
  int __retres;
  jsmntok_t *token;
  int start = (int)parser->pos;
  (parser->pos) ++;
  while (1) {
    if (parser->pos < len) {
      if (! ((int)*(js + parser->pos) != '\000')) break;
    }
    else break;
    {
      char c = *(js + parser->pos);
      if ((int)c == '\"') {
        if (tokens == (jsmntok_t *)0) {
          __retres = 0;
          goto return_label;
        }
        token = jsmn_alloc_token(parser,tokens,num_tokens);
        if (token == (jsmntok_t *)0) {
          parser->pos = (unsigned int)start;
          __retres = JSMN_ERROR_NOMEM;
          goto return_label;
        }
        jsmn_fill_token(token,JSMN_STRING,start + 1,(int)parser->pos);
        __retres = 0;
        goto return_label;
      }
      if ((int)c == '\\') 
        if (parser->pos + (unsigned int)1 < len) {
          int i;
          (parser->pos) ++;
          switch ((int)*(js + parser->pos)) {
            case '\"': case '/': case '\\': case 'b': case 'f': case 'r':
            case 'n': case 't':
            break;
            case 'u': (parser->pos) ++;
            i = 0;
            while (1) {
              if (i < 4) 
                if (parser->pos < len) {
                  if (! ((int)*(js + parser->pos) != '\000')) break;
                }
                else break;
              else break;
              if ((int)*(js + parser->pos) >= 48) {
                if (! ((int)*(js + parser->pos) <= 57)) goto _LAND_1;
              }
              else {
                _LAND_1: ;
                if ((int)*(js + parser->pos) >= 65) {
                  if (! ((int)*(js + parser->pos) <= 70)) goto _LAND_0;
                }
                else {
                  _LAND_0: ;
                  if ((int)*(js + parser->pos) >= 97) {
                    if (! ((int)*(js + parser->pos) <= 102)) goto _LAND;
                  }
                  else {
                    _LAND:
                    {
                      parser->pos = (unsigned int)start;
                      __retres = JSMN_ERROR_INVAL;
                      goto return_label;
                    }
                  }
                }
              }
              (parser->pos) ++;
              i ++;
            }
            (parser->pos) --;
            break;
            default: parser->pos = (unsigned int)start;
            __retres = JSMN_ERROR_INVAL;
            goto return_label;
          }
        }
    }
    (parser->pos) ++;
  }
  parser->pos = (unsigned int)start;
  __retres = JSMN_ERROR_PART;
  return_label: return __retres;
}

int jsmn_parse(jsmn_parser *parser, char const *js, size_t len,
               jsmntok_t *tokens, unsigned int num_tokens)
{
  int __retres;
  int r;
  int i;
  jsmntok_t *token;
  int count = (int)parser->toknext;
  while (1) {
    if (parser->pos < len) {
      if (! ((int)*(js + parser->pos) != '\000')) break;
    }
    else break;
    {
      char c;
      jsmntype_t type;
      c = *(js + parser->pos);
      switch ((int)c) {
        case '{': case '[': count ++;
        if (tokens == (jsmntok_t *)0) break;
        token = jsmn_alloc_token(parser,tokens,num_tokens);
        if (token == (jsmntok_t *)0) {
          __retres = JSMN_ERROR_NOMEM;
          goto return_label;
        }
        if (parser->toksuper != -1) ((tokens + parser->toksuper)->size) ++;
        if ((int)c == '{') token->type = JSMN_OBJECT;
        else token->type = JSMN_ARRAY;
        token->start = (int)parser->pos;
        parser->toksuper = (int)(parser->toknext - (unsigned int)1);
        break;
        case '}': case ']': ;
        if (tokens == (jsmntok_t *)0) break;
        if ((int)c == '}') type = JSMN_OBJECT; else type = JSMN_ARRAY;
        i = (int)(parser->toknext - (unsigned int)1);
        while (i >= 0) {
          token = tokens + i;
          if (token->start != -1) 
            if (token->end == -1) {
              if (token->type != type) {
                __retres = JSMN_ERROR_INVAL;
                goto return_label;
              }
              parser->toksuper = -1;
              token->end = (int)(parser->pos + (unsigned int)1);
              break;
            }
          i --;
        }
        if (i == -1) {
          __retres = JSMN_ERROR_INVAL;
          goto return_label;
        }
        while (i >= 0) {
          token = tokens + i;
          if (token->start != -1) 
            if (token->end == -1) {
              parser->toksuper = i;
              break;
            }
          i --;
        }
        break;
        case '\"': r = jsmn_parse_string(parser,js,len,tokens,num_tokens);
        if (r < 0) {
          __retres = r;
          goto return_label;
        }
        count ++;
        if (parser->toksuper != -1) 
          if (tokens != (jsmntok_t *)0) ((tokens + parser->toksuper)->size) ++;
        break;
        case '\t': case '\r': case '\n': case ' ': break;
        case ':':
        parser->toksuper = (int)(parser->toknext - (unsigned int)1);
        break;
        case ',': ;
        if (tokens != (jsmntok_t *)0) 
          if (parser->toksuper != -1) 
            if ((tokens + parser->toksuper)->type != (unsigned int)JSMN_ARRAY) 
              if ((tokens + parser->toksuper)->type != (unsigned int)JSMN_OBJECT) {
                i = (int)(parser->toknext - (unsigned int)1);
                while (i >= 0) {
                  if ((tokens + i)->type == (unsigned int)JSMN_ARRAY) 
                    goto _LOR;
                  else 
                    if ((tokens + i)->type == (unsigned int)JSMN_OBJECT) 
                      _LOR:
                      if ((tokens + i)->start != -1) 
                        if ((tokens + i)->end == -1) {
                          parser->toksuper = i;
                          break;
                        }
                  i --;
                }
              }
        break;
        default: r = jsmn_parse_primitive(parser,js,len,tokens,num_tokens);
        if (r < 0) {
          __retres = r;
          goto return_label;
        }
        count ++;
        if (parser->toksuper != -1) 
          if (tokens != (jsmntok_t *)0) ((tokens + parser->toksuper)->size) ++;
        break;
      }
    }
    (parser->pos) ++;
  }
  if (tokens != (jsmntok_t *)0) {
    i = (int)(parser->toknext - (unsigned int)1);
    while (i >= 0) {
      if ((tokens + i)->start != -1) 
        if ((tokens + i)->end == -1) {
          __retres = JSMN_ERROR_PART;
          goto return_label;
        }
      i --;
    }
  }
  __retres = count;
  return_label: return __retres;
}

void jsmn_init(jsmn_parser *parser)
{
  parser->pos = (unsigned int)0;
  parser->toknext = (unsigned int)0;
  parser->toksuper = -1;
  return;
}

static char const *JSON_STRING =
  "{\"user\": \"johndoe\", \"admin\": false, \"uid\": 1000,\n  \"groups\": [\"users\", \"wheel\", \"audio\", \"video\"]}";
static int jsoneq(char const *json, jsmntok_t *tok, char const *s)
{
  int __retres;
  if (tok->type == (unsigned int)JSMN_STRING) {
    size_t tmp;
    tmp = strlen(s);
    ;
    if ((int)tmp == tok->end - tok->start) {
      int tmp_0;
      tmp_0 = strncmp(json + tok->start,s,(size_t)(tok->end - tok->start));
      if (tmp_0 == 0) {
        __retres = 0;
        goto return_label;
      }
    }
  }
  __retres = -1;
  return_label: return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_1(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_2(char const * restrict format);

/*@ requires valid_read_nstring(param1, param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param1 + (0 ..)), param0;
 */
int printf_va_3(char const * restrict format, int param0, char *param1);

/*@ requires valid_read_nstring(param1, param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param1 + (0 ..)), param0;
 */
int printf_va_4(char const * restrict format, int param0, char *param1);

/*@ requires valid_read_nstring(param1, param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param1 + (0 ..)), param0;
 */
int printf_va_5(char const * restrict format, int param0, char *param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_6(char const * restrict format);

/*@ requires valid_read_nstring(param1, param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param1 + (0 ..)), param0;
 */
int printf_va_7(char const * restrict format, int param0, char *param1);

/*@ requires valid_read_nstring(param1, param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param1 + (0 ..)), param0;
 */
int printf_va_8(char const * restrict format, int param0, char *param1);

int main(void)
{
  int __retres;
  int i;
  int r;
  jsmn_parser p;
  jsmntok_t t[128];
  size_t tmp;
  jsmn_init(& p);
  tmp = strlen(JSON_STRING);
  ;
  r = jsmn_parse(& p,JSON_STRING,tmp,t,sizeof(t) / sizeof(t[0]));
  if (r < 0) {
    printf("Failed to parse JSON: %d\n",r); /* printf_va_1 */
    __retres = 1;
    goto return_label;
  }
  if (r < 1) goto _LOR;
  else 
    if (t[0].type != (unsigned int)JSMN_OBJECT) {
      _LOR:
      {
        printf("Object expected\n"); /* printf_va_2 */
        __retres = 1;
        goto return_label;
      }
    }
  i = 1;
  while (i < r) {
    {
      int tmp_3;
      tmp_3 = jsoneq(JSON_STRING,& t[i],"user");
      if (tmp_3 == 0) {
        printf("- User: %.*s\n",t[i + 1].end - t[i + 1].start,
               (char *)(JSON_STRING + t[i + 1].start)); /* printf_va_3 */
        i ++;
      }
      else {
        int tmp_2;
        tmp_2 = jsoneq(JSON_STRING,& t[i],"admin");
        if (tmp_2 == 0) {
          printf("- Admin: %.*s\n",t[i + 1].end - t[i + 1].start,
                 (char *)(JSON_STRING + t[i + 1].start)); /* printf_va_4 */
          i ++;
        }
        else {
          int tmp_1;
          tmp_1 = jsoneq(JSON_STRING,& t[i],"uid");
          if (tmp_1 == 0) {
            printf("- UID: %.*s\n",t[i + 1].end - t[i + 1].start,
                   (char *)(JSON_STRING + t[i + 1].start)); /* printf_va_5 */
            i ++;
          }
          else {
            int tmp_0;
            tmp_0 = jsoneq(JSON_STRING,& t[i],"groups");
            if (tmp_0 == 0) {
              int j;
              printf("- Groups:\n"); /* printf_va_6 */
              if (t[i + 1].type != (unsigned int)JSMN_ARRAY) goto __Cont;
              j = 0;
              while (j < t[i + 1].size) {
                {
                  jsmntok_t *g = & t[(i + j) + 2];
                  printf("  * %.*s\n",g->end - g->start,
                         (char *)(JSON_STRING + g->start)); /* printf_va_7 */
                }
                j ++;
              }
              i += t[i + 1].size + 1;
            }
            else printf("Unexpected key: %.*s\n",t[i].end - t[i].start,
                        (char *)(JSON_STRING + t[i].start)); /* printf_va_8 */
          }
        }
      }
    }
    __Cont: i ++;
  }
  __retres = 0;
  return_label: return __retres;
}


