Entering directory '/Users/carolt/Abstract_Interpretation/Tools_Development/Frama-c-Plugin/src/demo_1'
Leaving directory '/Users/carolt/Abstract_Interpretation/Tools_Development/Frama-c-Plugin/src/demo_1'
[kernel] Parsing test/tests.c (with preprocessing)
[variadic:typing] test/testutil.h:30: Warning: 
  Incorrect type for argument 3. The argument will be cast from jsmntype_t (unsigned int) to int.
mkdir: .parf_temp_files: File exists
rm: .parf_temp_files/*.sav: No such file or directory
[parf] checkout project: project "default"
[parf] init parameters: -eva-widening-delay 1 -eva-subdivide-non-linear 0 -eva-slevel 0 -eva-plevel 10 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 8 -eva-equality-through-calls none -eva-domains cvalue -eva-auto-loop-unroll 0
[parf] run eva: start
[parf] set eva options
[parf] parameters: -eva-widening-delay 1 -eva-subdivide-non-linear 0 -eva-slevel 0 -eva-plevel 10 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 8 -eva-equality-through-calls none -eva-domains cvalue -eva-auto-loop-unroll 0
[parf] @default,cvalue
[eva] Analyzing a complete application starting at main
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76
[eva] jsmn.c:158: starting to merge loop iterations
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:209: starting to merge loop iterations
[eva] using specification for function printf_va_7
[eva] test/testutil.h:14: starting to merge loop iterations
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_0
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_1
[eva] jsmn.c:250: starting to merge loop iterations
[eva] using specification for function printf_va_2
[eva] using specification for function printf_va_1
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_2
[eva] jsmn.c:93: starting to merge loop iterations
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_6
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_3
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_4
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_5
[eva] jsmn.c:125: starting to merge loop iterations
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_6
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_7
[eva] jsmn.c:42: starting to merge loop iterations
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_8
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_9
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_10
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_11
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_12
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_13
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_14
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_15
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_16
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_17
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_18
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_19
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_20
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_21
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_22
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_23
[eva] test/tests.c:83: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] test/tests.c:126: starting to merge loop iterations
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_24
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_25
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_26
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_27
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_28
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_29
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_30
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_31
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_32
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_33
[eva] using specification for function printf_va_8
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1215 statements reached (out of 1219): 99% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  58 alarms generated by the analysis:
      31 accesses to uninitialized left-values
      18 invalid memory accesses
       9 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    35 valid     2 unknown     0 invalid     37 total
  94% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[parf] base: base00
[parf] Analysis time for this epoch: 179
[parf] sample: base00-sample00
[parf] sample: base00-sample01
[parf] sample: base00-sample02
[parf] sample: base00-sample03
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 2 -eva-subdivide-non-linear 3 -eva-slevel 12 -eva-plevel 26 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 16 -eva-equality-through-calls none -eva-domains cvalue,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 9
[parf] set eva options
[parf] parameters: -eva-widening-delay 2 -eva-subdivide-non-linear 1 -eva-split-return auto -eva-slevel 8 -eva-remove-redundant-alarms -eva-plevel 28 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 16 -eva-equality-through-calls none -eva-domains cvalue,equality,octagon,symbolic-locations -eva-auto-loop-unroll 9
[parf] parameters: -eva-widening-delay 2 -eva-subdivide-non-linear 4 -eva-slevel 9 -eva-remove-redundant-alarms -eva-plevel 29 -eva-partition-history 2 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 16 -eva-equality-through-calls none -eva-domains cvalue,equality,octagon,symbolic-locations -eva-auto-loop-unroll 4
[parf] parameters: -eva-widening-delay 2 -eva-subdivide-non-linear 4 -eva-slevel 9 -eva-plevel 41 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 18 -eva-equality-through-calls none -eva-domains cvalue,symbolic-locations -eva-auto-loop-unroll 10
[parf] @default,cvalue,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,octagon,symbolic-locations
[parf] @default,cvalue,symbolic-locations
[parf] @default,cvalue,equality,octagon,symbolic-locations
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_parse) == -3, -1, 1, 2, 3, 4, 5, 7 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(tokeq) == 0 (auto)
  \return(parse) == 0 (auto)
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] Analyzing a complete application starting at main
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_6
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_6
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_6
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] test/testutil.h:91: cannot properly split on \result == 0
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] jsmn.c:158: starting to merge loop iterations
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_6
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:222: starting to merge loop iterations
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] using specification for function printf_va_7
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] using specification for function printf_va_5
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] jsmn.c:158: starting to merge loop iterations
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:158: starting to merge loop iterations
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:302: cannot properly split on \result == 4
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] jsmn.c:250: starting to merge loop iterations
[eva] jsmn.c:158: starting to merge loop iterations
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_5
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] using specification for function printf_va_2
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] jsmn.c:93: starting to merge loop iterations
[eva] jsmn.c:93: starting to merge loop iterations
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:42: starting to merge loop iterations
[eva] jsmn.c:42: starting to merge loop iterations
[eva] jsmn.c:250: starting to merge loop iterations
[eva] using specification for function printf_va_1
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] jsmn.c:294: starting to merge loop iterations
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] jsmn.c:250: starting to merge loop iterations
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_2
[eva] using specification for function printf_va_5
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] using specification for function printf_va_1
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] jsmn.c:294: starting to merge loop iterations
[eva] jsmn.c:302: cannot properly split on \result == -3
[eva] jsmn.c:302: cannot properly split on \result == 3
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] jsmn.c:93: starting to merge loop iterations
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] using specification for function printf_va_2
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] using specification for function printf_va_1
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] jsmn.c:250: starting to merge loop iterations
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] jsmn.c:93: starting to merge loop iterations
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] jsmn.c:42: starting to merge loop iterations
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/tests.c:83: starting to merge loop iterations
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/tests.c:83: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] jsmn.c:158: Trace partitioning superposing up to 100 states
[eva] jsmn.c:125: starting to merge loop iterations
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] jsmn.c:158: Trace partitioning superposing up to 100 states
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] test/tests.c:83: starting to merge loop iterations
[eva] jsmn.c:294: starting to merge loop iterations
[eva] test/testutil.h:68: cannot properly split on \result == 0
[eva] jsmn.c:125: starting to merge loop iterations
[eva] using specification for function printf_va_2
[eva] using specification for function printf_va_5
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] jsmn.c:302: cannot properly split on \result == 2
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] using specification for function printf_va_1
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] jsmn.c:302: cannot properly split on \result == 5
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] using specification for function printf_va_8
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] jsmn.c:250: Trace partitioning superposing up to 100 states
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1162 statements reached (out of 1219): 95% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  36 alarms generated by the analysis:
      21 accesses to uninitialized left-values
       9 invalid memory accesses
       6 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     2 unknown     0 invalid     35 total
  94% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] jsmn.c:133: Trace partitioning superposing up to 100 states
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] using specification for function printf_va_8
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1153 statements reached (out of 1219): 94% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  34 alarms generated by the analysis:
      18 accesses to uninitialized left-values
       9 invalid memory accesses
       7 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     2 unknown     0 invalid     35 total
  94% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] using specification for function printf_va_8
[eva] test/tests.c:83: starting to merge loop iterations
[scope:rm_asserts] removing 3 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1162 statements reached (out of 1219): 95% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  36 alarms generated by the analysis:
      21 accesses to uninitialized left-values
       8 invalid memory accesses
       7 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     2 unknown     0 invalid     35 total
  94% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] jsmn.c:125: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] using specification for function printf_va_8
[scope:rm_asserts] removing 4 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1156 statements reached (out of 1219): 94% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  38 alarms generated by the analysis:
      22 accesses to uninitialized left-values
       8 invalid memory accesses
       8 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     2 unknown     0 invalid     35 total
  94% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] sample base00-sample00: subset of base? false
[parf] sample base00-sample01: subset of base? false
[parf] sample base00-sample03: subset of base? true
[parf] sample base00-sample02: subset of base? false
[parf] base: base01
[parf] Analysis time for this epoch: 359
[parf] sample: base01-sample00
[parf] sample: base01-sample01
[parf] sample: base01-sample02
[parf] sample: base01-sample03
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 4 -eva-subdivide-non-linear 10 -eva-slevel 23 -eva-remove-redundant-alarms -eva-plevel 79 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 36 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 16
[parf] set eva options
[parf] parameters: -eva-widening-delay 5 -eva-subdivide-non-linear 11 -eva-split-return auto -eva-slevel 22 -eva-remove-redundant-alarms -eva-plevel 91 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 37 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 24
[parf] parameters: -eva-widening-delay 3 -eva-subdivide-non-linear 8 -eva-split-return auto -eva-slevel 22 -eva-remove-redundant-alarms -eva-plevel 84 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 45 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 20
[parf] parameters: -eva-widening-delay 3 -eva-subdivide-non-linear 11 -eva-slevel 26 -eva-remove-redundant-alarms -eva-plevel 76 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 39 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 17
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_parse) == -3, -1, 1, 2, 3, 4, 5, 7 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(tokeq) == 0 (auto)
  \return(parse) == 0 (auto)
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_parse) == -3, -1, 1, 2, 3, 4, 5, 7 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(tokeq) == 0 (auto)
  \return(parse) == 0 (auto)
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_6
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_6
[eva] test/testutil.h:91: cannot properly split on \result == 0
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] test/testutil.h:91: cannot properly split on \result == 0
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] jsmn.c:158: starting to merge loop iterations
[eva] jsmn.c:158: starting to merge loop iterations
[eva] jsmn.c:158: starting to merge loop iterations
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] jsmn.c:302: cannot properly split on \result == 7
[eva] jsmn.c:209: starting to merge loop iterations
[eva] using specification for function printf_va_7
[eva] jsmn.c:302: cannot properly split on \result == 7
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] using specification for function printf_va_1
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_7
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_7
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] using specification for function printf_va_1
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] using specification for function printf_va_1
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] using specification for function printf_va_1
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/tests.c:83: starting to merge loop iterations
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] using specification for function printf_va_2
[eva] using specification for function printf_va_5
[eva] test/tests.c:83: starting to merge loop iterations
[eva] jsmn.c:209: starting to merge loop iterations
[eva] test/tests.c:83: starting to merge loop iterations
[eva] test/tests.c:83: starting to merge loop iterations
[eva] using specification for function printf_va_2
[eva] using specification for function printf_va_5
[eva] jsmn.c:302: cannot properly split on \result == 5
[eva] using specification for function printf_va_2
[eva] test/testutil.h:68: cannot properly split on \result == 0
[eva] jsmn.c:302: cannot properly split on \result == 5
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] using specification for function printf_va_2
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] test/testutil.h:68: cannot properly split on \result == 0
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:302: cannot properly split on \result == -3
[eva] jsmn.c:302: cannot properly split on \result == 4
[eva] jsmn.c:302: cannot properly split on \result == -3
[eva] jsmn.c:302: cannot properly split on \result == 4
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] jsmn.c:158: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] jsmn.c:125: starting to merge loop iterations
[eva] jsmn.c:121: Trace partitioning superposing up to 100 states
[eva] jsmn.c:93: starting to merge loop iterations
[eva] jsmn.c:133: Trace partitioning superposing up to 200 states
[eva] jsmn.c:215: 
  The evaluation of the expression -1
  led to bottom without alarms:
  at this point the product of states has no possible concretization.
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:215: 
  The evaluation of the expression -1
  led to bottom without alarms:
  at this point the product of states has no possible concretization.
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:215: 
  The evaluation of the expression -1
  led to bottom without alarms:
  at this point the product of states has no possible concretization.
[eva] jsmn.c:42: starting to merge loop iterations
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:125: starting to merge loop iterations
[eva] jsmn.c:50: Trace partitioning superposing up to 100 states
[eva] jsmn.c:125: starting to merge loop iterations
[eva] jsmn.c:121: Trace partitioning superposing up to 100 states
[eva] jsmn.c:93: starting to merge loop iterations
[eva] jsmn.c:125: starting to merge loop iterations
[eva] jsmn.c:133: Trace partitioning superposing up to 100 states
[eva] jsmn.c:93: starting to merge loop iterations
[eva] jsmn.c:133: Trace partitioning superposing up to 100 states
[eva] jsmn.c:93: starting to merge loop iterations
[eva] jsmn.c:250: starting to merge loop iterations
[eva] jsmn.c:42: starting to merge loop iterations
[eva] jsmn.c:250: starting to merge loop iterations
[eva] jsmn.c:50: Trace partitioning superposing up to 100 states
[eva] jsmn.c:42: starting to merge loop iterations
[eva] jsmn.c:250: starting to merge loop iterations
[eva] jsmn.c:50: Trace partitioning superposing up to 100 states
[eva] jsmn.c:42: starting to merge loop iterations
[eva] jsmn.c:50: Trace partitioning superposing up to 100 states
[eva] jsmn.c:250: starting to merge loop iterations
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:294: starting to merge loop iterations
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] jsmn.c:294: starting to merge loop iterations
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] jsmn.c:158: Trace partitioning superposing up to 100 states
[eva] jsmn.c:294: starting to merge loop iterations
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] jsmn.c:294: starting to merge loop iterations
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] using specification for function printf_va_8
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] using specification for function printf_va_8
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] using specification for function printf_va_8
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] using specification for function printf_va_8
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1140 statements reached (out of 1219): 93% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  33 alarms generated by the analysis:
      18 accesses to uninitialized left-values
       8 invalid memory accesses
       7 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     2 unknown     0 invalid     35 total
  94% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1140 statements reached (out of 1219): 93% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  33 alarms generated by the analysis:
      18 accesses to uninitialized left-values
       8 invalid memory accesses
       7 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     2 unknown     0 invalid     35 total
  94% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1140 statements reached (out of 1219): 93% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  33 alarms generated by the analysis:
      18 accesses to uninitialized left-values
       8 invalid memory accesses
       7 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     2 unknown     0 invalid     35 total
  94% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1140 statements reached (out of 1219): 93% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  33 alarms generated by the analysis:
      18 accesses to uninitialized left-values
       8 invalid memory accesses
       7 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     2 unknown     0 invalid     35 total
  94% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] sample base01-sample01: subset of base? true
[parf] sample base01-sample00: subset of base? true
[parf] sample base01-sample02: subset of base? true
[parf] sample base01-sample03: subset of base? true
[parf] base: base02
[parf] Analysis time for this epoch: 718
[parf] sample: base02-sample00
[parf] sample: base02-sample01
[parf] sample: base02-sample02
[parf] sample: base02-sample03
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 6 -eva-subdivide-non-linear 16 -eva-slevel 39 -eva-remove-redundant-alarms -eva-plevel 155 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 79 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 35
[parf] set eva options
[parf] parameters: -eva-widening-delay 4 -eva-subdivide-non-linear 19 -eva-split-return auto -eva-slevel 45 -eva-remove-redundant-alarms -eva-plevel 154 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 76 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 33
[parf] set eva options
[parf] parameters: -eva-widening-delay 6 -eva-subdivide-non-linear 17 -eva-slevel 44 -eva-remove-redundant-alarms -eva-plevel 156 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 79 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 30
[parf] parameters: -eva-widening-delay 6 -eva-subdivide-non-linear 13 -eva-slevel 44 -eva-remove-redundant-alarms -eva-plevel 155 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 87 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 31
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_parse) == -3, -1, 1, 2, 3, 4, 5, 7 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(tokeq) == 0 (auto)
  \return(parse) == 0 (auto)
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_6
[eva] test/testutil.h:91: cannot properly split on \result == 0
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] using specification for function strncmp
[eva] using specification for function strncmp
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_6
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] using specification for function printf_va_1
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] using specification for function printf_va_1
[eva] using specification for function printf_va_1
[eva] using specification for function printf_va_1
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] using specification for function printf_va_7
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_7
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] test/testutil.h:68: cannot properly split on \result == 0
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] jsmn.c:158: starting to merge loop iterations
[eva] jsmn.c:250: starting to merge loop iterations
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:215: 
  The evaluation of the expression -1
  led to bottom without alarms:
  at this point the product of states has no possible concretization.
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:121: Trace partitioning superposing up to 100 states
[eva] jsmn.c:93: starting to merge loop iterations
[eva] jsmn.c:158: starting to merge loop iterations
[eva] jsmn.c:158: starting to merge loop iterations
[eva] jsmn.c:158: starting to merge loop iterations
[eva] jsmn.c:250: starting to merge loop iterations
[eva] jsmn.c:250: starting to merge loop iterations
[eva] jsmn.c:250: starting to merge loop iterations
[eva] jsmn.c:250: Trace partitioning superposing up to 100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 100 states
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:215: 
  The evaluation of the expression -1
  led to bottom without alarms:
  at this point the product of states has no possible concretization.
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:215: 
  The evaluation of the expression -1
  led to bottom without alarms:
  at this point the product of states has no possible concretization.
[eva] jsmn.c:215: 
  The evaluation of the expression -1
  led to bottom without alarms:
  at this point the product of states has no possible concretization.
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:42: starting to merge loop iterations
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:121: Trace partitioning superposing up to 100 states
[eva] jsmn.c:121: Trace partitioning superposing up to 100 states
[eva] jsmn.c:50: Trace partitioning superposing up to 200 states
[eva] jsmn.c:125: starting to merge loop iterations
[eva] jsmn.c:121: Trace partitioning superposing up to 200 states
[eva] jsmn.c:121: Trace partitioning superposing up to 200 states
[eva] jsmn.c:129: Trace partitioning superposing up to 100 states
[eva] jsmn.c:93: starting to merge loop iterations
[eva] jsmn.c:93: starting to merge loop iterations
[eva] jsmn.c:121: Trace partitioning superposing up to 300 states
[eva] jsmn.c:121: Trace partitioning superposing up to 300 states
[eva] jsmn.c:129: Trace partitioning superposing up to 200 states
[eva] jsmn.c:42: starting to merge loop iterations
[eva] jsmn.c:42: starting to merge loop iterations
[eva] jsmn.c:50: Trace partitioning superposing up to 200 states
[eva] jsmn.c:93: starting to merge loop iterations
[eva] jsmn.c:50: Trace partitioning superposing up to 200 states
[eva] jsmn.c:129: Trace partitioning superposing up to 300 states
[eva] jsmn.c:250: Trace partitioning superposing up to 100 states
[eva] jsmn.c:42: starting to merge loop iterations
[eva] jsmn.c:294: starting to merge loop iterations
[eva] jsmn.c:302: cannot properly split on \result == -3
[eva] jsmn.c:50: Trace partitioning superposing up to 200 states
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] jsmn.c:294: starting to merge loop iterations
[eva] using specification for function printf_va_8
[eva] jsmn.c:294: starting to merge loop iterations
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1124 statements reached (out of 1219): 92% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  28 alarms generated by the analysis:
      14 accesses to uninitialized left-values
       8 invalid memory accesses
       6 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     0 unknown     0 invalid     33 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] using specification for function printf_va_8
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] using specification for function printf_va_8
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1125 statements reached (out of 1219): 92% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  28 alarms generated by the analysis:
      14 accesses to uninitialized left-values
       8 invalid memory accesses
       6 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     0 unknown     0 invalid     33 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1125 statements reached (out of 1219): 92% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  28 alarms generated by the analysis:
      14 accesses to uninitialized left-values
       8 invalid memory accesses
       6 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     0 unknown     0 invalid     33 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] jsmn.c:294: starting to merge loop iterations
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] using specification for function printf_va_8
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1125 statements reached (out of 1219): 92% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  28 alarms generated by the analysis:
      14 accesses to uninitialized left-values
       8 invalid memory accesses
       6 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     0 unknown     0 invalid     33 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] sample base02-sample00: subset of base? true
[parf] sample base02-sample01: subset of base? true
[parf] sample base02-sample03: subset of base? true
[parf] sample base02-sample02: subset of base? true
[parf] base: base03
[parf] Analysis time for this epoch: 1437
[parf] sample: base03-sample00
[parf] sample: base03-sample01
[parf] sample: base03-sample02
[parf] sample: base03-sample03
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 6 -eva-subdivide-non-linear 23 -eva-slevel 84 -eva-remove-redundant-alarms -eva-plevel 303 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 160 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 58
[parf] parameters: -eva-widening-delay 11 -eva-subdivide-non-linear 36 -eva-slevel 73 -eva-remove-redundant-alarms -eva-plevel 321 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 146 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 57
[parf] set eva options
[parf] parameters: -eva-widening-delay 7 -eva-subdivide-non-linear 33 -eva-slevel 70 -eva-remove-redundant-alarms -eva-plevel 326 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 152 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 57
[parf] run eva: start
[parf] set eva options
[parf] parameters: -eva-widening-delay 9 -eva-subdivide-non-linear 23 -eva-slevel 82 -eva-remove-redundant-alarms -eva-plevel 314 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 157 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 59
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] using specification for function strncmp
[eva] using specification for function strncmp
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_6
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_6
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] using specification for function printf_va_1
[eva] using specification for function printf_va_1
[eva] using specification for function printf_va_1
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] using specification for function printf_va_1
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_7
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] using specification for function printf_va_7
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] jsmn.c:250: starting to merge loop iterations
[eva] jsmn.c:250: starting to merge loop iterations
[eva] jsmn.c:250: Trace partitioning superposing up to 100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 100 states
[eva] jsmn.c:250: starting to merge loop iterations
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:158: starting to merge loop iterations
[eva] jsmn.c:158: starting to merge loop iterations
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:158: starting to merge loop iterations
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:209: Trace partitioning superposing up to 200 states
[eva] jsmn.c:250: Trace partitioning superposing up to 200 states
[eva] jsmn.c:222: Trace partitioning superposing up to 200 states
[eva] jsmn.c:250: Trace partitioning superposing up to 100 states
[eva] jsmn.c:250: starting to merge loop iterations
[eva] jsmn.c:158: starting to merge loop iterations
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:250: Trace partitioning superposing up to 300 states
[eva] jsmn.c:209: Trace partitioning superposing up to 300 states
[eva] jsmn.c:222: Trace partitioning superposing up to 300 states
[eva] jsmn.c:222: Trace partitioning superposing up to 200 states
[eva] jsmn.c:250: Trace partitioning superposing up to 400 states
[eva] jsmn.c:250: Trace partitioning superposing up to 400 states
[eva] jsmn.c:250: Trace partitioning superposing up to 400 states
[eva] jsmn.c:222: Trace partitioning superposing up to 300 states
[eva] jsmn.c:121: Trace partitioning superposing up to 100 states
[eva] jsmn.c:93: starting to merge loop iterations
[eva] jsmn.c:121: Trace partitioning superposing up to 200 states
[eva] jsmn.c:121: Trace partitioning superposing up to 100 states
[eva] jsmn.c:93: Trace partitioning superposing up to 100 states
[eva] jsmn.c:93: starting to merge loop iterations
[eva] jsmn.c:121: Trace partitioning superposing up to 200 states
[eva] jsmn.c:121: Trace partitioning superposing up to 200 states
[eva] jsmn.c:250: Trace partitioning superposing up to 500 states
[eva] jsmn.c:93: starting to merge loop iterations
[eva] jsmn.c:121: Trace partitioning superposing up to 300 states
[eva] jsmn.c:42: starting to merge loop iterations
[eva] jsmn.c:250: Trace partitioning superposing up to 600 states
[eva] jsmn.c:42: starting to merge loop iterations
[eva] jsmn.c:50: Trace partitioning superposing up to 400 states
[eva] jsmn.c:50: Trace partitioning superposing up to 300 states
[eva] jsmn.c:121: Trace partitioning superposing up to 100 states
[eva] jsmn.c:93: starting to merge loop iterations
[eva] jsmn.c:121: Trace partitioning superposing up to 200 states
[eva] jsmn.c:42: starting to merge loop iterations
[eva] jsmn.c:50: Trace partitioning superposing up to 400 states
[eva] jsmn.c:250: Trace partitioning superposing up to 500 states
[eva] jsmn.c:42: starting to merge loop iterations
[eva] jsmn.c:50: Trace partitioning superposing up to 300 states
[eva] jsmn.c:294: starting to merge loop iterations
[eva] jsmn.c:294: starting to merge loop iterations
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] jsmn.c:294: starting to merge loop iterations
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] using specification for function printf_va_8
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] using specification for function printf_va_8
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] jsmn.c:294: starting to merge loop iterations
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[scope:rm_asserts] removing 1 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1124 statements reached (out of 1219): 92% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  29 alarms generated by the analysis:
      15 accesses to uninitialized left-values
       8 invalid memory accesses
       6 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     0 unknown     0 invalid     33 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[scope:rm_asserts] removing 1 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1124 statements reached (out of 1219): 92% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  29 alarms generated by the analysis:
      15 accesses to uninitialized left-values
       8 invalid memory accesses
       6 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     0 unknown     0 invalid     33 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_8
[scope:rm_asserts] removing 1 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1124 statements reached (out of 1219): 92% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  29 alarms generated by the analysis:
      15 accesses to uninitialized left-values
       8 invalid memory accesses
       6 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     0 unknown     0 invalid     33 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[scope:rm_asserts] removing 1 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1124 statements reached (out of 1219): 92% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  29 alarms generated by the analysis:
      15 accesses to uninitialized left-values
       8 invalid memory accesses
       6 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     0 unknown     0 invalid     33 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] sample base03-sample01: subset of base? true
[parf] sample base03-sample00: subset of base? true
[parf] sample base03-sample02: subset of base? true
[parf] sample base03-sample03: subset of base? true
[parf] base: base04
[parf] Analysis time for this epoch: 1733
[parf] sample: base04-sample00
[parf] sample: base04-sample01
[parf] sample: base04-sample02
[parf] sample: base04-sample03
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] run eva: start
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 9 -eva-subdivide-non-linear 47 -eva-split-return auto -eva-slevel 148 -eva-remove-redundant-alarms -eva-plevel 605 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 299 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 121
[parf] parameters: -eva-widening-delay 14 -eva-subdivide-non-linear 47 -eva-slevel 134 -eva-remove-redundant-alarms -eva-plevel 604 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 280 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 104
[parf] parameters: -eva-widening-delay 10 -eva-subdivide-non-linear 49 -eva-slevel 132 -eva-remove-redundant-alarms -eva-plevel 630 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 296 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 112
[parf] set eva options
[parf] parameters: -eva-widening-delay 11 -eva-subdivide-non-linear 47 -eva-slevel 151 -eva-remove-redundant-alarms -eva-plevel 617 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 294 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 119
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_parse) == -3, -1, 1, 2, 3, 4, 5, 7 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(tokeq) == 0 (auto)
  \return(parse) == 0 (auto)
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function strncmp
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_6
[eva] test/testutil.h:91: cannot properly split on \result == 0
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_6
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] using specification for function printf_va_1
[eva] using specification for function printf_va_1
[eva] using specification for function printf_va_1
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] using specification for function printf_va_1
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_7
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] using specification for function printf_va_7
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] test/testutil.h:68: cannot properly split on \result == 0
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] jsmn.c:250: Trace partitioning superposing up to 100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 100 states
[eva] jsmn.c:250: starting to merge loop iterations
[eva] jsmn.c:250: starting to merge loop iterations
[eva] jsmn.c:250: starting to merge loop iterations
[eva] jsmn.c:158: starting to merge loop iterations
[eva] jsmn.c:250: Trace partitioning superposing up to 100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 200 states
[eva] jsmn.c:250: starting to merge loop iterations
[eva] jsmn.c:250: Trace partitioning superposing up to 200 states
[eva] jsmn.c:250: Trace partitioning superposing up to 200 states
[eva] jsmn.c:158: starting to merge loop iterations
[eva] jsmn.c:250: Trace partitioning superposing up to 300 states
[eva] jsmn.c:158: starting to merge loop iterations
[eva] jsmn.c:250: Trace partitioning superposing up to 400 states
[eva] jsmn.c:158: starting to merge loop iterations
[eva] jsmn.c:250: Trace partitioning superposing up to 300 states
[eva] jsmn.c:250: Trace partitioning superposing up to 200 states
[eva] jsmn.c:250: Trace partitioning superposing up to 300 states
[eva] jsmn.c:250: Trace partitioning superposing up to 500 states
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:250: Trace partitioning superposing up to 300 states
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:250: Trace partitioning superposing up to 400 states
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:250: Trace partitioning superposing up to 400 states
[eva] jsmn.c:250: Trace partitioning superposing up to 500 states
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:250: Trace partitioning superposing up to 400 states
[eva] jsmn.c:250: Trace partitioning superposing up to 600 states
[eva] jsmn.c:250: Trace partitioning superposing up to 500 states
[eva] jsmn.c:250: Trace partitioning superposing up to 700 states
[eva] jsmn.c:250: Trace partitioning superposing up to 800 states
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:250: Trace partitioning superposing up to 900 states
[eva] jsmn.c:250: Trace partitioning superposing up to 600 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1000 states
[eva] jsmn.c:250: Trace partitioning superposing up to 700 states
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:250: Trace partitioning superposing up to 1100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1200 states
[eva] jsmn.c:294: starting to merge loop iterations
[eva] jsmn.c:294: starting to merge loop iterations
[eva] jsmn.c:302: cannot properly split on \result == -3
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] using specification for function printf_va_8
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] using specification for function printf_va_8
[scope:rm_asserts] removing 1 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1120 statements reached (out of 1219): 91% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  29 alarms generated by the analysis:
      15 accesses to uninitialized left-values
       8 invalid memory accesses
       6 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     0 unknown     0 invalid     33 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] jsmn.c:294: starting to merge loop iterations
[scope:rm_asserts] removing 1 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1120 statements reached (out of 1219): 91% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  29 alarms generated by the analysis:
      15 accesses to uninitialized left-values
       8 invalid memory accesses
       6 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     0 unknown     0 invalid     33 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] jsmn.c:294: starting to merge loop iterations
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] using specification for function printf_va_8
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] using specification for function printf_va_8
[scope:rm_asserts] removing 1 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1120 statements reached (out of 1219): 91% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  29 alarms generated by the analysis:
      15 accesses to uninitialized left-values
       8 invalid memory accesses
       6 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     0 unknown     0 invalid     33 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[scope:rm_asserts] removing 1 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1120 statements reached (out of 1219): 91% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  29 alarms generated by the analysis:
      15 accesses to uninitialized left-values
       8 invalid memory accesses
       6 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     0 unknown     0 invalid     33 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] sample base04-sample01: subset of base? true
[parf] sample base04-sample00: subset of base? true
[parf] sample base04-sample02: subset of base? true
[parf] sample base04-sample03: subset of base? true
[parf] base: base05
[parf] Analysis time for this epoch: 1717
[parf] sample: base05-sample00
[parf] sample: base05-sample01
[parf] sample: base05-sample02
[parf] sample: base05-sample03
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 20 -eva-subdivide-non-linear 84 -eva-slevel 246 -eva-remove-redundant-alarms -eva-plevel 1239 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 513 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 208
[parf] parameters: -eva-widening-delay 20 -eva-subdivide-non-linear 90 -eva-split-return auto -eva-slevel 281 -eva-remove-redundant-alarms -eva-plevel 1231 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 513 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 186
[parf] parameters: -eva-widening-delay 14 -eva-subdivide-non-linear 96 -eva-split-return auto -eva-slevel 252 -eva-remove-redundant-alarms -eva-plevel 1204 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 502 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 207
[parf] run eva: start
[parf] set eva options
[parf] parameters: -eva-widening-delay 20 -eva-subdivide-non-linear 91 -eva-split-return auto -eva-slevel 269 -eva-remove-redundant-alarms -eva-plevel 1268 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 503 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 216
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_parse) == -3, -1, 1, 2, 3, 4, 5, 7 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(tokeq) == 0 (auto)
  \return(parse) == 0 (auto)
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_parse) == -3, -1, 1, 2, 3, 4, 5, 7 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(tokeq) == 0 (auto)
  \return(parse) == 0 (auto)
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_parse) == -3, -1, 1, 2, 3, 4, 5, 7 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(tokeq) == 0 (auto)
  \return(parse) == 0 (auto)
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] using specification for function strncmp
[eva] using specification for function strncmp
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_6
[eva] test/testutil.h:91: cannot properly split on \result == 0
[eva] test/testutil.h:91: cannot properly split on \result == 0
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_6
[eva] test/testutil.h:91: cannot properly split on \result == 0
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] using specification for function printf_va_1
[eva] using specification for function printf_va_1
[eva] using specification for function printf_va_1
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_1
[eva] using specification for function printf_va_7
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] using specification for function printf_va_7
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] test/testutil.h:68: cannot properly split on \result == 0
[eva] test/testutil.h:68: cannot properly split on \result == 0
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] test/testutil.h:68: cannot properly split on \result == 0
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] jsmn.c:250: Trace partitioning superposing up to 100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 200 states
[eva] jsmn.c:250: Trace partitioning superposing up to 200 states
[eva] jsmn.c:250: Trace partitioning superposing up to 200 states
[eva] jsmn.c:250: Trace partitioning superposing up to 100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 300 states
[eva] jsmn.c:250: Trace partitioning superposing up to 300 states
[eva] jsmn.c:250: Trace partitioning superposing up to 300 states
[eva] jsmn.c:250: starting to merge loop iterations
[eva] jsmn.c:250: starting to merge loop iterations
[eva] jsmn.c:250: starting to merge loop iterations
[eva] jsmn.c:250: Trace partitioning superposing up to 400 states
[eva] jsmn.c:250: Trace partitioning superposing up to 400 states
[eva] jsmn.c:250: Trace partitioning superposing up to 400 states
[eva] jsmn.c:250: Trace partitioning superposing up to 200 states
[eva] jsmn.c:250: Trace partitioning superposing up to 500 states
[eva] jsmn.c:250: Trace partitioning superposing up to 500 states
[eva] jsmn.c:250: Trace partitioning superposing up to 500 states
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:250: Trace partitioning superposing up to 600 states
[eva] jsmn.c:250: Trace partitioning superposing up to 600 states
[eva] jsmn.c:250: Trace partitioning superposing up to 300 states
[eva] jsmn.c:250: starting to merge loop iterations
[eva] jsmn.c:250: Trace partitioning superposing up to 600 states
[eva] jsmn.c:250: Trace partitioning superposing up to 400 states
[eva] jsmn.c:250: Trace partitioning superposing up to 700 states
[eva] jsmn.c:250: Trace partitioning superposing up to 700 states
[eva] jsmn.c:250: Trace partitioning superposing up to 700 states
[eva] jsmn.c:250: Trace partitioning superposing up to 500 states
[eva] jsmn.c:158: starting to merge loop iterations
[eva] jsmn.c:158: starting to merge loop iterations
[eva] jsmn.c:250: Trace partitioning superposing up to 800 states
[eva] jsmn.c:250: Trace partitioning superposing up to 800 states
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:250: Trace partitioning superposing up to 600 states
[eva] jsmn.c:250: Trace partitioning superposing up to 700 states
[eva] jsmn.c:250: Trace partitioning superposing up to 900 states
[eva] jsmn.c:250: Trace partitioning superposing up to 900 states
[eva] jsmn.c:250: Trace partitioning superposing up to 800 states
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:250: Trace partitioning superposing up to 1000 states
[eva] jsmn.c:158: starting to merge loop iterations
[eva] jsmn.c:250: Trace partitioning superposing up to 800 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1000 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 900 states
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:250: Trace partitioning superposing up to 1200 states
[eva] jsmn.c:158: starting to merge loop iterations
[eva] jsmn.c:250: Trace partitioning superposing up to 1200 states
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:250: Trace partitioning superposing up to 1000 states
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:250: Trace partitioning superposing up to 1300 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 900 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1300 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1400 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1200 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1000 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1400 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1500 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1500 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1300 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1600 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1200 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1600 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1300 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1400 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1700 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1500 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1700 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1800 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1400 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1800 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1500 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1600 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1900 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1900 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1600 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1700 states
[eva] jsmn.c:250: Trace partitioning superposing up to 2000 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1800 states
[eva] jsmn.c:250: Trace partitioning superposing up to 2000 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1700 states
[eva] jsmn.c:250: Trace partitioning superposing up to 2100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 2100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1900 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1800 states
[eva] jsmn.c:250: Trace partitioning superposing up to 2200 states
[eva] jsmn.c:250: Trace partitioning superposing up to 1900 states
[eva] jsmn.c:250: Trace partitioning superposing up to 2200 states
[eva] jsmn.c:250: Trace partitioning superposing up to 2000 states
[eva] jsmn.c:250: Trace partitioning superposing up to 2300 states
[eva] jsmn.c:250: Trace partitioning superposing up to 2100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 2000 states
[eva] jsmn.c:250: Trace partitioning superposing up to 2400 states
[eva] jsmn.c:250: Trace partitioning superposing up to 2200 states
[eva] jsmn.c:250: Trace partitioning superposing up to 2500 states
[eva] jsmn.c:250: Trace partitioning superposing up to 2100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 2200 states
[eva] jsmn.c:294: starting to merge loop iterations
[eva] jsmn.c:302: cannot properly split on \result == -3
[eva] jsmn.c:250: Trace partitioning superposing up to 2300 states
[eva] jsmn.c:250: Trace partitioning superposing up to 2600 states
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] jsmn.c:250: Trace partitioning superposing up to 2400 states
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] jsmn.c:250: Trace partitioning superposing up to 2300 states
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] jsmn.c:250: Trace partitioning superposing up to 2400 states
[eva] using specification for function printf_va_8
[eva] jsmn.c:250: Trace partitioning superposing up to 2700 states
[scope:rm_asserts] removing 1 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1120 statements reached (out of 1219): 91% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  23 alarms generated by the analysis:
      12 accesses to uninitialized left-values
       7 invalid memory accesses
       4 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     0 unknown     0 invalid     33 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] jsmn.c:250: Trace partitioning superposing up to 2500 states
[eva] jsmn.c:250: Trace partitioning superposing up to 2800 states
[eva] jsmn.c:250: Trace partitioning superposing up to 2500 states
[eva] jsmn.c:250: Trace partitioning superposing up to 2600 states
[eva] jsmn.c:250: Trace partitioning superposing up to 2900 states
[eva] jsmn.c:250: Trace partitioning superposing up to 2700 states
[eva] jsmn.c:250: Trace partitioning superposing up to 2600 states
[eva] jsmn.c:250: Trace partitioning superposing up to 2700 states
[eva] jsmn.c:250: Trace partitioning superposing up to 3000 states
[eva] jsmn.c:250: Trace partitioning superposing up to 2800 states
[eva] jsmn.c:250: Trace partitioning superposing up to 3100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 2800 states
[eva] jsmn.c:250: Trace partitioning superposing up to 2900 states
[eva] jsmn.c:250: Trace partitioning superposing up to 3200 states
[eva] jsmn.c:250: Trace partitioning superposing up to 3000 states
[eva] jsmn.c:250: Trace partitioning superposing up to 2900 states
[eva] jsmn.c:250: Trace partitioning superposing up to 3000 states
[eva] jsmn.c:250: Trace partitioning superposing up to 3300 states
[eva] jsmn.c:250: Trace partitioning superposing up to 3100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 3400 states
[eva] jsmn.c:250: Trace partitioning superposing up to 3200 states
[eva] jsmn.c:250: Trace partitioning superposing up to 3100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 3200 states
[eva] jsmn.c:250: Trace partitioning superposing up to 3300 states
[eva] jsmn.c:250: Trace partitioning superposing up to 3500 states
[eva] jsmn.c:250: Trace partitioning superposing up to 3400 states
[eva] jsmn.c:302: cannot properly split on \result == -3
[eva] jsmn.c:250: Trace partitioning superposing up to 3500 states
[eva] jsmn.c:302: cannot properly split on \result == -3
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] using specification for function printf_va_8
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[scope:rm_asserts] removing 1 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1120 statements reached (out of 1219): 91% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  23 alarms generated by the analysis:
      12 accesses to uninitialized left-values
       7 invalid memory accesses
       4 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     0 unknown     0 invalid     33 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] using specification for function printf_va_8
[eva] jsmn.c:250: Trace partitioning superposing up to 3600 states
[scope:rm_asserts] removing 1 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1120 statements reached (out of 1219): 91% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  23 alarms generated by the analysis:
      12 accesses to uninitialized left-values
       7 invalid memory accesses
       4 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     0 unknown     0 invalid     33 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] jsmn.c:250: Trace partitioning superposing up to 3700 states
[eva] jsmn.c:250: Trace partitioning superposing up to 3800 states
[eva] jsmn.c:250: Trace partitioning superposing up to 3900 states
[eva] jsmn.c:294: starting to merge loop iterations
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] using specification for function printf_va_8
[scope:rm_asserts] removing 1 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1120 statements reached (out of 1219): 91% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  23 alarms generated by the analysis:
      12 accesses to uninitialized left-values
       7 invalid memory accesses
       4 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     0 unknown     0 invalid     33 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] sample base05-sample00: subset of base? true
[parf] sample base05-sample01: subset of base? true
[parf] sample base05-sample03: subset of base? true
[parf] sample base05-sample02: subset of base? true
[parf] base: base06
[parf] Analysis time for this epoch: 1665
[parf] sample: base06-sample00
[parf] sample: base06-sample01
[parf] sample: base06-sample02
[parf] sample: base06-sample03
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 21 -eva-subdivide-non-linear 162 -eva-split-return auto -eva-slevel 472 -eva-remove-redundant-alarms -eva-plevel 3205 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 504 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 368
[parf] set eva options
[parf] parameters: -eva-widening-delay 15 -eva-subdivide-non-linear 168 -eva-slevel 502 -eva-remove-redundant-alarms -eva-plevel 3205 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 513 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 373
[parf] parameters: -eva-widening-delay 21 -eva-subdivide-non-linear 176 -eva-slevel 493 -eva-remove-redundant-alarms -eva-plevel 3205 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 502 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 366
[parf] run eva: start
[parf] set eva options
[parf] parameters: -eva-widening-delay 17 -eva-subdivide-non-linear 152 -eva-split-return auto -eva-slevel 496 -eva-remove-redundant-alarms -eva-plevel 3205 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 513 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 359
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_parse) == -3, -1, 1, 2, 3, 4, 5, 7 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(tokeq) == 0 (auto)
  \return(parse) == 0 (auto)
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_parse) == -3, -1, 1, 2, 3, 4, 5, 7 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(tokeq) == 0 (auto)
  \return(parse) == 0 (auto)
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_6
[eva] test/testutil.h:91: cannot properly split on \result == 0
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] using specification for function strncmp
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_6
[eva] test/testutil.h:91: cannot properly split on \result == 0
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] using specification for function printf_va_1
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] using specification for function printf_va_1
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] using specification for function printf_va_1
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_1
[eva] using specification for function printf_va_7
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_7
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] test/testutil.h:68: cannot properly split on \result == 0
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] test/testutil.h:68: cannot properly split on \result == 0
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] jsmn.c:250: Trace partitioning superposing up to 100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 200 states
[eva] jsmn.c:250: Trace partitioning superposing up to 200 states
[eva] jsmn.c:250: Trace partitioning superposing up to 100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 300 states
[eva] jsmn.c:250: Trace partitioning superposing up to 300 states
[eva] jsmn.c:250: Trace partitioning superposing up to 200 states
[eva] jsmn.c:250: Trace partitioning superposing up to 200 states
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] jsmn.c:250: Trace partitioning superposing up to 300 states
[eva] jsmn.c:250: Trace partitioning superposing up to 300 states
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_8
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1116 statements reached (out of 1219): 91% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 invalid memory access
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     0 unknown     0 invalid     33 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1116 statements reached (out of 1219): 91% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 invalid memory access
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     0 unknown     0 invalid     33 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_8
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1116 statements reached (out of 1219): 91% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 invalid memory access
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     0 unknown     0 invalid     33 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1116 statements reached (out of 1219): 91% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 invalid memory access
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     0 unknown     0 invalid     33 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] sample base06-sample01: subset of base? true
[parf] sample base06-sample00: subset of base? true
[parf] sample base06-sample02: subset of base? true
[parf] sample base06-sample03: subset of base? true
[parf] base: base07
[parf] Analysis time for this epoch: 1657
[parf] sample: base07-sample00
[parf] sample: base07-sample01
[parf] sample: base07-sample02
[parf] sample: base07-sample03
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 20 -eva-subdivide-non-linear 317 -eva-slevel 968 -eva-remove-redundant-alarms -eva-plevel 4001 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 513 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 724
[parf] set eva options
[parf] parameters: -eva-widening-delay 21 -eva-subdivide-non-linear 302 -eva-slevel 941 -eva-remove-redundant-alarms -eva-plevel 4001 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 513 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 707
[parf] parameters: -eva-widening-delay 16 -eva-subdivide-non-linear 294 -eva-slevel 946 -eva-remove-redundant-alarms -eva-plevel 4001 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 513 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 740
[parf] run eva: start
[parf] set eva options
[parf] parameters: -eva-widening-delay 21 -eva-subdivide-non-linear 312 -eva-slevel 918 -eva-remove-redundant-alarms -eva-plevel 4001 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 512 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 727
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_34
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_35
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_36
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_37
[eva] using specification for function strncmp
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_6
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] using specification for function strncmp
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_6
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_38
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_39
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_40
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_41
[eva] using specification for function printf_va_1
[eva] using specification for function printf_va_1
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] using specification for function printf_va_1
[eva] using specification for function printf_va_1
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_42
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_7
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_43
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_7
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_44
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_45
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_46
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_47
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_48
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_49
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_50
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_51
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_52
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_53
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_54
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_55
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_56
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_57
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_58
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:134: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memset
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] jsmn.c:250: Trace partitioning superposing up to 100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 200 states
[eva] jsmn.c:250: Trace partitioning superposing up to 200 states
[eva] jsmn.c:250: Trace partitioning superposing up to 100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 100 states
[eva] jsmn.c:250: Trace partitioning superposing up to 300 states
[eva] jsmn.c:250: Trace partitioning superposing up to 300 states
[eva] jsmn.c:250: Trace partitioning superposing up to 200 states
[eva] jsmn.c:250: Trace partitioning superposing up to 200 states
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] jsmn.c:250: Trace partitioning superposing up to 300 states
[eva] jsmn.c:250: Trace partitioning superposing up to 300 states
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_59
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_60
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_61
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_8
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_62
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_63
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_64
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_65
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_66
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_67
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1116 statements reached (out of 1219): 91% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 invalid memory access
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     0 unknown     0 invalid     33 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1116 statements reached (out of 1219): 91% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 invalid memory access
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     0 unknown     0 invalid     33 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] test/testutil.h:76: allocating variable __malloc_parse_l76_68
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_8
[eva:summary] ====== ANALYSIS SUMMARY ======
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1116 statements reached (out of 1219): 91% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 invalid memory access
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     0 unknown     0 invalid     33 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
  ----------------------------------------------------------------------------
  26 functions analyzed (out of 26): 100% coverage.
  In these functions, 1116 statements reached (out of 1219): 91% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 invalid memory access
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    33 valid     0 unknown     0 invalid     33 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] sample base07-sample00: subset of base? true
[parf] sample base07-sample01: subset of base? true
[parf] sample base07-sample03: subset of base? true
[parf] sample base07-sample02: subset of base? true
[parf] Final parameters: -eva-widening-delay 10 -eva-subdivide-non-linear 220 -eva-slevel 918 -eva-remove-redundant-alarms -eva-plevel 2000 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 256 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 707
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] ================================= Summary ==================================
[parf] ====== project "Initial Base 2" ======
[parf] Parameter: -eva-widening-delay 1 -eva-subdivide-non-linear 0 -eva-slevel 0 -eva-plevel 10 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 8 -eva-equality-through-calls none -eva-domains cvalue -eva-auto-loop-unroll 0
[parf] alarms:
[parf] alarm (  1): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm (  2): Uninitialized((t + i)->start)
[parf] alarm (  3): Signed_overflow((t + i)->end - (t + i)->start <= 2147483647)
[parf] alarm (  4): Uninitialized((t + i)->start)
[parf] alarm (  5): Uninitialized((t + i)->end)
[parf] alarm (  6): Uninitialized((tokens + i)->type)
[parf] alarm (  7): Memory_access((tokens + i)->type, read)
[parf] alarm (  8): Signed_overflow((t + i)->end - (t + i)->start <= 2147483647)
[parf] alarm (  9): Uninitialized((t + i)->start)
[parf] alarm ( 10): Uninitialized((t + i)->end)
[parf] alarm ( 11): Uninitialized((tokens + i)->type)
[parf] alarm ( 12): Signed_overflow((t + i)->end - (t + i)->start <= 2147483647)
[parf] alarm ( 13): Uninitialized((t + i)->end)
[parf] alarm ( 14): Uninitialized((t + i)->start)
[parf] alarm ( 15): Uninitialized((tokens + i)->start)
[parf] alarm ( 16): Uninitialized((tokens + i)->end)
[parf] alarm ( 17): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 18): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 19): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 20): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 21): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 22): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 23): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 24): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 25): Memory_access((tokens + i)->start, read)
[parf] alarm ( 26): Uninitialized((tokens + i)->start)
[parf] alarm ( 27): Uninitialized((tokens + i)->end)
[parf] alarm ( 28): Uninitialized(token->start)
[parf] alarm ( 29): Memory_access(token->start, read)
[parf] alarm ( 30): Uninitialized(token->end)
[parf] alarm ( 31): Uninitialized(token->type)
[parf] alarm ( 32): Memory_access(token->start, read)
[parf] alarm ( 33): Uninitialized(token->start)
[parf] alarm ( 34): Uninitialized(token->end)
[parf] alarm ( 35): Memory_access((t + i)->type, read)
[parf] alarm ( 36): Uninitialized((t + i)->type)
[parf] alarm ( 37): Uninitialized((t + i)->type)
[parf] alarm ( 38): Memory_access(*ap, read)
[parf] alarm ( 39): Memory_access(*((char **)*ap), read)
[parf] alarm ( 40): Memory_access(*ap, read)
[parf] alarm ( 41): Uninitialized((t + i)->start)
[parf] alarm ( 42): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 43): Uninitialized((t + i)->start)
[parf] alarm ( 44): Memory_access(*ap, read)
[parf] alarm ( 45): Memory_access(*ap, read)
[parf] alarm ( 46): Memory_access(*((char **)*ap), read)
[parf] alarm ( 47): Uninitialized((t + i)->end)
[parf] alarm ( 48): Memory_access(*ap, read)
[parf] alarm ( 49): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 50): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 51): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 52): Uninitialized((t + i)->end)
[parf] alarm ( 53): Memory_access(*ap, read)
[parf] alarm ( 54): Memory_access(*ap, read)
[parf] alarm ( 55): Uninitialized((t + i)->size)
[parf] alarm ( 56): Uninitialized((t + i)->size)
[parf] alarm ( 57): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 58): Memory_access((tokens + parser->toksuper)->type, read)
[parf] ============================================================================
[parf] ====== project "base00-sample00 2" ======
[parf] Parameter: -eva-widening-delay 2 -eva-subdivide-non-linear 4 -eva-slevel 9 -eva-remove-redundant-alarms -eva-plevel 29 -eva-partition-history 2 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 16 -eva-equality-through-calls none -eva-domains cvalue,equality,octagon,symbolic-locations -eva-auto-loop-unroll 4
[parf] alarms:
[parf] alarm (  1): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm (  2): Uninitialized((t + i)->start)
[parf] alarm (  3): Signed_overflow((t + i)->end - (t + i)->start <= 2147483647)
[parf] alarm (  4): Uninitialized((t + i)->end)
[parf] alarm (  5): Uninitialized((tokens + i)->type)
[parf] alarm (  6): Memory_access((tokens + i)->type, read)
[parf] alarm (  7): Uninitialized((t + i)->end)
[parf] alarm (  8): Uninitialized((t + i)->start)
[parf] alarm (  9): Uninitialized((t + i)->start)
[parf] alarm ( 10): Uninitialized((tokens + i)->start)
[parf] alarm ( 11): Uninitialized((tokens + i)->end)
[parf] alarm ( 12): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 13): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 14): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 15): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 16): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 17): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 18): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 19): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 20): Memory_access((tokens + i)->start, read)
[parf] alarm ( 21): Uninitialized((tokens + i)->start)
[parf] alarm ( 22): Uninitialized((tokens + i)->end)
[parf] alarm ( 23): Uninitialized(token->start)
[parf] alarm ( 24): Memory_access(token->start, read)
[parf] alarm ( 25): Uninitialized(token->end)
[parf] alarm ( 26): Uninitialized(token->type)
[parf] alarm ( 27): Signed_overflow(start + 1 <= 2147483647)
[parf] alarm ( 28): Uninitialized(token->start)
[parf] alarm ( 29): Uninitialized(token->end)
[parf] alarm ( 30): Memory_access((t + i)->type, read)
[parf] alarm ( 31): Uninitialized((t + i)->type)
[parf] alarm ( 32): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 33): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 34): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 35): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 36): Uninitialized((t + i)->size)
[parf] alarm ( 37): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 38): Memory_access((tokens + parser->toksuper)->type, read)
[parf] ============================================================================
[parf] ====== project "base00-sample01 2" ======
[parf] Parameter: -eva-widening-delay 2 -eva-subdivide-non-linear 1 -eva-split-return auto -eva-slevel 8 -eva-remove-redundant-alarms -eva-plevel 28 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 16 -eva-equality-through-calls none -eva-domains cvalue,equality,octagon,symbolic-locations -eva-auto-loop-unroll 9
[parf] alarms:
[parf] alarm (  1): Uninitialized((t + i)->start)
[parf] alarm (  2): Signed_overflow((t + i)->end - (t + i)->start <= 2147483647)
[parf] alarm (  3): Uninitialized((t + i)->end)
[parf] alarm (  4): Uninitialized((tokens + i)->type)
[parf] alarm (  5): Memory_access((tokens + i)->type, read)
[parf] alarm (  6): Uninitialized((t + i)->end)
[parf] alarm (  7): Uninitialized((t + i)->start)
[parf] alarm (  8): Uninitialized((t + i)->start)
[parf] alarm (  9): Uninitialized((tokens + i)->start)
[parf] alarm ( 10): Uninitialized((tokens + i)->end)
[parf] alarm ( 11): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 12): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 13): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 14): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 15): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 16): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 17): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 18): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 19): Memory_access((tokens + i)->start, read)
[parf] alarm ( 20): Uninitialized((tokens + i)->start)
[parf] alarm ( 21): Uninitialized((tokens + i)->end)
[parf] alarm ( 22): Uninitialized(token->start)
[parf] alarm ( 23): Memory_access(token->start, read)
[parf] alarm ( 24): Uninitialized(token->end)
[parf] alarm ( 25): Uninitialized(token->type)
[parf] alarm ( 26): Uninitialized(token->start)
[parf] alarm ( 27): Uninitialized(token->end)
[parf] alarm ( 28): Memory_access((t + i)->type, read)
[parf] alarm ( 29): Uninitialized((t + i)->type)
[parf] alarm ( 30): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 31): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 32): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 33): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 34): Uninitialized((t + i)->size)
[parf] alarm ( 35): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 36): Memory_access((tokens + parser->toksuper)->type, read)
[parf] ============================================================================
[parf] ====== project "base00-sample02 2" ======
[parf] Parameter: -eva-widening-delay 2 -eva-subdivide-non-linear 4 -eva-slevel 9 -eva-plevel 41 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 18 -eva-equality-through-calls none -eva-domains cvalue,symbolic-locations -eva-auto-loop-unroll 10
[parf] alarms:
[parf] alarm (  1): Uninitialized((t + i)->start)
[parf] alarm (  2): Uninitialized((t + i)->end)
[parf] alarm (  3): Uninitialized((tokens + i)->type)
[parf] alarm (  4): Memory_access((tokens + i)->type, read)
[parf] alarm (  5): Uninitialized((t + i)->end)
[parf] alarm (  6): Uninitialized((t + i)->start)
[parf] alarm (  7): Uninitialized((t + i)->start)
[parf] alarm (  8): Uninitialized((tokens + i)->start)
[parf] alarm (  9): Uninitialized((tokens + i)->end)
[parf] alarm ( 10): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 11): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 12): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 13): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 14): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 15): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 16): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 17): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 18): Memory_access((tokens + i)->start, read)
[parf] alarm ( 19): Uninitialized((tokens + i)->start)
[parf] alarm ( 20): Uninitialized((tokens + i)->end)
[parf] alarm ( 21): Uninitialized(token->start)
[parf] alarm ( 22): Memory_access(token->start, read)
[parf] alarm ( 23): Uninitialized(token->end)
[parf] alarm ( 24): Uninitialized(token->type)
[parf] alarm ( 25): Memory_access(token->start, read)
[parf] alarm ( 26): Uninitialized(token->start)
[parf] alarm ( 27): Uninitialized(token->end)
[parf] alarm ( 28): Memory_access((t + i)->type, read)
[parf] alarm ( 29): Uninitialized((t + i)->type)
[parf] alarm ( 30): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 31): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 32): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 33): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 34): Uninitialized((t + i)->size)
[parf] alarm ( 35): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 36): Memory_access((tokens + parser->toksuper)->type, read)
[parf] ============================================================================
[parf] ====== project "base00-sample03 2" ======
[parf] Parameter: -eva-widening-delay 2 -eva-subdivide-non-linear 3 -eva-slevel 12 -eva-plevel 26 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 16 -eva-equality-through-calls none -eva-domains cvalue,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 9
[parf] alarms:
[parf] alarm (  1): Uninitialized((t + i)->start)
[parf] alarm (  2): Signed_overflow((t + i)->end - (t + i)->start <= 2147483647)
[parf] alarm (  3): Uninitialized((t + i)->end)
[parf] alarm (  4): Uninitialized((tokens + i)->type)
[parf] alarm (  5): Memory_access((tokens + i)->type, read)
[parf] alarm (  6): Uninitialized((tokens + i)->start)
[parf] alarm (  7): Uninitialized((tokens + i)->end)
[parf] alarm (  8): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  9): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 10): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 11): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 12): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 13): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 14): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 15): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 16): Memory_access((tokens + i)->start, read)
[parf] alarm ( 17): Uninitialized((tokens + i)->start)
[parf] alarm ( 18): Uninitialized((tokens + i)->end)
[parf] alarm ( 19): Uninitialized(token->start)
[parf] alarm ( 20): Memory_access(token->start, read)
[parf] alarm ( 21): Uninitialized(token->end)
[parf] alarm ( 22): Uninitialized(token->type)
[parf] alarm ( 23): Memory_access(token->start, read)
[parf] alarm ( 24): Uninitialized(token->start)
[parf] alarm ( 25): Uninitialized(token->end)
[parf] alarm ( 26): Memory_access((t + i)->type, read)
[parf] alarm ( 27): Uninitialized((t + i)->type)
[parf] alarm ( 28): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 29): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 30): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 31): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 32): Uninitialized((t + i)->size)
[parf] alarm ( 33): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 34): Memory_access((tokens + parser->toksuper)->type, read)
[parf] ============================================================================
[parf] ====== project "base01-sample00 2" ======
[parf] Parameter: -eva-widening-delay 5 -eva-subdivide-non-linear 11 -eva-split-return auto -eva-slevel 22 -eva-remove-redundant-alarms -eva-plevel 91 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 37 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 24
[parf] alarms:
[parf] alarm (  1): Uninitialized((t + i)->start)
[parf] alarm (  2): Signed_overflow((t + i)->end - (t + i)->start <= 2147483647)
[parf] alarm (  3): Uninitialized((t + i)->end)
[parf] alarm (  4): Uninitialized((tokens + i)->type)
[parf] alarm (  5): Memory_access((tokens + i)->type, read)
[parf] alarm (  6): Uninitialized((tokens + i)->start)
[parf] alarm (  7): Uninitialized((tokens + i)->end)
[parf] alarm (  8): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  9): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 10): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 11): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 12): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 13): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 14): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 15): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 16): Memory_access((tokens + i)->start, read)
[parf] alarm ( 17): Uninitialized((tokens + i)->start)
[parf] alarm ( 18): Uninitialized((tokens + i)->end)
[parf] alarm ( 19): Uninitialized(token->start)
[parf] alarm ( 20): Memory_access(token->start, read)
[parf] alarm ( 21): Uninitialized(token->end)
[parf] alarm ( 22): Uninitialized(token->type)
[parf] alarm ( 23): Uninitialized(token->start)
[parf] alarm ( 24): Uninitialized(token->end)
[parf] alarm ( 25): Memory_access((t + i)->type, read)
[parf] alarm ( 26): Uninitialized((t + i)->type)
[parf] alarm ( 27): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 28): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 29): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 30): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 31): Uninitialized((t + i)->size)
[parf] alarm ( 32): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 33): Memory_access((tokens + parser->toksuper)->type, read)
[parf] ============================================================================
[parf] ====== project "base01-sample01 2" ======
[parf] Parameter: -eva-widening-delay 3 -eva-subdivide-non-linear 11 -eva-slevel 26 -eva-remove-redundant-alarms -eva-plevel 76 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 39 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 17
[parf] alarms:
[parf] alarm (  1): Uninitialized((t + i)->start)
[parf] alarm (  2): Signed_overflow((t + i)->end - (t + i)->start <= 2147483647)
[parf] alarm (  3): Uninitialized((t + i)->end)
[parf] alarm (  4): Uninitialized((tokens + i)->type)
[parf] alarm (  5): Memory_access((tokens + i)->type, read)
[parf] alarm (  6): Uninitialized((tokens + i)->start)
[parf] alarm (  7): Uninitialized((tokens + i)->end)
[parf] alarm (  8): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  9): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 10): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 11): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 12): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 13): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 14): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 15): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 16): Memory_access((tokens + i)->start, read)
[parf] alarm ( 17): Uninitialized((tokens + i)->start)
[parf] alarm ( 18): Uninitialized((tokens + i)->end)
[parf] alarm ( 19): Uninitialized(token->start)
[parf] alarm ( 20): Memory_access(token->start, read)
[parf] alarm ( 21): Uninitialized(token->end)
[parf] alarm ( 22): Uninitialized(token->type)
[parf] alarm ( 23): Uninitialized(token->start)
[parf] alarm ( 24): Uninitialized(token->end)
[parf] alarm ( 25): Memory_access((t + i)->type, read)
[parf] alarm ( 26): Uninitialized((t + i)->type)
[parf] alarm ( 27): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 28): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 29): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 30): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 31): Uninitialized((t + i)->size)
[parf] alarm ( 32): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 33): Memory_access((tokens + parser->toksuper)->type, read)
[parf] ============================================================================
[parf] ====== project "base01-sample02 2" ======
[parf] Parameter: -eva-widening-delay 3 -eva-subdivide-non-linear 8 -eva-split-return auto -eva-slevel 22 -eva-remove-redundant-alarms -eva-plevel 84 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 45 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 20
[parf] alarms:
[parf] alarm (  1): Uninitialized((t + i)->start)
[parf] alarm (  2): Signed_overflow((t + i)->end - (t + i)->start <= 2147483647)
[parf] alarm (  3): Uninitialized((t + i)->end)
[parf] alarm (  4): Uninitialized((tokens + i)->type)
[parf] alarm (  5): Memory_access((tokens + i)->type, read)
[parf] alarm (  6): Uninitialized((tokens + i)->start)
[parf] alarm (  7): Uninitialized((tokens + i)->end)
[parf] alarm (  8): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  9): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 10): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 11): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 12): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 13): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 14): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 15): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 16): Memory_access((tokens + i)->start, read)
[parf] alarm ( 17): Uninitialized((tokens + i)->start)
[parf] alarm ( 18): Uninitialized((tokens + i)->end)
[parf] alarm ( 19): Uninitialized(token->start)
[parf] alarm ( 20): Memory_access(token->start, read)
[parf] alarm ( 21): Uninitialized(token->end)
[parf] alarm ( 22): Uninitialized(token->type)
[parf] alarm ( 23): Uninitialized(token->start)
[parf] alarm ( 24): Uninitialized(token->end)
[parf] alarm ( 25): Memory_access((t + i)->type, read)
[parf] alarm ( 26): Uninitialized((t + i)->type)
[parf] alarm ( 27): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 28): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 29): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 30): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 31): Uninitialized((t + i)->size)
[parf] alarm ( 32): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 33): Memory_access((tokens + parser->toksuper)->type, read)
[parf] ============================================================================
[parf] ====== project "base01-sample03 2" ======
[parf] Parameter: -eva-widening-delay 4 -eva-subdivide-non-linear 10 -eva-slevel 23 -eva-remove-redundant-alarms -eva-plevel 79 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 36 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 16
[parf] alarms:
[parf] alarm (  1): Uninitialized((t + i)->start)
[parf] alarm (  2): Signed_overflow((t + i)->end - (t + i)->start <= 2147483647)
[parf] alarm (  3): Uninitialized((t + i)->end)
[parf] alarm (  4): Uninitialized((tokens + i)->type)
[parf] alarm (  5): Memory_access((tokens + i)->type, read)
[parf] alarm (  6): Uninitialized((tokens + i)->start)
[parf] alarm (  7): Uninitialized((tokens + i)->end)
[parf] alarm (  8): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  9): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 10): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 11): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 12): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 13): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 14): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 15): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 16): Memory_access((tokens + i)->start, read)
[parf] alarm ( 17): Uninitialized((tokens + i)->start)
[parf] alarm ( 18): Uninitialized((tokens + i)->end)
[parf] alarm ( 19): Uninitialized(token->start)
[parf] alarm ( 20): Memory_access(token->start, read)
[parf] alarm ( 21): Uninitialized(token->end)
[parf] alarm ( 22): Uninitialized(token->type)
[parf] alarm ( 23): Uninitialized(token->start)
[parf] alarm ( 24): Uninitialized(token->end)
[parf] alarm ( 25): Memory_access((t + i)->type, read)
[parf] alarm ( 26): Uninitialized((t + i)->type)
[parf] alarm ( 27): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 28): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 29): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 30): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 31): Uninitialized((t + i)->size)
[parf] alarm ( 32): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 33): Memory_access((tokens + parser->toksuper)->type, read)
[parf] ============================================================================
[parf] ====== project "base02-sample00 2" ======
[parf] Parameter: -eva-widening-delay 6 -eva-subdivide-non-linear 17 -eva-slevel 44 -eva-remove-redundant-alarms -eva-plevel 156 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 79 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 30
[parf] alarms:
[parf] alarm (  1): Uninitialized((tokens + i)->type)
[parf] alarm (  2): Memory_access((tokens + i)->type, read)
[parf] alarm (  3): Uninitialized((tokens + i)->start)
[parf] alarm (  4): Uninitialized((tokens + i)->end)
[parf] alarm (  5): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  6): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  7): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm (  8): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm (  9): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 10): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 11): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 12): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 13): Memory_access((tokens + i)->start, read)
[parf] alarm ( 14): Uninitialized((tokens + i)->start)
[parf] alarm ( 15): Uninitialized((tokens + i)->end)
[parf] alarm ( 16): Uninitialized(token->start)
[parf] alarm ( 17): Memory_access(token->start, read)
[parf] alarm ( 18): Uninitialized(token->end)
[parf] alarm ( 19): Uninitialized(token->type)
[parf] alarm ( 20): Uninitialized(token->start)
[parf] alarm ( 21): Uninitialized(token->end)
[parf] alarm ( 22): Memory_access((t + i)->type, read)
[parf] alarm ( 23): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 24): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 25): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 26): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 27): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 28): Memory_access((tokens + parser->toksuper)->type, read)
[parf] ============================================================================
[parf] ====== project "base02-sample01 2" ======
[parf] Parameter: -eva-widening-delay 6 -eva-subdivide-non-linear 13 -eva-slevel 44 -eva-remove-redundant-alarms -eva-plevel 155 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 87 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 31
[parf] alarms:
[parf] alarm (  1): Uninitialized((tokens + i)->type)
[parf] alarm (  2): Memory_access((tokens + i)->type, read)
[parf] alarm (  3): Uninitialized((tokens + i)->start)
[parf] alarm (  4): Uninitialized((tokens + i)->end)
[parf] alarm (  5): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  6): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  7): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm (  8): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm (  9): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 10): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 11): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 12): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 13): Memory_access((tokens + i)->start, read)
[parf] alarm ( 14): Uninitialized((tokens + i)->start)
[parf] alarm ( 15): Uninitialized((tokens + i)->end)
[parf] alarm ( 16): Uninitialized(token->start)
[parf] alarm ( 17): Memory_access(token->start, read)
[parf] alarm ( 18): Uninitialized(token->end)
[parf] alarm ( 19): Uninitialized(token->type)
[parf] alarm ( 20): Uninitialized(token->start)
[parf] alarm ( 21): Uninitialized(token->end)
[parf] alarm ( 22): Memory_access((t + i)->type, read)
[parf] alarm ( 23): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 24): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 25): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 26): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 27): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 28): Memory_access((tokens + parser->toksuper)->type, read)
[parf] ============================================================================
[parf] ====== project "base02-sample02 2" ======
[parf] Parameter: -eva-widening-delay 4 -eva-subdivide-non-linear 19 -eva-split-return auto -eva-slevel 45 -eva-remove-redundant-alarms -eva-plevel 154 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 76 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 33
[parf] alarms:
[parf] alarm (  1): Uninitialized((tokens + i)->type)
[parf] alarm (  2): Memory_access((tokens + i)->type, read)
[parf] alarm (  3): Uninitialized((tokens + i)->start)
[parf] alarm (  4): Uninitialized((tokens + i)->end)
[parf] alarm (  5): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  6): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  7): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm (  8): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm (  9): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 10): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 11): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 12): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 13): Memory_access((tokens + i)->start, read)
[parf] alarm ( 14): Uninitialized((tokens + i)->start)
[parf] alarm ( 15): Uninitialized((tokens + i)->end)
[parf] alarm ( 16): Uninitialized(token->start)
[parf] alarm ( 17): Memory_access(token->start, read)
[parf] alarm ( 18): Uninitialized(token->end)
[parf] alarm ( 19): Uninitialized(token->type)
[parf] alarm ( 20): Uninitialized(token->start)
[parf] alarm ( 21): Uninitialized(token->end)
[parf] alarm ( 22): Memory_access((t + i)->type, read)
[parf] alarm ( 23): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 24): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 25): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 26): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 27): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 28): Memory_access((tokens + parser->toksuper)->type, read)
[parf] ============================================================================
[parf] ====== project "base02-sample03 2" ======
[parf] Parameter: -eva-widening-delay 6 -eva-subdivide-non-linear 16 -eva-slevel 39 -eva-remove-redundant-alarms -eva-plevel 155 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 79 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 35
[parf] alarms:
[parf] alarm (  1): Uninitialized((tokens + i)->type)
[parf] alarm (  2): Memory_access((tokens + i)->type, read)
[parf] alarm (  3): Uninitialized((tokens + i)->start)
[parf] alarm (  4): Uninitialized((tokens + i)->end)
[parf] alarm (  5): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  6): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  7): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm (  8): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm (  9): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 10): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 11): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 12): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 13): Memory_access((tokens + i)->start, read)
[parf] alarm ( 14): Uninitialized((tokens + i)->start)
[parf] alarm ( 15): Uninitialized((tokens + i)->end)
[parf] alarm ( 16): Uninitialized(token->start)
[parf] alarm ( 17): Memory_access(token->start, read)
[parf] alarm ( 18): Uninitialized(token->end)
[parf] alarm ( 19): Uninitialized(token->type)
[parf] alarm ( 20): Uninitialized(token->start)
[parf] alarm ( 21): Uninitialized(token->end)
[parf] alarm ( 22): Memory_access((t + i)->type, read)
[parf] alarm ( 23): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 24): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 25): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 26): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 27): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 28): Memory_access((tokens + parser->toksuper)->type, read)
[parf] ============================================================================
[parf] ====== project "base03-sample00 2" ======
[parf] Parameter: -eva-widening-delay 6 -eva-subdivide-non-linear 23 -eva-slevel 84 -eva-remove-redundant-alarms -eva-plevel 303 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 160 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 58
[parf] alarms:
[parf] alarm (  1): Uninitialized((tokens + i)->type)
[parf] alarm (  2): Memory_access((tokens + i)->type, read)
[parf] alarm (  3): Uninitialized((tokens + i)->type)
[parf] alarm (  4): Uninitialized((tokens + i)->start)
[parf] alarm (  5): Uninitialized((tokens + i)->end)
[parf] alarm (  6): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  7): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  8): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm (  9): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 10): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 11): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 12): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 13): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 14): Memory_access((tokens + i)->start, read)
[parf] alarm ( 15): Uninitialized((tokens + i)->start)
[parf] alarm ( 16): Uninitialized((tokens + i)->end)
[parf] alarm ( 17): Uninitialized(token->start)
[parf] alarm ( 18): Memory_access(token->start, read)
[parf] alarm ( 19): Uninitialized(token->end)
[parf] alarm ( 20): Uninitialized(token->type)
[parf] alarm ( 21): Uninitialized(token->start)
[parf] alarm ( 22): Uninitialized(token->end)
[parf] alarm ( 23): Memory_access((t + i)->type, read)
[parf] alarm ( 24): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 25): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 26): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 27): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 28): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 29): Memory_access((tokens + parser->toksuper)->type, read)
[parf] ============================================================================
[parf] ====== project "base03-sample01 2" ======
[parf] Parameter: -eva-widening-delay 7 -eva-subdivide-non-linear 33 -eva-slevel 70 -eva-remove-redundant-alarms -eva-plevel 326 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 152 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 57
[parf] alarms:
[parf] alarm (  1): Uninitialized((tokens + i)->type)
[parf] alarm (  2): Memory_access((tokens + i)->type, read)
[parf] alarm (  3): Uninitialized((tokens + i)->type)
[parf] alarm (  4): Uninitialized((tokens + i)->start)
[parf] alarm (  5): Uninitialized((tokens + i)->end)
[parf] alarm (  6): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  7): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  8): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm (  9): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 10): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 11): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 12): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 13): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 14): Memory_access((tokens + i)->start, read)
[parf] alarm ( 15): Uninitialized((tokens + i)->start)
[parf] alarm ( 16): Uninitialized((tokens + i)->end)
[parf] alarm ( 17): Uninitialized(token->start)
[parf] alarm ( 18): Memory_access(token->start, read)
[parf] alarm ( 19): Uninitialized(token->end)
[parf] alarm ( 20): Uninitialized(token->type)
[parf] alarm ( 21): Uninitialized(token->start)
[parf] alarm ( 22): Uninitialized(token->end)
[parf] alarm ( 23): Memory_access((t + i)->type, read)
[parf] alarm ( 24): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 25): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 26): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 27): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 28): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 29): Memory_access((tokens + parser->toksuper)->type, read)
[parf] ============================================================================
[parf] ====== project "base03-sample02 2" ======
[parf] Parameter: -eva-widening-delay 11 -eva-subdivide-non-linear 36 -eva-slevel 73 -eva-remove-redundant-alarms -eva-plevel 321 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 146 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 57
[parf] alarms:
[parf] alarm (  1): Uninitialized((tokens + i)->type)
[parf] alarm (  2): Memory_access((tokens + i)->type, read)
[parf] alarm (  3): Uninitialized((tokens + i)->type)
[parf] alarm (  4): Uninitialized((tokens + i)->start)
[parf] alarm (  5): Uninitialized((tokens + i)->end)
[parf] alarm (  6): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  7): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  8): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm (  9): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 10): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 11): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 12): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 13): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 14): Memory_access((tokens + i)->start, read)
[parf] alarm ( 15): Uninitialized((tokens + i)->start)
[parf] alarm ( 16): Uninitialized((tokens + i)->end)
[parf] alarm ( 17): Uninitialized(token->start)
[parf] alarm ( 18): Memory_access(token->start, read)
[parf] alarm ( 19): Uninitialized(token->end)
[parf] alarm ( 20): Uninitialized(token->type)
[parf] alarm ( 21): Uninitialized(token->start)
[parf] alarm ( 22): Uninitialized(token->end)
[parf] alarm ( 23): Memory_access((t + i)->type, read)
[parf] alarm ( 24): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 25): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 26): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 27): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 28): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 29): Memory_access((tokens + parser->toksuper)->type, read)
[parf] ============================================================================
[parf] ====== project "base03-sample03 2" ======
[parf] Parameter: -eva-widening-delay 9 -eva-subdivide-non-linear 23 -eva-slevel 82 -eva-remove-redundant-alarms -eva-plevel 314 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 157 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 59
[parf] alarms:
[parf] alarm (  1): Uninitialized((tokens + i)->type)
[parf] alarm (  2): Memory_access((tokens + i)->type, read)
[parf] alarm (  3): Uninitialized((tokens + i)->type)
[parf] alarm (  4): Uninitialized((tokens + i)->start)
[parf] alarm (  5): Uninitialized((tokens + i)->end)
[parf] alarm (  6): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  7): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  8): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm (  9): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 10): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 11): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 12): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 13): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 14): Memory_access((tokens + i)->start, read)
[parf] alarm ( 15): Uninitialized((tokens + i)->start)
[parf] alarm ( 16): Uninitialized((tokens + i)->end)
[parf] alarm ( 17): Uninitialized(token->start)
[parf] alarm ( 18): Memory_access(token->start, read)
[parf] alarm ( 19): Uninitialized(token->end)
[parf] alarm ( 20): Uninitialized(token->type)
[parf] alarm ( 21): Uninitialized(token->start)
[parf] alarm ( 22): Uninitialized(token->end)
[parf] alarm ( 23): Memory_access((t + i)->type, read)
[parf] alarm ( 24): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 25): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 26): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 27): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 28): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 29): Memory_access((tokens + parser->toksuper)->type, read)
[parf] ============================================================================
[parf] ====== project "base04-sample00 2" ======
[parf] Parameter: -eva-widening-delay 9 -eva-subdivide-non-linear 47 -eva-split-return auto -eva-slevel 148 -eva-remove-redundant-alarms -eva-plevel 605 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 299 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 121
[parf] alarms:
[parf] alarm (  1): Uninitialized((tokens + i)->type)
[parf] alarm (  2): Memory_access((tokens + i)->type, read)
[parf] alarm (  3): Uninitialized((tokens + i)->type)
[parf] alarm (  4): Uninitialized((tokens + i)->start)
[parf] alarm (  5): Uninitialized((tokens + i)->end)
[parf] alarm (  6): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  7): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  8): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm (  9): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 10): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 11): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 12): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 13): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 14): Memory_access((tokens + i)->start, read)
[parf] alarm ( 15): Uninitialized((tokens + i)->start)
[parf] alarm ( 16): Uninitialized((tokens + i)->end)
[parf] alarm ( 17): Uninitialized(token->start)
[parf] alarm ( 18): Memory_access(token->start, read)
[parf] alarm ( 19): Uninitialized(token->end)
[parf] alarm ( 20): Uninitialized(token->type)
[parf] alarm ( 21): Uninitialized(token->start)
[parf] alarm ( 22): Uninitialized(token->end)
[parf] alarm ( 23): Memory_access((t + i)->type, read)
[parf] alarm ( 24): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 25): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 26): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 27): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 28): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 29): Memory_access((tokens + parser->toksuper)->type, read)
[parf] ============================================================================
[parf] ====== project "base04-sample01 2" ======
[parf] Parameter: -eva-widening-delay 10 -eva-subdivide-non-linear 49 -eva-slevel 132 -eva-remove-redundant-alarms -eva-plevel 630 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 296 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 112
[parf] alarms:
[parf] alarm (  1): Uninitialized((tokens + i)->type)
[parf] alarm (  2): Memory_access((tokens + i)->type, read)
[parf] alarm (  3): Uninitialized((tokens + i)->type)
[parf] alarm (  4): Uninitialized((tokens + i)->start)
[parf] alarm (  5): Uninitialized((tokens + i)->end)
[parf] alarm (  6): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  7): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  8): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm (  9): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 10): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 11): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 12): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 13): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 14): Memory_access((tokens + i)->start, read)
[parf] alarm ( 15): Uninitialized((tokens + i)->start)
[parf] alarm ( 16): Uninitialized((tokens + i)->end)
[parf] alarm ( 17): Uninitialized(token->start)
[parf] alarm ( 18): Memory_access(token->start, read)
[parf] alarm ( 19): Uninitialized(token->end)
[parf] alarm ( 20): Uninitialized(token->type)
[parf] alarm ( 21): Uninitialized(token->start)
[parf] alarm ( 22): Uninitialized(token->end)
[parf] alarm ( 23): Memory_access((t + i)->type, read)
[parf] alarm ( 24): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 25): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 26): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 27): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 28): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 29): Memory_access((tokens + parser->toksuper)->type, read)
[parf] ============================================================================
[parf] ====== project "base04-sample02 2" ======
[parf] Parameter: -eva-widening-delay 14 -eva-subdivide-non-linear 47 -eva-slevel 134 -eva-remove-redundant-alarms -eva-plevel 604 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 280 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 104
[parf] alarms:
[parf] alarm (  1): Uninitialized((tokens + i)->type)
[parf] alarm (  2): Memory_access((tokens + i)->type, read)
[parf] alarm (  3): Uninitialized((tokens + i)->type)
[parf] alarm (  4): Uninitialized((tokens + i)->start)
[parf] alarm (  5): Uninitialized((tokens + i)->end)
[parf] alarm (  6): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  7): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  8): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm (  9): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 10): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 11): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 12): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 13): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 14): Memory_access((tokens + i)->start, read)
[parf] alarm ( 15): Uninitialized((tokens + i)->start)
[parf] alarm ( 16): Uninitialized((tokens + i)->end)
[parf] alarm ( 17): Uninitialized(token->start)
[parf] alarm ( 18): Memory_access(token->start, read)
[parf] alarm ( 19): Uninitialized(token->end)
[parf] alarm ( 20): Uninitialized(token->type)
[parf] alarm ( 21): Uninitialized(token->start)
[parf] alarm ( 22): Uninitialized(token->end)
[parf] alarm ( 23): Memory_access((t + i)->type, read)
[parf] alarm ( 24): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 25): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 26): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 27): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 28): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 29): Memory_access((tokens + parser->toksuper)->type, read)
[parf] ============================================================================
[parf] ====== project "base04-sample03 2" ======
[parf] Parameter: -eva-widening-delay 11 -eva-subdivide-non-linear 47 -eva-slevel 151 -eva-remove-redundant-alarms -eva-plevel 617 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 294 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 119
[parf] alarms:
[parf] alarm (  1): Uninitialized((tokens + i)->type)
[parf] alarm (  2): Memory_access((tokens + i)->type, read)
[parf] alarm (  3): Uninitialized((tokens + i)->type)
[parf] alarm (  4): Uninitialized((tokens + i)->start)
[parf] alarm (  5): Uninitialized((tokens + i)->end)
[parf] alarm (  6): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  7): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  8): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm (  9): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 10): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 11): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 12): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 13): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 14): Memory_access((tokens + i)->start, read)
[parf] alarm ( 15): Uninitialized((tokens + i)->start)
[parf] alarm ( 16): Uninitialized((tokens + i)->end)
[parf] alarm ( 17): Uninitialized(token->start)
[parf] alarm ( 18): Memory_access(token->start, read)
[parf] alarm ( 19): Uninitialized(token->end)
[parf] alarm ( 20): Uninitialized(token->type)
[parf] alarm ( 21): Uninitialized(token->start)
[parf] alarm ( 22): Uninitialized(token->end)
[parf] alarm ( 23): Memory_access((t + i)->type, read)
[parf] alarm ( 24): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 25): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 26): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 27): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 28): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 29): Memory_access((tokens + parser->toksuper)->type, read)
[parf] ============================================================================
[parf] ====== project "base05-sample00 2" ======
[parf] Parameter: -eva-widening-delay 20 -eva-subdivide-non-linear 84 -eva-slevel 246 -eva-remove-redundant-alarms -eva-plevel 1239 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 513 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 208
[parf] alarms:
[parf] alarm (  1): Uninitialized((tokens + i)->type)
[parf] alarm (  2): Memory_access((tokens + i)->type, read)
[parf] alarm (  3): Uninitialized((tokens + i)->type)
[parf] alarm (  4): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  5): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm (  6): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm (  7): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm (  8): Memory_access((tokens + i)->start, read)
[parf] alarm (  9): Uninitialized((tokens + i)->start)
[parf] alarm ( 10): Uninitialized((tokens + i)->end)
[parf] alarm ( 11): Uninitialized(token->start)
[parf] alarm ( 12): Memory_access(token->start, read)
[parf] alarm ( 13): Uninitialized(token->end)
[parf] alarm ( 14): Uninitialized(token->type)
[parf] alarm ( 15): Uninitialized(token->start)
[parf] alarm ( 16): Uninitialized(token->end)
[parf] alarm ( 17): Memory_access((t + i)->type, read)
[parf] alarm ( 18): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 19): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 20): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 21): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 22): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 23): Memory_access((tokens + parser->toksuper)->type, read)
[parf] ============================================================================
[parf] ====== project "base05-sample01 2" ======
[parf] Parameter: -eva-widening-delay 14 -eva-subdivide-non-linear 96 -eva-split-return auto -eva-slevel 252 -eva-remove-redundant-alarms -eva-plevel 1204 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 502 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 207
[parf] alarms:
[parf] alarm (  1): Uninitialized((tokens + i)->type)
[parf] alarm (  2): Memory_access((tokens + i)->type, read)
[parf] alarm (  3): Uninitialized((tokens + i)->type)
[parf] alarm (  4): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  5): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm (  6): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm (  7): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm (  8): Memory_access((tokens + i)->start, read)
[parf] alarm (  9): Uninitialized((tokens + i)->start)
[parf] alarm ( 10): Uninitialized((tokens + i)->end)
[parf] alarm ( 11): Uninitialized(token->start)
[parf] alarm ( 12): Memory_access(token->start, read)
[parf] alarm ( 13): Uninitialized(token->end)
[parf] alarm ( 14): Uninitialized(token->type)
[parf] alarm ( 15): Uninitialized(token->start)
[parf] alarm ( 16): Uninitialized(token->end)
[parf] alarm ( 17): Memory_access((t + i)->type, read)
[parf] alarm ( 18): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 19): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 20): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 21): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 22): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 23): Memory_access((tokens + parser->toksuper)->type, read)
[parf] ============================================================================
[parf] ====== project "base05-sample02 2" ======
[parf] Parameter: -eva-widening-delay 20 -eva-subdivide-non-linear 90 -eva-split-return auto -eva-slevel 281 -eva-remove-redundant-alarms -eva-plevel 1231 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 513 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 186
[parf] alarms:
[parf] alarm (  1): Uninitialized((tokens + i)->type)
[parf] alarm (  2): Memory_access((tokens + i)->type, read)
[parf] alarm (  3): Uninitialized((tokens + i)->type)
[parf] alarm (  4): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  5): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm (  6): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm (  7): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm (  8): Memory_access((tokens + i)->start, read)
[parf] alarm (  9): Uninitialized((tokens + i)->start)
[parf] alarm ( 10): Uninitialized((tokens + i)->end)
[parf] alarm ( 11): Uninitialized(token->start)
[parf] alarm ( 12): Memory_access(token->start, read)
[parf] alarm ( 13): Uninitialized(token->end)
[parf] alarm ( 14): Uninitialized(token->type)
[parf] alarm ( 15): Uninitialized(token->start)
[parf] alarm ( 16): Uninitialized(token->end)
[parf] alarm ( 17): Memory_access((t + i)->type, read)
[parf] alarm ( 18): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 19): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 20): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 21): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 22): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 23): Memory_access((tokens + parser->toksuper)->type, read)
[parf] ============================================================================
[parf] ====== project "base05-sample03 2" ======
[parf] Parameter: -eva-widening-delay 20 -eva-subdivide-non-linear 91 -eva-split-return auto -eva-slevel 269 -eva-remove-redundant-alarms -eva-plevel 1268 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 503 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 216
[parf] alarms:
[parf] alarm (  1): Uninitialized((tokens + i)->type)
[parf] alarm (  2): Memory_access((tokens + i)->type, read)
[parf] alarm (  3): Uninitialized((tokens + i)->type)
[parf] alarm (  4): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm (  5): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm (  6): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm (  7): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm (  8): Memory_access((tokens + i)->start, read)
[parf] alarm (  9): Uninitialized((tokens + i)->start)
[parf] alarm ( 10): Uninitialized((tokens + i)->end)
[parf] alarm ( 11): Uninitialized(token->start)
[parf] alarm ( 12): Memory_access(token->start, read)
[parf] alarm ( 13): Uninitialized(token->end)
[parf] alarm ( 14): Uninitialized(token->type)
[parf] alarm ( 15): Uninitialized(token->start)
[parf] alarm ( 16): Uninitialized(token->end)
[parf] alarm ( 17): Memory_access((t + i)->type, read)
[parf] alarm ( 18): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 19): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 20): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 21): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 22): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 23): Memory_access((tokens + parser->toksuper)->type, read)
[parf] ============================================================================
[parf] ====== project "base06-sample00 2" ======
[parf] Parameter: -eva-widening-delay 21 -eva-subdivide-non-linear 162 -eva-split-return auto -eva-slevel 472 -eva-remove-redundant-alarms -eva-plevel 3205 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 504 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 368
[parf] alarms:
[parf] alarm (  1): Memory_access((t + i)->type, read)
[parf] ============================================================================
[parf] ====== project "base06-sample01 2" ======
[parf] Parameter: -eva-widening-delay 17 -eva-subdivide-non-linear 152 -eva-split-return auto -eva-slevel 496 -eva-remove-redundant-alarms -eva-plevel 3205 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 513 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 359
[parf] alarms:
[parf] alarm (  1): Memory_access((t + i)->type, read)
[parf] ============================================================================
[parf] ====== project "base06-sample02 2" ======
[parf] Parameter: -eva-widening-delay 15 -eva-subdivide-non-linear 168 -eva-slevel 502 -eva-remove-redundant-alarms -eva-plevel 3205 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 513 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 373
[parf] alarms:
[parf] alarm (  1): Memory_access((t + i)->type, read)
[parf] ============================================================================
[parf] ====== project "base06-sample03 2" ======
[parf] Parameter: -eva-widening-delay 21 -eva-subdivide-non-linear 176 -eva-slevel 493 -eva-remove-redundant-alarms -eva-plevel 3205 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 502 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 366
[parf] alarms:
[parf] alarm (  1): Memory_access((t + i)->type, read)
[parf] ============================================================================
[parf] ====== project "base07-sample00 2" ======
[parf] Parameter: -eva-widening-delay 20 -eva-subdivide-non-linear 317 -eva-slevel 968 -eva-remove-redundant-alarms -eva-plevel 4001 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 513 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 724
[parf] alarms:
[parf] alarm (  1): Memory_access((t + i)->type, read)
[parf] ============================================================================
[parf] ====== project "base07-sample01 2" ======
[parf] Parameter: -eva-widening-delay 16 -eva-subdivide-non-linear 294 -eva-slevel 946 -eva-remove-redundant-alarms -eva-plevel 4001 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 513 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 740
[parf] alarms:
[parf] alarm (  1): Memory_access((t + i)->type, read)
[parf] ============================================================================
[parf] ====== project "base07-sample02 2" ======
[parf] Parameter: -eva-widening-delay 21 -eva-subdivide-non-linear 312 -eva-slevel 918 -eva-remove-redundant-alarms -eva-plevel 4001 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 512 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 727
[parf] alarms:
[parf] alarm (  1): Memory_access((t + i)->type, read)
[parf] ============================================================================
[parf] ====== project "base07-sample03 2" ======
[parf] Parameter: -eva-widening-delay 21 -eva-subdivide-non-linear 302 -eva-slevel 941 -eva-remove-redundant-alarms -eva-plevel 4001 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 513 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 707
[parf] alarms:
[parf] alarm (  1): Memory_access((t + i)->type, read)
[parf] ============================================================================
[parf] Final parameter: -eva-widening-delay 21 -eva-subdivide-non-linear 162 -eva-split-return auto -eva-slevel 472 -eva-remove-redundant-alarms -eva-plevel 3205 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 504 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 368
[parf] alarms:
[parf] alarm (  1): Memory_access((t + i)->type, read)

real	2m42.689s
user	7m3.630s
sys	0m10.546s
Entering directory '/Users/carolt/Abstract_Interpretation/Tools_Development/Frama-c-Plugin/src/demo_1'
Leaving directory '/Users/carolt/Abstract_Interpretation/Tools_Development/Frama-c-Plugin/src/demo_1'
[kernel] Parsing jsmn.c (with preprocessing)
[kernel] Parsing example/simple.c (with preprocessing)
mkdir: .parf_temp_files: File exists
rm: .parf_temp_files/*.sav: No such file or directory
[parf] checkout project: project "default"
[parf] init parameters: -eva-widening-delay 1 -eva-subdivide-non-linear 0 -eva-slevel 0 -eva-plevel 10 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 8 -eva-equality-through-calls none -eva-domains cvalue -eva-auto-loop-unroll 0
[parf] run eva: start
[parf] set eva options
[parf] parameters: -eva-widening-delay 1 -eva-subdivide-non-linear 0 -eva-slevel 0 -eva-plevel 10 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 8 -eva-equality-through-calls none -eva-domains cvalue -eva-auto-loop-unroll 0
[parf] @default,cvalue
[eva] Analyzing a complete application starting at main
[eva] jsmn.c:158: starting to merge loop iterations
[eva] jsmn.c:93: starting to merge loop iterations
[eva] jsmn.c:125: starting to merge loop iterations
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:250: starting to merge loop iterations
[eva] using specification for function printf_va_1
[eva] using specification for function printf_va_2
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_7
[eva] example/simple.c:65: starting to merge loop iterations
[eva] using specification for function printf_va_8
[eva] example/simple.c:43: starting to merge loop iterations
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 296 statements reached (out of 311): 95% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  68 alarms generated by the analysis:
      35 accesses to uninitialized left-values
      18 integer overflows
      10 invalid memory accesses
       5 accesses out of bounds index
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    11 valid     6 unknown     0 invalid     17 total
  64% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[parf] base: base00
[parf] Analysis time for this epoch: 180
[parf] sample: base00-sample00
[parf] sample: base00-sample01
[parf] sample: base00-sample02
[parf] sample: base00-sample03
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] parameters: -eva-widening-delay 2 -eva-subdivide-non-linear 3 -eva-slevel 15 -eva-remove-redundant-alarms -eva-plevel 31 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 16 -eva-equality-through-calls none -eva-domains cvalue,gauges,symbolic-locations -eva-auto-loop-unroll 4
[parf] set eva options
[parf] parameters: -eva-widening-delay 2 -eva-subdivide-non-linear 3 -eva-slevel 14 -eva-plevel 33 -eva-partition-history 1 -eva-min-loop-unroll 0 -eva-ilevel 16 -eva-equality-through-calls none -eva-domains cvalue -eva-auto-loop-unroll 17
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] parameters: -eva-widening-delay 3 -eva-subdivide-non-linear 3 -eva-slevel 13 -eva-remove-redundant-alarms -eva-plevel 28 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 17 -eva-equality-through-calls none -eva-domains cvalue,equality -eva-auto-loop-unroll 14
[parf] set eva options
[parf] parameters: -eva-widening-delay 2 -eva-subdivide-non-linear 1 -eva-slevel 8 -eva-plevel 29 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 21 -eva-equality-through-calls formals -eva-domains cvalue,equality -eva-auto-loop-unroll 14
[parf] @default,cvalue,equality
[parf] @default,cvalue,equality
[parf] @default,cvalue
[parf] @default,cvalue,gauges,symbolic-locations
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] jsmn.c:158: starting to merge loop iterations
[eva] jsmn.c:158: starting to merge loop iterations
[eva] jsmn.c:158: starting to merge loop iterations
[eva] jsmn.c:158: starting to merge loop iterations
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:125: starting to merge loop iterations
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:250: starting to merge loop iterations
[eva] jsmn.c:133: Trace partitioning superposing up to 100 states
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:250: starting to merge loop iterations
[eva] jsmn.c:250: starting to merge loop iterations
[eva] using specification for function printf_va_1
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_3
[eva] jsmn.c:93: starting to merge loop iterations
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_7
[eva] jsmn.c:133: Trace partitioning superposing up to 200 states
[eva] example/simple.c:65: starting to merge loop iterations
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_1
[eva] using specification for function printf_va_1
[eva] using specification for function printf_va_2
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_2
[eva] using specification for function strncmp
[eva] using specification for function printf_va_4
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_7
[eva] example/simple.c:65: starting to merge loop iterations
[eva] using specification for function printf_va_8
[eva] example/simple.c:65: starting to merge loop iterations
[eva] using specification for function printf_va_8
[eva] jsmn.c:42: starting to merge loop iterations
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 290 statements reached (out of 311): 93% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  71 alarms generated by the analysis:
      38 accesses to uninitialized left-values
      18 integer overflows
      10 invalid memory accesses
       5 accesses out of bounds index
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    10 valid     6 unknown     0 invalid     16 total
  62% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:222: starting to merge loop iterations
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 296 statements reached (out of 311): 95% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  68 alarms generated by the analysis:
      37 accesses to uninitialized left-values
      17 integer overflows
       9 invalid memory accesses
       5 accesses out of bounds index
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    11 valid     6 unknown     0 invalid     17 total
  64% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[scope:rm_asserts] removing 4 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 296 statements reached (out of 311): 95% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  68 alarms generated by the analysis:
      37 accesses to uninitialized left-values
      17 integer overflows
       9 invalid memory accesses
       5 accesses out of bounds index
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    11 valid     6 unknown     0 invalid     17 total
  64% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] jsmn.c:250: starting to merge loop iterations
[eva] jsmn.c:294: starting to merge loop iterations
[eva] using specification for function printf_va_1
[eva] using specification for function printf_va_2
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_7
[eva] example/simple.c:65: starting to merge loop iterations
[eva] using specification for function printf_va_8
[eva] example/simple.c:43: starting to merge loop iterations
[eva] example/simple.c:43: Trace partitioning superposing up to 100 states
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 296 statements reached (out of 311): 95% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  65 alarms generated by the analysis:
      33 accesses to uninitialized left-values
      17 integer overflows
      10 invalid memory accesses
       5 accesses out of bounds index
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    11 valid     6 unknown     0 invalid     17 total
  64% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] sample base00-sample00: subset of base? false
[parf] sample base00-sample01: subset of base? false
[parf] sample base00-sample03: subset of base? false
[parf] sample base00-sample02: subset of base? false
[parf] base: base01
[parf] Analysis time for this epoch: 360
[parf] sample: base01-sample00
[parf] sample: base01-sample01
[parf] sample: base01-sample02
[parf] sample: base01-sample03
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 6 -eva-subdivide-non-linear 5 -eva-slevel 24 -eva-remove-redundant-alarms -eva-plevel 69 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 34 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,symbolic-locations -eva-auto-loop-unroll 27
[parf] set eva options
[parf] parameters: -eva-widening-delay 3 -eva-subdivide-non-linear 4 -eva-split-return auto -eva-slevel 30 -eva-remove-redundant-alarms -eva-plevel 58 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 4 -eva-ilevel 33 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 29
[parf] parameters: -eva-widening-delay 4 -eva-subdivide-non-linear 7 -eva-split-return auto -eva-slevel 29 -eva-remove-redundant-alarms -eva-plevel 58 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 40 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,symbolic-locations -eva-auto-loop-unroll 33
[parf] set eva options
[parf] parameters: -eva-widening-delay 4 -eva-subdivide-non-linear 9 -eva-split-return auto -eva-slevel 31 -eva-remove-redundant-alarms -eva-plevel 72 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 38 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 26
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,symbolic-locations
[parf] @default,cvalue,equality,gauges,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(jsoneq) == 0 (auto)
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(jsoneq) == 0 (auto)
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(jsoneq) == 0 (auto)
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] jsmn.c:158: starting to merge loop iterations
[eva] jsmn.c:158: starting to merge loop iterations
[eva] jsmn.c:158: starting to merge loop iterations
[eva] jsmn.c:158: starting to merge loop iterations
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:250: starting to merge loop iterations
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:250: starting to merge loop iterations
[eva] jsmn.c:209: starting to merge loop iterations
[eva] jsmn.c:250: starting to merge loop iterations
[eva] jsmn.c:222: starting to merge loop iterations
[eva] jsmn.c:250: starting to merge loop iterations
[eva] jsmn.c:250: Trace partitioning superposing up to 100 states
[eva] jsmn.c:158: Trace partitioning superposing up to 100 states
[eva] jsmn.c:294: starting to merge loop iterations
[eva] using specification for function printf_va_1
[eva] using specification for function printf_va_2
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_7
[eva] jsmn.c:294: starting to merge loop iterations
[eva] example/simple.c:65: starting to merge loop iterations
[eva] using specification for function printf_va_8
[eva] jsmn.c:158: Trace partitioning superposing up to 100 states
[eva] using specification for function printf_va_1
[eva] using specification for function printf_va_2
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_7
[eva] example/simple.c:65: starting to merge loop iterations
[eva] using specification for function printf_va_8
[eva] jsmn.c:294: starting to merge loop iterations
[eva] jsmn.c:294: starting to merge loop iterations
[eva] using specification for function printf_va_1
[eva] using specification for function printf_va_2
[eva] using specification for function printf_va_1
[eva] using specification for function strncmp
[eva] using specification for function printf_va_2
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_7
[eva] example/simple.c:65: starting to merge loop iterations
[eva] example/simple.c:65: starting to merge loop iterations
[eva] using specification for function printf_va_8
[eva] example/simple.c:43: Trace partitioning superposing up to 100 states
[eva] using specification for function printf_va_8
[eva] example/simple.c:43: Trace partitioning superposing up to 100 states
[eva] example/simple.c:43: starting to merge loop iterations
[eva] example/simple.c:43: starting to merge loop iterations
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 251 statements reached (out of 311): 80% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  60 alarms generated by the analysis:
      32 accesses to uninitialized left-values
      15 integer overflows
       8 invalid memory accesses
       5 accesses out of bounds index
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    11 valid     6 unknown     0 invalid     17 total
  64% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 254 statements reached (out of 311): 81% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  64 alarms generated by the analysis:
      33 accesses to uninitialized left-values
      17 integer overflows
       9 invalid memory accesses
       5 accesses out of bounds index
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    11 valid     6 unknown     0 invalid     17 total
  64% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] example/simple.c:43: Trace partitioning superposing up to 100 states
[eva] example/simple.c:65: Trace partitioning superposing up to 100 states
[eva] example/simple.c:43: starting to merge loop iterations
[eva] example/simple.c:43: Trace partitioning superposing up to 200 states
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 251 statements reached (out of 311): 80% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  60 alarms generated by the analysis:
      32 accesses to uninitialized left-values
      15 integer overflows
       8 invalid memory accesses
       5 accesses out of bounds index
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    11 valid     6 unknown     0 invalid     17 total
  64% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] example/simple.c:65: Trace partitioning superposing up to 200 states
[eva] example/simple.c:43: starting to merge loop iterations
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 251 statements reached (out of 311): 80% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  60 alarms generated by the analysis:
      32 accesses to uninitialized left-values
      15 integer overflows
       8 invalid memory accesses
       5 accesses out of bounds index
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    11 valid     6 unknown     0 invalid     17 total
  64% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] sample base01-sample01: subset of base? false
[parf] sample base01-sample00: subset of base? false
[parf] sample base01-sample02: subset of base? false
[parf] sample base01-sample03: subset of base? false
[parf] base: base02
[parf] Analysis time for this epoch: 720
[parf] sample: base02-sample00
[parf] sample: base02-sample01
[parf] sample: base02-sample02
[parf] sample: base02-sample03
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 7 -eva-subdivide-non-linear 9 -eva-split-return auto -eva-slevel 54 -eva-remove-redundant-alarms -eva-plevel 107 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 3 -eva-ilevel 70 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 49
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 6 -eva-subdivide-non-linear 8 -eva-split-return auto -eva-slevel 54 -eva-remove-redundant-alarms -eva-plevel 116 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 64 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 47
[parf] parameters: -eva-widening-delay 7 -eva-subdivide-non-linear 12 -eva-split-return auto -eva-slevel 62 -eva-remove-redundant-alarms -eva-plevel 118 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 2 -eva-ilevel 67 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 56
[parf] parameters: -eva-widening-delay 7 -eva-subdivide-non-linear 6 -eva-split-return auto -eva-slevel 51 -eva-remove-redundant-alarms -eva-plevel 116 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 70 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 61
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(jsoneq) == 0 (auto)
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(jsoneq) == 0 (auto)
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(jsoneq) == 0 (auto)
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(jsoneq) == 0 (auto)
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function strncmp
[eva] using specification for function strncmp
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_7
[eva:summary] ====== ANALYSIS SUMMARY ======
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 208 statements reached (out of 311): 66% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 access to uninitialized left-values
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    15 valid     0 unknown     0 invalid     15 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 208 statements reached (out of 311): 66% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 access to uninitialized left-values
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    15 valid     0 unknown     0 invalid     15 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 208 statements reached (out of 311): 66% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 access to uninitialized left-values
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    15 valid     0 unknown     0 invalid     15 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 208 statements reached (out of 311): 66% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 access to uninitialized left-values
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    15 valid     0 unknown     0 invalid     15 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] sample base02-sample00: subset of base? true
[parf] sample base02-sample01: subset of base? true
[parf] sample base02-sample03: subset of base? true
[parf] sample base02-sample02: subset of base? true
[parf] base: base03
[parf] Analysis time for this epoch: 1440
[parf] sample: base03-sample00
[parf] sample: base03-sample01
[parf] sample: base03-sample02
[parf] sample: base03-sample03
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 13 -eva-subdivide-non-linear 16 -eva-split-return auto -eva-slevel 108 -eva-remove-redundant-alarms -eva-plevel 217 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 2 -eva-ilevel 129 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 99
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 13 -eva-subdivide-non-linear 13 -eva-split-return auto -eva-slevel 97 -eva-remove-redundant-alarms -eva-plevel 202 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 3 -eva-ilevel 134 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 90
[parf] parameters: -eva-widening-delay 12 -eva-subdivide-non-linear 12 -eva-split-return auto -eva-slevel 97 -eva-remove-redundant-alarms -eva-plevel 214 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 126 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 87
[parf] parameters: -eva-widening-delay 13 -eva-subdivide-non-linear 10 -eva-split-return auto -eva-slevel 92 -eva-remove-redundant-alarms -eva-plevel 214 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 134 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 106
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(jsoneq) == 0 (auto)
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(jsoneq) == 0 (auto)
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(jsoneq) == 0 (auto)
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(jsoneq) == 0 (auto)
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] using specification for function strncmp
[eva] using specification for function strncmp
[eva] using specification for function strncmp
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_7
[eva] example/simple.c:49: Trace partitioning superposing up to 100 states
[eva] example/simple.c:49: Trace partitioning superposing up to 100 states
[eva] example/simple.c:49: Trace partitioning superposing up to 100 states
[eva] example/simple.c:49: Trace partitioning superposing up to 100 states
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 208 statements reached (out of 311): 66% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 access to uninitialized left-values
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    15 valid     0 unknown     0 invalid     15 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva:summary] ====== ANALYSIS SUMMARY ======
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 208 statements reached (out of 311): 66% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 access to uninitialized left-values
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    15 valid     0 unknown     0 invalid     15 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 208 statements reached (out of 311): 66% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 access to uninitialized left-values
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    15 valid     0 unknown     0 invalid     15 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[parf] run eva: finished
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 208 statements reached (out of 311): 66% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 access to uninitialized left-values
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    15 valid     0 unknown     0 invalid     15 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] sample base03-sample01: subset of base? true
[parf] sample base03-sample00: subset of base? true
[parf] sample base03-sample02: subset of base? true
[parf] sample base03-sample03: subset of base? true
[parf] base: base04
[parf] Analysis time for this epoch: 1796
[parf] sample: base04-sample00
[parf] sample: base04-sample01
[parf] sample: base04-sample02
[parf] sample: base04-sample03
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 20 -eva-subdivide-non-linear 20 -eva-split-return auto -eva-slevel 194 -eva-remove-redundant-alarms -eva-plevel 415 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 250 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 168
[parf] set eva options
[parf] parameters: -eva-widening-delay 21 -eva-subdivide-non-linear 16 -eva-split-return auto -eva-slevel 178 -eva-remove-redundant-alarms -eva-plevel 415 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 2 -eva-ilevel 240 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 182
[parf] parameters: -eva-widening-delay 21 -eva-subdivide-non-linear 20 -eva-split-return auto -eva-slevel 183 -eva-remove-redundant-alarms -eva-plevel 417 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 2 -eva-ilevel 262 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 177
[parf] parameters: -eva-widening-delay 19 -eva-subdivide-non-linear 18 -eva-split-return auto -eva-slevel 196 -eva-remove-redundant-alarms -eva-plevel 402 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 2 -eva-ilevel 237 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 172
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(jsoneq) == 0 (auto)
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(jsoneq) == 0 (auto)
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(jsoneq) == 0 (auto)
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(jsoneq) == 0 (auto)
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] using specification for function strncmp
[eva] using specification for function strncmp
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_7
[eva] example/simple.c:49: Trace partitioning superposing up to 100 states
[eva] example/simple.c:49: Trace partitioning superposing up to 100 states
[eva] example/simple.c:49: Trace partitioning superposing up to 100 states
[eva] example/simple.c:49: Trace partitioning superposing up to 100 states
[eva:summary] ====== ANALYSIS SUMMARY ======
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 208 statements reached (out of 311): 66% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 access to uninitialized left-values
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    15 valid     0 unknown     0 invalid     15 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 208 statements reached (out of 311): 66% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 access to uninitialized left-values
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    15 valid     0 unknown     0 invalid     15 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 208 statements reached (out of 311): 66% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 access to uninitialized left-values
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    15 valid     0 unknown     0 invalid     15 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 208 statements reached (out of 311): 66% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 access to uninitialized left-values
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    15 valid     0 unknown     0 invalid     15 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] sample base04-sample01: subset of base? true
[parf] sample base04-sample00: subset of base? true
[parf] sample base04-sample02: subset of base? true
[parf] sample base04-sample03: subset of base? true
[parf] base: base05
[parf] Analysis time for this epoch: 1795
[parf] sample: base05-sample00
[parf] sample: base05-sample01
[parf] sample: base05-sample02
[parf] sample: base05-sample03
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 19 -eva-subdivide-non-linear 28 -eva-split-return auto -eva-slevel 351 -eva-remove-redundant-alarms -eva-plevel 782 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 2 -eva-ilevel 485 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 339
[parf] set eva options
[parf] parameters: -eva-widening-delay 16 -eva-subdivide-non-linear 26 -eva-split-return auto -eva-slevel 369 -eva-remove-redundant-alarms -eva-plevel 798 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 3 -eva-ilevel 483 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 373
[parf] set eva options
[parf] parameters: -eva-widening-delay 21 -eva-subdivide-non-linear 31 -eva-split-return auto -eva-slevel 334 -eva-remove-redundant-alarms -eva-plevel 773 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 471 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 334
[parf] parameters: -eva-widening-delay 18 -eva-subdivide-non-linear 32 -eva-split-return auto -eva-slevel 358 -eva-remove-redundant-alarms -eva-plevel 784 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 2 -eva-ilevel 440 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 339
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(jsoneq) == 0 (auto)
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(jsoneq) == 0 (auto)
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(jsoneq) == 0 (auto)
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(jsoneq) == 0 (auto)
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_8
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_3
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_7
[eva] example/simple.c:49: Trace partitioning superposing up to 100 states
[eva] example/simple.c:49: Trace partitioning superposing up to 100 states
[eva] example/simple.c:49: Trace partitioning superposing up to 100 states
[eva] example/simple.c:49: Trace partitioning superposing up to 100 states
[eva:summary] ====== ANALYSIS SUMMARY ======
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 208 statements reached (out of 311): 66% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 access to uninitialized left-values
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    15 valid     0 unknown     0 invalid     15 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 208 statements reached (out of 311): 66% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 access to uninitialized left-values
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    15 valid     0 unknown     0 invalid     15 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[parf] run eva: finished
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 208 statements reached (out of 311): 66% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 access to uninitialized left-values
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    15 valid     0 unknown     0 invalid     15 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 208 statements reached (out of 311): 66% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 access to uninitialized left-values
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    15 valid     0 unknown     0 invalid     15 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] sample base05-sample00: subset of base? true
[parf] sample base05-sample01: subset of base? true
[parf] sample base05-sample03: subset of base? true
[parf] sample base05-sample02: subset of base? true
[parf] base: base06
[parf] Analysis time for this epoch: 1794
[parf] sample: base06-sample00
[parf] sample: base06-sample01
[parf] sample: base06-sample02
[parf] sample: base06-sample03
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 20 -eva-subdivide-non-linear 53 -eva-split-return auto -eva-slevel 667 -eva-remove-redundant-alarms -eva-plevel 2774 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 3 -eva-ilevel 513 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 683
[parf] parameters: -eva-widening-delay 16 -eva-subdivide-non-linear 49 -eva-split-return auto -eva-slevel 680 -eva-remove-redundant-alarms -eva-plevel 2774 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 500 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 625
[parf] set eva options
[parf] parameters: -eva-widening-delay 20 -eva-subdivide-non-linear 61 -eva-split-return auto -eva-slevel 653 -eva-remove-redundant-alarms -eva-plevel 2774 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 513 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 650
[parf] parameters: -eva-widening-delay 20 -eva-subdivide-non-linear 58 -eva-split-return auto -eva-slevel 647 -eva-remove-redundant-alarms -eva-plevel 2774 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 511 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 655
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(jsoneq) == 0 (auto)
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(jsoneq) == 0 (auto)
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(jsoneq) == 0 (auto)
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(jsoneq) == 0 (auto)
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] using specification for function strncmp
[eva] using specification for function strncmp
[eva] using specification for function strncmp
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_7
[eva] example/simple.c:49: Trace partitioning superposing up to 100 states
[eva] example/simple.c:49: Trace partitioning superposing up to 100 states
[eva] example/simple.c:49: Trace partitioning superposing up to 100 states
[eva] example/simple.c:49: Trace partitioning superposing up to 100 states
[eva:summary] ====== ANALYSIS SUMMARY ======
[eva:summary] ====== ANALYSIS SUMMARY ======
[eva:summary] ====== ANALYSIS SUMMARY ======
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 208 statements reached (out of 311): 66% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 access to uninitialized left-values
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    15 valid     0 unknown     0 invalid     15 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 208 statements reached (out of 311): 66% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 access to uninitialized left-values
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    15 valid     0 unknown     0 invalid     15 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[parf] run eva: finished
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 208 statements reached (out of 311): 66% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 access to uninitialized left-values
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    15 valid     0 unknown     0 invalid     15 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 208 statements reached (out of 311): 66% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 access to uninitialized left-values
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    15 valid     0 unknown     0 invalid     15 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] sample base06-sample01: subset of base? true
[parf] sample base06-sample00: subset of base? true
[parf] sample base06-sample02: subset of base? true
[parf] sample base06-sample03: subset of base? true
[parf] base: base07
[parf] Analysis time for this epoch: 1794
[parf] sample: base07-sample00
[parf] sample: base07-sample01
[parf] sample: base07-sample02
[parf] sample: base07-sample03
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 20 -eva-subdivide-non-linear 106 -eva-split-return auto -eva-slevel 1264 -eva-remove-redundant-alarms -eva-plevel 4001 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 511 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 1233
[parf] parameters: -eva-widening-delay 20 -eva-subdivide-non-linear 110 -eva-split-return auto -eva-slevel 1274 -eva-remove-redundant-alarms -eva-plevel 4001 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 513 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 1226
[parf] parameters: -eva-widening-delay 16 -eva-subdivide-non-linear 94 -eva-split-return auto -eva-slevel 1311 -eva-remove-redundant-alarms -eva-plevel 4001 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 500 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 1191
[parf] set eva options
[parf] parameters: -eva-widening-delay 20 -eva-subdivide-non-linear 99 -eva-split-return auto -eva-slevel 1293 -eva-remove-redundant-alarms -eva-plevel 4001 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 3 -eva-ilevel 513 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 1271
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(jsoneq) == 0 (auto)
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(jsoneq) == 0 (auto)
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(jsoneq) == 0 (auto)
[eva] Splitting return states on:
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strncmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(jsmn_alloc_token) == 0 (auto)
  \return(jsoneq) == 0 (auto)
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] using specification for function strncmp
[eva] using specification for function strncmp
[eva] using specification for function strncmp
[eva] using specification for function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] FRAMAC_SHARE/libc/string.h:163: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strncmp
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_6
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_7
[eva] example/simple.c:49: Trace partitioning superposing up to 100 states
[eva] example/simple.c:49: Trace partitioning superposing up to 100 states
[eva] example/simple.c:49: Trace partitioning superposing up to 100 states
[eva] example/simple.c:49: Trace partitioning superposing up to 100 states
[eva:summary] ====== ANALYSIS SUMMARY ======
[eva:summary] ====== ANALYSIS SUMMARY ======
[eva:summary] ====== ANALYSIS SUMMARY ======
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 208 statements reached (out of 311): 66% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 access to uninitialized left-values
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    15 valid     0 unknown     0 invalid     15 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 208 statements reached (out of 311): 66% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 access to uninitialized left-values
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    15 valid     0 unknown     0 invalid     15 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------

  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 208 statements reached (out of 311): 66% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 access to uninitialized left-values
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    15 valid     0 unknown     0 invalid     15 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------[parf] run eva: finished

  ----------------------------------------------------------------------------
  8 functions analyzed (out of 8): 100% coverage.
  In these functions, 208 statements reached (out of 311): 66% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 access to uninitialized left-values
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    15 valid     0 unknown     0 invalid     15 total
  100% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------[parf] run eva: finished

[parf] run eva: finished
[parf] run eva: finished
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] sample base07-sample00: subset of base? true
[parf] sample base07-sample01: subset of base? true
[parf] sample base07-sample03: subset of base? true
[parf] sample base07-sample02: subset of base? true
[parf] Final parameters: -eva-widening-delay 10 -eva-subdivide-non-linear 94 -eva-split-return auto -eva-slevel 1264 -eva-remove-redundant-alarms -eva-plevel 2000 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 256 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 1024
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] ================================= Summary ==================================
[parf] ====== project "Initial Base 2" ======
[parf] Parameter: -eva-widening-delay 1 -eva-subdivide-non-linear 0 -eva-slevel 0 -eva-plevel 10 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 8 -eva-equality-through-calls none -eva-domains cvalue -eva-auto-loop-unroll 0
[parf] alarms:
[parf] alarm (  1): Signed_overflow(i + (t[i + 1].size + 1) <= 2147483647)
[parf] alarm (  2): Uninitialized(t[i + 1].size)
[parf] alarm (  3): Signed_overflow(t[i + 1].size + 1 <= 2147483647)
[parf] alarm (  4): Memory_access((tokens + i)->type, read)
[parf] alarm (  5): Uninitialized((tokens + i)->type)
[parf] alarm (  6): Uninitialized(t[i].end)
[parf] alarm (  7): Index_out_of_bound(i < 128)
[parf] alarm (  8): Uninitialized(t[i].start)
[parf] alarm (  9): Signed_overflow(t[i].end - t[i].start <= 2147483647)
[parf] alarm ( 10): Signed_overflow(i + 1 <= 2147483647)
[parf] alarm ( 11): Uninitialized((tokens + i)->type)
[parf] alarm ( 12): Uninitialized((tokens + i)->start)
[parf] alarm ( 13): Uninitialized((tokens + i)->end)
[parf] alarm ( 14): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 15): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 16): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 17): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 18): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 19): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 20): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 21): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 22): Uninitialized((tokens + i)->start)
[parf] alarm ( 23): Memory_access((tokens + i)->start, read)
[parf] alarm ( 24): Uninitialized((tokens + i)->end)
[parf] alarm ( 25): Memory_access(tok->type, read)
[parf] alarm ( 26): Uninitialized(tok->type)
[parf] alarm ( 27): Memory_access(token->start, read)
[parf] alarm ( 28): Uninitialized(token->start)
[parf] alarm ( 29): Uninitialized(token->end)
[parf] alarm ( 30): Uninitialized(tok->start)
[parf] alarm ( 31): Signed_overflow(tok->end - tok->start <= 2147483647)
[parf] alarm ( 32): Uninitialized(tok->end)
[parf] alarm ( 33): Uninitialized(token->type)
[parf] alarm ( 34): Uninitialized(tok->start)
[parf] alarm ( 35): Signed_overflow(tok->end - tok->start <= 2147483647)
[parf] alarm ( 36): Uninitialized(tok->end)
[parf] alarm ( 37): Uninitialized(token->start)
[parf] alarm ( 38): Memory_access(token->start, read)
[parf] alarm ( 39): Uninitialized(token->end)
[parf] alarm ( 40): Uninitialized(t[0].type)
[parf] alarm ( 41): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 42): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 43): Signed_overflow(t[i + 1].end - t[i + 1].start <= 2147483647)
[parf] alarm ( 44): Uninitialized(t[i + 1].start)
[parf] alarm ( 45): Uninitialized(t[i + 1].end)
[parf] alarm ( 46): Uninitialized(t[i + 1].start)
[parf] alarm ( 47): Signed_overflow(t[i + 1].end - t[i + 1].start <= 2147483647)
[parf] alarm ( 48): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 49): Uninitialized(t[i + 1].end)
[parf] alarm ( 50): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 51): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 52): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 53): Signed_overflow(t[i + 1].end - t[i + 1].start <= 2147483647)
[parf] alarm ( 54): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 55): Uninitialized(t[i + 1].end)
[parf] alarm ( 56): Uninitialized(t[i + 1].start)
[parf] alarm ( 57): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 58): Uninitialized(t[i + 1].type)
[parf] alarm ( 59): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 60): Memory_access((tokens + parser->toksuper)->type, read)
[parf] alarm ( 61): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 62): Uninitialized(t[i + 1].size)
[parf] alarm ( 63): Signed_overflow((i + j) + 2 <= 2147483647)
[parf] alarm ( 64): Signed_overflow(i + j <= 2147483647)
[parf] alarm ( 65): Signed_overflow(g->end - g->start <= 2147483647)
[parf] alarm ( 66): Uninitialized(g->start)
[parf] alarm ( 67): Memory_access(g->start, read)
[parf] alarm ( 68): Uninitialized(g->end)
[parf] ============================================================================
[parf] ====== project "base00-sample00 2" ======
[parf] Parameter: -eva-widening-delay 3 -eva-subdivide-non-linear 3 -eva-slevel 13 -eva-remove-redundant-alarms -eva-plevel 28 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 17 -eva-equality-through-calls none -eva-domains cvalue,equality -eva-auto-loop-unroll 14
[parf] alarms:
[parf] alarm (  1): Signed_overflow(i + (t[i + 1].size + 1) <= 2147483647)
[parf] alarm (  2): Uninitialized(t[i + 1].size)
[parf] alarm (  3): Signed_overflow(t[i + 1].size + 1 <= 2147483647)
[parf] alarm (  4): Memory_access((tokens + i)->type, read)
[parf] alarm (  5): Uninitialized((tokens + i)->type)
[parf] alarm (  6): Uninitialized(t[i].end)
[parf] alarm (  7): Uninitialized(t[i].start)
[parf] alarm (  8): Index_out_of_bound(i < 128)
[parf] alarm (  9): Signed_overflow(t[i].end - t[i].start <= 2147483647)
[parf] alarm ( 10): Uninitialized(t[i].start)
[parf] alarm ( 11): Signed_overflow(i + 1 <= 2147483647)
[parf] alarm ( 12): Uninitialized((tokens + i)->type)
[parf] alarm ( 13): Uninitialized((tokens + i)->start)
[parf] alarm ( 14): Uninitialized((tokens + i)->end)
[parf] alarm ( 15): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 16): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 17): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 18): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 19): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 20): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 21): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 22): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 23): Uninitialized((tokens + i)->start)
[parf] alarm ( 24): Memory_access((tokens + i)->start, read)
[parf] alarm ( 25): Uninitialized((tokens + i)->end)
[parf] alarm ( 26): Memory_access(tok->type, read)
[parf] alarm ( 27): Uninitialized(tok->type)
[parf] alarm ( 28): Memory_access(token->start, read)
[parf] alarm ( 29): Uninitialized(token->start)
[parf] alarm ( 30): Uninitialized(token->end)
[parf] alarm ( 31): Uninitialized(tok->start)
[parf] alarm ( 32): Signed_overflow(tok->end - tok->start <= 2147483647)
[parf] alarm ( 33): Uninitialized(tok->end)
[parf] alarm ( 34): Uninitialized(token->type)
[parf] alarm ( 35): Uninitialized(tok->start)
[parf] alarm ( 36): Uninitialized(token->start)
[parf] alarm ( 37): Uninitialized(token->end)
[parf] alarm ( 38): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 39): Signed_overflow(t[i + 1].end - t[i + 1].start <= 2147483647)
[parf] alarm ( 40): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 41): Uninitialized(t[i + 1].start)
[parf] alarm ( 42): Uninitialized(t[i + 1].start)
[parf] alarm ( 43): Uninitialized(t[i + 1].end)
[parf] alarm ( 44): Uninitialized(t[i + 1].start)
[parf] alarm ( 45): Uninitialized(t[i + 1].start)
[parf] alarm ( 46): Signed_overflow(t[i + 1].end - t[i + 1].start <= 2147483647)
[parf] alarm ( 47): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 48): Uninitialized(t[i + 1].end)
[parf] alarm ( 49): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 50): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 51): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 52): Signed_overflow(t[i + 1].end - t[i + 1].start <= 2147483647)
[parf] alarm ( 53): Uninitialized(t[i + 1].start)
[parf] alarm ( 54): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 55): Uninitialized(t[i + 1].end)
[parf] alarm ( 56): Uninitialized(t[i + 1].start)
[parf] alarm ( 57): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 58): Uninitialized(t[i + 1].type)
[parf] alarm ( 59): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 60): Memory_access((tokens + parser->toksuper)->type, read)
[parf] alarm ( 61): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 62): Uninitialized(t[i + 1].size)
[parf] alarm ( 63): Signed_overflow((i + j) + 2 <= 2147483647)
[parf] alarm ( 64): Signed_overflow(i + j <= 2147483647)
[parf] alarm ( 65): Signed_overflow(g->end - g->start <= 2147483647)
[parf] alarm ( 66): Uninitialized(g->start)
[parf] alarm ( 67): Memory_access(g->start, read)
[parf] alarm ( 68): Uninitialized(g->end)
[parf] ============================================================================
[parf] ====== project "base00-sample01 2" ======
[parf] Parameter: -eva-widening-delay 2 -eva-subdivide-non-linear 3 -eva-slevel 15 -eva-remove-redundant-alarms -eva-plevel 31 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 16 -eva-equality-through-calls none -eva-domains cvalue,gauges,symbolic-locations -eva-auto-loop-unroll 4
[parf] alarms:
[parf] alarm (  1): Signed_overflow(i + (t[i + 1].size + 1) <= 2147483647)
[parf] alarm (  2): Signed_overflow(t[i + 1].size + 1 <= 2147483647)
[parf] alarm (  3): Memory_access((tokens + i)->type, read)
[parf] alarm (  4): Uninitialized((tokens + i)->type)
[parf] alarm (  5): Uninitialized(t[i].end)
[parf] alarm (  6): Uninitialized(t[i].start)
[parf] alarm (  7): Index_out_of_bound(i < 128)
[parf] alarm (  8): Signed_overflow(t[i].end - t[i].start <= 2147483647)
[parf] alarm (  9): Uninitialized(t[i].start)
[parf] alarm ( 10): Signed_overflow(i + 1 <= 2147483647)
[parf] alarm ( 11): Uninitialized((tokens + i)->start)
[parf] alarm ( 12): Uninitialized((tokens + i)->end)
[parf] alarm ( 13): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 14): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 15): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 16): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 17): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 18): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 19): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 20): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 21): Uninitialized((tokens + i)->start)
[parf] alarm ( 22): Memory_access((tokens + i)->start, read)
[parf] alarm ( 23): Uninitialized((tokens + i)->end)
[parf] alarm ( 24): Memory_access(tok->type, read)
[parf] alarm ( 25): Uninitialized(tok->type)
[parf] alarm ( 26): Memory_access(token->start, read)
[parf] alarm ( 27): Uninitialized(token->start)
[parf] alarm ( 28): Uninitialized(token->end)
[parf] alarm ( 29): Uninitialized(tok->start)
[parf] alarm ( 30): Signed_overflow(tok->end - tok->start <= 2147483647)
[parf] alarm ( 31): Uninitialized(tok->end)
[parf] alarm ( 32): Uninitialized(token->type)
[parf] alarm ( 33): Uninitialized(token->start)
[parf] alarm ( 34): Memory_access(token->start, read)
[parf] alarm ( 35): Uninitialized(token->end)
[parf] alarm ( 36): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 37): Signed_overflow(t[i + 1].end - t[i + 1].start <= 2147483647)
[parf] alarm ( 38): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 39): Uninitialized(t[i + 1].start)
[parf] alarm ( 40): Uninitialized(t[i + 1].start)
[parf] alarm ( 41): Uninitialized(t[i + 1].end)
[parf] alarm ( 42): Uninitialized(t[i + 1].start)
[parf] alarm ( 43): Uninitialized(t[i + 1].start)
[parf] alarm ( 44): Signed_overflow(t[i + 1].end - t[i + 1].start <= 2147483647)
[parf] alarm ( 45): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 46): Uninitialized(t[i + 1].end)
[parf] alarm ( 47): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 48): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 49): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 50): Signed_overflow(t[i + 1].end - t[i + 1].start <= 2147483647)
[parf] alarm ( 51): Uninitialized(t[i + 1].start)
[parf] alarm ( 52): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 53): Uninitialized(t[i + 1].end)
[parf] alarm ( 54): Uninitialized(t[i + 1].start)
[parf] alarm ( 55): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 56): Uninitialized(t[i + 1].type)
[parf] alarm ( 57): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 58): Memory_access((tokens + parser->toksuper)->type, read)
[parf] alarm ( 59): Uninitialized(t[i + 1].size)
[parf] alarm ( 60): Signed_overflow((i + j) + 2 <= 2147483647)
[parf] alarm ( 61): Signed_overflow(i + j <= 2147483647)
[parf] alarm ( 62): Signed_overflow(g->end - g->start <= 2147483647)
[parf] alarm ( 63): Uninitialized(g->start)
[parf] alarm ( 64): Memory_access(g->start, read)
[parf] alarm ( 65): Uninitialized(g->end)
[parf] ============================================================================
[parf] ====== project "base00-sample02 2" ======
[parf] Parameter: -eva-widening-delay 2 -eva-subdivide-non-linear 3 -eva-slevel 14 -eva-plevel 33 -eva-partition-history 1 -eva-min-loop-unroll 0 -eva-ilevel 16 -eva-equality-through-calls none -eva-domains cvalue -eva-auto-loop-unroll 17
[parf] alarms:
[parf] alarm (  1): Signed_overflow(i + (t[i + 1].size + 1) <= 2147483647)
[parf] alarm (  2): Uninitialized(t[i + 1].size)
[parf] alarm (  3): Signed_overflow(t[i + 1].size + 1 <= 2147483647)
[parf] alarm (  4): Memory_access((tokens + i)->type, read)
[parf] alarm (  5): Uninitialized((tokens + i)->type)
[parf] alarm (  6): Uninitialized(t[i].end)
[parf] alarm (  7): Uninitialized(t[i].start)
[parf] alarm (  8): Index_out_of_bound(i < 128)
[parf] alarm (  9): Signed_overflow(t[i].end - t[i].start <= 2147483647)
[parf] alarm ( 10): Uninitialized(t[i].start)
[parf] alarm ( 11): Signed_overflow(i + 1 <= 2147483647)
[parf] alarm ( 12): Uninitialized((tokens + i)->type)
[parf] alarm ( 13): Uninitialized((tokens + i)->start)
[parf] alarm ( 14): Uninitialized((tokens + i)->end)
[parf] alarm ( 15): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 16): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 17): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 18): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 19): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 20): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 21): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 22): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 23): Uninitialized((tokens + i)->start)
[parf] alarm ( 24): Memory_access((tokens + i)->start, read)
[parf] alarm ( 25): Uninitialized((tokens + i)->end)
[parf] alarm ( 26): Memory_access(tok->type, read)
[parf] alarm ( 27): Uninitialized(tok->type)
[parf] alarm ( 28): Memory_access(token->start, read)
[parf] alarm ( 29): Uninitialized(token->start)
[parf] alarm ( 30): Uninitialized(token->end)
[parf] alarm ( 31): Uninitialized(tok->start)
[parf] alarm ( 32): Signed_overflow(tok->end - tok->start <= 2147483647)
[parf] alarm ( 33): Uninitialized(tok->end)
[parf] alarm ( 34): Uninitialized(token->type)
[parf] alarm ( 35): Uninitialized(tok->start)
[parf] alarm ( 36): Signed_overflow(tok->end - tok->start <= 2147483647)
[parf] alarm ( 37): Uninitialized(tok->end)
[parf] alarm ( 38): Uninitialized(token->start)
[parf] alarm ( 39): Memory_access(token->start, read)
[parf] alarm ( 40): Uninitialized(token->end)
[parf] alarm ( 41): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 42): Signed_overflow(t[i + 1].end - t[i + 1].start <= 2147483647)
[parf] alarm ( 43): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 44): Uninitialized(t[i + 1].start)
[parf] alarm ( 45): Uninitialized(t[i + 1].start)
[parf] alarm ( 46): Uninitialized(t[i + 1].end)
[parf] alarm ( 47): Uninitialized(t[i + 1].start)
[parf] alarm ( 48): Uninitialized(t[i + 1].start)
[parf] alarm ( 49): Signed_overflow(t[i + 1].end - t[i + 1].start <= 2147483647)
[parf] alarm ( 50): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 51): Uninitialized(t[i + 1].end)
[parf] alarm ( 52): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 53): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 54): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 55): Signed_overflow(t[i + 1].end - t[i + 1].start <= 2147483647)
[parf] alarm ( 56): Uninitialized(t[i + 1].start)
[parf] alarm ( 57): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 58): Uninitialized(t[i + 1].end)
[parf] alarm ( 59): Uninitialized(t[i + 1].start)
[parf] alarm ( 60): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 61): Uninitialized(t[i + 1].type)
[parf] alarm ( 62): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 63): Memory_access((tokens + parser->toksuper)->type, read)
[parf] alarm ( 64): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 65): Uninitialized(t[i + 1].size)
[parf] alarm ( 66): Signed_overflow((i + j) + 2 <= 2147483647)
[parf] alarm ( 67): Signed_overflow(i + j <= 2147483647)
[parf] alarm ( 68): Signed_overflow(g->end - g->start <= 2147483647)
[parf] alarm ( 69): Uninitialized(g->start)
[parf] alarm ( 70): Memory_access(g->start, read)
[parf] alarm ( 71): Uninitialized(g->end)
[parf] ============================================================================
[parf] ====== project "base00-sample03 2" ======
[parf] Parameter: -eva-widening-delay 2 -eva-subdivide-non-linear 1 -eva-slevel 8 -eva-plevel 29 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 21 -eva-equality-through-calls formals -eva-domains cvalue,equality -eva-auto-loop-unroll 14
[parf] alarms:
[parf] alarm (  1): Signed_overflow(i + (t[i + 1].size + 1) <= 2147483647)
[parf] alarm (  2): Uninitialized(t[i + 1].size)
[parf] alarm (  3): Signed_overflow(t[i + 1].size + 1 <= 2147483647)
[parf] alarm (  4): Memory_access((tokens + i)->type, read)
[parf] alarm (  5): Uninitialized((tokens + i)->type)
[parf] alarm (  6): Uninitialized(t[i].end)
[parf] alarm (  7): Uninitialized(t[i].start)
[parf] alarm (  8): Index_out_of_bound(i < 128)
[parf] alarm (  9): Signed_overflow(t[i].end - t[i].start <= 2147483647)
[parf] alarm ( 10): Uninitialized(t[i].start)
[parf] alarm ( 11): Signed_overflow(i + 1 <= 2147483647)
[parf] alarm ( 12): Uninitialized((tokens + i)->type)
[parf] alarm ( 13): Uninitialized((tokens + i)->start)
[parf] alarm ( 14): Uninitialized((tokens + i)->end)
[parf] alarm ( 15): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 16): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 17): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 18): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 19): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 20): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 21): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 22): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 23): Uninitialized((tokens + i)->start)
[parf] alarm ( 24): Memory_access((tokens + i)->start, read)
[parf] alarm ( 25): Uninitialized((tokens + i)->end)
[parf] alarm ( 26): Memory_access(tok->type, read)
[parf] alarm ( 27): Uninitialized(tok->type)
[parf] alarm ( 28): Memory_access(token->start, read)
[parf] alarm ( 29): Uninitialized(token->start)
[parf] alarm ( 30): Uninitialized(token->end)
[parf] alarm ( 31): Uninitialized(tok->start)
[parf] alarm ( 32): Signed_overflow(tok->end - tok->start <= 2147483647)
[parf] alarm ( 33): Uninitialized(tok->end)
[parf] alarm ( 34): Uninitialized(token->type)
[parf] alarm ( 35): Uninitialized(tok->start)
[parf] alarm ( 36): Uninitialized(token->start)
[parf] alarm ( 37): Uninitialized(token->end)
[parf] alarm ( 38): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 39): Signed_overflow(t[i + 1].end - t[i + 1].start <= 2147483647)
[parf] alarm ( 40): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 41): Uninitialized(t[i + 1].start)
[parf] alarm ( 42): Uninitialized(t[i + 1].start)
[parf] alarm ( 43): Uninitialized(t[i + 1].end)
[parf] alarm ( 44): Uninitialized(t[i + 1].start)
[parf] alarm ( 45): Uninitialized(t[i + 1].start)
[parf] alarm ( 46): Signed_overflow(t[i + 1].end - t[i + 1].start <= 2147483647)
[parf] alarm ( 47): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 48): Uninitialized(t[i + 1].end)
[parf] alarm ( 49): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 50): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 51): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 52): Signed_overflow(t[i + 1].end - t[i + 1].start <= 2147483647)
[parf] alarm ( 53): Uninitialized(t[i + 1].start)
[parf] alarm ( 54): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 55): Uninitialized(t[i + 1].end)
[parf] alarm ( 56): Uninitialized(t[i + 1].start)
[parf] alarm ( 57): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 58): Uninitialized(t[i + 1].type)
[parf] alarm ( 59): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 60): Memory_access((tokens + parser->toksuper)->type, read)
[parf] alarm ( 61): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 62): Uninitialized(t[i + 1].size)
[parf] alarm ( 63): Signed_overflow((i + j) + 2 <= 2147483647)
[parf] alarm ( 64): Signed_overflow(i + j <= 2147483647)
[parf] alarm ( 65): Signed_overflow(g->end - g->start <= 2147483647)
[parf] alarm ( 66): Uninitialized(g->start)
[parf] alarm ( 67): Memory_access(g->start, read)
[parf] alarm ( 68): Uninitialized(g->end)
[parf] ============================================================================
[parf] ====== project "base01-sample00 2" ======
[parf] Parameter: -eva-widening-delay 4 -eva-subdivide-non-linear 9 -eva-split-return auto -eva-slevel 31 -eva-remove-redundant-alarms -eva-plevel 72 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 38 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 26
[parf] alarms:
[parf] alarm (  1): Signed_overflow(i + (t[i + 1].size + 1) <= 2147483647)
[parf] alarm (  2): Signed_overflow(t[i + 1].size + 1 <= 2147483647)
[parf] alarm (  3): Memory_access((tokens + i)->type, read)
[parf] alarm (  4): Uninitialized((tokens + i)->type)
[parf] alarm (  5): Uninitialized(t[i].end)
[parf] alarm (  6): Uninitialized(t[i].start)
[parf] alarm (  7): Index_out_of_bound(i < 128)
[parf] alarm (  8): Signed_overflow(t[i].end - t[i].start <= 2147483647)
[parf] alarm (  9): Uninitialized(t[i].start)
[parf] alarm ( 10): Signed_overflow(i + 1 <= 2147483647)
[parf] alarm ( 11): Uninitialized((tokens + i)->start)
[parf] alarm ( 12): Uninitialized((tokens + i)->end)
[parf] alarm ( 13): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 14): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 15): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 16): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 17): Uninitialized((tokens + i)->start)
[parf] alarm ( 18): Memory_access((tokens + i)->start, read)
[parf] alarm ( 19): Uninitialized((tokens + i)->end)
[parf] alarm ( 20): Memory_access(tok->type, read)
[parf] alarm ( 21): Uninitialized(tok->type)
[parf] alarm ( 22): Memory_access(token->start, read)
[parf] alarm ( 23): Uninitialized(token->start)
[parf] alarm ( 24): Uninitialized(token->end)
[parf] alarm ( 25): Uninitialized(tok->start)
[parf] alarm ( 26): Signed_overflow(tok->end - tok->start <= 2147483647)
[parf] alarm ( 27): Uninitialized(tok->end)
[parf] alarm ( 28): Uninitialized(token->type)
[parf] alarm ( 29): Uninitialized(token->start)
[parf] alarm ( 30): Uninitialized(token->end)
[parf] alarm ( 31): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 32): Signed_overflow(t[i + 1].end - t[i + 1].start <= 2147483647)
[parf] alarm ( 33): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 34): Uninitialized(t[i + 1].start)
[parf] alarm ( 35): Uninitialized(t[i + 1].start)
[parf] alarm ( 36): Uninitialized(t[i + 1].end)
[parf] alarm ( 37): Uninitialized(t[i + 1].start)
[parf] alarm ( 38): Uninitialized(t[i + 1].start)
[parf] alarm ( 39): Signed_overflow(t[i + 1].end - t[i + 1].start <= 2147483647)
[parf] alarm ( 40): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 41): Uninitialized(t[i + 1].end)
[parf] alarm ( 42): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 43): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 44): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 45): Signed_overflow(t[i + 1].end - t[i + 1].start <= 2147483647)
[parf] alarm ( 46): Uninitialized(t[i + 1].start)
[parf] alarm ( 47): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 48): Uninitialized(t[i + 1].end)
[parf] alarm ( 49): Uninitialized(t[i + 1].start)
[parf] alarm ( 50): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 51): Uninitialized(t[i + 1].type)
[parf] alarm ( 52): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 53): Memory_access((tokens + parser->toksuper)->type, read)
[parf] alarm ( 54): Uninitialized(t[i + 1].size)
[parf] alarm ( 55): Signed_overflow((i + j) + 2 <= 2147483647)
[parf] alarm ( 56): Signed_overflow(i + j <= 2147483647)
[parf] alarm ( 57): Signed_overflow(g->end - g->start <= 2147483647)
[parf] alarm ( 58): Uninitialized(g->start)
[parf] alarm ( 59): Memory_access(g->start, read)
[parf] alarm ( 60): Uninitialized(g->end)
[parf] ============================================================================
[parf] ====== project "base01-sample01 2" ======
[parf] Parameter: -eva-widening-delay 3 -eva-subdivide-non-linear 4 -eva-split-return auto -eva-slevel 30 -eva-remove-redundant-alarms -eva-plevel 58 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 4 -eva-ilevel 33 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 29
[parf] alarms:
[parf] alarm (  1): Signed_overflow(i + (t[i + 1].size + 1) <= 2147483647)
[parf] alarm (  2): Signed_overflow(t[i + 1].size + 1 <= 2147483647)
[parf] alarm (  3): Memory_access((tokens + i)->type, read)
[parf] alarm (  4): Uninitialized((tokens + i)->type)
[parf] alarm (  5): Uninitialized(t[i].end)
[parf] alarm (  6): Uninitialized(t[i].start)
[parf] alarm (  7): Index_out_of_bound(i < 128)
[parf] alarm (  8): Signed_overflow(t[i].end - t[i].start <= 2147483647)
[parf] alarm (  9): Uninitialized(t[i].start)
[parf] alarm ( 10): Signed_overflow(i + 1 <= 2147483647)
[parf] alarm ( 11): Uninitialized((tokens + i)->start)
[parf] alarm ( 12): Uninitialized((tokens + i)->end)
[parf] alarm ( 13): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 14): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 15): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 16): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 17): Uninitialized((tokens + i)->start)
[parf] alarm ( 18): Memory_access((tokens + i)->start, read)
[parf] alarm ( 19): Uninitialized((tokens + i)->end)
[parf] alarm ( 20): Memory_access(tok->type, read)
[parf] alarm ( 21): Uninitialized(tok->type)
[parf] alarm ( 22): Memory_access(token->start, read)
[parf] alarm ( 23): Uninitialized(token->start)
[parf] alarm ( 24): Uninitialized(token->end)
[parf] alarm ( 25): Uninitialized(tok->start)
[parf] alarm ( 26): Signed_overflow(tok->end - tok->start <= 2147483647)
[parf] alarm ( 27): Uninitialized(tok->end)
[parf] alarm ( 28): Uninitialized(token->type)
[parf] alarm ( 29): Uninitialized(token->start)
[parf] alarm ( 30): Uninitialized(token->end)
[parf] alarm ( 31): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 32): Signed_overflow(t[i + 1].end - t[i + 1].start <= 2147483647)
[parf] alarm ( 33): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 34): Uninitialized(t[i + 1].start)
[parf] alarm ( 35): Uninitialized(t[i + 1].start)
[parf] alarm ( 36): Uninitialized(t[i + 1].end)
[parf] alarm ( 37): Uninitialized(t[i + 1].start)
[parf] alarm ( 38): Uninitialized(t[i + 1].start)
[parf] alarm ( 39): Signed_overflow(t[i + 1].end - t[i + 1].start <= 2147483647)
[parf] alarm ( 40): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 41): Uninitialized(t[i + 1].end)
[parf] alarm ( 42): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 43): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 44): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 45): Signed_overflow(t[i + 1].end - t[i + 1].start <= 2147483647)
[parf] alarm ( 46): Uninitialized(t[i + 1].start)
[parf] alarm ( 47): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 48): Uninitialized(t[i + 1].end)
[parf] alarm ( 49): Uninitialized(t[i + 1].start)
[parf] alarm ( 50): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 51): Uninitialized(t[i + 1].type)
[parf] alarm ( 52): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 53): Memory_access((tokens + parser->toksuper)->type, read)
[parf] alarm ( 54): Uninitialized(t[i + 1].size)
[parf] alarm ( 55): Signed_overflow((i + j) + 2 <= 2147483647)
[parf] alarm ( 56): Signed_overflow(i + j <= 2147483647)
[parf] alarm ( 57): Signed_overflow(g->end - g->start <= 2147483647)
[parf] alarm ( 58): Uninitialized(g->start)
[parf] alarm ( 59): Memory_access(g->start, read)
[parf] alarm ( 60): Uninitialized(g->end)
[parf] ============================================================================
[parf] ====== project "base01-sample02 2" ======
[parf] Parameter: -eva-widening-delay 6 -eva-subdivide-non-linear 5 -eva-slevel 24 -eva-remove-redundant-alarms -eva-plevel 69 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 34 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,symbolic-locations -eva-auto-loop-unroll 27
[parf] alarms:
[parf] alarm (  1): Signed_overflow(i + (t[i + 1].size + 1) <= 2147483647)
[parf] alarm (  2): Signed_overflow(t[i + 1].size + 1 <= 2147483647)
[parf] alarm (  3): Memory_access((tokens + i)->type, read)
[parf] alarm (  4): Uninitialized((tokens + i)->type)
[parf] alarm (  5): Uninitialized(t[i].end)
[parf] alarm (  6): Uninitialized(t[i].start)
[parf] alarm (  7): Index_out_of_bound(i < 128)
[parf] alarm (  8): Signed_overflow(t[i].end - t[i].start <= 2147483647)
[parf] alarm (  9): Uninitialized(t[i].start)
[parf] alarm ( 10): Signed_overflow(i + 1 <= 2147483647)
[parf] alarm ( 11): Uninitialized((tokens + i)->start)
[parf] alarm ( 12): Uninitialized((tokens + i)->end)
[parf] alarm ( 13): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 14): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 15): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 16): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 17): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 18): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 19): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 20): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 21): Uninitialized((tokens + i)->start)
[parf] alarm ( 22): Memory_access((tokens + i)->start, read)
[parf] alarm ( 23): Uninitialized((tokens + i)->end)
[parf] alarm ( 24): Memory_access(tok->type, read)
[parf] alarm ( 25): Uninitialized(tok->type)
[parf] alarm ( 26): Memory_access(token->start, read)
[parf] alarm ( 27): Uninitialized(token->start)
[parf] alarm ( 28): Uninitialized(token->end)
[parf] alarm ( 29): Uninitialized(tok->start)
[parf] alarm ( 30): Signed_overflow(tok->end - tok->start <= 2147483647)
[parf] alarm ( 31): Uninitialized(tok->end)
[parf] alarm ( 32): Uninitialized(token->type)
[parf] alarm ( 33): Uninitialized(token->start)
[parf] alarm ( 34): Uninitialized(token->end)
[parf] alarm ( 35): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 36): Signed_overflow(t[i + 1].end - t[i + 1].start <= 2147483647)
[parf] alarm ( 37): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 38): Uninitialized(t[i + 1].start)
[parf] alarm ( 39): Uninitialized(t[i + 1].start)
[parf] alarm ( 40): Uninitialized(t[i + 1].end)
[parf] alarm ( 41): Uninitialized(t[i + 1].start)
[parf] alarm ( 42): Uninitialized(t[i + 1].start)
[parf] alarm ( 43): Signed_overflow(t[i + 1].end - t[i + 1].start <= 2147483647)
[parf] alarm ( 44): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 45): Uninitialized(t[i + 1].end)
[parf] alarm ( 46): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 47): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 48): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 49): Signed_overflow(t[i + 1].end - t[i + 1].start <= 2147483647)
[parf] alarm ( 50): Uninitialized(t[i + 1].start)
[parf] alarm ( 51): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 52): Uninitialized(t[i + 1].end)
[parf] alarm ( 53): Uninitialized(t[i + 1].start)
[parf] alarm ( 54): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 55): Uninitialized(t[i + 1].type)
[parf] alarm ( 56): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 57): Memory_access((tokens + parser->toksuper)->type, read)
[parf] alarm ( 58): Uninitialized(t[i + 1].size)
[parf] alarm ( 59): Signed_overflow((i + j) + 2 <= 2147483647)
[parf] alarm ( 60): Signed_overflow(i + j <= 2147483647)
[parf] alarm ( 61): Signed_overflow(g->end - g->start <= 2147483647)
[parf] alarm ( 62): Uninitialized(g->start)
[parf] alarm ( 63): Memory_access(g->start, read)
[parf] alarm ( 64): Uninitialized(g->end)
[parf] ============================================================================
[parf] ====== project "base01-sample03 2" ======
[parf] Parameter: -eva-widening-delay 4 -eva-subdivide-non-linear 7 -eva-split-return auto -eva-slevel 29 -eva-remove-redundant-alarms -eva-plevel 58 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 40 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,symbolic-locations -eva-auto-loop-unroll 33
[parf] alarms:
[parf] alarm (  1): Signed_overflow(i + (t[i + 1].size + 1) <= 2147483647)
[parf] alarm (  2): Signed_overflow(t[i + 1].size + 1 <= 2147483647)
[parf] alarm (  3): Memory_access((tokens + i)->type, read)
[parf] alarm (  4): Uninitialized((tokens + i)->type)
[parf] alarm (  5): Uninitialized(t[i].end)
[parf] alarm (  6): Uninitialized(t[i].start)
[parf] alarm (  7): Index_out_of_bound(i < 128)
[parf] alarm (  8): Signed_overflow(t[i].end - t[i].start <= 2147483647)
[parf] alarm (  9): Uninitialized(t[i].start)
[parf] alarm ( 10): Signed_overflow(i + 1 <= 2147483647)
[parf] alarm ( 11): Uninitialized((tokens + i)->start)
[parf] alarm ( 12): Uninitialized((tokens + i)->end)
[parf] alarm ( 13): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 14): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 15): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 16): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 17): Uninitialized((tokens + i)->start)
[parf] alarm ( 18): Memory_access((tokens + i)->start, read)
[parf] alarm ( 19): Uninitialized((tokens + i)->end)
[parf] alarm ( 20): Memory_access(tok->type, read)
[parf] alarm ( 21): Uninitialized(tok->type)
[parf] alarm ( 22): Memory_access(token->start, read)
[parf] alarm ( 23): Uninitialized(token->start)
[parf] alarm ( 24): Uninitialized(token->end)
[parf] alarm ( 25): Uninitialized(tok->start)
[parf] alarm ( 26): Signed_overflow(tok->end - tok->start <= 2147483647)
[parf] alarm ( 27): Uninitialized(tok->end)
[parf] alarm ( 28): Uninitialized(token->type)
[parf] alarm ( 29): Uninitialized(token->start)
[parf] alarm ( 30): Uninitialized(token->end)
[parf] alarm ( 31): Signed_overflow(count + 1 <= 2147483647)
[parf] alarm ( 32): Signed_overflow(t[i + 1].end - t[i + 1].start <= 2147483647)
[parf] alarm ( 33): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 34): Uninitialized(t[i + 1].start)
[parf] alarm ( 35): Uninitialized(t[i + 1].start)
[parf] alarm ( 36): Uninitialized(t[i + 1].end)
[parf] alarm ( 37): Uninitialized(t[i + 1].start)
[parf] alarm ( 38): Uninitialized(t[i + 1].start)
[parf] alarm ( 39): Signed_overflow(t[i + 1].end - t[i + 1].start <= 2147483647)
[parf] alarm ( 40): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 41): Uninitialized(t[i + 1].end)
[parf] alarm ( 42): Signed_overflow((tokens + parser->toksuper)->size + 1 <= 2147483647)
[parf] alarm ( 43): Memory_access((tokens + parser->toksuper)->size, write)
[parf] alarm ( 44): Uninitialized((tokens + parser->toksuper)->size)
[parf] alarm ( 45): Signed_overflow(t[i + 1].end - t[i + 1].start <= 2147483647)
[parf] alarm ( 46): Uninitialized(t[i + 1].start)
[parf] alarm ( 47): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 48): Uninitialized(t[i + 1].end)
[parf] alarm ( 49): Uninitialized(t[i + 1].start)
[parf] alarm ( 50): Index_out_of_bound(i + 1 < 128)
[parf] alarm ( 51): Uninitialized(t[i + 1].type)
[parf] alarm ( 52): Uninitialized((tokens + parser->toksuper)->type)
[parf] alarm ( 53): Memory_access((tokens + parser->toksuper)->type, read)
[parf] alarm ( 54): Uninitialized(t[i + 1].size)
[parf] alarm ( 55): Signed_overflow((i + j) + 2 <= 2147483647)
[parf] alarm ( 56): Signed_overflow(i + j <= 2147483647)
[parf] alarm ( 57): Signed_overflow(g->end - g->start <= 2147483647)
[parf] alarm ( 58): Uninitialized(g->start)
[parf] alarm ( 59): Memory_access(g->start, read)
[parf] alarm ( 60): Uninitialized(g->end)
[parf] ============================================================================
[parf] ====== project "base02-sample00 2" ======
[parf] Parameter: -eva-widening-delay 7 -eva-subdivide-non-linear 9 -eva-split-return auto -eva-slevel 54 -eva-remove-redundant-alarms -eva-plevel 107 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 3 -eva-ilevel 70 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 49
[parf] alarms:
[parf] alarm (  1): Uninitialized(t[i + 1].start)
[parf] ============================================================================
[parf] ====== project "base02-sample01 2" ======
[parf] Parameter: -eva-widening-delay 7 -eva-subdivide-non-linear 6 -eva-split-return auto -eva-slevel 51 -eva-remove-redundant-alarms -eva-plevel 116 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 70 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 61
[parf] alarms:
[parf] alarm (  1): Uninitialized(t[i + 1].start)
[parf] ============================================================================
[parf] ====== project "base02-sample02 2" ======
[parf] Parameter: -eva-widening-delay 7 -eva-subdivide-non-linear 12 -eva-split-return auto -eva-slevel 62 -eva-remove-redundant-alarms -eva-plevel 118 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 2 -eva-ilevel 67 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 56
[parf] alarms:
[parf] alarm (  1): Uninitialized(t[i + 1].start)
[parf] ============================================================================
[parf] ====== project "base02-sample03 2" ======
[parf] Parameter: -eva-widening-delay 6 -eva-subdivide-non-linear 8 -eva-split-return auto -eva-slevel 54 -eva-remove-redundant-alarms -eva-plevel 116 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 64 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 47
[parf] alarms:
[parf] alarm (  1): Uninitialized(t[i + 1].start)
[parf] ============================================================================
[parf] ====== project "base03-sample00 2" ======
[parf] Parameter: -eva-widening-delay 13 -eva-subdivide-non-linear 13 -eva-split-return auto -eva-slevel 97 -eva-remove-redundant-alarms -eva-plevel 202 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 3 -eva-ilevel 134 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 90
[parf] alarms:
[parf] alarm (  1): Uninitialized(t[i + 1].start)
[parf] ============================================================================
[parf] ====== project "base03-sample01 2" ======
[parf] Parameter: -eva-widening-delay 13 -eva-subdivide-non-linear 10 -eva-split-return auto -eva-slevel 92 -eva-remove-redundant-alarms -eva-plevel 214 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 134 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 106
[parf] alarms:
[parf] alarm (  1): Uninitialized(t[i + 1].start)
[parf] ============================================================================
[parf] ====== project "base03-sample02 2" ======
[parf] Parameter: -eva-widening-delay 13 -eva-subdivide-non-linear 16 -eva-split-return auto -eva-slevel 108 -eva-remove-redundant-alarms -eva-plevel 217 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 2 -eva-ilevel 129 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 99
[parf] alarms:
[parf] alarm (  1): Uninitialized(t[i + 1].start)
[parf] ============================================================================
[parf] ====== project "base03-sample03 2" ======
[parf] Parameter: -eva-widening-delay 12 -eva-subdivide-non-linear 12 -eva-split-return auto -eva-slevel 97 -eva-remove-redundant-alarms -eva-plevel 214 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 126 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 87
[parf] alarms:
[parf] alarm (  1): Uninitialized(t[i + 1].start)
[parf] ============================================================================
[parf] ====== project "base04-sample00 2" ======
[parf] Parameter: -eva-widening-delay 21 -eva-subdivide-non-linear 16 -eva-split-return auto -eva-slevel 178 -eva-remove-redundant-alarms -eva-plevel 415 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 2 -eva-ilevel 240 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 182
[parf] alarms:
[parf] alarm (  1): Uninitialized(t[i + 1].start)
[parf] ============================================================================
[parf] ====== project "base04-sample01 2" ======
[parf] Parameter: -eva-widening-delay 21 -eva-subdivide-non-linear 20 -eva-split-return auto -eva-slevel 183 -eva-remove-redundant-alarms -eva-plevel 417 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 2 -eva-ilevel 262 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 177
[parf] alarms:
[parf] alarm (  1): Uninitialized(t[i + 1].start)
[parf] ============================================================================
[parf] ====== project "base04-sample02 2" ======
[parf] Parameter: -eva-widening-delay 20 -eva-subdivide-non-linear 20 -eva-split-return auto -eva-slevel 194 -eva-remove-redundant-alarms -eva-plevel 415 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 250 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 168
[parf] alarms:
[parf] alarm (  1): Uninitialized(t[i + 1].start)
[parf] ============================================================================
[parf] ====== project "base04-sample03 2" ======
[parf] Parameter: -eva-widening-delay 19 -eva-subdivide-non-linear 18 -eva-split-return auto -eva-slevel 196 -eva-remove-redundant-alarms -eva-plevel 402 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 2 -eva-ilevel 237 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 172
[parf] alarms:
[parf] alarm (  1): Uninitialized(t[i + 1].start)
[parf] ============================================================================
[parf] ====== project "base05-sample00 2" ======
[parf] Parameter: -eva-widening-delay 18 -eva-subdivide-non-linear 32 -eva-split-return auto -eva-slevel 358 -eva-remove-redundant-alarms -eva-plevel 784 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 2 -eva-ilevel 440 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 339
[parf] alarms:
[parf] alarm (  1): Uninitialized(t[i + 1].start)
[parf] ============================================================================
[parf] ====== project "base05-sample01 2" ======
[parf] Parameter: -eva-widening-delay 21 -eva-subdivide-non-linear 31 -eva-split-return auto -eva-slevel 334 -eva-remove-redundant-alarms -eva-plevel 773 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 471 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 334
[parf] alarms:
[parf] alarm (  1): Uninitialized(t[i + 1].start)
[parf] ============================================================================
[parf] ====== project "base05-sample02 2" ======
[parf] Parameter: -eva-widening-delay 19 -eva-subdivide-non-linear 28 -eva-split-return auto -eva-slevel 351 -eva-remove-redundant-alarms -eva-plevel 782 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 2 -eva-ilevel 485 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 339
[parf] alarms:
[parf] alarm (  1): Uninitialized(t[i + 1].start)
[parf] ============================================================================
[parf] ====== project "base05-sample03 2" ======
[parf] Parameter: -eva-widening-delay 16 -eva-subdivide-non-linear 26 -eva-split-return auto -eva-slevel 369 -eva-remove-redundant-alarms -eva-plevel 798 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 3 -eva-ilevel 483 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 373
[parf] alarms:
[parf] alarm (  1): Uninitialized(t[i + 1].start)
[parf] ============================================================================
[parf] ====== project "base06-sample00 2" ======
[parf] Parameter: -eva-widening-delay 20 -eva-subdivide-non-linear 53 -eva-split-return auto -eva-slevel 667 -eva-remove-redundant-alarms -eva-plevel 2774 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 3 -eva-ilevel 513 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 683
[parf] alarms:
[parf] alarm (  1): Uninitialized(t[i + 1].start)
[parf] ============================================================================
[parf] ====== project "base06-sample01 2" ======
[parf] Parameter: -eva-widening-delay 20 -eva-subdivide-non-linear 61 -eva-split-return auto -eva-slevel 653 -eva-remove-redundant-alarms -eva-plevel 2774 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 513 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 650
[parf] alarms:
[parf] alarm (  1): Uninitialized(t[i + 1].start)
[parf] ============================================================================
[parf] ====== project "base06-sample02 2" ======
[parf] Parameter: -eva-widening-delay 20 -eva-subdivide-non-linear 58 -eva-split-return auto -eva-slevel 647 -eva-remove-redundant-alarms -eva-plevel 2774 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 511 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 655
[parf] alarms:
[parf] alarm (  1): Uninitialized(t[i + 1].start)
[parf] ============================================================================
[parf] ====== project "base06-sample03 2" ======
[parf] Parameter: -eva-widening-delay 16 -eva-subdivide-non-linear 49 -eva-split-return auto -eva-slevel 680 -eva-remove-redundant-alarms -eva-plevel 2774 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 500 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 625
[parf] alarms:
[parf] alarm (  1): Uninitialized(t[i + 1].start)
[parf] ============================================================================
[parf] ====== project "base07-sample00 2" ======
[parf] Parameter: -eva-widening-delay 20 -eva-subdivide-non-linear 99 -eva-split-return auto -eva-slevel 1293 -eva-remove-redundant-alarms -eva-plevel 4001 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 3 -eva-ilevel 513 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 1271
[parf] alarms:
[parf] alarm (  1): Uninitialized(t[i + 1].start)
[parf] ============================================================================
[parf] ====== project "base07-sample01 2" ======
[parf] Parameter: -eva-widening-delay 20 -eva-subdivide-non-linear 110 -eva-split-return auto -eva-slevel 1274 -eva-remove-redundant-alarms -eva-plevel 4001 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 513 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 1226
[parf] alarms:
[parf] alarm (  1): Uninitialized(t[i + 1].start)
[parf] ============================================================================
[parf] ====== project "base07-sample02 2" ======
[parf] Parameter: -eva-widening-delay 20 -eva-subdivide-non-linear 106 -eva-split-return auto -eva-slevel 1264 -eva-remove-redundant-alarms -eva-plevel 4001 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 511 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 1233
[parf] alarms:
[parf] alarm (  1): Uninitialized(t[i + 1].start)
[parf] ============================================================================
[parf] ====== project "base07-sample03 2" ======
[parf] Parameter: -eva-widening-delay 16 -eva-subdivide-non-linear 94 -eva-split-return auto -eva-slevel 1311 -eva-remove-redundant-alarms -eva-plevel 4001 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 500 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 1191
[parf] alarms:
[parf] alarm (  1): Uninitialized(t[i + 1].start)
[parf] ============================================================================
[parf] Final parameter: -eva-widening-delay 7 -eva-subdivide-non-linear 9 -eva-split-return auto -eva-slevel 54 -eva-remove-redundant-alarms -eva-plevel 107 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 3 -eva-ilevel 70 -eva-equality-through-calls none -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 49
[parf] alarms:
[parf] alarm (  1): Uninitialized(t[i + 1].start)

real	0m10.846s
user	0m20.086s
sys	0m1.679s
