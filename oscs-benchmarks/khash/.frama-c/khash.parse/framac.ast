/* Generated by Frama-C */
#include "stdlib.h"
#include "string.h"
#include "strings.h"
typedef unsigned char khint8_t;
typedef unsigned int khint32_t;
typedef khint32_t khint_t;
typedef khint_t khiter_t;
struct kh_32_s {
   khint_t n_buckets ;
   khint_t size ;
   khint_t n_occupied ;
   khint_t upper_bound ;
   khint8_t *flags ;
   khint32_t *keys ;
   char *vals ;
};
typedef struct kh_32_s kh_32_t;
static double const __ac_HASH_UPPER = 0.77;
__inline static khint_t __ac_X31_hash_string(char const *s)
{
  khint_t h = (khint_t)*s;
  if (h) {
    s ++;
    while (*s) {
      h = ((h << 5) - h) + (khint_t)*s;
      s ++;
    }
  }
  return h;
}

__inline static khint_t __ac_Wang_hash(khint_t key)
{
  key += ~ (key << 15);
  key ^= key >> 10;
  key += key << 3;
  key ^= key >> 6;
  key += ~ (key << 11);
  key ^= key >> 16;
  return key;
}

__inline static kh_32_t *kh_init_32(void) __attribute__((__unused__));
__inline static kh_32_t *kh_init_32(void)
{
  kh_32_t *tmp;
  tmp = (kh_32_t *)calloc((size_t)1,sizeof(kh_32_t));
  return tmp;
}

__inline static void kh_destroy_32(kh_32_t *h) __attribute__((__unused__));
__inline static void kh_destroy_32(kh_32_t *h)
{
  if (h) {
    free((void *)h->keys);
    free((void *)h->flags);
    free((void *)h->vals);
    free((void *)h);
  }
  return;
}

__inline static void kh_clear_32(kh_32_t *h) __attribute__((__unused__));
__inline static void kh_clear_32(kh_32_t *h)
{
  if (h) 
    if (h->flags) {
      khint_t tmp;
      memset((void *)h->flags,2,h->n_buckets);
      tmp = (khint_t)0;
      h->n_occupied = tmp;
      h->size = tmp;
    }
  return;
}

__inline static khint_t kh_get_32(kh_32_t const *h, khint32_t key) __attribute__((
__unused__));
__inline static khint_t kh_get_32(kh_32_t const *h, khint32_t key)
{
  khint_t __retres;
  if (h->n_buckets) {
    khint_t k;
    khint_t i;
    khint_t last;
    khint_t mask;
    khint_t tmp;
    khint_t step = (khint_t)0;
    mask = h->n_buckets - (khint_t)1;
    k = key;
    i = k & mask;
    last = i;
    while (1) {
      if (! ((int)*(h->flags + i) & 2)) {
        if (! ((int)*(h->flags + i) & 1)) 
          if (! (! (*(h->keys + i) == key))) break;
      }
      else break;
      step ++;
      i = (i + step) & mask;
      if (i == last) {
        __retres = h->n_buckets;
        goto return_label;
      }
    }
    if ((int)*(h->flags + i) & 3) tmp = h->n_buckets; else tmp = i;
    __retres = tmp;
    goto return_label;
  }
  else {
    __retres = (khint_t)0;
    goto return_label;
  }
  return_label: return __retres;
}

__inline static int kh_resize_32(kh_32_t *h, khint_t new_n_buckets) __attribute__((
__unused__));
__inline static int kh_resize_32(kh_32_t *h, khint_t new_n_buckets)
{
  int __retres;
  khint8_t *new_flags = (khint8_t *)0;
  khint_t j = (khint_t)1;
  new_n_buckets --;
  new_n_buckets |= new_n_buckets >> 1;
  new_n_buckets |= new_n_buckets >> 2;
  new_n_buckets |= new_n_buckets >> 4;
  new_n_buckets |= new_n_buckets >> 8;
  new_n_buckets |= new_n_buckets >> 16;
  new_n_buckets ++;
  if (new_n_buckets < (khint_t)4) new_n_buckets = (khint_t)32;
  if (h->size >= (khint_t)((double)new_n_buckets * __ac_HASH_UPPER + 0.5)) 
    j = (khint_t)0;
  else {
    new_flags = (khint8_t *)malloc(new_n_buckets);
    if (! new_flags) {
      __retres = -1;
      goto return_label;
    }
    memset((void *)new_flags,2,new_n_buckets);
    if (h->n_buckets < new_n_buckets) {
      khint32_t *new_keys =
        realloc((void *)h->keys,new_n_buckets * sizeof(khint32_t));
      if (! new_keys) {
        free((void *)new_flags);
        __retres = -1;
        goto return_label;
      }
      h->keys = new_keys;
      {
        char *new_vals =
          realloc((void *)h->vals,new_n_buckets * sizeof(char));
        if (! new_vals) {
          free((void *)new_flags);
          __retres = -1;
          goto return_label;
        }
        h->vals = new_vals;
      }
    }
  }
  if (j) {
    j = (khint_t)0;
    while (j != h->n_buckets) {
      if (((int)*(h->flags + j) & 3) == 0) {
        char val;
        khint_t new_mask;
        khint32_t key = *(h->keys + j);
        new_mask = new_n_buckets - (khint_t)1;
        val = *(h->vals + j);
        *(h->flags + j) = (khint8_t)((int)*(h->flags + j) | 1);
        while (1) {
          {
            khint_t k;
            khint_t i;
            khint_t step = (khint_t)0;
            k = key;
            i = k & new_mask;
            while (! ((int)*(new_flags + i) & 2)) {
              step ++;
              i = (i + step) & new_mask;
            }
            *(new_flags + i) = (khint8_t)((int)*(new_flags + i) & ~ 2);
            if (i < h->n_buckets) {
              if (((int)*(h->flags + i) & 3) == 0) {
                {
                  khint32_t tmp_2 = *(h->keys + i);
                  *(h->keys + i) = key;
                  key = tmp_2;
                }
                {
                  char tmp_3 = *(h->vals + i);
                  *(h->vals + i) = val;
                  val = tmp_3;
                }
                *(h->flags + i) = (khint8_t)((int)*(h->flags + i) | 1);
              }
              else goto _LAND;
            }
            else {
              _LAND: {
                       *(h->keys + i) = key;
                       *(h->vals + i) = val;
                       break;
                     }
            }
          }
        }
      }
      j ++;
    }
    if (h->n_buckets > new_n_buckets) {
      h->keys = (khint32_t *)realloc((void *)h->keys,
                                     new_n_buckets * sizeof(khint32_t));
      h->vals = (char *)realloc((void *)h->vals,new_n_buckets * sizeof(char));
    }
    free((void *)h->flags);
    h->flags = new_flags;
    h->n_buckets = new_n_buckets;
    h->n_occupied = h->size;
    h->upper_bound = (khint_t)((double)h->n_buckets * __ac_HASH_UPPER + 0.5);
  }
  __retres = 0;
  return_label: return __retres;
}

__inline static khint_t kh_put_32(kh_32_t *h, khint32_t key, int *ret) __attribute__((
__unused__));
__inline static khint_t kh_put_32(kh_32_t *h, khint32_t key, int *ret)
{
  khint_t __retres;
  khint_t x;
  if (h->n_occupied >= h->upper_bound) 
    if (h->n_buckets > h->size << 1) {
      int tmp;
      tmp = kh_resize_32(h,h->n_buckets - (khint_t)1);
      if (tmp < 0) {
        *ret = -1;
        __retres = h->n_buckets;
        goto return_label;
      }
    }
    else {
      int tmp_0;
      tmp_0 = kh_resize_32(h,h->n_buckets + (khint_t)1);
      if (tmp_0 < 0) {
        *ret = -1;
        __retres = h->n_buckets;
        goto return_label;
      }
    }
  {
    khint_t k;
    khint_t i;
    khint_t site;
    khint_t last;
    khint_t mask = h->n_buckets - (khint_t)1;
    khint_t step = (khint_t)0;
    site = h->n_buckets;
    x = site;
    k = key;
    i = k & mask;
    if ((int)*(h->flags + i) & 2) x = i;
    else {
      last = i;
      while (1) {
        if (! ((int)*(h->flags + i) & 2)) {
          if (! ((int)*(h->flags + i) & 1)) 
            if (! (! (*(h->keys + i) == key))) break;
        }
        else break;
        if ((int)*(h->flags + i) & 1) site = i;
        step ++;
        i = (i + step) & mask;
        if (i == last) {
          x = site;
          break;
        }
      }
      if (x == h->n_buckets) 
        if ((int)*(h->flags + i) & 2) 
          if (site != h->n_buckets) x = site; else x = i;
        else x = i;
    }
  }
  if ((int)*(h->flags + x) & 2) {
    *(h->keys + x) = key;
    *(h->flags + x) = (khint8_t)0;
    (h->size) ++;
    (h->n_occupied) ++;
    *ret = 1;
  }
  else 
    if ((int)*(h->flags + x) & 1) {
      *(h->keys + x) = key;
      *(h->flags + x) = (khint8_t)0;
      (h->size) ++;
      *ret = 2;
    }
    else *ret = 0;
  __retres = x;
  return_label: return __retres;
}

__inline static void kh_del_32(kh_32_t *h, khint_t x) __attribute__((
__unused__));
__inline static void kh_del_32(kh_32_t *h, khint_t x)
{
  if (x != h->n_buckets) 
    if (! ((int)*(h->flags + x) & 3)) {
      *(h->flags + x) = (khint8_t)((int)*(h->flags + x) | 1);
      (h->size) --;
    }
  return;
}

int main(void)
{
  int __retres;
  int ret;
  int is_missing;
  khiter_t k;
  kh_32_t *h = kh_init_32();
  k = kh_put_32(h,(khint32_t)5,& ret);
  *(h->vals + k) = (char)10;
  k = kh_get_32((kh_32_t const *)h,(khint32_t)10);
  is_missing = k == h->n_buckets;
  k = kh_get_32((kh_32_t const *)h,(khint32_t)5);
  kh_del_32(h,k);
  k = (khint_t)0;
  /*@ loop unroll 32; */
  while (k != h->n_buckets) {
    if (! ((int)*(h->flags + k) & 3)) *(h->vals + k) = (char)1;
    k ++;
  }
  kh_destroy_32(h);
  __retres = 0;
  return __retres;
}


