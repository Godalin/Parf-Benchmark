/* Generated by Frama-C */
#include "errno.h"
#include "stdarg.h"
#include "stddef.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "strings.h"
typedef unsigned char u8;
typedef unsigned long u32;
typedef unsigned long long u64;
typedef long long i64;
typedef i64 gf[16];
int crypto_box_curve25519xsalsa20poly1305_tweet(unsigned char *c,
                                                unsigned char const *m,
                                                unsigned long long d,
                                                unsigned char const *n,
                                                unsigned char const *y,
                                                unsigned char const *x);

int crypto_box_curve25519xsalsa20poly1305_tweet_open(unsigned char *m,
                                                     unsigned char const *c,
                                                     unsigned long long d,
                                                     unsigned char const *n,
                                                     unsigned char const *y,
                                                     unsigned char const *x);

int crypto_box_curve25519xsalsa20poly1305_tweet_keypair(unsigned char *y,
                                                        unsigned char *x);

int crypto_box_curve25519xsalsa20poly1305_tweet_beforenm(unsigned char *k,
                                                         unsigned char const *y,
                                                         unsigned char const *x);

int crypto_box_curve25519xsalsa20poly1305_tweet_afternm(unsigned char *c,
                                                        unsigned char const *m,
                                                        unsigned long long d,
                                                        unsigned char const *n,
                                                        unsigned char const *k);

int crypto_box_curve25519xsalsa20poly1305_tweet_open_afternm(unsigned char *m,
                                                             unsigned char const *c,
                                                             unsigned long long d,
                                                             unsigned char const *n,
                                                             unsigned char const *k);

int crypto_core_salsa20_tweet(unsigned char *out, unsigned char const *in,
                              unsigned char const *k, unsigned char const *c);

int crypto_core_hsalsa20_tweet(unsigned char *out, unsigned char const *in,
                               unsigned char const *k, unsigned char const *c);

int crypto_hashblocks_sha512_tweet(unsigned char *x, unsigned char const *m,
                                   unsigned long long n);

int crypto_hash_sha512_tweet(unsigned char *out, unsigned char const *m,
                             unsigned long long n);

int crypto_onetimeauth_poly1305_tweet(unsigned char *out,
                                      unsigned char const *m,
                                      unsigned long long n,
                                      unsigned char const *k);

int crypto_onetimeauth_poly1305_tweet_verify(unsigned char const *h,
                                             unsigned char const *m,
                                             unsigned long long n,
                                             unsigned char const *k);

int crypto_scalarmult_curve25519_tweet(unsigned char *q,
                                       unsigned char const *n,
                                       unsigned char const *p);

int crypto_scalarmult_curve25519_tweet_base(unsigned char *q,
                                            unsigned char const *n);

int crypto_secretbox_xsalsa20poly1305_tweet(unsigned char *c,
                                            unsigned char const *m,
                                            unsigned long long d,
                                            unsigned char const *n,
                                            unsigned char const *k);

int crypto_secretbox_xsalsa20poly1305_tweet_open(unsigned char *m,
                                                 unsigned char const *c,
                                                 unsigned long long d,
                                                 unsigned char const *n,
                                                 unsigned char const *k);

int crypto_sign_ed25519_tweet(unsigned char *sm, unsigned long long *smlen,
                              unsigned char const *m, unsigned long long n,
                              unsigned char const *sk);

int crypto_sign_ed25519_tweet_open(unsigned char *m,
                                   unsigned long long *mlen,
                                   unsigned char const *sm,
                                   unsigned long long n,
                                   unsigned char const *pk);

int crypto_sign_ed25519_tweet_keypair(unsigned char *pk, unsigned char *sk);

int crypto_stream_xsalsa20_tweet(unsigned char *c, unsigned long long d,
                                 unsigned char const *n,
                                 unsigned char const *k);

int crypto_stream_xsalsa20_tweet_xor(unsigned char *c,
                                     unsigned char const *m,
                                     unsigned long long d,
                                     unsigned char const *n,
                                     unsigned char const *k);

int crypto_stream_salsa20_tweet(unsigned char *c, unsigned long long d,
                                unsigned char const *n,
                                unsigned char const *k);

int crypto_stream_salsa20_tweet_xor(unsigned char *c, unsigned char const *m,
                                    unsigned long long b,
                                    unsigned char const *n,
                                    unsigned char const *k);

int crypto_verify_16_tweet(unsigned char const *x, unsigned char const *y);

int crypto_verify_32_tweet(unsigned char const *x, unsigned char const *y);

void randombytes(unsigned char *ptr, unsigned long long length);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_1(char const * restrict format, unsigned int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_2(char const * restrict format);

/*@ requires len â‰¥ 0; */
void hexdump(char *data, int len)
{
  int i;
  i = 0;
  /*@ loop unroll 105; */
  while (i < len) {
    printf("%02X",(unsigned int)((int)((u8)*(data + i)))); /* printf_va_1 */
    i ++;
  }
  printf("\n"); /* printf_va_2 */
  return;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_3(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_4(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_5(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_6(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_7(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_8(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_9(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_10(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_11(char const * restrict format);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_12(char const * restrict format, char *param0);

int main(void)
{
  int __retres;
  char *padded_message;
  int padded_mlen;
  u8 *ciphertext;
  char *decryptedmessage;
  size_t tmp;
  size_t tmp_1;
  int tmp_4;
  int tmp_5;
  u8 sk[32] = {(u8)0};
  u8 pk[32] = {(u8)0};
  u8 sk2[32] = {(u8)0};
  u8 pk2[32] = {(u8)0};
  u8 nonce[24] = {(u8)0};
  char *message =
    (char *)"This is a cross-platform test of crypto_box/crypto_box_open in TweetNaCl.";
  randombytes(nonce,(unsigned long long)24);
  printf("Nonce: \n"); /* printf_va_3 */
  hexdump((char *)(nonce),24);
  crypto_box_curve25519xsalsa20poly1305_tweet_keypair(pk,sk);
  crypto_box_curve25519xsalsa20poly1305_tweet_keypair(pk2,sk2);
  printf("Public key: \n"); /* printf_va_4 */
  hexdump((char *)(pk),32);
  printf("\nSecret key: \n"); /* printf_va_5 */
  hexdump((char *)(sk),32);
  printf("Public key2: \n"); /* printf_va_6 */
  hexdump((char *)(pk2),32);
  printf("\nSecret key2: \n"); /* printf_va_7 */
  hexdump((char *)(sk2),32);
  tmp = strlen((char const *)message);
  padded_mlen = (int)(tmp + (size_t)32);
  padded_message = (char *)malloc((size_t)padded_mlen);
  memset((void *)padded_message,0,(size_t)32);
  tmp_1 = strlen((char const *)message);
  ;
  ;
  memcpy((void *)(padded_message + 32),(void const *)message,tmp_1);
  ciphertext = (u8 *)malloc((size_t)padded_mlen);
  decryptedmessage = (char *)malloc((size_t)(padded_mlen + 1));
  *(decryptedmessage + padded_mlen) = (char)'\000';
  tmp_4 = crypto_box_curve25519xsalsa20poly1305_tweet(ciphertext,
                                                      (unsigned char const *)padded_message,
                                                      (unsigned long long)padded_mlen,
                                                      (unsigned char const *)(nonce),
                                                      (unsigned char const *)(pk2),
                                                      (unsigned char const *)(sk));
  printf("crypto_box returned: %d\n",tmp_4); /* printf_va_8 */
  free((void *)padded_message);
  printf("\nCipher text: \n"); /* printf_va_9 */
  hexdump((char *)ciphertext,padded_mlen);
  tmp_5 = crypto_box_curve25519xsalsa20poly1305_tweet_open((u8 *)decryptedmessage,
                                                           (unsigned char const *)ciphertext,
                                                           (unsigned long long)padded_mlen,
                                                           (unsigned char const *)(nonce),
                                                           (unsigned char const *)(pk),
                                                           (unsigned char const *)(sk2));
  printf("crypto_box_open returned: %d\n",tmp_5); /* printf_va_10 */
  free((void *)ciphertext);
  printf("\nDecrypted text: \n"); /* printf_va_11 */
  hexdump(decryptedmessage,padded_mlen);
  printf("%s\n",decryptedmessage + 32); /* printf_va_12 */
  free((void *)decryptedmessage);
  __retres = 0;
  return __retres;
}

static u8 const _0[16];
static u8 const _9[32] = {(u8)9};
static gf const gf0;
static gf const gf1 = {(i64)1};
static gf const _121665 = {(i64)0xDB41, (i64)1};
static gf const D =
  {(i64)0x78a3,
   (i64)0x1359,
   (i64)0x4dca,
   (i64)0x75eb,
   (i64)0xd8ab,
   (i64)0x4141,
   (i64)0x0a4d,
   (i64)0x0070,
   (i64)0xe898,
   (i64)0x7779,
   (i64)0x4079,
   (i64)0x8cc7,
   (i64)0xfe73,
   (i64)0x2b6f,
   (i64)0x6cee,
   (i64)0x5203};
static gf const D2 =
  {(i64)0xf159,
   (i64)0x26b2,
   (i64)0x9b94,
   (i64)0xebd6,
   (i64)0xb156,
   (i64)0x8283,
   (i64)0x149a,
   (i64)0x00e0,
   (i64)0xd130,
   (i64)0xeef3,
   (i64)0x80f2,
   (i64)0x198e,
   (i64)0xfce7,
   (i64)0x56df,
   (i64)0xd9dc,
   (i64)0x2406};
static gf const X =
  {(i64)0xd51a,
   (i64)0x8f25,
   (i64)0x2d60,
   (i64)0xc956,
   (i64)0xa7b2,
   (i64)0x9525,
   (i64)0xc760,
   (i64)0x692c,
   (i64)0xdc5c,
   (i64)0xfdd6,
   (i64)0xe231,
   (i64)0xc0a4,
   (i64)0x53fe,
   (i64)0xcd6e,
   (i64)0x36d3,
   (i64)0x2169};
static gf const Y =
  {(i64)0x6658,
   (i64)0x6666,
   (i64)0x6666,
   (i64)0x6666,
   (i64)0x6666,
   (i64)0x6666,
   (i64)0x6666,
   (i64)0x6666,
   (i64)0x6666,
   (i64)0x6666,
   (i64)0x6666,
   (i64)0x6666,
   (i64)0x6666,
   (i64)0x6666,
   (i64)0x6666,
   (i64)0x6666};
static gf const I =
  {(i64)0xa0b0,
   (i64)0x4a0e,
   (i64)0x1b27,
   (i64)0xc4ee,
   (i64)0xe478,
   (i64)0xad2f,
   (i64)0x1806,
   (i64)0x2f43,
   (i64)0xd7a7,
   (i64)0x3dfb,
   (i64)0x0099,
   (i64)0x2b4d,
   (i64)0xdf0b,
   (i64)0x4fc1,
   (i64)0x2480,
   (i64)0x2b83};
static u32 L32(u32 x, int c)
{
  u32 __retres;
  __retres = (x << c) | ((x & (unsigned long)0xffffffff) >> (32 - c));
  return __retres;
}

static u32 ld32(u8 const *x)
{
  u32 __retres;
  u32 u = (u32)*(x + 3);
  u = (u << 8) | (unsigned long)*(x + 2);
  u = (u << 8) | (unsigned long)*(x + 1);
  __retres = (u << 8) | (unsigned long)*(x + 0);
  return __retres;
}

static u64 dl64(u8 const *x)
{
  u64 i;
  u64 u = (u64)0;
  i = (u64)0;
  while (i < (u64)8) {
    u = (u << 8) | (unsigned long long)*(x + i);
    i ++;
  }
  return u;
}

static void st32(u8 *x, u32 u)
{
  int i;
  i = 0;
  while (i < 4) {
    *(x + i) = (u8)u;
    u >>= 8;
    i ++;
  }
  return;
}

static void ts64(u8 *x, u64 u)
{
  int i;
  i = 7;
  while (i >= 0) {
    *(x + i) = (u8)u;
    u >>= 8;
    i --;
  }
  return;
}

static int vn(u8 const *x, u8 const *y, int n)
{
  int __retres;
  u32 i;
  u32 d = (u32)0;
  i = (u32)0;
  while (i < (u32)n) {
    d |= (unsigned long)((int)*(x + i) ^ (int)*(y + i));
    i ++;
  }
  __retres = (int)(((unsigned long)1 & ((d - (u32)1) >> 8)) - (unsigned long)1);
  return __retres;
}

int crypto_verify_16_tweet(unsigned char const *x, unsigned char const *y)
{
  int tmp;
  tmp = vn(x,y,16);
  return tmp;
}

int crypto_verify_32_tweet(unsigned char const *x, unsigned char const *y)
{
  int tmp;
  tmp = vn(x,y,32);
  return tmp;
}

static void core(u8 *out, u8 const *in, u8 const *k, u8 const *c, int h)
{
  u32 w[16];
  u32 x[16];
  u32 y[16];
  u32 t[4];
  int i;
  int j;
  int m;
  i = 0;
  while (i < 4) {
    x[5 * i] = ld32(c + 4 * i);
    x[1 + i] = ld32(k + 4 * i);
    x[6 + i] = ld32(in + 4 * i);
    x[11 + i] = ld32((k + 16) + 4 * i);
    i ++;
  }
  i = 0;
  while (i < 16) {
    y[i] = x[i];
    i ++;
  }
  i = 0;
  while (i < 20) {
    j = 0;
    while (j < 4) {
      {
        u32 tmp;
        u32 tmp_0;
        u32 tmp_1;
        u32 tmp_2;
        m = 0;
        while (m < 4) {
          t[m] = x[(5 * j + 4 * m) % 16];
          m ++;
        }
        tmp = L32(t[0] + t[3],7);
        t[1] ^= tmp;
        tmp_0 = L32(t[1] + t[0],9);
        t[2] ^= tmp_0;
        tmp_1 = L32(t[2] + t[1],13);
        t[3] ^= tmp_1;
        tmp_2 = L32(t[3] + t[2],18);
        t[0] ^= tmp_2;
        m = 0;
        while (m < 4) {
          w[4 * j + (j + m) % 4] = t[m];
          m ++;
        }
      }
      j ++;
    }
    m = 0;
    while (m < 16) {
      x[m] = w[m];
      m ++;
    }
    i ++;
  }
  if (h) {
    i = 0;
    while (i < 16) {
      x[i] += y[i];
      i ++;
    }
    i = 0;
    while (i < 4) {
      {
        u32 tmp_3;
        u32 tmp_4;
        tmp_3 = ld32(c + 4 * i);
        x[5 * i] -= tmp_3;
        tmp_4 = ld32(in + 4 * i);
        x[6 + i] -= tmp_4;
      }
      i ++;
    }
    i = 0;
    while (i < 4) {
      st32(out + 4 * i,x[5 * i]);
      st32((out + 16) + 4 * i,x[6 + i]);
      i ++;
    }
  }
  else {
    i = 0;
    while (i < 16) {
      st32(out + 4 * i,x[i] + y[i]);
      i ++;
    }
  }
  return;
}

int crypto_core_salsa20_tweet(unsigned char *out, unsigned char const *in,
                              unsigned char const *k, unsigned char const *c)
{
  int __retres;
  core(out,in,k,c,0);
  __retres = 0;
  return __retres;
}

int crypto_core_hsalsa20_tweet(unsigned char *out, unsigned char const *in,
                               unsigned char const *k, unsigned char const *c)
{
  int __retres;
  core(out,in,k,c,1);
  __retres = 0;
  return __retres;
}

static u8 const sigma[16] =
  {(u8)'e',
   (u8)'x',
   (u8)'p',
   (u8)'a',
   (u8)'n',
   (u8)'d',
   (u8)' ',
   (u8)'3',
   (u8)'2',
   (u8)'-',
   (u8)'b',
   (u8)'y',
   (u8)'t',
   (u8)'e',
   (u8)' ',
   (u8)'k'};
int crypto_stream_salsa20_tweet_xor(unsigned char *c, unsigned char const *m,
                                    unsigned long long b,
                                    unsigned char const *n,
                                    unsigned char const *k)
{
  int __retres;
  u8 z[16];
  u8 x[64];
  u32 u;
  u32 i;
  if (! b) {
    __retres = 0;
    goto return_label;
  }
  i = (u32)0;
  while (i < (u32)16) {
    z[i] = (u8)0;
    i ++;
  }
  i = (u32)0;
  while (i < (u32)8) {
    z[i] = *(n + i);
    i ++;
  }
  while (b >= (unsigned long long)64) {
    crypto_core_salsa20_tweet(x,(unsigned char const *)(z),k,sigma);
    i = (u32)0;
    while (i < (u32)64) {
      int tmp;
      if (m) tmp = (int)*(m + i); else tmp = 0;
      *(c + i) = (unsigned char)(tmp ^ (int)x[i]);
      i ++;
    }
    u = (u32)1;
    i = (u32)8;
    while (i < (u32)16) {
      u += (u32)z[i];
      z[i] = (u8)u;
      u >>= 8;
      i ++;
    }
    b -= (unsigned long long)64;
    c += 64;
    if (m) m += 64;
  }
  if (b) {
    crypto_core_salsa20_tweet(x,(unsigned char const *)(z),k,sigma);
    i = (u32)0;
    while ((unsigned long long)i < b) {
      int tmp_0;
      if (m) tmp_0 = (int)*(m + i); else tmp_0 = 0;
      *(c + i) = (unsigned char)(tmp_0 ^ (int)x[i]);
      i ++;
    }
  }
  __retres = 0;
  return_label: return __retres;
}

int crypto_stream_salsa20_tweet(unsigned char *c, unsigned long long d,
                                unsigned char const *n,
                                unsigned char const *k)
{
  int tmp;
  tmp = crypto_stream_salsa20_tweet_xor(c,(unsigned char const *)0,d,n,k);
  return tmp;
}

int crypto_stream_xsalsa20_tweet(unsigned char *c, unsigned long long d,
                                 unsigned char const *n,
                                 unsigned char const *k)
{
  u8 s[32];
  int tmp;
  crypto_core_hsalsa20_tweet(s,n,k,sigma);
  tmp = crypto_stream_salsa20_tweet(c,d,n + 16,(unsigned char const *)(s));
  return tmp;
}

int crypto_stream_xsalsa20_tweet_xor(unsigned char *c,
                                     unsigned char const *m,
                                     unsigned long long d,
                                     unsigned char const *n,
                                     unsigned char const *k)
{
  u8 s[32];
  int tmp;
  crypto_core_hsalsa20_tweet(s,n,k,sigma);
  tmp = crypto_stream_salsa20_tweet_xor(c,m,d,n + 16,
                                        (unsigned char const *)(s));
  return tmp;
}

static void add1305(u32 *h, u32 const *c)
{
  u32 j;
  u32 u = (u32)0;
  j = (u32)0;
  while (j < (u32)17) {
    u += *(h + j) + *(c + j);
    *(h + j) = u & (unsigned long)255;
    u >>= 8;
    j ++;
  }
  return;
}

static u32 const minusp[17] =
  {(u32)5,
   (u32)0,
   (u32)0,
   (u32)0,
   (u32)0,
   (u32)0,
   (u32)0,
   (u32)0,
   (u32)0,
   (u32)0,
   (u32)0,
   (u32)0,
   (u32)0,
   (u32)0,
   (u32)0,
   (u32)0,
   (u32)252};
int crypto_onetimeauth_poly1305_tweet(unsigned char *out,
                                      unsigned char const *m,
                                      unsigned long long n,
                                      unsigned char const *k)
{
  int __retres;
  u32 s;
  u32 i;
  u32 j;
  u32 u;
  u32 x[17];
  u32 r[17];
  u32 h[17];
  u32 c[17];
  u32 g[17];
  j = (u32)0;
  while (j < (u32)17) {
    u32 tmp;
    tmp = (u32)0;
    h[j] = tmp;
    r[j] = tmp;
    j ++;
  }
  j = (u32)0;
  while (j < (u32)16) {
    r[j] = (u32)*(k + j);
    j ++;
  }
  r[3] &= (unsigned long)15;
  r[4] &= (unsigned long)252;
  r[7] &= (unsigned long)15;
  r[8] &= (unsigned long)252;
  r[11] &= (unsigned long)15;
  r[12] &= (unsigned long)252;
  r[15] &= (unsigned long)15;
  /*@ loop unroll 5; */
  while (n > (unsigned long long)0) {
    j = (u32)0;
    while (j < (u32)17) {
      c[j] = (u32)0;
      j ++;
    }
    j = (u32)0;
    while (1) {
      if (j < (u32)16) {
        if (! ((unsigned long long)j < n)) break;
      }
      else break;
      c[j] = (u32)*(m + j);
      j ++;
    }
    c[j] = (u32)1;
    m += j;
    n -= (unsigned long long)j;
    add1305(h,(u32 const *)(c));
    i = (u32)0;
    while (i < (u32)17) {
      x[i] = (u32)0;
      j = (u32)0;
      while (j < (u32)17) {
        u32 tmp_0;
        if (j <= i) tmp_0 = r[i - j];
        else tmp_0 = (u32)320 * r[(i + (u32)17) - j];
        x[i] += h[j] * tmp_0;
        j ++;
      }
      i ++;
    }
    i = (u32)0;
    while (i < (u32)17) {
      h[i] = x[i];
      i ++;
    }
    u = (u32)0;
    j = (u32)0;
    while (j < (u32)16) {
      u += h[j];
      h[j] = u & (unsigned long)255;
      u >>= 8;
      j ++;
    }
    u += h[16];
    h[16] = u & (unsigned long)3;
    u = (u32)5 * (u >> 2);
    j = (u32)0;
    while (j < (u32)16) {
      u += h[j];
      h[j] = u & (unsigned long)255;
      u >>= 8;
      j ++;
    }
    u += h[16];
    h[16] = u;
  }
  j = (u32)0;
  while (j < (u32)17) {
    g[j] = h[j];
    j ++;
  }
  add1305(h,minusp);
  s = - (h[16] >> 7);
  j = (u32)0;
  while (j < (u32)17) {
    h[j] ^= s & (g[j] ^ h[j]);
    j ++;
  }
  j = (u32)0;
  while (j < (u32)16) {
    c[j] = (u32)*(k + (j + (u32)16));
    j ++;
  }
  c[16] = (u32)0;
  add1305(h,(u32 const *)(c));
  j = (u32)0;
  while (j < (u32)16) {
    *(out + j) = (unsigned char)h[j];
    j ++;
  }
  __retres = 0;
  return __retres;
}

int crypto_onetimeauth_poly1305_tweet_verify(unsigned char const *h,
                                             unsigned char const *m,
                                             unsigned long long n,
                                             unsigned char const *k)
{
  u8 x[16];
  int tmp;
  crypto_onetimeauth_poly1305_tweet(x,m,n,k);
  tmp = crypto_verify_16_tweet(h,(unsigned char const *)(x));
  return tmp;
}

int crypto_secretbox_xsalsa20poly1305_tweet(unsigned char *c,
                                            unsigned char const *m,
                                            unsigned long long d,
                                            unsigned char const *n,
                                            unsigned char const *k)
{
  int __retres;
  int i;
  if (d < (unsigned long long)32) {
    __retres = -1;
    goto return_label;
  }
  crypto_stream_xsalsa20_tweet_xor(c,m,d,n,k);
  crypto_onetimeauth_poly1305_tweet(c + 16,(unsigned char const *)(c + 32),
                                    d - (unsigned long long)32,
                                    (unsigned char const *)c);
  i = 0;
  while (i < 16) {
    *(c + i) = (unsigned char)0;
    i ++;
  }
  __retres = 0;
  return_label: return __retres;
}

int crypto_secretbox_xsalsa20poly1305_tweet_open(unsigned char *m,
                                                 unsigned char const *c,
                                                 unsigned long long d,
                                                 unsigned char const *n,
                                                 unsigned char const *k)
{
  int __retres;
  int i;
  u8 x[32];
  int tmp;
  if (d < (unsigned long long)32) {
    __retres = -1;
    goto return_label;
  }
  crypto_stream_xsalsa20_tweet(x,(unsigned long long)32,n,k);
  tmp = crypto_onetimeauth_poly1305_tweet_verify(c + 16,c + 32,
                                                 d - (unsigned long long)32,
                                                 (unsigned char const *)(x));
  if (tmp != 0) {
    __retres = -1;
    goto return_label;
  }
  crypto_stream_xsalsa20_tweet_xor(m,c,d,n,k);
  i = 0;
  while (i < 32) {
    *(m + i) = (unsigned char)0;
    i ++;
  }
  __retres = 0;
  return_label: return __retres;
}

static void set25519(i64 r[16], i64 const a[16])
{
  int i;
  i = 0;
  while (i < 16) {
    *(r + i) = *(a + i);
    i ++;
  }
  return;
}

static void car25519(i64 o[16])
{
  int i;
  i64 c;
  i = 0;
  while (i < 16) {
    *(o + i) += 1LL << 16;
    c = *(o + i) >> 16;
    *(o + (i + 1) * (i < 15)) += (c - (i64)1) + ((i64)37 * (c - (i64)1)) * (i64)(
                                                i == 15);
    *(o + i) -= c << 16;
    i ++;
  }
  return;
}

static void sel25519(i64 p[16], i64 q[16], int b)
{
  i64 t;
  i64 i;
  i64 c = (i64)(~ (b - 1));
  i = (i64)0;
  while (i < (i64)16) {
    t = c & (*(p + i) ^ *(q + i));
    *(p + i) ^= t;
    *(q + i) ^= t;
    i ++;
  }
  return;
}

static void pack25519(u8 *o, i64 const n[16])
{
  int i;
  int j;
  int b;
  gf m;
  gf t;
  i = 0;
  while (i < 16) {
    t[i] = *(n + i);
    i ++;
  }
  car25519(t);
  car25519(t);
  car25519(t);
  j = 0;
  while (j < 2) {
    m[0] = t[0] - (i64)0xffed;
    i = 1;
    while (i < 15) {
      m[i] = (t[i] - (i64)0xffff) - ((m[i - 1] >> 16) & (long long)1);
      m[i - 1] &= (long long)0xffff;
      i ++;
    }
    m[15] = (t[15] - (i64)0x7fff) - ((m[14] >> 16) & (long long)1);
    b = (int)((m[15] >> 16) & (long long)1);
    m[14] &= (long long)0xffff;
    sel25519(t,m,1 - b);
    j ++;
  }
  i = 0;
  while (i < 16) {
    *(o + 2 * i) = (u8)(t[i] & (long long)0xff);
    *(o + (2 * i + 1)) = (u8)(t[i] >> 8);
    i ++;
  }
  return;
}

static int neq25519(i64 const a[16], i64 const b[16])
{
  u8 c[32];
  u8 d[32];
  int tmp;
  pack25519(c,a);
  pack25519(d,b);
  tmp = crypto_verify_32_tweet((unsigned char const *)(c),
                               (unsigned char const *)(d));
  return tmp;
}

static u8 par25519(i64 const a[16])
{
  u8 __retres;
  u8 d[32];
  pack25519(d,a);
  __retres = (u8)((int)d[0] & 1);
  return __retres;
}

static void unpack25519(i64 o[16], u8 const *n)
{
  int i;
  i = 0;
  while (i < 16) {
    *(o + i) = (i64)*(n + 2 * i) + ((i64)*(n + (2 * i + 1)) << 8);
    i ++;
  }
  *(o + 15) &= (long long)0x7fff;
  return;
}

static void A(i64 o[16], i64 const a[16], i64 const b[16])
{
  int i;
  i = 0;
  while (i < 16) {
    *(o + i) = *(a + i) + *(b + i);
    i ++;
  }
  return;
}

static void Z(i64 o[16], i64 const a[16], i64 const b[16])
{
  int i;
  i = 0;
  while (i < 16) {
    *(o + i) = *(a + i) - *(b + i);
    i ++;
  }
  return;
}

static void M(i64 o[16], i64 const a[16], i64 const b[16])
{
  i64 i;
  i64 j;
  i64 t[31];
  i = (i64)0;
  while (i < (i64)31) {
    t[i] = (i64)0;
    i ++;
  }
  i = (i64)0;
  while (i < (i64)16) {
    j = (i64)0;
    while (j < (i64)16) {
      t[i + j] += *(a + i) * *(b + j);
      j ++;
    }
    i ++;
  }
  i = (i64)0;
  while (i < (i64)15) {
    t[i] += (i64)38 * t[i + (i64)16];
    i ++;
  }
  i = (i64)0;
  while (i < (i64)16) {
    *(o + i) = t[i];
    i ++;
  }
  car25519(o);
  car25519(o);
  return;
}

static void S(i64 o[16], i64 const a[16])
{
  M(o,a,a);
  return;
}

static void inv25519(i64 o[16], i64 const i[16])
{
  gf c;
  int a;
  a = 0;
  while (a < 16) {
    c[a] = *(i + a);
    a ++;
  }
  a = 253;
  while (a >= 0) {
    S(c,(i64 const *)(c));
    if (a != 2) 
      if (a != 4) M(c,(i64 const *)(c),i);
    a --;
  }
  a = 0;
  while (a < 16) {
    *(o + a) = c[a];
    a ++;
  }
  return;
}

static void pow2523(i64 o[16], i64 const i[16])
{
  gf c;
  int a;
  a = 0;
  while (a < 16) {
    c[a] = *(i + a);
    a ++;
  }
  a = 250;
  while (a >= 0) {
    S(c,(i64 const *)(c));
    if (a != 1) M(c,(i64 const *)(c),i);
    a --;
  }
  a = 0;
  while (a < 16) {
    *(o + a) = c[a];
    a ++;
  }
  return;
}

int crypto_scalarmult_curve25519_tweet(unsigned char *q,
                                       unsigned char const *n,
                                       unsigned char const *p)
{
  int __retres;
  u8 z[32];
  i64 x[80];
  i64 r;
  i64 i;
  gf a;
  gf b;
  gf c;
  gf d;
  gf e;
  gf f;
  i = (i64)0;
  while (i < (i64)31) {
    z[i] = *(n + i);
    i ++;
  }
  z[31] = (u8)(((int)*(n + 31) & 127) | 64);
  z[0] = (u8)((int)z[0] & 248);
  unpack25519(x,p);
  i = (i64)0;
  while (i < (i64)16) {
    {
      i64 tmp_0;
      i64 tmp;
      b[i] = x[i];
      tmp_0 = (i64)0;
      c[i] = tmp_0;
      tmp = tmp_0;
      a[i] = tmp;
      d[i] = tmp;
    }
    i ++;
  }
  d[0] = (i64)1;
  a[0] = d[0];
  i = (i64)254;
  while (i >= (i64)0) {
    r = (i64)(((int)z[i >> 3] >> (i & (long long)7)) & 1);
    sel25519(a,b,(int)r);
    sel25519(c,d,(int)r);
    A(e,(i64 const *)(a),(i64 const *)(c));
    Z(a,(i64 const *)(a),(i64 const *)(c));
    A(c,(i64 const *)(b),(i64 const *)(d));
    Z(b,(i64 const *)(b),(i64 const *)(d));
    S(d,(i64 const *)(e));
    S(f,(i64 const *)(a));
    M(a,(i64 const *)(c),(i64 const *)(a));
    M(c,(i64 const *)(b),(i64 const *)(e));
    A(e,(i64 const *)(a),(i64 const *)(c));
    Z(a,(i64 const *)(a),(i64 const *)(c));
    S(b,(i64 const *)(a));
    Z(c,(i64 const *)(d),(i64 const *)(f));
    M(a,(i64 const *)(c),_121665);
    A(a,(i64 const *)(a),(i64 const *)(d));
    M(c,(i64 const *)(c),(i64 const *)(a));
    M(a,(i64 const *)(d),(i64 const *)(f));
    M(d,(i64 const *)(b),(i64 const *)(x));
    S(b,(i64 const *)(e));
    sel25519(a,b,(int)r);
    sel25519(c,d,(int)r);
    i --;
  }
  i = (i64)0;
  while (i < (i64)16) {
    x[i + (i64)16] = a[i];
    x[i + (i64)32] = c[i];
    x[i + (i64)48] = b[i];
    x[i + (i64)64] = d[i];
    i ++;
  }
  inv25519(& x[32],(i64 const *)(& x[32]));
  M(& x[16],(i64 const *)(& x[16]),(i64 const *)(& x[32]));
  pack25519(q,(i64 const *)(& x[16]));
  __retres = 0;
  return __retres;
}

int crypto_scalarmult_curve25519_tweet_base(unsigned char *q,
                                            unsigned char const *n)
{
  int tmp;
  tmp = crypto_scalarmult_curve25519_tweet(q,n,_9);
  return tmp;
}

int crypto_box_curve25519xsalsa20poly1305_tweet_keypair(unsigned char *y,
                                                        unsigned char *x)
{
  int tmp;
  randombytes(x,(u64)32);
  tmp = crypto_scalarmult_curve25519_tweet_base(y,(unsigned char const *)x);
  return tmp;
}

int crypto_box_curve25519xsalsa20poly1305_tweet_beforenm(unsigned char *k,
                                                         unsigned char const *y,
                                                         unsigned char const *x)
{
  u8 s[32];
  int tmp;
  crypto_scalarmult_curve25519_tweet(s,x,y);
  tmp = crypto_core_hsalsa20_tweet(k,_0,(unsigned char const *)(s),sigma);
  return tmp;
}

int crypto_box_curve25519xsalsa20poly1305_tweet_afternm(unsigned char *c,
                                                        unsigned char const *m,
                                                        unsigned long long d,
                                                        unsigned char const *n,
                                                        unsigned char const *k)
{
  int tmp;
  tmp = crypto_secretbox_xsalsa20poly1305_tweet(c,m,d,n,k);
  return tmp;
}

int crypto_box_curve25519xsalsa20poly1305_tweet_open_afternm(unsigned char *m,
                                                             unsigned char const *c,
                                                             unsigned long long d,
                                                             unsigned char const *n,
                                                             unsigned char const *k)
{
  int tmp;
  tmp = crypto_secretbox_xsalsa20poly1305_tweet_open(m,c,d,n,k);
  return tmp;
}

int crypto_box_curve25519xsalsa20poly1305_tweet(unsigned char *c,
                                                unsigned char const *m,
                                                unsigned long long d,
                                                unsigned char const *n,
                                                unsigned char const *y,
                                                unsigned char const *x)
{
  u8 k[32];
  int tmp;
  crypto_box_curve25519xsalsa20poly1305_tweet_beforenm(k,y,x);
  tmp = crypto_box_curve25519xsalsa20poly1305_tweet_afternm(c,m,d,n,
                                                            (unsigned char const *)(k));
  return tmp;
}

int crypto_box_curve25519xsalsa20poly1305_tweet_open(unsigned char *m,
                                                     unsigned char const *c,
                                                     unsigned long long d,
                                                     unsigned char const *n,
                                                     unsigned char const *y,
                                                     unsigned char const *x)
{
  u8 k[32];
  int tmp;
  crypto_box_curve25519xsalsa20poly1305_tweet_beforenm(k,y,x);
  tmp = crypto_box_curve25519xsalsa20poly1305_tweet_open_afternm(m,c,d,n,
                                                                 (unsigned char const *)(k));
  return tmp;
}

static u64 R(u64 x, int c)
{
  u64 __retres;
  __retres = (x >> c) | (x << (64 - c));
  return __retres;
}

static u64 Ch(u64 x, u64 y, u64 z)
{
  u64 __retres;
  __retres = (x & y) ^ (~ x & z);
  return __retres;
}

static u64 Maj(u64 x, u64 y, u64 z)
{
  u64 __retres;
  __retres = ((x & y) ^ (x & z)) ^ (y & z);
  return __retres;
}

static u64 Sigma0(u64 x)
{
  u64 __retres;
  u64 tmp;
  u64 tmp_0;
  u64 tmp_1;
  tmp = R(x,28);
  tmp_0 = R(x,34);
  tmp_1 = R(x,39);
  __retres = (tmp ^ tmp_0) ^ tmp_1;
  return __retres;
}

static u64 Sigma1(u64 x)
{
  u64 __retres;
  u64 tmp;
  u64 tmp_0;
  u64 tmp_1;
  tmp = R(x,14);
  tmp_0 = R(x,18);
  tmp_1 = R(x,41);
  __retres = (tmp ^ tmp_0) ^ tmp_1;
  return __retres;
}

static u64 sigma0(u64 x)
{
  u64 __retres;
  u64 tmp;
  u64 tmp_0;
  tmp = R(x,1);
  tmp_0 = R(x,8);
  ;
  __retres = (tmp ^ tmp_0) ^ (x >> 7);
  return __retres;
}

static u64 sigma1(u64 x)
{
  u64 __retres;
  u64 tmp;
  u64 tmp_0;
  tmp = R(x,19);
  tmp_0 = R(x,61);
  ;
  __retres = (tmp ^ tmp_0) ^ (x >> 6);
  return __retres;
}

static u64 const K[80] =
  {0x428a2f98d728ae22ULL,
   0x7137449123ef65cdULL,
   0xb5c0fbcfec4d3b2fULL,
   0xe9b5dba58189dbbcULL,
   0x3956c25bf348b538ULL,
   0x59f111f1b605d019ULL,
   0x923f82a4af194f9bULL,
   0xab1c5ed5da6d8118ULL,
   0xd807aa98a3030242ULL,
   0x12835b0145706fbeULL,
   0x243185be4ee4b28cULL,
   0x550c7dc3d5ffb4e2ULL,
   0x72be5d74f27b896fULL,
   0x80deb1fe3b1696b1ULL,
   0x9bdc06a725c71235ULL,
   0xc19bf174cf692694ULL,
   0xe49b69c19ef14ad2ULL,
   0xefbe4786384f25e3ULL,
   0x0fc19dc68b8cd5b5ULL,
   0x240ca1cc77ac9c65ULL,
   0x2de92c6f592b0275ULL,
   0x4a7484aa6ea6e483ULL,
   0x5cb0a9dcbd41fbd4ULL,
   0x76f988da831153b5ULL,
   0x983e5152ee66dfabULL,
   0xa831c66d2db43210ULL,
   0xb00327c898fb213fULL,
   0xbf597fc7beef0ee4ULL,
   0xc6e00bf33da88fc2ULL,
   0xd5a79147930aa725ULL,
   0x06ca6351e003826fULL,
   0x142929670a0e6e70ULL,
   0x27b70a8546d22ffcULL,
   0x2e1b21385c26c926ULL,
   0x4d2c6dfc5ac42aedULL,
   0x53380d139d95b3dfULL,
   0x650a73548baf63deULL,
   0x766a0abb3c77b2a8ULL,
   0x81c2c92e47edaee6ULL,
   0x92722c851482353bULL,
   0xa2bfe8a14cf10364ULL,
   0xa81a664bbc423001ULL,
   0xc24b8b70d0f89791ULL,
   0xc76c51a30654be30ULL,
   0xd192e819d6ef5218ULL,
   0xd69906245565a910ULL,
   0xf40e35855771202aULL,
   0x106aa07032bbd1b8ULL,
   0x19a4c116b8d2d0c8ULL,
   0x1e376c085141ab53ULL,
   0x2748774cdf8eeb99ULL,
   0x34b0bcb5e19b48a8ULL,
   0x391c0cb3c5c95a63ULL,
   0x4ed8aa4ae3418acbULL,
   0x5b9cca4f7763e373ULL,
   0x682e6ff3d6b2b8a3ULL,
   0x748f82ee5defb2fcULL,
   0x78a5636f43172f60ULL,
   0x84c87814a1f0ab72ULL,
   0x8cc702081a6439ecULL,
   0x90befffa23631e28ULL,
   0xa4506cebde82bde9ULL,
   0xbef9a3f7b2c67915ULL,
   0xc67178f2e372532bULL,
   0xca273eceea26619cULL,
   0xd186b8c721c0c207ULL,
   0xeada7dd6cde0eb1eULL,
   0xf57d4f7fee6ed178ULL,
   0x06f067aa72176fbaULL,
   0x0a637dc5a2c898a6ULL,
   0x113f9804bef90daeULL,
   0x1b710b35131c471bULL,
   0x28db77f523047d84ULL,
   0x32caab7b40c72493ULL,
   0x3c9ebe0a15c9bebcULL,
   0x431d67c49c100d4cULL,
   0x4cc5d4becb3e42b6ULL,
   0x597f299cfc657e2aULL,
   0x5fcb6fab3ad6faecULL,
   0x6c44198c4a475817ULL};
int crypto_hashblocks_sha512_tweet(unsigned char *x, unsigned char const *m,
                                   unsigned long long n)
{
  int __retres;
  u64 z[8];
  u64 b[8];
  u64 a[8];
  u64 w[16];
  u64 t;
  int i;
  int j;
  i = 0;
  while (i < 8) {
    u64 tmp;
    tmp = dl64((u8 const *)(x + 8 * i));
    a[i] = tmp;
    z[i] = tmp;
    i ++;
  }
  while (n >= (unsigned long long)128) {
    i = 0;
    while (i < 16) {
      w[i] = dl64(m + 8 * i);
      i ++;
    }
    i = 0;
    while (i < 80) {
      {
        u64 tmp_0;
        u64 tmp_1;
        u64 tmp_2;
        u64 tmp_3;
        j = 0;
        while (j < 8) {
          b[j] = a[j];
          j ++;
        }
        tmp_0 = Sigma1(a[4]);
        tmp_1 = Ch(a[4],a[5],a[6]);
        t = (((a[7] + tmp_0) + tmp_1) + K[i]) + w[i % 16];
        tmp_2 = Sigma0(a[0]);
        tmp_3 = Maj(a[0],a[1],a[2]);
        b[7] = (t + tmp_2) + tmp_3;
        b[3] += t;
        j = 0;
        while (j < 8) {
          a[(j + 1) % 8] = b[j];
          j ++;
        }
        if (i % 16 == 15) {
          j = 0;
          while (j < 16) {
            u64 tmp_4;
            u64 tmp_5;
            tmp_4 = sigma0(w[(j + 1) % 16]);
            tmp_5 = sigma1(w[(j + 14) % 16]);
            w[j] += (w[(j + 9) % 16] + tmp_4) + tmp_5;
            j ++;
          }
        }
      }
      i ++;
    }
    i = 0;
    while (i < 8) {
      a[i] += z[i];
      z[i] = a[i];
      i ++;
    }
    m += 128;
    n -= (unsigned long long)128;
  }
  i = 0;
  while (i < 8) {
    ts64(x + 8 * i,z[i]);
    i ++;
  }
  __retres = (int)n;
  return __retres;
}

static u8 const iv[64] =
  {(u8)0x6a,
   (u8)0x09,
   (u8)0xe6,
   (u8)0x67,
   (u8)0xf3,
   (u8)0xbc,
   (u8)0xc9,
   (u8)0x08,
   (u8)0xbb,
   (u8)0x67,
   (u8)0xae,
   (u8)0x85,
   (u8)0x84,
   (u8)0xca,
   (u8)0xa7,
   (u8)0x3b,
   (u8)0x3c,
   (u8)0x6e,
   (u8)0xf3,
   (u8)0x72,
   (u8)0xfe,
   (u8)0x94,
   (u8)0xf8,
   (u8)0x2b,
   (u8)0xa5,
   (u8)0x4f,
   (u8)0xf5,
   (u8)0x3a,
   (u8)0x5f,
   (u8)0x1d,
   (u8)0x36,
   (u8)0xf1,
   (u8)0x51,
   (u8)0x0e,
   (u8)0x52,
   (u8)0x7f,
   (u8)0xad,
   (u8)0xe6,
   (u8)0x82,
   (u8)0xd1,
   (u8)0x9b,
   (u8)0x05,
   (u8)0x68,
   (u8)0x8c,
   (u8)0x2b,
   (u8)0x3e,
   (u8)0x6c,
   (u8)0x1f,
   (u8)0x1f,
   (u8)0x83,
   (u8)0xd9,
   (u8)0xab,
   (u8)0xfb,
   (u8)0x41,
   (u8)0xbd,
   (u8)0x6b,
   (u8)0x5b,
   (u8)0xe0,
   (u8)0xcd,
   (u8)0x19,
   (u8)0x13,
   (u8)0x7e,
   (u8)0x21,
   (u8)0x79};
int crypto_hash_sha512_tweet(unsigned char *out, unsigned char const *m,
                             unsigned long long n)
{
  int __retres;
  u8 h[64];
  u8 x[256];
  u64 i;
  u64 b = n;
  i = (u64)0;
  while (i < (u64)64) {
    h[i] = iv[i];
    i ++;
  }
  crypto_hashblocks_sha512_tweet(h,m,n);
  m += n;
  n &= (unsigned long long)127;
  m -= n;
  i = (u64)0;
  while (i < (u64)256) {
    x[i] = (u8)0;
    i ++;
  }
  i = (u64)0;
  while (i < n) {
    x[i] = *(m + i);
    i ++;
  }
  x[n] = (u8)128;
  n = (unsigned long long)(256 - 128 * (n < (unsigned long long)112));
  x[n - (unsigned long long)9] = (u8)(b >> 61);
  ts64(& x[n] - 8,b << 3);
  crypto_hashblocks_sha512_tweet(h,(unsigned char const *)(x),n);
  i = (u64)0;
  while (i < (u64)64) {
    *(out + i) = h[i];
    i ++;
  }
  __retres = 0;
  return __retres;
}

static void add(gf p[4], gf q[4])
{
  gf a;
  gf b;
  gf c;
  gf d;
  gf t;
  gf e;
  gf f;
  gf g;
  gf h;
  Z(a,(i64 const *)(*(p + 1)),(i64 const *)(*(p + 0)));
  Z(t,(i64 const *)(*(q + 1)),(i64 const *)(*(q + 0)));
  M(a,(i64 const *)(a),(i64 const *)(t));
  A(b,(i64 const *)(*(p + 0)),(i64 const *)(*(p + 1)));
  A(t,(i64 const *)(*(q + 0)),(i64 const *)(*(q + 1)));
  M(b,(i64 const *)(b),(i64 const *)(t));
  M(c,(i64 const *)(*(p + 3)),(i64 const *)(*(q + 3)));
  M(c,(i64 const *)(c),D2);
  M(d,(i64 const *)(*(p + 2)),(i64 const *)(*(q + 2)));
  A(d,(i64 const *)(d),(i64 const *)(d));
  Z(e,(i64 const *)(b),(i64 const *)(a));
  Z(f,(i64 const *)(d),(i64 const *)(c));
  A(g,(i64 const *)(d),(i64 const *)(c));
  A(h,(i64 const *)(b),(i64 const *)(a));
  M(*(p + 0),(i64 const *)(e),(i64 const *)(f));
  M(*(p + 1),(i64 const *)(h),(i64 const *)(g));
  M(*(p + 2),(i64 const *)(g),(i64 const *)(f));
  M(*(p + 3),(i64 const *)(e),(i64 const *)(h));
  return;
}

static void cswap(gf p[4], gf q[4], u8 b)
{
  int i;
  i = 0;
  while (i < 4) {
    sel25519(*(p + i),*(q + i),(int)b);
    i ++;
  }
  return;
}

static void pack(u8 *r, gf p[4])
{
  gf tx;
  gf ty;
  gf zi;
  u8 tmp;
  inv25519(zi,(i64 const *)(*(p + 2)));
  M(tx,(i64 const *)(*(p + 0)),(i64 const *)(zi));
  M(ty,(i64 const *)(*(p + 1)),(i64 const *)(zi));
  pack25519(r,(i64 const *)(ty));
  tmp = par25519((i64 const *)(tx));
  *(r + 31) = (u8)((int)*(r + 31) ^ ((int)tmp << 7));
  return;
}

static void scalarmult(gf p[4], gf q[4], u8 const *s)
{
  int i;
  set25519(*(p + 0),gf0);
  set25519(*(p + 1),gf1);
  set25519(*(p + 2),gf1);
  set25519(*(p + 3),gf0);
  i = 255;
  while (i >= 0) {
    {
      u8 b = (u8)(((int)*(s + i / 8) >> (i & 7)) & 1);
      cswap(p,q,b);
      add(q,p);
      add(p,p);
      cswap(p,q,b);
    }
    i --;
  }
  return;
}

static void scalarbase(gf p[4], u8 const *s)
{
  gf q[4];
  set25519(q[0],X);
  set25519(q[1],Y);
  set25519(q[2],gf1);
  M(q[3],X,Y);
  scalarmult(p,q,s);
  return;
}

int crypto_sign_ed25519_tweet_keypair(unsigned char *pk, unsigned char *sk)
{
  int __retres;
  u8 d[64];
  gf p[4];
  int i;
  randombytes(sk,(u64)32);
  crypto_hash_sha512_tweet(d,(unsigned char const *)sk,
                           (unsigned long long)32);
  d[0] = (u8)((int)d[0] & 248);
  d[31] = (u8)((int)d[31] & 127);
  d[31] = (u8)((int)d[31] | 64);
  scalarbase(p,(u8 const *)(d));
  pack(pk,p);
  i = 0;
  while (i < 32) {
    *(sk + (32 + i)) = *(pk + i);
    i ++;
  }
  __retres = 0;
  return __retres;
}

static u64 const L[32] =
  {(u64)0xed,
   (u64)0xd3,
   (u64)0xf5,
   (u64)0x5c,
   (u64)0x1a,
   (u64)0x63,
   (u64)0x12,
   (u64)0x58,
   (u64)0xd6,
   (u64)0x9c,
   (u64)0xf7,
   (u64)0xa2,
   (u64)0xde,
   (u64)0xf9,
   (u64)0xde,
   (u64)0x14,
   (u64)0,
   (u64)0,
   (u64)0,
   (u64)0,
   (u64)0,
   (u64)0,
   (u64)0,
   (u64)0,
   (u64)0,
   (u64)0,
   (u64)0,
   (u64)0,
   (u64)0,
   (u64)0,
   (u64)0,
   (u64)0x10};
static void modL(u8 *r, i64 x[64])
{
  i64 carry;
  i64 i;
  i64 j;
  i = (i64)63;
  while (i >= (i64)32) {
    carry = (i64)0;
    j = i - (i64)32;
    while (j < i - (i64)12) {
      *(x + j) = (i64)((u64)*(x + j) + ((u64)carry - (u64)((i64)16 * *(x + i)) * L[
                                                     j - (i - (i64)32)]));
      carry = (*(x + j) + (i64)128) >> 8;
      *(x + j) -= carry << 8;
      j ++;
    }
    *(x + j) += carry;
    *(x + i) = (i64)0;
    i --;
  }
  carry = (i64)0;
  j = (i64)0;
  while (j < (i64)32) {
    *(x + j) = (i64)((u64)*(x + j) + ((u64)carry - (u64)(*(x + 31) >> 4) * L[j]));
    carry = *(x + j) >> 8;
    *(x + j) &= (long long)255;
    j ++;
  }
  j = (i64)0;
  while (j < (i64)32) {
    *(x + j) = (i64)((u64)*(x + j) - (u64)carry * L[j]);
    j ++;
  }
  i = (i64)0;
  while (i < (i64)32) {
    *(x + (i + (i64)1)) += *(x + i) >> 8;
    *(r + i) = (u8)(*(x + i) & (long long)255);
    i ++;
  }
  return;
}

static void reduce(u8 *r)
{
  i64 x[64];
  i64 i;
  i = (i64)0;
  while (i < (i64)64) {
    x[i] = (i64)((u64)*(r + i));
    i ++;
  }
  i = (i64)0;
  while (i < (i64)64) {
    *(r + i) = (u8)0;
    i ++;
  }
  modL(r,x);
  return;
}

int crypto_sign_ed25519_tweet(unsigned char *sm, unsigned long long *smlen,
                              unsigned char const *m, unsigned long long n,
                              unsigned char const *sk)
{
  int __retres;
  u8 d[64];
  u8 h[64];
  u8 r[64];
  i64 i;
  i64 j;
  i64 x[64];
  gf p[4];
  crypto_hash_sha512_tweet(d,sk,(unsigned long long)32);
  d[0] = (u8)((int)d[0] & 248);
  d[31] = (u8)((int)d[31] & 127);
  d[31] = (u8)((int)d[31] | 64);
  *smlen = n + (unsigned long long)64;
  i = (i64)0;
  while ((unsigned long long)i < n) {
    *(sm + ((i64)64 + i)) = *(m + i);
    i ++;
  }
  i = (i64)0;
  while (i < (i64)32) {
    *(sm + ((i64)32 + i)) = d[(i64)32 + i];
    i ++;
  }
  crypto_hash_sha512_tweet(r,(unsigned char const *)(sm + 32),
                           n + (unsigned long long)32);
  reduce(r);
  scalarbase(p,(u8 const *)(r));
  pack(sm,p);
  i = (i64)0;
  while (i < (i64)32) {
    *(sm + (i + (i64)32)) = *(sk + (i + (i64)32));
    i ++;
  }
  crypto_hash_sha512_tweet(h,(unsigned char const *)sm,
                           n + (unsigned long long)64);
  reduce(h);
  i = (i64)0;
  while (i < (i64)64) {
    x[i] = (i64)0;
    i ++;
  }
  i = (i64)0;
  while (i < (i64)32) {
    x[i] = (i64)((u64)r[i]);
    i ++;
  }
  i = (i64)0;
  while (i < (i64)32) {
    j = (i64)0;
    while (j < (i64)32) {
      x[i + j] = (i64)((u64)x[i + j] + (u64)h[i] * (u64)d[j]);
      j ++;
    }
    i ++;
  }
  modL(sm + 32,x);
  __retres = 0;
  return __retres;
}

static int unpackneg(gf r[4], u8 const p[32])
{
  int __retres;
  gf t;
  gf chk;
  gf num;
  gf den;
  gf den2;
  gf den4;
  gf den6;
  int tmp;
  int tmp_0;
  u8 tmp_1;
  set25519(*(r + 2),gf1);
  unpack25519(*(r + 1),p);
  S(num,(i64 const *)(*(r + 1)));
  M(den,(i64 const *)(num),D);
  Z(num,(i64 const *)(num),(i64 const *)(*(r + 2)));
  A(den,(i64 const *)(*(r + 2)),(i64 const *)(den));
  S(den2,(i64 const *)(den));
  S(den4,(i64 const *)(den2));
  M(den6,(i64 const *)(den4),(i64 const *)(den2));
  M(t,(i64 const *)(den6),(i64 const *)(num));
  M(t,(i64 const *)(t),(i64 const *)(den));
  pow2523(t,(i64 const *)(t));
  M(t,(i64 const *)(t),(i64 const *)(num));
  M(t,(i64 const *)(t),(i64 const *)(den));
  M(t,(i64 const *)(t),(i64 const *)(den));
  M(*(r + 0),(i64 const *)(t),(i64 const *)(den));
  S(chk,(i64 const *)(*(r + 0)));
  M(chk,(i64 const *)(chk),(i64 const *)(den));
  tmp = neq25519((i64 const *)(chk),(i64 const *)(num));
  if (tmp) M(*(r + 0),(i64 const *)(*(r + 0)),I);
  S(chk,(i64 const *)(*(r + 0)));
  M(chk,(i64 const *)(chk),(i64 const *)(den));
  tmp_0 = neq25519((i64 const *)(chk),(i64 const *)(num));
  if (tmp_0) {
    __retres = -1;
    goto return_label;
  }
  tmp_1 = par25519((i64 const *)(*(r + 0)));
  ;
  if ((int)tmp_1 == (int)*(p + 31) >> 7) Z(*(r + 0),gf0,
                                           (i64 const *)(*(r + 0)));
  M(*(r + 3),(i64 const *)(*(r + 0)),(i64 const *)(*(r + 1)));
  __retres = 0;
  return_label: return __retres;
}

int crypto_sign_ed25519_tweet_open(unsigned char *m,
                                   unsigned long long *mlen,
                                   unsigned char const *sm,
                                   unsigned long long n,
                                   unsigned char const *pk)
{
  int __retres;
  int i;
  u8 t[32];
  u8 h[64];
  gf p[4];
  gf q[4];
  int tmp;
  int tmp_0;
  *mlen = (unsigned long long)(-1);
  if (n < (unsigned long long)64) {
    __retres = -1;
    goto return_label;
  }
  tmp = unpackneg(q,pk);
  if (tmp) {
    __retres = -1;
    goto return_label;
  }
  i = 0;
  while ((unsigned long long)i < n) {
    *(m + i) = *(sm + i);
    i ++;
  }
  i = 0;
  while (i < 32) {
    *(m + (i + 32)) = *(pk + i);
    i ++;
  }
  crypto_hash_sha512_tweet(h,(unsigned char const *)m,n);
  reduce(h);
  scalarmult(p,q,(u8 const *)(h));
  scalarbase(q,sm + 32);
  add(p,q);
  pack(t,p);
  n -= (unsigned long long)64;
  tmp_0 = crypto_verify_32_tweet(sm,(unsigned char const *)(t));
  if (tmp_0) {
    i = 0;
    while ((unsigned long long)i < n) {
      *(m + i) = (unsigned char)0;
      i ++;
    }
    __retres = -1;
    goto return_label;
  }
  i = 0;
  while ((unsigned long long)i < n) {
    *(m + i) = *(sm + (i + 64));
    i ++;
  }
  *mlen = n;
  __retres = 0;
  return_label: return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_1(FILE * restrict stream, char const * restrict format);

void randombytes(unsigned char *ptr, unsigned long long length)
{
  char failed = (char)0;
  FILE *fh = fopen("/dev/urandom","rb");
  if (fh != (FILE *)0) {
    size_t tmp_0;
    tmp_0 = fread((void *)ptr,(size_t)length,(size_t)1,fh);
    if (tmp_0 == (size_t)0) failed = (char)1;
    fclose(fh);
  }
  else failed = (char)1;
  if (failed) {
    fprintf(__fc_stderr,
            "Generating random data failed. Please report this to https://github.com/ultramancool\n"); /* fprintf_va_1 */
    exit(1);
  }
  return;
}


