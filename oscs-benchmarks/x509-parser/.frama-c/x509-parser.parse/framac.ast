/* Generated by Frama-C */
#include "__fc_builtin.h"
#include "stdint.h"
#include "string.h"
#include "strings.h"
#include "unistd.h"
typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
enum __anonenum_tag_class_1 {
    CLASS_UNIVERSAL = 0x00,
    CLASS_APPLICATION = 0x01,
    CLASS_CONTEXT_SPECIFIC = 0x02,
    CLASS_PRIVATE = 0x03
};
typedef enum __anonenum_tag_class_1 tag_class;
enum __anonenum_asn1_type_2 {
    ASN1_TYPE_INTEGER = 0x02,
    ASN1_TYPE_BIT_STRING = 0x03,
    ASN1_TYPE_OCTET_STRING = 0x04,
    ASN1_TYPE_NULL = 0x05,
    ASN1_TYPE_OID = 0x06,
    ASN1_TYPE_SEQUENCE = 0x10,
    ASN1_TYPE_SET = 0x11,
    ASN1_TYPE_PrintableString = 0x13,
    ASN1_TYPE_T61String = 0x14,
    ASN1_TYPE_IA5String = 0x16,
    ASN1_TYPE_UTCTime = 0x17,
    ASN1_TYPE_GeneralizedTime = 0x18
};
struct __anonstruct__curve_3 {
   u8 const *crv_name ;
   u8 const *crv_printable_oid ;
   u8 const *crv_der_oid ;
   u8 const crv_der_oid_len ;
   u16 const crv_order_bit_len ;
};
typedef struct __anonstruct__curve_3 _curve;
struct __anonstruct_alg_param_4 {
   _curve const *curve_param ;
   u8 const *null_param ;
   int ecdsa_no_param ;
   int unparsed_param ;
};
typedef struct __anonstruct_alg_param_4 alg_param;
struct __anonstruct__alg_id_5 {
   u8 const *alg_name ;
   u8 const *alg_printable_oid ;
   u8 const *alg_der_oid ;
   u8 const alg_der_oid_len ;
   u8 const alg_type ;
   int (*parse_sig)(u8 const *buf, u16 len, u16 *eaten) ;
   int (*parse_subjectpubkey)(u8 const *buf, u16 len, alg_param *param) ;
   int (*parse_algoid_params)(u8 const *buf, u16 len, alg_param *param) ;
};
typedef struct __anonstruct__alg_id_5 _alg_id;
enum __anonenum_alg_types_6 {
    ALG_INVALID = 0x00,
    ALG_SIG = 0x01,
    ALG_PUBKEY = 0x02
};
struct __anonstruct__name_oid_7 {
   u8 const *oid ;
   u8 oid_len ;
   int (*parse_rdn_val)(u8 const *buf, u16 len) ;
};
typedef struct __anonstruct__name_oid_7 _name_oid;
struct __anonstruct_cert_parsing_ctx_8 {
   int empty_subject ;
   int san_empty ;
   int san_critical ;
   int ca_true ;
   int bc_critical ;
   int has_ski ;
   int has_keyUsage ;
   int keyCertSign_set ;
   int cRLSign_set ;
   int pathLenConstraint_set ;
   int has_name_constraints ;
   int has_crldp ;
   int one_crldp_has_all_reasons ;
   int aki_has_keyIdentifier ;
   int self_signed ;
};
typedef struct __anonstruct_cert_parsing_ctx_8 cert_parsing_ctx;
struct __anonstruct__kp_oid_9 {
   u8 const *oid ;
   u8 oid_len ;
};
typedef struct __anonstruct__kp_oid_9 _kp_oid;
struct __anonstruct__ext_oid_10 {
   u8 const *oid ;
   u8 oid_len ;
   int (*parse_ext_params)(u8 const *buf, u16 len, int critical,
                           cert_parsing_ctx *ctx) ;
};
typedef struct __anonstruct__ext_oid_10 _ext_oid;
int parse_x509_cert(u8 const *buf, u16 len);

int parse_x509_cert_relaxed(u8 const *buf, u16 len, u16 *eaten);

/*@
predicate bmatch{L}(u8 *b1, u8 *b2, u16 n) =
  \at(∀ ℤ i; 0 ≤ i < n ⇒ *(b1 + i) ≡ *(b2 + i),L);
 */
/*@ predicate bdiffer{L}(u8 *b1, u8 *b2, u16 n) = \at(¬bmatch(b1, b2, n),L);

*/
/*@ requires \valid_read(b1 + (0 .. n - 1));
    requires \valid_read(b2 + (0 .. n - 1));
    assigns \nothing;
 */
static int bufs_differ(u8 const *b1, u8 const *b2, u16 n)
{
  int ret = 0;
  u16 i = (u16)0;
  i = (u16)0;
  /*@ loop invariant 0 ≤ i ≤ n;
      loop invariant bmatch(b1, b2, i);
      loop assigns i;
  */
  while ((int)i < (int)n) {
    if ((int)*(b1 + i) != (int)*(b2 + i)) {
      ret = 1;
      break;
    }
    i = (u16)((int)i + 1);
  }
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \separated(tag_num, eaten, buf + (..));
    requires \valid(tag_num);
    requires \valid(eaten);
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    ensures \result ≡ 0 ⇒ 1 ≤ *\old(eaten) ≤ \old(len);
    ensures \result ≡ 0 ⇒ *\old(eaten) ≤ \old(len);
    ensures \result ≡ 0 ⇒ *\old(eaten) > 0;
    assigns *tag_num, *eaten;
 */
static int _extract_complex_tag(u8 const *buf, u16 len, u32 *tag_num,
                                u16 *eaten)
{
  u16 rbytes;
  int ret;
  u32 t = (u32)0;
  if ((int)len == 0) goto _LOR;
  else 
    if (buf == (u8 const *)0) {
      _LOR: {
              ret = -109;
              goto out;
            }
    }
  if ((int)len > 4) len = (u16)4;
  rbytes = (u16)0;
  /*@ loop invariant 0 ≤ rbytes ≤ len;
      loop invariant t ≤ (1 << (u32)(7 * rbytes)) - 1;
      loop invariant
        ∀ ℤ x; 0 ≤ x < rbytes ⇒ (*(buf + x) & 0x80) ≢ 0;
      loop assigns rbytes, t;
      loop variant len - rbytes;
  */
  while ((int)rbytes < (int)len) {
    {
      u32 tmp1;
      u32 tmp2;
      /*@ assert rbytes ≤ 3; */ ;
      /*@ assert t ≤ (1 << (u32)(7 * rbytes)) - 1; */ ;
      /*@ assert t ≤ (u32)0x1fffff; */ ;
      tmp1 = t << (u32)7;
      tmp2 = (u32)*(buf + rbytes) & (u32)0x7f;
      /*@ assert tmp1 ≤ (u32)0xfffff80; */ ;
      /*@ assert tmp2 ≤ (u32)0x7f; */ ;
      t = tmp1 + tmp2;
      /*@ assert t ≤ (1 << (u32)(7 * (rbytes + 1))) - 1; */ ;
      /*@ assert t ≤ 0xfffffff; */ ;
      if (((int)*(buf + rbytes) & 0x80) == 0) break;
    }
    rbytes = (u16)((int)rbytes + 1);
  }
  if ((int)rbytes == (int)len) {
    /*@ assert (*(buf + (len - 1)) & 0x80) ≢ 0; */ ;
    ret = -147;
    goto out;
  }
  if (t < (u32)0x1f) {
    ret = -153;
    goto out;
  }
  *tag_num = t;
  *eaten = (u16)((int)rbytes + 1);
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \separated(cls, prim, tag_num, eaten, buf + (..));
    requires \valid(cls);
    requires \valid(prim);
    requires \valid(tag_num);
    requires \valid(eaten);
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \result ≡ 0 ⇒ 0 < *\old(eaten) ≤ \old(len);
    ensures \result ≡ 0 ⇒ *\old(cls) ≤ 0x3;
    ensures \result ≡ 0 ⇒ *\old(prim) ≤ 0x1;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *tag_num, *eaten, *prim, *cls;
 */
static int get_identifier(u8 const *buf, u16 len, tag_class *cls, u8 *prim,
                          u32 *tag_num, u16 *eaten)
{
  int ret;
  u32 t;
  u8 p;
  tag_class c;
  u16 rbytes = (u16)0;
  if (buf == (u8 const *)0) {
    ret = -207;
    goto out;
  }
  if ((int)len == 0) {
    ret = -218;
    goto out;
  }
  c = (tag_class)(((int)*(buf + 0) >> 6) & 0x03);
  p = (u8)(((int)*(buf + 0) >> 5) & 0x01);
  t = (u32)((int)*(buf + 0) & 0x1f);
  rbytes = (u16)1;
  switch (c) {
    case CLASS_UNIVERSAL: case CLASS_APPLICATION:
    case CLASS_CONTEXT_SPECIFIC: case CLASS_PRIVATE:
    break;
    default: ret = -241;
    goto out;
    break;
  }
  if (t == (u32)0x1f) {
    u16 tag_len = (u16)0;
    /*@
    assert
    len ≥ rbytes ∧ len - rbytes ≤ 65535 ∧
    \valid_read(buf + (rbytes .. len - 1)); */
    ;
    ret = _extract_complex_tag(buf + (int)rbytes,
                               (u16)((int)len - (int)rbytes),& t,& tag_len);
    if (ret) goto out;
    rbytes = (u16)((int)rbytes + (int)tag_len);
  }
  *cls = c;
  *prim = p;
  *tag_num = t;
  *eaten = rbytes;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \separated(adv_len, eaten, buf + (..));
    requires \valid(adv_len);
    requires \valid(eaten);
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \result ≡ 0 ⇒ 0 < *\old(eaten) ≤ \old(len);
    ensures \result ≡ 0 ⇒ *\old(adv_len) ≤ \old(len);
    ensures \result ≡ 0 ⇒ *\old(adv_len) + *\old(eaten) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *adv_len, *eaten;
 */
static int get_length(u8 const *buf, u16 len, u16 *adv_len, u16 *eaten)
{
  u16 l;
  u8 len_len;
  u8 b0;
  int ret;
  u16 rbytes = (u16)0;
  if (buf == (u8 const *)0) {
    ret = -312;
    goto out;
  }
  if ((int)len == 0) {
    ret = -318;
    goto out;
  }
  /*@ assert \valid_read(buf + 0); */ ;
  b0 = *(buf + 0);
  if (((int)b0 & 0x80) == 0) {
    l = (u16)((int)b0 & 0x7f);
    /*@ assert l ≤ 0x7f; */ ;
    if ((int)l + 1 > (int)len) {
      ret = -338;
      goto out;
    }
    *eaten = (u16)1;
    *adv_len = l;
    /*@ assert *eaten + *adv_len ≤ len; */ ;
    ret = 0;
    goto out;
  }
  if ((int)b0 == 0x80) {
    ret = -357;
    goto out;
  }
  len_len = (u8)((int)b0 & 0x7f);
  /*@ assert len_len ≤ 0x7f; */ ;
  rbytes = (u16)((int)rbytes + 1);
  /*@ assert rbytes > 0; */ ;
  if ((int)len_len + 1 > (int)len) {
    ret = -378;
    goto out;
  }
  switch ((int)len_len) {
    case 0: ret = -387;
    goto out;
    break;
    case 1: l = (u16)*(buf + 1);
    if ((int)l <= 127) {
      ret = -400;
      goto out;
    }
    /*@ assert 127 < l; */ ;
    rbytes = (u16)((int)rbytes + 1);
    break;
    case 2: l = (u16)((int)((u16)*(buf + 1)) * 256 + (int)*(buf + 2));
    if ((int)l <= 0xff) {
      ret = -413;
      goto out;
    }
    /*@ assert 0xff < l ≤ 0xffff; */ ;
    rbytes = (u16)((int)rbytes + 2);
    break;
    default: ret = -428;
    goto out;
    break;
  }
  /*@ assert l > 127; */ ;
  /*@ assert len ≥ rbytes; */ ;
  if ((int)len - (int)rbytes < (int)l) {
    ret = -437;
    goto out;
  }
  /*@ assert rbytes + l ≤ len; */ ;
  /*@ assert rbytes > 0; */ ;
  *eaten = rbytes;
  *adv_len = l;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(parsed);
    requires \valid(content_len);
    requires \separated(parsed, content_len, buf + (..));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \result ≡ 0 ⇒ 1 < *\old(parsed) ≤ \old(len);
    ensures \result ≡ 0 ⇒ *\old(content_len) ≤ \old(len);
    ensures
      \result ≡ 0 ⇒ *\old(content_len) + *\old(parsed) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *parsed, *content_len;
 */
static int parse_id_len(u8 const *buf, u16 len, tag_class exp_class,
                        u32 exp_type, u16 *parsed, u16 *content_len)
{
  u8 p;
  u16 grabbed;
  int ret;
  tag_class c = (tag_class)0;
  u32 t = (u32)0;
  u16 cur_parsed = (u16)0;
  u16 adv_len = (u16)0;
  if (buf == (u8 const *)0) {
    ret = -509;
    goto out;
  }
  if ((int)len > 65534) {
    ret = -516;
    goto out;
  }
  ret = get_identifier(buf,len,& c,& p,& t,& cur_parsed);
  if (ret) goto out;
  /*@ assert cur_parsed > 0; */ ;
  if (t != exp_type) {
    ret = -534;
    goto out;
  }
  if (c != exp_class) {
    ret = -541;
    goto out;
  }
  grabbed = cur_parsed;
  /*@ assert grabbed > 0; */ ;
  len = (u16)((int)len - (int)cur_parsed);
  buf += (int)cur_parsed;
  ret = get_length(buf,len,& adv_len,& cur_parsed);
  if (ret) goto out;
  /*@ assert cur_parsed > 0; */ ;
  grabbed = (u16)((int)grabbed + (int)cur_parsed);
  /*@ assert grabbed > 1; */ ;
  len = (u16)((int)len - (int)cur_parsed);
  buf += (int)cur_parsed;
  if ((int)adv_len > (int)len) {
    ret = -566;
    goto out;
  }
  *parsed = grabbed;
  /*@ assert *parsed > 1; */ ;
  *content_len = adv_len;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(parsed);
    requires \valid(data_len);
    requires \separated(parsed, data_len, buf + (..));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \result ≡ 0 ⇒ *\old(parsed) ≤ \old(len);
    ensures \result ≡ 0 ⇒ *\old(data_len) ≤ \old(len);
    ensures \result ≡ 0 ⇒ *\old(data_len) + *\old(parsed) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *parsed, *data_len;
 */
static int parse_explicit_id_len(u8 const *buf, u16 len, u32 exp_ext_type,
                                 tag_class exp_int_class, u32 exp_int_type,
                                 u16 *parsed, u16 *data_len)
{
  int ret;
  u16 hdr_len = (u16)0;
  u16 val_len = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -614;
              goto out;
            }
    }
  ret = parse_id_len(buf,len,CLASS_CONTEXT_SPECIFIC,exp_ext_type,& hdr_len,
                     & val_len);
  if (ret) goto out;
  buf += (int)hdr_len;
  len = (u16)((int)len - (int)hdr_len);
  *parsed = hdr_len;
  ret = parse_id_len(buf,len,exp_int_class,exp_int_type,& hdr_len,& val_len);
  if (ret) goto out;
  len = (u16)((int)len - (int)hdr_len);
  *parsed = (u16)((int)*parsed + (int)hdr_len);
  if ((int)len < (int)val_len) {
    ret = -642;
    goto out;
  }
  *data_len = val_len;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(arc_val);
    requires \valid(eaten);
    requires \separated(arc_val, eaten, buf + (..));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \result ≡ 0 ⇒ *\old(eaten) ≤ \old(len);
    ensures \result ≡ 0 ⇒ *\old(eaten) > 0;
    ensures
      \old(len) > 0 ∧ \old(buf) ≢ \null ∧ \result ≢ 0 ⇒
      (∀ ℤ x;
         0 ≤ x < \min(\old(len), 4) ⇒ (*(\old(buf) + x) & 0x80) ≢ 0);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    assigns *arc_val, *eaten;
 */
static int _parse_arc(u8 const *buf, u16 len, u32 *arc_val, u16 *eaten)
{
  u16 rbytes;
  int ret;
  u32 av = (u32)0;
  if ((int)len == 0) goto _LOR;
  else 
    if (buf == (u8 const *)0) {
      _LOR: {
              ret = -679;
              goto out;
            }
    }
  if ((int)len > 4) len = (u16)4;
  rbytes = (u16)0;
  /*@ loop invariant 0 ≤ rbytes ≤ len;
      loop invariant av ≤ (1 << (u32)(7 * rbytes)) - 1;
      loop invariant
        ∀ ℤ x; 0 ≤ x < rbytes ⇒ (*(buf + x) & 0x80) ≢ 0;
      loop assigns rbytes, av;
      loop variant len - rbytes;
  */
  while ((int)rbytes < (int)len) {
    {
      u32 tmp1;
      u32 tmp2;
      /*@ assert rbytes ≤ 3; */ ;
      /*@ assert av ≤ (1 << (u32)(7 * rbytes)) - 1; */ ;
      /*@ assert av ≤ (u32)0x1fffff; */ ;
      tmp1 = av << (u32)7;
      /*@ assert tmp1 ≤ (u32)0xfffff80; */ ;
      tmp2 = (u32)*(buf + rbytes) & (u32)0x7f;
      /*@ assert tmp2 ≤ (u32)0x7f; */ ;
      av = tmp1 + tmp2;
      /*@ assert av ≤ (1 << (u32)(7 * (rbytes + 1))) - 1; */ ;
      /*@ assert av ≤ 0xfffffff; */ ;
      if (((int)*(buf + rbytes) & 0x80) == 0) break;
    }
    rbytes = (u16)((int)rbytes + 1);
  }
  if ((int)rbytes >= (int)len) {
    /*@ assert (*(buf + (len - 1)) & 0x80) ≢ 0; */ ;
    ret = -726;
    goto out;
  }
  *arc_val = av;
  *eaten = (u16)((int)rbytes + 1);
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(parsed);
    requires \separated(parsed, buf + (..));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \result ≡ 0 ⇒ 2 < *\old(parsed) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *parsed;
 */
static int parse_OID(u8 const *buf, u16 len, u16 *parsed)
{
  u16 num;
  int ret;
  u16 data_len = (u16)0;
  u16 hdr_len = (u16)0;
  u16 remain = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -766;
              goto out;
            }
    }
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_OID,& hdr_len,
                     & data_len);
  if (ret) goto out;
  len = (u16)((int)len - (int)hdr_len);
  buf += (int)hdr_len;
  if ((int)data_len < 1) {
    ret = -781;
    goto out;
  }
  /*@ assert \valid_read(buf + (0 .. data_len - 1)); */ ;
  remain = data_len;
  num = (u16)0;
  /*@ loop invariant \valid_read(buf + (0 .. remain - 1));
      loop assigns ret, num, buf, remain;
      loop variant remain;
  */
  while (remain) {
    u32 arc_val = (u32)0;
    u16 rbytes = (u16)0;
    if ((int)num > 20) {
      ret = -804;
      goto out;
    }
    ret = _parse_arc(buf,remain,& arc_val,& rbytes);
    if (ret) goto out;
    /*@ assert rbytes ≤ remain; */ ;
    num = (u16)((int)num + 1);
    buf += (int)rbytes;
    remain = (u16)((int)remain - (int)rbytes);
  }
  if ((int)num < 1) {
    ret = -829;
    goto out;
  }
  *parsed = (u16)((int)hdr_len + (int)data_len);
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(eaten);
    requires \separated(eaten, buf + (..));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \result ≡ 0 ⇒ 2 < *\old(eaten) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *eaten;
 */
static int parse_integer(u8 const *buf, u16 len, tag_class exp_class,
                         u32 exp_type, u16 *eaten)
{
  int ret;
  u16 hdr_len = (u16)0;
  u16 data_len = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -867;
              goto out;
            }
    }
  ret = parse_id_len(buf,len,exp_class,exp_type,& hdr_len,& data_len);
  if (ret) goto out;
  buf += (int)hdr_len;
  if ((int)data_len == 0) {
    ret = -885;
    goto out;
  }
  if ((int)data_len > 1) {
    if ((int)*(buf + 0) == 0) 
      if (((int)*(buf + 1) & 0x80) == 0) {
        ret = -900;
        goto out;
      }
    if ((int)*(buf + 0) == 0xff) 
      if ((int)*(buf + 1) & 0x80) {
        ret = -906;
        goto out;
      }
  }
  *eaten = (u16)((int)hdr_len + (int)data_len);
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \separated(eaten, buf + (..));
    requires \valid(eaten);
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \result ≡ 0 ⇒ *\old(eaten) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *eaten;
 */
static int parse_boolean(u8 const *buf, u16 len, u16 *eaten)
{
  int ret;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -945;
              goto out;
            }
    }
  if ((int)len < 3) {
    ret = -951;
    goto out;
  }
  if ((int)*(buf + 0) != 0x01) goto _LOR_0;
  else 
    if ((int)*(buf + 1) != 0x01) {
      _LOR_0: {
                ret = -957;
                goto out;
              }
    }
  switch ((int)*(buf + 2)) {
    case 0x00: case 0xff: break;
    default: ret = -967;
    goto out;
    break;
  }
  *eaten = (u16)3;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(eaten);
    requires \separated(eaten, buf + (..));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \result ≡ 0 ⇒ *\old(eaten) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *eaten;
 */
static int parse_x509_Version(u8 const *buf, u16 len, u16 *eaten)
{
  int ret;
  u16 data_len = (u16)0;
  u16 hdr_len = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -1009;
              goto out;
            }
    }
  ret = parse_explicit_id_len(buf,len,(u32)0,CLASS_UNIVERSAL,
                              (u32)ASN1_TYPE_INTEGER,& hdr_len,& data_len);
  if (ret) goto out;
  buf += (int)hdr_len;
  if ((int)data_len != 1) {
    ret = -1029;
    goto out;
  }
  if ((int)*(buf + 0) != 0x02) {
    ret = -1035;
    goto out;
  }
  *eaten = (u16)((int)hdr_len + (int)data_len);
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(eaten);
    requires \separated(eaten, buf + (..));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \result ≡ 0 ⇒ *\old(eaten) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *eaten;
 */
static int parse_CertificateSerialNumber(u8 const *buf, u16 len,
                                         tag_class exp_class, u32 exp_type,
                                         u16 *eaten)
{
  int ret;
  u16 parsed = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -1077;
              goto out;
            }
    }
  ret = parse_integer(buf,len,exp_class,exp_type,& parsed);
  if (ret) goto out;
  if ((int)parsed == 3) 
    if ((int)*(buf + 2) == 0) {
      ret = -1101;
      goto out;
    }
  if ((int)parsed > 22) {
    ret = -1113;
    goto out;
  }
  if ((int)*(buf + 2) & 0x80) {
    ret = -1120;
    goto out;
  }
  *eaten = parsed;
  ret = 0;
  out: ;
  return ret;
}

static int parse_sig_ecdsa(u8 const *buf, u16 len, u16 *eaten);

static int parse_algoid_params_ecdsa_with(u8 const *buf, u16 len,
                                          alg_param *param);

static int parse_algoid_params_ecPublicKey(u8 const *buf, u16 len,
                                           alg_param *param);

static int parse_subjectpubkey_ec(u8 const *buf, u16 len, alg_param *param);

static int parse_subjectpubkey_rsa(u8 const *buf, u16 len, alg_param *param);

static int parse_sig_generic(u8 const *buf, u16 len, u16 *eaten);

static int parse_algoid_params_generic(u8 const *buf, u16 len,
                                       alg_param *param);

static int parse_algoid_params_rsa(u8 const *buf, u16 len, alg_param *param);

static u8 const _ecdsa_sha1_name[16] =
  {(u8)'e',
   (u8)'c',
   (u8)'d',
   (u8)'s',
   (u8)'a',
   (u8)'-',
   (u8)'w',
   (u8)'i',
   (u8)'t',
   (u8)'h',
   (u8)'-',
   (u8)'S',
   (u8)'H',
   (u8)'A',
   (u8)'1',
   (u8)'\000'};
static u8 const _ecdsa_sha1_printable_oid[18] =
  {(u8)'1',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'8',
   (u8)'4',
   (u8)'0',
   (u8)'.',
   (u8)'1',
   (u8)'0',
   (u8)'0',
   (u8)'4',
   (u8)'5',
   (u8)'.',
   (u8)'4',
   (u8)'.',
   (u8)'1',
   (u8)'\000'};
static u8 const _ecdsa_sha1_der_oid[9] =
  {(u8)0x06,
   (u8)0x07,
   (u8)0x2a,
   (u8)0x86,
   (u8)0x48,
   (u8)0xce,
   (u8)0x3d,
   (u8)0x04,
   (u8)0x01};
static _alg_id const _ecdsa_sha1_alg =
  {.alg_name = _ecdsa_sha1_name,
   .alg_printable_oid = _ecdsa_sha1_printable_oid,
   .alg_der_oid = _ecdsa_sha1_der_oid,
   .alg_der_oid_len = (u8)sizeof(_ecdsa_sha1_der_oid),
   .alg_type = (u8)ALG_SIG,
   .parse_sig = & parse_sig_ecdsa,
   .parse_subjectpubkey = (int (*)(u8 const *buf, u16 len, alg_param *param))0,
   .parse_algoid_params = & parse_algoid_params_ecdsa_with};
static u8 const _ecdsa_sha224_name[18] =
  {(u8)'e',
   (u8)'c',
   (u8)'d',
   (u8)'s',
   (u8)'a',
   (u8)'-',
   (u8)'w',
   (u8)'i',
   (u8)'t',
   (u8)'h',
   (u8)'-',
   (u8)'S',
   (u8)'H',
   (u8)'A',
   (u8)'2',
   (u8)'2',
   (u8)'4',
   (u8)'\000'};
static u8 const _ecdsa_sha224_printable_oid[20] =
  {(u8)'1',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'8',
   (u8)'4',
   (u8)'0',
   (u8)'.',
   (u8)'1',
   (u8)'0',
   (u8)'0',
   (u8)'4',
   (u8)'5',
   (u8)'.',
   (u8)'4',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'1',
   (u8)'\000'};
static u8 const _ecdsa_sha224_der_oid[10] =
  {(u8)0x06,
   (u8)0x08,
   (u8)0x2a,
   (u8)0x86,
   (u8)0x48,
   (u8)0xce,
   (u8)0x3d,
   (u8)0x04,
   (u8)0x03,
   (u8)0x01};
static _alg_id const _ecdsa_sha224_alg =
  {.alg_name = _ecdsa_sha224_name,
   .alg_printable_oid = _ecdsa_sha224_printable_oid,
   .alg_der_oid = _ecdsa_sha224_der_oid,
   .alg_der_oid_len = (u8)sizeof(_ecdsa_sha224_der_oid),
   .alg_type = (u8)ALG_SIG,
   .parse_sig = & parse_sig_ecdsa,
   .parse_subjectpubkey = (int (*)(u8 const *buf, u16 len, alg_param *param))0,
   .parse_algoid_params = & parse_algoid_params_ecdsa_with};
static u8 const _ecdsa_sha256_name[18] =
  {(u8)'e',
   (u8)'c',
   (u8)'d',
   (u8)'s',
   (u8)'a',
   (u8)'-',
   (u8)'w',
   (u8)'i',
   (u8)'t',
   (u8)'h',
   (u8)'-',
   (u8)'S',
   (u8)'H',
   (u8)'A',
   (u8)'2',
   (u8)'5',
   (u8)'6',
   (u8)'\000'};
static u8 const _ecdsa_sha256_printable_oid[20] =
  {(u8)'1',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'8',
   (u8)'4',
   (u8)'0',
   (u8)'.',
   (u8)'1',
   (u8)'0',
   (u8)'0',
   (u8)'4',
   (u8)'5',
   (u8)'.',
   (u8)'4',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'2',
   (u8)'\000'};
static u8 const _ecdsa_sha256_der_oid[10] =
  {(u8)0x06,
   (u8)0x08,
   (u8)0x2a,
   (u8)0x86,
   (u8)0x48,
   (u8)0xce,
   (u8)0x3d,
   (u8)0x04,
   (u8)0x03,
   (u8)0x02};
static _alg_id const _ecdsa_sha256_alg =
  {.alg_name = _ecdsa_sha256_name,
   .alg_printable_oid = _ecdsa_sha256_printable_oid,
   .alg_der_oid = _ecdsa_sha256_der_oid,
   .alg_der_oid_len = (u8)sizeof(_ecdsa_sha256_der_oid),
   .alg_type = (u8)ALG_SIG,
   .parse_sig = & parse_sig_ecdsa,
   .parse_subjectpubkey = (int (*)(u8 const *buf, u16 len, alg_param *param))0,
   .parse_algoid_params = & parse_algoid_params_ecdsa_with};
static u8 const _ecdsa_sha384_name[18] =
  {(u8)'e',
   (u8)'c',
   (u8)'d',
   (u8)'s',
   (u8)'a',
   (u8)'-',
   (u8)'w',
   (u8)'i',
   (u8)'t',
   (u8)'h',
   (u8)'-',
   (u8)'S',
   (u8)'H',
   (u8)'A',
   (u8)'3',
   (u8)'8',
   (u8)'4',
   (u8)'\000'};
static u8 const _ecdsa_sha384_printable_oid[20] =
  {(u8)'1',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'8',
   (u8)'4',
   (u8)'0',
   (u8)'.',
   (u8)'1',
   (u8)'0',
   (u8)'0',
   (u8)'4',
   (u8)'5',
   (u8)'.',
   (u8)'4',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'3',
   (u8)'\000'};
static u8 const _ecdsa_sha384_der_oid[10] =
  {(u8)0x06,
   (u8)0x08,
   (u8)0x2a,
   (u8)0x86,
   (u8)0x48,
   (u8)0xce,
   (u8)0x3d,
   (u8)0x04,
   (u8)0x03,
   (u8)0x03};
static _alg_id const _ecdsa_sha384_alg =
  {.alg_name = _ecdsa_sha384_name,
   .alg_printable_oid = _ecdsa_sha384_printable_oid,
   .alg_der_oid = _ecdsa_sha384_der_oid,
   .alg_der_oid_len = (u8)sizeof(_ecdsa_sha384_der_oid),
   .alg_type = (u8)ALG_SIG,
   .parse_sig = & parse_sig_ecdsa,
   .parse_subjectpubkey = (int (*)(u8 const *buf, u16 len, alg_param *param))0,
   .parse_algoid_params = & parse_algoid_params_ecdsa_with};
static u8 const _ecdsa_sha512_name[18] =
  {(u8)'e',
   (u8)'c',
   (u8)'d',
   (u8)'s',
   (u8)'a',
   (u8)'-',
   (u8)'w',
   (u8)'i',
   (u8)'t',
   (u8)'h',
   (u8)'-',
   (u8)'S',
   (u8)'H',
   (u8)'A',
   (u8)'5',
   (u8)'1',
   (u8)'2',
   (u8)'\000'};
static u8 const _ecdsa_sha512_printable_oid[20] =
  {(u8)'1',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'8',
   (u8)'4',
   (u8)'0',
   (u8)'.',
   (u8)'1',
   (u8)'0',
   (u8)'0',
   (u8)'4',
   (u8)'5',
   (u8)'.',
   (u8)'4',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'4',
   (u8)'\000'};
static u8 const _ecdsa_sha512_der_oid[10] =
  {(u8)0x06,
   (u8)0x08,
   (u8)0x2a,
   (u8)0x86,
   (u8)0x48,
   (u8)0xce,
   (u8)0x3d,
   (u8)0x04,
   (u8)0x03,
   (u8)0x04};
static _alg_id const _ecdsa_sha512_alg =
  {.alg_name = _ecdsa_sha512_name,
   .alg_printable_oid = _ecdsa_sha512_printable_oid,
   .alg_der_oid = _ecdsa_sha512_der_oid,
   .alg_der_oid_len = (u8)sizeof(_ecdsa_sha512_der_oid),
   .alg_type = (u8)ALG_SIG,
   .parse_sig = & parse_sig_ecdsa,
   .parse_subjectpubkey = (int (*)(u8 const *buf, u16 len, alg_param *param))0,
   .parse_algoid_params = & parse_algoid_params_ecdsa_with};
static u8 const _ecpublickey_name[12] =
  {(u8)'e',
   (u8)'c',
   (u8)'P',
   (u8)'u',
   (u8)'b',
   (u8)'l',
   (u8)'i',
   (u8)'c',
   (u8)'K',
   (u8)'e',
   (u8)'y',
   (u8)'\000'};
static u8 const _ecpublickey_printable_oid[18] =
  {(u8)'1',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'8',
   (u8)'4',
   (u8)'0',
   (u8)'.',
   (u8)'1',
   (u8)'0',
   (u8)'0',
   (u8)'4',
   (u8)'5',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'1',
   (u8)'\000'};
static u8 const _ecpublickey_der_oid[9] =
  {(u8)0x06,
   (u8)0x07,
   (u8)0x2a,
   (u8)0x86,
   (u8)0x48,
   (u8)0xce,
   (u8)0x3d,
   (u8)0x02,
   (u8)0x01};
static _alg_id const _ecpublickey_alg =
  {.alg_name = _ecpublickey_name,
   .alg_printable_oid = _ecpublickey_printable_oid,
   .alg_der_oid = _ecpublickey_der_oid,
   .alg_der_oid_len = (u8)sizeof(_ecpublickey_der_oid),
   .alg_type = (u8)ALG_PUBKEY,
   .parse_sig = (int (*)(u8 const *buf, u16 len, u16 *eaten))0,
   .parse_subjectpubkey = & parse_subjectpubkey_ec,
   .parse_algoid_params = & parse_algoid_params_ecPublicKey};
static u8 const _rsa_md2_name[21] =
  {(u8)'m',
   (u8)'d',
   (u8)'2',
   (u8)'W',
   (u8)'i',
   (u8)'t',
   (u8)'h',
   (u8)'R',
   (u8)'S',
   (u8)'A',
   (u8)'E',
   (u8)'n',
   (u8)'c',
   (u8)'r',
   (u8)'y',
   (u8)'p',
   (u8)'t',
   (u8)'i',
   (u8)'o',
   (u8)'n',
   (u8)'\000'};
static u8 const _rsa_md2_printable_oid[21] =
  {(u8)'1',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'8',
   (u8)'4',
   (u8)'0',
   (u8)'.',
   (u8)'1',
   (u8)'1',
   (u8)'3',
   (u8)'5',
   (u8)'4',
   (u8)'9',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'2',
   (u8)'\000'};
static u8 const _rsa_md2_der_oid[11] =
  {(u8)0x06,
   (u8)0x09,
   (u8)0x2a,
   (u8)0x86,
   (u8)0x48,
   (u8)0x86,
   (u8)0xf7,
   (u8)0x0d,
   (u8)0x01,
   (u8)0x01,
   (u8)0x02};
static _alg_id const _rsa_md2_alg =
  {.alg_name = _rsa_md2_name,
   .alg_printable_oid = _rsa_md2_printable_oid,
   .alg_der_oid = _rsa_md2_der_oid,
   .alg_der_oid_len = (u8)sizeof(_rsa_md2_der_oid),
   .alg_type = (u8)ALG_SIG,
   .parse_sig = & parse_sig_generic,
   .parse_subjectpubkey = (int (*)(u8 const *buf, u16 len, alg_param *param))0,
   .parse_algoid_params = & parse_algoid_params_generic};
static u8 const _rsa_md4_name[21] =
  {(u8)'m',
   (u8)'d',
   (u8)'4',
   (u8)'W',
   (u8)'i',
   (u8)'t',
   (u8)'h',
   (u8)'R',
   (u8)'S',
   (u8)'A',
   (u8)'E',
   (u8)'n',
   (u8)'c',
   (u8)'r',
   (u8)'y',
   (u8)'p',
   (u8)'t',
   (u8)'i',
   (u8)'o',
   (u8)'n',
   (u8)'\000'};
static u8 const _rsa_md4_printable_oid[21] =
  {(u8)'1',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'8',
   (u8)'4',
   (u8)'0',
   (u8)'.',
   (u8)'1',
   (u8)'1',
   (u8)'3',
   (u8)'5',
   (u8)'4',
   (u8)'9',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'3',
   (u8)'\000'};
static u8 const _rsa_md4_der_oid[11] =
  {(u8)0x06,
   (u8)0x09,
   (u8)0x2a,
   (u8)0x86,
   (u8)0x48,
   (u8)0x86,
   (u8)0xf7,
   (u8)0x0d,
   (u8)0x01,
   (u8)0x01,
   (u8)0x03};
static _alg_id const _rsa_md4_alg =
  {.alg_name = _rsa_md4_name,
   .alg_printable_oid = _rsa_md4_printable_oid,
   .alg_der_oid = _rsa_md4_der_oid,
   .alg_der_oid_len = (u8)sizeof(_rsa_md4_der_oid),
   .alg_type = (u8)ALG_SIG,
   .parse_sig = & parse_sig_generic,
   .parse_subjectpubkey = (int (*)(u8 const *buf, u16 len, alg_param *param))0,
   .parse_algoid_params = & parse_algoid_params_generic};
static u8 const _rsa_md5_name[21] =
  {(u8)'m',
   (u8)'d',
   (u8)'5',
   (u8)'W',
   (u8)'i',
   (u8)'t',
   (u8)'h',
   (u8)'R',
   (u8)'S',
   (u8)'A',
   (u8)'E',
   (u8)'n',
   (u8)'c',
   (u8)'r',
   (u8)'y',
   (u8)'p',
   (u8)'t',
   (u8)'i',
   (u8)'o',
   (u8)'n',
   (u8)'\000'};
static u8 const _rsa_md5_printable_oid[21] =
  {(u8)'1',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'8',
   (u8)'4',
   (u8)'0',
   (u8)'.',
   (u8)'1',
   (u8)'1',
   (u8)'3',
   (u8)'5',
   (u8)'4',
   (u8)'9',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'4',
   (u8)'\000'};
static u8 const _rsa_md5_der_oid[11] =
  {(u8)0x06,
   (u8)0x09,
   (u8)0x2a,
   (u8)0x86,
   (u8)0x48,
   (u8)0x86,
   (u8)0xf7,
   (u8)0x0d,
   (u8)0x01,
   (u8)0x01,
   (u8)0x04};
static _alg_id const _rsa_md5_alg =
  {.alg_name = _rsa_md5_name,
   .alg_printable_oid = _rsa_md5_printable_oid,
   .alg_der_oid = _rsa_md5_der_oid,
   .alg_der_oid_len = (u8)sizeof(_rsa_md5_der_oid),
   .alg_type = (u8)ALG_SIG,
   .parse_sig = & parse_sig_generic,
   .parse_subjectpubkey = (int (*)(u8 const *buf, u16 len, alg_param *param))0,
   .parse_algoid_params = & parse_algoid_params_rsa};
static u8 const _rsa_sha1_name[22] =
  {(u8)'s',
   (u8)'h',
   (u8)'a',
   (u8)'1',
   (u8)'W',
   (u8)'i',
   (u8)'t',
   (u8)'h',
   (u8)'R',
   (u8)'S',
   (u8)'A',
   (u8)'E',
   (u8)'n',
   (u8)'c',
   (u8)'r',
   (u8)'y',
   (u8)'p',
   (u8)'t',
   (u8)'i',
   (u8)'o',
   (u8)'n',
   (u8)'\000'};
static u8 const _rsa_sha1_printable_oid[21] =
  {(u8)'1',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'8',
   (u8)'4',
   (u8)'0',
   (u8)'.',
   (u8)'1',
   (u8)'1',
   (u8)'3',
   (u8)'5',
   (u8)'4',
   (u8)'9',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'5',
   (u8)'\000'};
static u8 const _rsa_sha1_der_oid[11] =
  {(u8)0x06,
   (u8)0x09,
   (u8)0x2a,
   (u8)0x86,
   (u8)0x48,
   (u8)0x86,
   (u8)0xf7,
   (u8)0x0d,
   (u8)0x01,
   (u8)0x01,
   (u8)0x05};
static _alg_id const _rsa_sha1_alg =
  {.alg_name = _rsa_sha1_name,
   .alg_printable_oid = _rsa_sha1_printable_oid,
   .alg_der_oid = _rsa_sha1_der_oid,
   .alg_der_oid_len = (u8)sizeof(_rsa_sha1_der_oid),
   .alg_type = (u8)ALG_SIG,
   .parse_sig = & parse_sig_generic,
   .parse_subjectpubkey = (int (*)(u8 const *buf, u16 len, alg_param *param))0,
   .parse_algoid_params = & parse_algoid_params_rsa};
static u8 const _rsa_sha256_name[24] =
  {(u8)'s',
   (u8)'h',
   (u8)'a',
   (u8)'2',
   (u8)'5',
   (u8)'6',
   (u8)'W',
   (u8)'i',
   (u8)'t',
   (u8)'h',
   (u8)'R',
   (u8)'S',
   (u8)'A',
   (u8)'E',
   (u8)'n',
   (u8)'c',
   (u8)'r',
   (u8)'y',
   (u8)'p',
   (u8)'t',
   (u8)'i',
   (u8)'o',
   (u8)'n',
   (u8)'\000'};
static u8 const _rsa_sha256_printable_oid[22] =
  {(u8)'1',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'8',
   (u8)'4',
   (u8)'0',
   (u8)'.',
   (u8)'1',
   (u8)'1',
   (u8)'3',
   (u8)'5',
   (u8)'4',
   (u8)'9',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'1',
   (u8)'1',
   (u8)'\000'};
static u8 const _rsa_sha256_der_oid[11] =
  {(u8)0x06,
   (u8)0x09,
   (u8)0x2a,
   (u8)0x86,
   (u8)0x48,
   (u8)0x86,
   (u8)0xf7,
   (u8)0x0d,
   (u8)0x01,
   (u8)0x01,
   (u8)0x0b};
static _alg_id const _rsa_sha256_alg =
  {.alg_name = _rsa_sha256_name,
   .alg_printable_oid = _rsa_sha256_printable_oid,
   .alg_der_oid = _rsa_sha256_der_oid,
   .alg_der_oid_len = (u8)sizeof(_rsa_sha256_der_oid),
   .alg_type = (u8)ALG_SIG,
   .parse_sig = & parse_sig_generic,
   .parse_subjectpubkey = (int (*)(u8 const *buf, u16 len, alg_param *param))0,
   .parse_algoid_params = & parse_algoid_params_generic};
static u8 const _rsa_sha224_name[24] =
  {(u8)'s',
   (u8)'h',
   (u8)'a',
   (u8)'2',
   (u8)'2',
   (u8)'4',
   (u8)'W',
   (u8)'i',
   (u8)'t',
   (u8)'h',
   (u8)'R',
   (u8)'S',
   (u8)'A',
   (u8)'E',
   (u8)'n',
   (u8)'c',
   (u8)'r',
   (u8)'y',
   (u8)'p',
   (u8)'t',
   (u8)'i',
   (u8)'o',
   (u8)'n',
   (u8)'\000'};
static u8 const _rsa_sha224_printable_oid[22] =
  {(u8)'1',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'8',
   (u8)'4',
   (u8)'0',
   (u8)'.',
   (u8)'1',
   (u8)'1',
   (u8)'3',
   (u8)'5',
   (u8)'4',
   (u8)'9',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'1',
   (u8)'4',
   (u8)'\000'};
static u8 const _rsa_sha224_der_oid[11] =
  {(u8)0x06,
   (u8)0x09,
   (u8)0x2a,
   (u8)0x86,
   (u8)0x48,
   (u8)0x86,
   (u8)0xf7,
   (u8)0x0d,
   (u8)0x01,
   (u8)0x01,
   (u8)0x0e};
static _alg_id const _rsa_sha224_alg =
  {.alg_name = _rsa_sha224_name,
   .alg_printable_oid = _rsa_sha224_printable_oid,
   .alg_der_oid = _rsa_sha224_der_oid,
   .alg_der_oid_len = (u8)sizeof(_rsa_sha224_der_oid),
   .alg_type = (u8)ALG_SIG,
   .parse_sig = & parse_sig_generic,
   .parse_subjectpubkey = (int (*)(u8 const *buf, u16 len, alg_param *param))0,
   .parse_algoid_params = & parse_algoid_params_generic};
static u8 const _rsa_sha384_name[24] =
  {(u8)'s',
   (u8)'h',
   (u8)'a',
   (u8)'3',
   (u8)'8',
   (u8)'4',
   (u8)'W',
   (u8)'i',
   (u8)'t',
   (u8)'h',
   (u8)'R',
   (u8)'S',
   (u8)'A',
   (u8)'E',
   (u8)'n',
   (u8)'c',
   (u8)'r',
   (u8)'y',
   (u8)'p',
   (u8)'t',
   (u8)'i',
   (u8)'o',
   (u8)'n',
   (u8)'\000'};
static u8 const _rsa_sha384_printable_oid[22] =
  {(u8)'1',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'8',
   (u8)'4',
   (u8)'0',
   (u8)'.',
   (u8)'1',
   (u8)'1',
   (u8)'3',
   (u8)'5',
   (u8)'4',
   (u8)'9',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'1',
   (u8)'2',
   (u8)'\000'};
static u8 const _rsa_sha384_der_oid[11] =
  {(u8)0x06,
   (u8)0x09,
   (u8)0x2a,
   (u8)0x86,
   (u8)0x48,
   (u8)0x86,
   (u8)0xf7,
   (u8)0x0d,
   (u8)0x01,
   (u8)0x01,
   (u8)0x0c};
static _alg_id const _rsa_sha384_alg =
  {.alg_name = _rsa_sha384_name,
   .alg_printable_oid = _rsa_sha384_printable_oid,
   .alg_der_oid = _rsa_sha384_der_oid,
   .alg_der_oid_len = (u8)sizeof(_rsa_sha384_der_oid),
   .alg_type = (u8)ALG_SIG,
   .parse_sig = & parse_sig_generic,
   .parse_subjectpubkey = (int (*)(u8 const *buf, u16 len, alg_param *param))0,
   .parse_algoid_params = & parse_algoid_params_generic};
static u8 const _rsa_sha512_name[24] =
  {(u8)'s',
   (u8)'h',
   (u8)'a',
   (u8)'5',
   (u8)'1',
   (u8)'2',
   (u8)'W',
   (u8)'i',
   (u8)'t',
   (u8)'h',
   (u8)'R',
   (u8)'S',
   (u8)'A',
   (u8)'E',
   (u8)'n',
   (u8)'c',
   (u8)'r',
   (u8)'y',
   (u8)'p',
   (u8)'t',
   (u8)'i',
   (u8)'o',
   (u8)'n',
   (u8)'\000'};
static u8 const _rsa_sha512_printable_oid[22] =
  {(u8)'1',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'8',
   (u8)'4',
   (u8)'0',
   (u8)'.',
   (u8)'1',
   (u8)'1',
   (u8)'3',
   (u8)'5',
   (u8)'4',
   (u8)'9',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'1',
   (u8)'3',
   (u8)'\000'};
static u8 const _rsa_sha512_der_oid[11] =
  {(u8)0x06,
   (u8)0x09,
   (u8)0x2a,
   (u8)0x86,
   (u8)0x48,
   (u8)0x86,
   (u8)0xf7,
   (u8)0x0d,
   (u8)0x01,
   (u8)0x01,
   (u8)0x0d};
static _alg_id const _rsa_sha512_alg =
  {.alg_name = _rsa_sha512_name,
   .alg_printable_oid = _rsa_sha512_printable_oid,
   .alg_der_oid = _rsa_sha512_der_oid,
   .alg_der_oid_len = (u8)sizeof(_rsa_sha512_der_oid),
   .alg_type = (u8)ALG_SIG,
   .parse_sig = & parse_sig_generic,
   .parse_subjectpubkey = (int (*)(u8 const *buf, u16 len, alg_param *param))0,
   .parse_algoid_params = & parse_algoid_params_generic};
static u8 const _dsa_sha1_name[12] =
  {(u8)'d',
   (u8)'s',
   (u8)'a',
   (u8)'W',
   (u8)'i',
   (u8)'t',
   (u8)'h',
   (u8)'S',
   (u8)'H',
   (u8)'A',
   (u8)'1',
   (u8)'\000'};
static u8 const _dsa_sha1_printable_oid[14] =
  {(u8)'1',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'1',
   (u8)'4',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'2',
   (u8)'7',
   (u8)'\000'};
static u8 const _dsa_sha1_der_oid[9] =
  {(u8)0x06,
   (u8)0x07,
   (u8)0x2a,
   (u8)0x86,
   (u8)0x48,
   (u8)0xce,
   (u8)0x38,
   (u8)0x04,
   (u8)0x03};
static _alg_id const _dsa_sha1_alg =
  {.alg_name = _dsa_sha1_name,
   .alg_printable_oid = _dsa_sha1_printable_oid,
   .alg_der_oid = _dsa_sha1_der_oid,
   .alg_der_oid_len = (u8)sizeof(_dsa_sha1_der_oid),
   .alg_type = (u8)ALG_SIG,
   .parse_sig = & parse_sig_generic,
   .parse_subjectpubkey = (int (*)(u8 const *buf, u16 len, alg_param *param))0,
   .parse_algoid_params = & parse_algoid_params_generic};
static u8 const _pkcs1_rsaEncryption_name[21] =
  {(u8)'P',
   (u8)'K',
   (u8)'C',
   (u8)'S',
   (u8)'-',
   (u8)'1',
   (u8)' ',
   (u8)'r',
   (u8)'s',
   (u8)'a',
   (u8)'E',
   (u8)'n',
   (u8)'c',
   (u8)'r',
   (u8)'y',
   (u8)'p',
   (u8)'t',
   (u8)'i',
   (u8)'o',
   (u8)'n',
   (u8)'\000'};
static u8 const _pkcs1_rsaEncryption_printable_oid[21] =
  {(u8)'1',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'8',
   (u8)'4',
   (u8)'0',
   (u8)'.',
   (u8)'1',
   (u8)'1',
   (u8)'3',
   (u8)'5',
   (u8)'4',
   (u8)'9',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'1',
   (u8)'\000'};
static u8 const _pkcs1_rsaEncryption_der_oid[11] =
  {(u8)0x06,
   (u8)0x09,
   (u8)0x2a,
   (u8)0x86,
   (u8)0x48,
   (u8)0x86,
   (u8)0xf7,
   (u8)0x0d,
   (u8)0x01,
   (u8)0x01,
   (u8)0x01};
static _alg_id const _pkcs1_rsaEncryption_alg =
  {.alg_name = _pkcs1_rsaEncryption_name,
   .alg_printable_oid = _pkcs1_rsaEncryption_printable_oid,
   .alg_der_oid = _pkcs1_rsaEncryption_der_oid,
   .alg_der_oid_len = (u8)sizeof(_pkcs1_rsaEncryption_der_oid),
   .alg_type = (u8)ALG_PUBKEY,
   .parse_sig = (int (*)(u8 const *buf, u16 len, u16 *eaten))0,
   .parse_subjectpubkey = & parse_subjectpubkey_rsa,
   .parse_algoid_params = & parse_algoid_params_rsa};
static u8 const _rsassapss_name[11] =
  {(u8)'R',
   (u8)'S',
   (u8)'A',
   (u8)'S',
   (u8)'S',
   (u8)'A',
   (u8)'-',
   (u8)'P',
   (u8)'S',
   (u8)'S',
   (u8)'\000'};
static u8 const _rsassapss_printable_oid[22] =
  {(u8)'1',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'8',
   (u8)'4',
   (u8)'0',
   (u8)'.',
   (u8)'1',
   (u8)'1',
   (u8)'3',
   (u8)'5',
   (u8)'4',
   (u8)'9',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'1',
   (u8)'0',
   (u8)'\000'};
static u8 const _rsassapss_der_oid[11] =
  {(u8)0x06,
   (u8)0x09,
   (u8)0x2a,
   (u8)0x86,
   (u8)0x48,
   (u8)0x86,
   (u8)0xf7,
   (u8)0x0d,
   (u8)0x01,
   (u8)0x01,
   (u8)0x0a};
static _alg_id const _rsassapss_alg =
  {.alg_name = _rsassapss_name,
   .alg_printable_oid = _rsassapss_printable_oid,
   .alg_der_oid = _rsassapss_der_oid,
   .alg_der_oid_len = (u8)sizeof(_rsassapss_der_oid),
   .alg_type = (u8)ALG_SIG,
   .parse_sig = & parse_sig_generic,
   .parse_subjectpubkey = (int (*)(u8 const *buf, u16 len, alg_param *param))0,
   .parse_algoid_params = & parse_algoid_params_generic};
static u8 const _odd1_name[27] =
  {(u8)'o',
   (u8)'i',
   (u8)'w',
   (u8)'-',
   (u8)'s',
   (u8)'h',
   (u8)'a',
   (u8)'-',
   (u8)'1',
   (u8)'W',
   (u8)'i',
   (u8)'t',
   (u8)'h',
   (u8)'R',
   (u8)'S',
   (u8)'A',
   (u8)'E',
   (u8)'n',
   (u8)'c',
   (u8)'r',
   (u8)'y',
   (u8)'p',
   (u8)'t',
   (u8)'i',
   (u8)'o',
   (u8)'n',
   (u8)'\000'};
static u8 const _odd1_printable_oid[14] =
  {(u8)'1',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'1',
   (u8)'4',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'2',
   (u8)'9',
   (u8)'\000'};
static u8 const _odd1_der_oid[7] =
  {(u8)0x06, (u8)0x05, (u8)0x2b, (u8)0x0e, (u8)0x03, (u8)0x02, (u8)0x1d};
static _alg_id const _odd1_alg =
  {.alg_name = _odd1_name,
   .alg_printable_oid = _odd1_printable_oid,
   .alg_der_oid = _odd1_der_oid,
   .alg_der_oid_len = (u8)sizeof(_odd1_der_oid),
   .alg_type = (u8)ALG_SIG,
   .parse_sig = & parse_sig_generic,
   .parse_subjectpubkey = (int (*)(u8 const *buf, u16 len, alg_param *param))0,
   .parse_algoid_params = & parse_algoid_params_generic};
static u8 const _odd2_name[24] =
  {(u8)'o',
   (u8)'i',
   (u8)'w',
   (u8)'-',
   (u8)'s',
   (u8)'h',
   (u8)'a',
   (u8)'W',
   (u8)'i',
   (u8)'t',
   (u8)'h',
   (u8)'R',
   (u8)'S',
   (u8)'A',
   (u8)'S',
   (u8)'i',
   (u8)'g',
   (u8)'n',
   (u8)'a',
   (u8)'t',
   (u8)'u',
   (u8)'r',
   (u8)'e',
   (u8)'\000'};
static u8 const _odd2_printable_oid[14] =
  {(u8)'1',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'1',
   (u8)'4',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'1',
   (u8)'5',
   (u8)'\000'};
static u8 const _odd2_der_oid[7] =
  {(u8)0x06, (u8)0x05, (u8)0x2b, (u8)0x0e, (u8)0x03, (u8)0x02, (u8)0x0f};
static _alg_id const _odd2_alg =
  {.alg_name = _odd2_name,
   .alg_printable_oid = _odd2_printable_oid,
   .alg_der_oid = _odd2_der_oid,
   .alg_der_oid_len = (u8)sizeof(_odd2_der_oid),
   .alg_type = (u8)ALG_SIG,
   .parse_sig = & parse_sig_generic,
   .parse_subjectpubkey = (int (*)(u8 const *buf, u16 len, alg_param *param))0,
   .parse_algoid_params = & parse_algoid_params_generic};
static u8 const _odd3_name[10] =
  {(u8)'o',
   (u8)'i',
   (u8)'w',
   (u8)'-',
   (u8)'S',
   (u8)'H',
   (u8)'A',
   (u8)'-',
   (u8)'1',
   (u8)'\000'};
static u8 const _odd3_printable_oid[14] =
  {(u8)'1',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'1',
   (u8)'4',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'2',
   (u8)'6',
   (u8)'\000'};
static u8 const _odd3_der_oid[7] =
  {(u8)0x06, (u8)0x05, (u8)0x2b, (u8)0x0e, (u8)0x03, (u8)0x02, (u8)0x1a};
static _alg_id const _odd3_alg =
  {.alg_name = _odd3_name,
   .alg_printable_oid = _odd3_printable_oid,
   .alg_der_oid = _odd3_der_oid,
   .alg_der_oid_len = (u8)sizeof(_odd3_der_oid),
   .alg_type = (u8)ALG_INVALID,
   .parse_sig = & parse_sig_generic,
   .parse_subjectpubkey = (int (*)(u8 const *buf, u16 len, alg_param *param))0,
   .parse_algoid_params = & parse_algoid_params_generic};
static u8 const _odd4_name[16] =
  {(u8)'o',
   (u8)'i',
   (u8)'w',
   (u8)'-',
   (u8)'d',
   (u8)'s',
   (u8)'a',
   (u8)'W',
   (u8)'i',
   (u8)'t',
   (u8)'h',
   (u8)'S',
   (u8)'H',
   (u8)'A',
   (u8)'1',
   (u8)'\000'};
static u8 const _odd4_printable_oid[14] =
  {(u8)'1',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'1',
   (u8)'4',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'2',
   (u8)'7',
   (u8)'\000'};
static u8 const _odd4_der_oid[7] =
  {(u8)0x06, (u8)0x05, (u8)0x2b, (u8)0x0e, (u8)0x03, (u8)0x02, (u8)0x1b};
static _alg_id const _odd4_alg =
  {.alg_name = _odd4_name,
   .alg_printable_oid = _odd4_printable_oid,
   .alg_der_oid = _odd4_der_oid,
   .alg_der_oid_len = (u8)sizeof(_odd4_der_oid),
   .alg_type = (u8)ALG_SIG,
   .parse_sig = & parse_sig_generic,
   .parse_subjectpubkey = (int (*)(u8 const *buf, u16 len, alg_param *param))0,
   .parse_algoid_params = & parse_algoid_params_generic};
static u8 const _gost1_name[33] =
  {(u8)'g',
   (u8)'o',
   (u8)'s',
   (u8)'t',
   (u8)'R',
   (u8)'3',
   (u8)'4',
   (u8)'1',
   (u8)'1',
   (u8)'-',
   (u8)'9',
   (u8)'4',
   (u8)'-',
   (u8)'w',
   (u8)'i',
   (u8)'t',
   (u8)'h',
   (u8)'-',
   (u8)'g',
   (u8)'o',
   (u8)'s',
   (u8)'t',
   (u8)'R',
   (u8)'3',
   (u8)'4',
   (u8)'1',
   (u8)'0',
   (u8)'-',
   (u8)'2',
   (u8)'0',
   (u8)'0',
   (u8)'1',
   (u8)'\000'};
static u8 const _gost1_printable_oid[14] =
  {(u8)'1',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'6',
   (u8)'4',
   (u8)'3',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'3',
   (u8)'\000'};
static u8 const _gost1_der_oid[8] =
  {(u8)0x06,
   (u8)0x06,
   (u8)0x2a,
   (u8)0x85,
   (u8)0x03,
   (u8)0x02,
   (u8)0x02,
   (u8)0x03};
static _alg_id const _gost1_alg =
  {.alg_name = _gost1_name,
   .alg_printable_oid = _gost1_printable_oid,
   .alg_der_oid = _gost1_der_oid,
   .alg_der_oid_len = (u8)sizeof(_gost1_der_oid),
   .alg_type = (u8)ALG_SIG,
   .parse_sig = & parse_sig_generic,
   .parse_subjectpubkey = (int (*)(u8 const *buf, u16 len, alg_param *param))0,
   .parse_algoid_params = & parse_algoid_params_generic};
static u8 const _gost2_name[31] =
  {(u8)'g',
   (u8)'o',
   (u8)'s',
   (u8)'t',
   (u8)'R',
   (u8)'3',
   (u8)'4',
   (u8)'1',
   (u8)'1',
   (u8)'-',
   (u8)'9',
   (u8)'4',
   (u8)'-',
   (u8)'w',
   (u8)'i',
   (u8)'t',
   (u8)'h',
   (u8)'-',
   (u8)'g',
   (u8)'o',
   (u8)'s',
   (u8)'t',
   (u8)'R',
   (u8)'3',
   (u8)'4',
   (u8)'1',
   (u8)'0',
   (u8)'-',
   (u8)'9',
   (u8)'4',
   (u8)'\000'};
static u8 const _gost2_printable_oid[14] =
  {(u8)'1',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'6',
   (u8)'4',
   (u8)'3',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'4',
   (u8)'\000'};
static u8 const _gost2_der_oid[8] =
  {(u8)0x06,
   (u8)0x06,
   (u8)0x2a,
   (u8)0x85,
   (u8)0x03,
   (u8)0x02,
   (u8)0x02,
   (u8)0x04};
static _alg_id const _gost2_alg =
  {.alg_name = _gost2_name,
   .alg_printable_oid = _gost2_printable_oid,
   .alg_der_oid = _gost2_der_oid,
   .alg_der_oid_len = (u8)sizeof(_gost2_der_oid),
   .alg_type = (u8)ALG_SIG,
   .parse_sig = & parse_sig_generic,
   .parse_subjectpubkey = (int (*)(u8 const *buf, u16 len, alg_param *param))0,
   .parse_algoid_params = & parse_algoid_params_generic};
static u8 const _rsa_ripemd160_name[26] =
  {(u8)'r',
   (u8)'s',
   (u8)'a',
   (u8)'S',
   (u8)'i',
   (u8)'g',
   (u8)'n',
   (u8)'a',
   (u8)'t',
   (u8)'u',
   (u8)'r',
   (u8)'e',
   (u8)'W',
   (u8)'i',
   (u8)'t',
   (u8)'h',
   (u8)'r',
   (u8)'i',
   (u8)'p',
   (u8)'e',
   (u8)'m',
   (u8)'d',
   (u8)'1',
   (u8)'6',
   (u8)'0',
   (u8)'\000'};
static u8 const _rsa_ripemd160_printable_oid[15] =
  {(u8)'1',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'3',
   (u8)'6',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'2',
   (u8)'\000'};
static u8 const _rsa_ripemd160_der_oid[8] =
  {(u8)0x06,
   (u8)0x06,
   (u8)0x2b,
   (u8)0x24,
   (u8)0x03,
   (u8)0x03,
   (u8)0x01,
   (u8)0x02};
static _alg_id const _rsa_ripemd160_alg =
  {.alg_name = _rsa_ripemd160_name,
   .alg_printable_oid = _rsa_ripemd160_printable_oid,
   .alg_der_oid = _rsa_ripemd160_der_oid,
   .alg_der_oid_len = (u8)sizeof(_rsa_ripemd160_der_oid),
   .alg_type = (u8)ALG_SIG,
   .parse_sig = & parse_sig_generic,
   .parse_subjectpubkey = (int (*)(u8 const *buf, u16 len, alg_param *param))0,
   .parse_algoid_params = & parse_algoid_params_generic};
static u8 const _weird1_name[17] =
  {(u8)'w',
   (u8)'e',
   (u8)'i',
   (u8)'r',
   (u8)'d',
   (u8)'1',
   (u8)'-',
   (u8)'a',
   (u8)'v',
   (u8)'e',
   (u8)'s',
   (u8)'t',
   (u8)'-',
   (u8)'p',
   (u8)'l',
   (u8)'c',
   (u8)'\000'};
static u8 const _weird1_printable_oid[23] =
  {(u8)'1',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'6',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'4',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'1',
   (u8)'2',
   (u8)'6',
   (u8)'5',
   (u8)'6',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'3',
   (u8)'6',
   (u8)'\000'};
static u8 const _weird1_der_oid[11] =
  {(u8)0x06,
   (u8)0x09,
   (u8)0x2b,
   (u8)0x06,
   (u8)0x01,
   (u8)0x04,
   (u8)0x01,
   (u8)0xe2,
   (u8)0x70,
   (u8)0x01,
   (u8)0x24};
static _alg_id const _weird1_alg =
  {.alg_name = _weird1_name,
   .alg_printable_oid = _weird1_printable_oid,
   .alg_der_oid = _weird1_der_oid,
   .alg_der_oid_len = (u8)sizeof(_weird1_der_oid),
   .alg_type = (u8)ALG_SIG,
   .parse_sig = & parse_sig_generic,
   .parse_subjectpubkey = (int (*)(u8 const *buf, u16 len, alg_param *param))0,
   .parse_algoid_params = & parse_algoid_params_generic};
static u8 const _weird2_name[17] =
  {(u8)'w',
   (u8)'e',
   (u8)'i',
   (u8)'r',
   (u8)'d',
   (u8)'2',
   (u8)'-',
   (u8)'a',
   (u8)'v',
   (u8)'e',
   (u8)'s',
   (u8)'t',
   (u8)'-',
   (u8)'p',
   (u8)'l',
   (u8)'c',
   (u8)'\000'};
static u8 const _weird2_printable_oid[23] =
  {(u8)'1',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'6',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'4',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'1',
   (u8)'2',
   (u8)'6',
   (u8)'5',
   (u8)'6',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'4',
   (u8)'0',
   (u8)'\000'};
static u8 const _weird2_der_oid[11] =
  {(u8)0x06,
   (u8)0x09,
   (u8)0x2b,
   (u8)0x06,
   (u8)0x01,
   (u8)0x04,
   (u8)0x01,
   (u8)0xe2,
   (u8)0x70,
   (u8)0x01,
   (u8)0x28};
static _alg_id const _weird2_alg =
  {.alg_name = _weird2_name,
   .alg_printable_oid = _weird2_printable_oid,
   .alg_der_oid = _weird2_der_oid,
   .alg_der_oid_len = (u8)sizeof(_weird2_der_oid),
   .alg_type = (u8)ALG_SIG,
   .parse_sig = & parse_sig_generic,
   .parse_subjectpubkey = (int (*)(u8 const *buf, u16 len, alg_param *param))0,
   .parse_algoid_params = & parse_algoid_params_generic};
static u8 const _weird3_name[17] =
  {(u8)'w',
   (u8)'e',
   (u8)'i',
   (u8)'r',
   (u8)'d',
   (u8)'3',
   (u8)'-',
   (u8)'a',
   (u8)'v',
   (u8)'e',
   (u8)'s',
   (u8)'t',
   (u8)'-',
   (u8)'p',
   (u8)'l',
   (u8)'c',
   (u8)'\000'};
static u8 const _weird3_printable_oid[23] =
  {(u8)'1',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'6',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'4',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'1',
   (u8)'2',
   (u8)'6',
   (u8)'5',
   (u8)'6',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'4',
   (u8)'3',
   (u8)'\000'};
static u8 const _weird3_der_oid[11] =
  {(u8)0x06,
   (u8)0x09,
   (u8)0x2b,
   (u8)0x06,
   (u8)0x01,
   (u8)0x04,
   (u8)0x01,
   (u8)0xe2,
   (u8)0x70,
   (u8)0x01,
   (u8)0x2b};
static _alg_id const _weird3_alg =
  {.alg_name = _weird3_name,
   .alg_printable_oid = _weird3_printable_oid,
   .alg_der_oid = _weird3_der_oid,
   .alg_der_oid_len = (u8)sizeof(_weird3_der_oid),
   .alg_type = (u8)ALG_SIG,
   .parse_sig = & parse_sig_generic,
   .parse_subjectpubkey = (int (*)(u8 const *buf, u16 len, alg_param *param))0,
   .parse_algoid_params = & parse_algoid_params_generic};
static _alg_id const *known_algs[27] =
  {& _ecdsa_sha1_alg,
   & _ecdsa_sha224_alg,
   & _ecdsa_sha256_alg,
   & _ecdsa_sha384_alg,
   & _ecdsa_sha512_alg,
   & _ecpublickey_alg,
   & _rsa_md2_alg,
   & _rsa_md4_alg,
   & _rsa_md5_alg,
   & _rsa_sha1_alg,
   & _rsa_sha224_alg,
   & _rsa_sha256_alg,
   & _rsa_sha384_alg,
   & _rsa_sha512_alg,
   & _dsa_sha1_alg,
   & _pkcs1_rsaEncryption_alg,
   & _rsassapss_alg,
   & _odd1_alg,
   & _odd2_alg,
   & _odd3_alg,
   & _odd4_alg,
   & _gost1_alg,
   & _gost2_alg,
   & _rsa_ripemd160_alg,
   & _weird1_alg,
   & _weird2_alg,
   & _weird3_alg};
/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(param);
    requires \separated(param, buf + (..));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \old(buf) ≢ \null ∧ \old(len) ≡ 0 ⇒ \result ≡ 0;
    ensures \old(len) ≢ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    ensures \result ≡ 0 ⇒ \old(param)->ecdsa_no_param ≡ 1;
    assigns param->ecdsa_no_param;
 */
static int parse_algoid_params_ecdsa_with(u8 const *buf, u16 len,
                                          alg_param *param)
{
  int ret;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len != 0) _LOR: ret = -1716;
    else {
      param->ecdsa_no_param = 1;
      ret = 0;
    }
  return ret;
}

static u8 const _curve_secp256r1_name[10] =
  {(u8)'s',
   (u8)'e',
   (u8)'c',
   (u8)'p',
   (u8)'2',
   (u8)'5',
   (u8)'6',
   (u8)'r',
   (u8)'1',
   (u8)'\000'};
static u8 const _curve_secp256r1_printable_oid[20] =
  {(u8)'1',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'8',
   (u8)'4',
   (u8)'0',
   (u8)'.',
   (u8)'1',
   (u8)'0',
   (u8)'0',
   (u8)'4',
   (u8)'5',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'7',
   (u8)'\000'};
static u8 const _curve_secp256r1_der_oid[10] =
  {(u8)0x06,
   (u8)0x08,
   (u8)0x2a,
   (u8)0x86,
   (u8)0x48,
   (u8)0xce,
   (u8)0x3d,
   (u8)0x03,
   (u8)0x01,
   (u8)0x07};
static _curve const _curve_secp256r1 =
  {.crv_name = _curve_secp256r1_name,
   .crv_printable_oid = _curve_secp256r1_printable_oid,
   .crv_der_oid = _curve_secp256r1_der_oid,
   .crv_der_oid_len = (u8)sizeof(_curve_secp256r1_der_oid),
   .crv_order_bit_len = (u16)256};
static u8 const _curve_secp384r1_name[10] =
  {(u8)'s',
   (u8)'e',
   (u8)'c',
   (u8)'p',
   (u8)'3',
   (u8)'8',
   (u8)'4',
   (u8)'r',
   (u8)'1',
   (u8)'\000'};
static u8 const _curve_secp384r1_printable_oid[13] =
  {(u8)'1',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'1',
   (u8)'3',
   (u8)'2',
   (u8)'.',
   (u8)'0',
   (u8)'.',
   (u8)'3',
   (u8)'4',
   (u8)'\000'};
static u8 const _curve_secp384r1_der_oid[7] =
  {(u8)0x06, (u8)0x05, (u8)0x2b, (u8)0x81, (u8)0x04, (u8)0x00, (u8)0x22};
static _curve const _curve_secp384r1 =
  {.crv_name = _curve_secp384r1_name,
   .crv_printable_oid = _curve_secp384r1_printable_oid,
   .crv_der_oid = _curve_secp384r1_der_oid,
   .crv_der_oid_len = (u8)sizeof(_curve_secp384r1_der_oid),
   .crv_order_bit_len = (u16)384};
static u8 const _curve_secp521r1_name[10] =
  {(u8)'s',
   (u8)'e',
   (u8)'c',
   (u8)'p',
   (u8)'5',
   (u8)'2',
   (u8)'1',
   (u8)'r',
   (u8)'1',
   (u8)'\000'};
static u8 const _curve_secp521r1_printable_oid[13] =
  {(u8)'1',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'1',
   (u8)'3',
   (u8)'2',
   (u8)'.',
   (u8)'0',
   (u8)'.',
   (u8)'3',
   (u8)'5',
   (u8)'\000'};
static u8 const _curve_secp521r1_der_oid[7] =
  {(u8)0x06, (u8)0x05, (u8)0x2b, (u8)0x81, (u8)0x04, (u8)0x00, (u8)0x23};
static _curve const _curve_secp521r1 =
  {.crv_name = _curve_secp521r1_name,
   .crv_printable_oid = _curve_secp521r1_printable_oid,
   .crv_der_oid = _curve_secp521r1_der_oid,
   .crv_der_oid_len = (u8)sizeof(_curve_secp521r1_der_oid),
   .crv_order_bit_len = (u16)521};
static u8 const _curve_brainpoolP256R1_name[16] =
  {(u8)'b',
   (u8)'r',
   (u8)'a',
   (u8)'i',
   (u8)'n',
   (u8)'p',
   (u8)'o',
   (u8)'o',
   (u8)'l',
   (u8)'P',
   (u8)'2',
   (u8)'5',
   (u8)'6',
   (u8)'R',
   (u8)'1',
   (u8)'\000'};
static u8 const _curve_brainpoolP256R1_printable_oid[21] =
  {(u8)'1',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'3',
   (u8)'6',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'8',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'7',
   (u8)'\000'};
static u8 const _curve_brainpoolP256R1_der_oid[11] =
  {(u8)0x06,
   (u8)0x05,
   (u8)0x2b,
   (u8)0x24,
   (u8)0x03,
   (u8)0x03,
   (u8)0x02,
   (u8)0x08,
   (u8)0x01,
   (u8)0x01,
   (u8)0x07};
static _curve const _curve_brainpoolP256R1 =
  {.crv_name = _curve_brainpoolP256R1_name,
   .crv_printable_oid = _curve_brainpoolP256R1_printable_oid,
   .crv_der_oid = _curve_brainpoolP256R1_der_oid,
   .crv_der_oid_len = (u8)sizeof(_curve_brainpoolP256R1_der_oid),
   .crv_order_bit_len = (u16)256};
static u8 const _curve_brainpoolP384R1_name[16] =
  {(u8)'b',
   (u8)'r',
   (u8)'a',
   (u8)'i',
   (u8)'n',
   (u8)'p',
   (u8)'o',
   (u8)'o',
   (u8)'l',
   (u8)'P',
   (u8)'3',
   (u8)'8',
   (u8)'4',
   (u8)'R',
   (u8)'1',
   (u8)'\000'};
static u8 const _curve_brainpoolP384R1_printable_oid[22] =
  {(u8)'1',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'3',
   (u8)'6',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'8',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'1',
   (u8)'1',
   (u8)'\000'};
static u8 const _curve_brainpoolP384R1_der_oid[11] =
  {(u8)0x06,
   (u8)0x05,
   (u8)0x2b,
   (u8)0x24,
   (u8)0x03,
   (u8)0x03,
   (u8)0x02,
   (u8)0x08,
   (u8)0x01,
   (u8)0x01,
   (u8)0x0b};
static _curve const _curve_brainpoolP384R1 =
  {.crv_name = _curve_brainpoolP384R1_name,
   .crv_printable_oid = _curve_brainpoolP384R1_printable_oid,
   .crv_der_oid = _curve_brainpoolP384R1_der_oid,
   .crv_der_oid_len = (u8)sizeof(_curve_brainpoolP384R1_der_oid),
   .crv_order_bit_len = (u16)384};
static u8 const _curve_brainpoolP512R1_name[16] =
  {(u8)'b',
   (u8)'r',
   (u8)'a',
   (u8)'i',
   (u8)'n',
   (u8)'p',
   (u8)'o',
   (u8)'o',
   (u8)'l',
   (u8)'P',
   (u8)'5',
   (u8)'1',
   (u8)'2',
   (u8)'R',
   (u8)'1',
   (u8)'\000'};
static u8 const _curve_brainpoolP512R1_printable_oid[22] =
  {(u8)'1',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'3',
   (u8)'6',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'3',
   (u8)'.',
   (u8)'2',
   (u8)'.',
   (u8)'8',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'1',
   (u8)'.',
   (u8)'1',
   (u8)'3',
   (u8)'\000'};
static u8 const _curve_brainpoolP512R1_der_oid[11] =
  {(u8)0x06,
   (u8)0x05,
   (u8)0x2b,
   (u8)0x24,
   (u8)0x03,
   (u8)0x03,
   (u8)0x02,
   (u8)0x08,
   (u8)0x01,
   (u8)0x01,
   (u8)0x0d};
static _curve const _curve_brainpoolP512R1 =
  {.crv_name = _curve_brainpoolP512R1_name,
   .crv_printable_oid = _curve_brainpoolP512R1_printable_oid,
   .crv_der_oid = _curve_brainpoolP512R1_der_oid,
   .crv_der_oid_len = (u8)sizeof(_curve_brainpoolP512R1_der_oid),
   .crv_order_bit_len = (u16)512};
static _curve const *known_curves[6] =
  {& _curve_secp256r1,
   & _curve_secp384r1,
   & _curve_secp521r1,
   & _curve_brainpoolP256R1,
   & _curve_brainpoolP384R1,
   & _curve_brainpoolP512R1};
/*@ requires len ≥ 0;
    requires
      len > 0 ∧ buf ≢ (u8 const *)0 ⇒ \valid_read(buf + (0 .. len - 1));
    ensures
      \result ≢ (_curve const *)0 ⇒
      (∃ ℤ i;
         0 ≤ i < sizeof(known_curves) / sizeof(known_curves[0]) ∧
         \result ≡ known_curves[i]);
    ensures \old(len) ≡ 0 ⇒ \result ≡ (_curve const *)0;
    ensures \old(buf) ≡ (u8 const *)0 ⇒ \result ≡ (_curve const *)0;
    assigns \nothing;
 */
static _curve const *find_curve_by_oid(u8 const *buf, u16 len)
{
  u8 k;
  _curve const *found = (_curve const *)0;
  _curve const *cur = (_curve const *)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) _LOR: goto out;
  k = (u8)0;
  /*@ loop invariant
        0 ≤ k ≤ sizeof(known_curves) / sizeof(known_curves[0]);
      loop invariant found ≡ (_curve const *)0;
      loop assigns cur, found, k;
      loop variant sizeof(known_curves) / sizeof(known_curves[0]) - k;
  */
  while ((unsigned long)k < sizeof(known_curves) / sizeof(known_curves[0])) {
    {
      int ret;
      int tmp_0;
      int tmp;
      cur = known_curves[k];
      /*@ assert cur ≡ known_curves[k]; */ ;
      if ((int)cur->crv_der_oid_len != (int)len) goto __Cont;
      /*@ assert \valid_read(buf + (0 .. len - 1)); */ ;
      tmp = bufs_differ(cur->crv_der_oid,buf,(u16)cur->crv_der_oid_len);
      if (tmp) tmp_0 = 0; else tmp_0 = 1;
      ret = tmp_0;
      if (ret) {
        found = cur;
        break;
      }
    }
    __Cont: k = (u8)((int)k + 1);
  }
  out: ;
  return found;
}

static u8 const null_encoded_val[2] = {(u8)0x05, (u8)0x00};
/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(param);
    requires \separated(param, buf + (..));
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \result < 0 ∨ \result ≡ 0;
    ensures
      \result ≡ 0 ⇒
      (∃ ℤ i;
         0 ≤ i < sizeof(known_curves) / sizeof(known_curves[0]) ∧
         \old(param)->curve_param ≡ known_curves[i]);
    assigns param->curve_param;
 */
static int parse_algoid_params_ecPublicKey(u8 const *buf, u16 len,
                                           alg_param *param)
{
  int ret;
  _curve const *curve = (_curve const *)0;
  u16 oid_len = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -1885;
              goto out;
            }
    }
  ret = parse_OID(buf,len,& oid_len);
  if (ret) goto out;
  if ((int)oid_len != (int)len) {
    ret = -1930;
    goto out;
  }
  curve = find_curve_by_oid(buf,oid_len);
  if (curve == (_curve const *)0) {
    ret = -1938;
    goto out;
  }
  param->curve_param = curve;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \initialized(&param->curve_param);
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int parse_subjectpubkey_ec(u8 const *buf, u16 len, alg_param *param)
{
  u16 remain;
  u16 order_ceil_len;
  int ret;
  u8 pc;
  u16 hdr_len = (u16)0;
  u16 data_len = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -1993;
              goto out;
            }
    }
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_BIT_STRING,
                     & hdr_len,& data_len);
  if (ret) goto out;
  if ((int)data_len == 0) {
    ret = -2012;
    goto out;
  }
  buf += (int)hdr_len;
  if ((int)*(buf + 0) != 0) {
    ret = -2025;
    goto out;
  }
  buf ++;
  remain = (u16)((int)data_len - 1);
  if ((int)remain == 0) {
    ret = -2042;
    goto out;
  }
  pc = *(buf + 0);
  remain = (u16)((int)remain - 1);
  buf ++;
  if (param->curve_param == (_curve const *)0) {
    ret = -2057;
    goto out;
  }
  order_ceil_len = (u16)(((int)(param->curve_param)->crv_order_bit_len + 7) / 8);
  switch ((int)pc) {
    case 0x04: ;
    if ((int)remain != (int)order_ceil_len * 2) {
      ret = -2071;
      goto out;
    }
    break;
    case 0x02: case 0x03: ;
    if ((int)remain != (int)order_ceil_len) {
      ret = -2079;
      goto out;
    }
    break;
    default: ret = -2085;
    goto out;
    break;
  }
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires param ≢ \null ⇒ \valid_read(param);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    ensures \old(param) ≡ \null ⇒ \result < 0;
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \result ≡ 0 ⇒ \old(param)->unparsed_param ≡ 1;
    assigns param->unparsed_param;
 */
static int parse_algoid_params_generic(u8 const *buf, u16 len,
                                       alg_param *param)
{
  int ret;
  if ((int)len == 0) goto _LOR;
  else 
    if (buf == (u8 const *)0) goto _LOR;
    else 
      if (param == (alg_param *)0) {
        _LOR: {
                ret = -2119;
                goto out;
              }
      }
  param->unparsed_param = 1;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires param ≢ \null ⇒ \valid_read(param);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    ensures \old(param) ≡ \null ⇒ \result < 0;
    ensures \result < 0 ∨ \result ≡ 0;
    ensures
      \result ≡ 0 ⇒
      \old(param)->null_param ≡ (u8 const *)null_encoded_val;
    assigns param->null_param;
 */
static int parse_algoid_params_rsa(u8 const *buf, u16 len, alg_param *param)
{
  int ret;
  if ((int)len == 0) goto _LOR;
  else 
    if (buf == (u8 const *)0) goto _LOR;
    else 
      if (param == (alg_param *)0) {
        _LOR: {
                ret = -2147;
                goto out;
              }
      }
  if ((unsigned long)len != sizeof(null_encoded_val)) {
    ret = -2161;
    goto out;
  }
  ret = bufs_differ(buf,null_encoded_val,(u16)sizeof(null_encoded_val));
  if (ret) {
    ret = -2168;
    goto out;
  }
  param->null_param = null_encoded_val;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \initialized(&param->null_param);
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int parse_subjectpubkey_rsa(u8 const *buf, u16 len, alg_param *param)
{
  u16 remain;
  int ret;
  u16 hdr_len = (u16)0;
  u16 data_len = (u16)0;
  u16 eaten = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -2213;
              goto out;
            }
    }
  if (param->null_param != null_encoded_val) {
    ret = -2219;
    goto out;
  }
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_BIT_STRING,
                     & hdr_len,& data_len);
  if (ret) goto out;
  if ((int)data_len == 0) {
    ret = -2238;
    goto out;
  }
  buf += (int)hdr_len;
  if ((int)*(buf + 0) != 0) {
    ret = -2251;
    goto out;
  }
  buf ++;
  remain = (u16)((int)data_len - 1);
  ret = parse_id_len(buf,remain,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & hdr_len,& data_len);
  if (ret) goto out;
  buf += (int)hdr_len;
  remain = data_len;
  ret = parse_integer(buf,remain,CLASS_UNIVERSAL,(u32)ASN1_TYPE_INTEGER,
                      & eaten);
  if (ret) goto out;
  remain = (u16)((int)remain - (int)eaten);
  buf += (int)eaten;
  ret = parse_integer(buf,remain,CLASS_UNIVERSAL,(u32)ASN1_TYPE_INTEGER,
                      & eaten);
  if (ret) goto out;
  remain = (u16)((int)remain - (int)eaten);
  if ((int)remain != 0) {
    ret = -2294;
    goto out;
  }
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires
      len > 0 ∧ buf ≢ (u8 const *)0 ⇒ \valid_read(buf + (0 .. len - 1));
    ensures
      \result ≢ (_alg_id const *)0 ⇒
      (∃ ℤ i;
         0 ≤ i < sizeof(known_algs) / sizeof(known_algs[0]) ∧
         \result ≡ known_algs[i]);
    ensures \old(len) ≡ 0 ⇒ \result ≡ (_alg_id const *)0;
    ensures \old(buf) ≡ (u8 const *)0 ⇒ \result ≡ (_alg_id const *)0;
    assigns \nothing;
 */
static _alg_id const *find_alg_by_oid(u8 const *buf, u16 len)
{
  u8 k;
  _alg_id const *found = (_alg_id const *)0;
  _alg_id const *cur = (_alg_id const *)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) _LOR: goto out;
  k = (u8)0;
  /*@ loop invariant 0 ≤ k ≤ sizeof(known_algs) / sizeof(known_algs[0]);
      loop invariant found ≡ (_alg_id const *)0;
      loop assigns cur, found, k;
      loop variant sizeof(known_algs) / sizeof(known_algs[0]) - k;
      loop unroll sizeof(known_algs) / sizeof(known_algs[0]);
  */
  while ((unsigned long)k < sizeof(known_algs) / sizeof(known_algs[0])) {
    {
      int ret;
      int tmp_0;
      int tmp;
      cur = known_algs[k];
      /*@ assert cur ≡ known_algs[k]; */ ;
      if ((int)cur->alg_der_oid_len != (int)len) goto __Cont;
      /*@ assert \valid_read(buf + (0 .. len - 1)); */ ;
      tmp = bufs_differ(cur->alg_der_oid,buf,(u16)cur->alg_der_oid_len);
      if (tmp) tmp_0 = 0; else tmp_0 = 1;
      ret = tmp_0;
      if (ret) {
        found = cur;
        break;
      }
    }
    __Cont: k = (u8)((int)k + 1);
  }
  out: ;
  return found;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(param);
    requires \valid(alg);
    requires \separated(buf, alg, param, eaten);
    ensures \result < 0 ∨ \result ≡ 0;
    ensures
      \result ≡ 0 ⇒ (∃ unsigned char x; *\old(alg) ≡ known_algs[x]);
    ensures \result ≡ 0 ⇒ 1 < *\old(eaten) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    ensures \result ≡ 0 ⇒ \valid_read(*\old(alg));
    assigns *alg, *eaten, *param;
 */
static int parse_x509_AlgorithmIdentifier(u8 const *buf, u16 len,
                                          _alg_id const **alg,
                                          alg_param *param, u16 *eaten)
{
  u16 param_len;
  int ret;
  _alg_id const *talg = (_alg_id const *)0;
  u16 hdr_len = (u16)0;
  u16 data_len = (u16)0;
  u16 oid_len = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -2387;
              goto out;
            }
    }
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & hdr_len,& data_len);
  if (ret) goto out;
  buf += (int)hdr_len;
  ret = parse_OID(buf,data_len,& oid_len);
  if (ret) goto out;
  talg = find_alg_by_oid(buf,oid_len);
  if (talg == (_alg_id const *)0) {
    ret = -2412;
    goto out;
  }
  /*@ assert \valid_read(talg); */ ;
  buf += (int)oid_len;
  param_len = (u16)((int)data_len - (int)oid_len);
  /*@
  assert
  talg->parse_algoid_params ∈
  {&parse_algoid_params_generic, &parse_algoid_params_ecdsa_with,
   &parse_algoid_params_ecPublicKey, &parse_algoid_params_rsa}; */
  ;
  /*@ calls parse_algoid_params_generic, parse_algoid_params_ecdsa_with,
            parse_algoid_params_ecPublicKey, parse_algoid_params_rsa;
  */
  ret = (*(talg->parse_algoid_params))(buf,param_len,param);
  if (ret) goto out;
  *alg = talg;
  *eaten = (u16)((int)hdr_len + (int)data_len);
  ret = 0;
  out: ;
  return ret;
}

static u8 const _dn_oid_cn[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x04, (u8)0x03};
static u8 const _dn_oid_surname[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x04, (u8)0x04};
static u8 const _dn_oid_serial[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x04, (u8)0x05};
static u8 const _dn_oid_country[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x04, (u8)0x06};
static u8 const _dn_oid_locality[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x04, (u8)0x07};
static u8 const _dn_oid_state[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x04, (u8)0x08};
static u8 const _dn_oid_org[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x04, (u8)0x0a};
static u8 const _dn_oid_org_unit[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x04, (u8)0x0b};
static u8 const _dn_oid_title[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x04, (u8)0x0c};
static u8 const _dn_oid_name[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x04, (u8)0x29};
static u8 const _dn_oid_given_name[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x04, (u8)0x2a};
static u8 const _dn_oid_initials[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x04, (u8)0x2b};
static u8 const _dn_oid_gen_qual[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x04, (u8)0x2c};
static u8 const _dn_oid_dn_qual[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x04, (u8)0x2e};
static u8 const _dn_oid_pseudo[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x04, (u8)0x41};
static u8 const _dn_oid_dc[12] =
  {(u8)0x06,
   (u8)0x0a,
   (u8)0x09,
   (u8)0x92,
   (u8)0x26,
   (u8)0x89,
   (u8)0x93,
   (u8)0xf2,
   (u8)0x2c,
   (u8)0x64,
   (u8)0x01,
   (u8)0x19};
/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int check_utf8_string(u8 const *buf, u16 len)
{
  int ret;
  u8 b0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -2475;
              goto out;
            }
    }
  /*@ loop invariant \valid_read(buf + (0 .. len - 1));
      loop assigns b0, len, buf, ret;
      loop variant len;
  */
  while (len) {
    b0 = *(buf + 0);
    if ((int)b0 <= 0x7f) {
      len = (u16)((int)len - 1);
      buf ++;
      continue;
    }
    if ((int)b0 >= 0xc2) 
      if ((int)b0 <= 0xdf) {
        if ((int)len < 2) {
          ret = -2506;
          goto out;
        }
        /*@ assert \valid_read(buf + (0 .. 1)); */ ;
        if (((int)*(buf + 1) & 0xc0) != 0x80) {
          ret = -2513;
          goto out;
        }
        len = (u16)((int)len - 2);
        buf += 2;
        continue;
      }
    if ((int)b0 >= 0xe0) 
      if ((int)b0 <= 0xef) {
        if ((int)len < 3) {
          ret = -2530;
          goto out;
        }
        /*@ assert \valid_read(buf + (0 .. 2)); */ ;
        if (((int)*(buf + 1) & 0xc0) != 0x80) goto _LOR_0;
        else 
          if (((int)*(buf + 2) & 0xc0) != 0x80) {
            _LOR_0: {
                      ret = -2538;
                      goto out;
                    }
          }
        if ((int)b0 == 0xe0) {
          if ((int)*(buf + 1) < 0xa0) goto _LOR_2;
          else 
            if ((int)*(buf + 1) > 0xbf) {
              _LOR_2: {
                        ret = -2549;
                        goto out;
                      }
            }
            else goto _LAND;
        }
        else {
          _LAND: ;
          if ((int)b0 == 0xed) 
            if ((int)*(buf + 1) < 0x80) goto _LOR_1;
            else 
              if ((int)*(buf + 1) > 0x9f) {
                _LOR_1: {
                          ret = -2554;
                          goto out;
                        }
              }
        }
        len = (u16)((int)len - 3);
        buf += 3;
        continue;
      }
    if ((int)b0 >= 0xf0) 
      if ((int)b0 <= 0xf4) {
        if ((int)len < 4) {
          ret = -2571;
          goto out;
        }
        /*@ assert \valid_read(buf + (0 .. 3)); */ ;
        if ((int)b0 == 0xf0) {
          if ((int)*(buf + 1) < 0x90) goto _LOR_4;
          else 
            if ((int)*(buf + 1) > 0xbf) {
              _LOR_4: {
                        ret = -2583;
                        goto out;
                      }
            }
            else goto _LAND_0;
        }
        else {
          _LAND_0: ;
          if ((int)b0 == 0xf4) 
            if ((int)*(buf + 1) < 0x80) goto _LOR_3;
            else 
              if ((int)*(buf + 1) > 0x8f) {
                _LOR_3: {
                          ret = -2588;
                          goto out;
                        }
              }
        }
        if (((int)*(buf + 1) & 0xc0) != 0x80) goto _LOR_5;
        else 
          if (((int)*(buf + 2) & 0xc0) != 0x80) goto _LOR_5;
          else 
            if (((int)*(buf + 3) & 0xc0) != 0x80) {
              _LOR_5: {
                        ret = -2596;
                        goto out;
                      }
            }
        len = (u16)((int)len - 4);
        buf += 4;
        continue;
      }
    ret = -2606;
    goto out;
  }
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int check_printable_string(u8 const *buf, u16 len)
{
  int ret;
  u16 rbytes;
  u8 c;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -2642;
              goto out;
            }
    }
  rbytes = (u16)0;
  /*@ loop invariant 0 ≤ rbytes ≤ len;
      loop assigns rbytes, c, ret;
      loop variant len - rbytes;
  */
  while ((int)rbytes < (int)len) {
    c = *(buf + rbytes);
    if ((int)c >= 'a') {
      if ((int)c <= 'z') goto _LOR_0; else goto _LAND_0;
    }
    else {
      _LAND_0: ;
      if ((int)c >= 'A') {
        if ((int)c <= 'Z') goto _LOR_0; else goto _LAND;
      }
      else {
        _LAND: ;
        if ((int)c >= '0') 
          if ((int)c <= '9') _LOR_0: goto __Cont;
      }
    }
    switch ((int)c) {
      case 39: case '=': case '(': case ')': case '+': case ',': case '-':
      case '.': case '/': case ':': case '?': case ' ':
      goto __Cont;
      default: break;
    }
    ret = -2679;
    goto out;
    __Cont: rbytes = (u16)((int)rbytes + 1);
  }
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int check_visible_string(u8 const *buf, u16 len)
{
  int ret;
  u8 c;
  u16 rbytes = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -2708;
              goto out;
            }
    }
  /*@ loop assigns rbytes, c, ret;
      loop variant len - rbytes; */
  while ((int)rbytes < (int)len) {
    c = *(buf + rbytes);
    if ((int)c >= 'a') {
      if ((int)c <= 'z') goto _LOR_0; else goto _LAND_0;
    }
    else {
      _LAND_0: ;
      if ((int)c >= 'A') {
        if ((int)c <= 'Z') goto _LOR_0; else goto _LAND;
      }
      else {
        _LAND: ;
        if ((int)c >= '0') 
          if ((int)c <= '9') {
            _LOR_0: {
                      rbytes = (u16)((int)rbytes + 1);
                      continue;
                    }
          }
      }
    }
    switch ((int)c) {
      case 39: case '=': case '(': case ')': case '+': case ',': case '-':
      case '.': case '/': case ':': case '?': case ' ': case '!': case '\"':
      case '#': case '$': case '%': case '&': case '*': case ';': case '<':
      case '>': case '[': case '\\': case ']': case '^': case '_': case '`':
      case '{': case '|': case '}': case '~':
      rbytes = (u16)((int)rbytes + 1);
      continue;
      default: break;
    }
    ret = -2766;
    goto out;
  }
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int check_teletex_string(u8 const *buf, u16 len)
{
  int __retres;
  __retres = -2790;
  return __retres;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int check_universal_string(u8 const *buf, u16 len)
{
  int __retres;
  __retres = -2805;
  return __retres;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int check_bmp_string(u8 const *buf, u16 len)
{
  int __retres;
  __retres = -2820;
  return __retres;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures
      \result ≡ 0 ⇒
      \old(len) ≥ 2 ∧ \old(lb) ≤ \old(len) - 2 ≤ \old(ub);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int parse_directory_string(u8 const *buf, u16 len, u16 lb, u16 ub)
{
  u8 str_type;
  int ret = -2863;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -2867;
              goto out;
            }
    }
  if ((int)len < 2) {
    ret = -2873;
    goto out;
  }
  str_type = *(buf + 0);
  len = (u16)((int)len - 2);
  if ((int)*(buf + 1) != (int)len) {
    ret = -2882;
    goto out;
  }
  buf += 2;
  if ((int)len < (int)lb) goto _LOR_0;
  else 
    if ((int)len > (int)ub) {
      _LOR_0: {
                ret = -2889;
                goto out;
              }
    }
  switch ((int)str_type) {
    case 19: ret = check_printable_string(buf,len);
    if (ret) ;
    break;
    case 12: ret = check_utf8_string(buf,len);
    if (ret) ;
    break;
    case 20: ret = check_teletex_string(buf,len);
    if (ret) ;
    break;
    case 28: ret = check_universal_string(buf,len);
    if (ret) ;
    break;
    case 30: ret = check_bmp_string(buf,len);
    if (ret) ;
    break;
    default: ret = -2933;
    break;
  }
  if (ret) goto out;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures
      \result ≡ 0 ⇒
      \old(len) ≥ 2 ∧ \old(lb) ≤ \old(len) - 2 ≤ \old(ub);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int parse_printable_string(u8 const *buf, u16 len, u16 lb, u16 ub)
{
  u8 str_type;
  int ret = -2964;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -2968;
              goto out;
            }
    }
  if ((int)len < 2) {
    ret = -2974;
    goto out;
  }
  str_type = *(buf + 0);
  if ((int)str_type != 19) {
    ret = -2981;
    goto out;
  }
  len = (u16)((int)len - 2);
  if ((int)*(buf + 1) != (int)len) {
    ret = -2988;
    goto out;
  }
  buf += 2;
  if ((int)len < (int)lb) goto _LOR_0;
  else 
    if ((int)len > (int)ub) {
      _LOR_0: {
                ret = -2995;
                goto out;
              }
    }
  ret = check_printable_string(buf,len);
  if (ret) goto out;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int check_ia5_string(u8 const *buf, u16 len)
{
  int ret;
  u16 i;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -3026;
              goto out;
            }
    }
  i = (u16)0;
  /*@ loop invariant ∀ ℤ x; 0 ≤ x < i ⇒ *(buf + x) ≤ 0x7f;
      loop assigns i;
      loop variant len - i;
  */
  while ((int)i < (int)len) {
    if ((int)*(buf + i) > 0x7f) {
      ret = -3039;
      goto out;
    }
    i = (u16)((int)i + 1);
  }
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures
      \result ≡ 0 ⇒
      \old(len) ≥ 2 ∧ \old(lb) ≤ \old(len) - 2 ≤ \old(ub);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int parse_ia5_string(u8 const *buf, u16 len, u16 lb, u16 ub)
{
  u8 str_type;
  int ret = -3066;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -3070;
              goto out;
            }
    }
  if ((int)len < 2) {
    ret = -3076;
    goto out;
  }
  str_type = *(buf + 0);
  if ((int)str_type != 22) {
    ret = -3083;
    goto out;
  }
  len = (u16)((int)len - 2);
  if ((int)*(buf + 1) != (int)len) {
    ret = -3090;
    goto out;
  }
  buf += 2;
  if ((int)len < (int)lb) goto _LOR_0;
  else 
    if ((int)len > (int)ub) {
      _LOR_0: {
                ret = -3097;
                goto out;
              }
    }
  ret = check_ia5_string(buf,len);
  if (ret) goto out;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int parse_rdn_val_cn(u8 const *buf, u16 len)
{
  int tmp;
  tmp = parse_directory_string(buf,len,(u16)1,(u16)64);
  return tmp;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int parse_rdn_val_x520name(u8 const *buf, u16 len)
{
  int tmp;
  tmp = parse_directory_string(buf,len,(u16)1,(u16)32768);
  return tmp;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int parse_rdn_val_serial(u8 const *buf, u16 len)
{
  int tmp;
  tmp = parse_printable_string(buf,len,(u16)1,(u16)64);
  return tmp;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int parse_rdn_val_country(u8 const *buf, u16 len)
{
  int tmp;
  tmp = parse_directory_string(buf,len,(u16)2,(u16)2);
  return tmp;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int parse_rdn_val_locality(u8 const *buf, u16 len)
{
  int tmp;
  tmp = parse_directory_string(buf,len,(u16)1,(u16)128);
  return tmp;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int parse_rdn_val_state(u8 const *buf, u16 len)
{
  int tmp;
  tmp = parse_directory_string(buf,len,(u16)1,(u16)128);
  return tmp;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int parse_rdn_val_org(u8 const *buf, u16 len)
{
  int tmp;
  tmp = parse_directory_string(buf,len,(u16)1,(u16)64);
  return tmp;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int parse_rdn_val_org_unit(u8 const *buf, u16 len)
{
  int tmp;
  tmp = parse_directory_string(buf,len,(u16)1,(u16)64);
  return tmp;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int parse_rdn_val_title(u8 const *buf, u16 len)
{
  int tmp;
  tmp = parse_directory_string(buf,len,(u16)1,(u16)64);
  return tmp;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int parse_rdn_val_dn_qual(u8 const *buf, u16 len)
{
  int tmp;
  tmp = parse_printable_string(buf,len,(u16)1,(u16)65534);
  return tmp;
}

/*@ assigns \nothing; */
__inline static int _is_digit(u8 c)
{
  int tmp;
  if ((int)c >= '0') 
    if ((int)c <= '9') tmp = 1; else tmp = 0;
  else tmp = 0;
  return tmp;
}

/*@ assigns \nothing; */
__inline static int _is_alpha(u8 c)
{
  int tmp;
  if ((int)c >= 'a') {
    if ((int)c <= 'z') tmp = 1; else goto _LAND;
  }
  else {
    _LAND: ;
    if ((int)c >= 'A') 
      if ((int)c <= 'Z') tmp = 1; else tmp = 0;
    else tmp = 0;
  }
  return tmp;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int parse_rdn_val_dc(u8 const *buf, u16 len)
{
  int ret;
  u16 i;
  u8 c;
  int tmp_1;
  int tmp;
  int tmp_4;
  int tmp_2;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -3323;
              goto out;
            }
    }
  ret = parse_ia5_string(buf,len,(u16)1,(u16)63);
  if (ret) goto out;
  buf += 2;
  len = (u16)((int)len - 2);
  c = *(buf + 0);
  tmp = _is_alpha(c);
  if (tmp) tmp_1 = 1;
  else {
    int tmp_0;
    tmp_0 = _is_digit(c);
    if (tmp_0) tmp_1 = 1; else tmp_1 = 0;
  }
  ret = tmp_1;
  if (! ret) {
    ret = -3342;
    goto out;
  }
  buf ++;
  len = (u16)((int)len - 1);
  if (! len) {
    ret = 0;
    goto out;
  }
  c = *(buf + ((int)len - 1));
  tmp_2 = _is_alpha(c);
  if (tmp_2) tmp_4 = 1;
  else {
    int tmp_3;
    tmp_3 = _is_digit(c);
    if (tmp_3) tmp_4 = 1; else tmp_4 = 0;
  }
  ret = tmp_4;
  if (! ret) {
    ret = -3359;
    goto out;
  }
  buf ++;
  len = (u16)((int)len - 1);
  i = (u16)0;
  /*@ loop invariant 0 ≤ i ≤ len;
      loop assigns c, ret, i;
      loop variant len - i;
  */
  while ((int)i < (int)len) {
    {
      int tmp_7;
      int tmp_5;
      c = *(buf + i);
      tmp_5 = _is_digit(c);
      if (tmp_5) tmp_7 = 1;
      else {
        int tmp_6;
        tmp_6 = _is_alpha(c);
        if (tmp_6) tmp_7 = 1;
        else 
          if ((int)c == '-') tmp_7 = 1; else tmp_7 = 0;
      }
      ret = tmp_7;
      if (! ret) {
        ret = -3377;
        goto out;
      }
    }
    i = (u16)((int)i + 1);
  }
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int parse_rdn_val_pseudo(u8 const *buf, u16 len)
{
  int tmp;
  tmp = parse_directory_string(buf,len,(u16)1,(u16)128);
  return tmp;
}

static _name_oid const known_dn_oids[16] =
  {{.oid = _dn_oid_cn,
    .oid_len = (u8)sizeof(_dn_oid_cn),
    .parse_rdn_val = & parse_rdn_val_cn},
   {.oid = _dn_oid_surname,
    .oid_len = (u8)sizeof(_dn_oid_surname),
    .parse_rdn_val = & parse_rdn_val_x520name},
   {.oid = _dn_oid_serial,
    .oid_len = (u8)sizeof(_dn_oid_serial),
    .parse_rdn_val = & parse_rdn_val_serial},
   {.oid = _dn_oid_country,
    .oid_len = (u8)sizeof(_dn_oid_country),
    .parse_rdn_val = & parse_rdn_val_country},
   {.oid = _dn_oid_locality,
    .oid_len = (u8)sizeof(_dn_oid_locality),
    .parse_rdn_val = & parse_rdn_val_locality},
   {.oid = _dn_oid_state,
    .oid_len = (u8)sizeof(_dn_oid_state),
    .parse_rdn_val = & parse_rdn_val_state},
   {.oid = _dn_oid_org,
    .oid_len = (u8)sizeof(_dn_oid_org),
    .parse_rdn_val = & parse_rdn_val_org},
   {.oid = _dn_oid_org_unit,
    .oid_len = (u8)sizeof(_dn_oid_org_unit),
    .parse_rdn_val = & parse_rdn_val_org_unit},
   {.oid = _dn_oid_title,
    .oid_len = (u8)sizeof(_dn_oid_title),
    .parse_rdn_val = & parse_rdn_val_title},
   {.oid = _dn_oid_name,
    .oid_len = (u8)sizeof(_dn_oid_name),
    .parse_rdn_val = & parse_rdn_val_x520name},
   {.oid = _dn_oid_given_name,
    .oid_len = (u8)sizeof(_dn_oid_given_name),
    .parse_rdn_val = & parse_rdn_val_x520name},
   {.oid = _dn_oid_initials,
    .oid_len = (u8)sizeof(_dn_oid_initials),
    .parse_rdn_val = & parse_rdn_val_x520name},
   {.oid = _dn_oid_gen_qual,
    .oid_len = (u8)sizeof(_dn_oid_gen_qual),
    .parse_rdn_val = & parse_rdn_val_x520name},
   {.oid = _dn_oid_dn_qual,
    .oid_len = (u8)sizeof(_dn_oid_dn_qual),
    .parse_rdn_val = & parse_rdn_val_dn_qual},
   {.oid = _dn_oid_pseudo,
    .oid_len = (u8)sizeof(_dn_oid_pseudo),
    .parse_rdn_val = & parse_rdn_val_pseudo},
   {.oid = _dn_oid_dc,
    .oid_len = (u8)sizeof(_dn_oid_dc),
    .parse_rdn_val = & parse_rdn_val_dc}};
/*@ requires len ≥ 0;
    requires
      len > 0 ∧ buf ≢ (u8 const *)0 ⇒ \valid_read(buf + (0 .. len - 1));
    ensures
      \result ≢ (_name_oid const *)0 ⇒
      (∃ ℤ i;
         0 ≤ i < sizeof(known_dn_oids) / sizeof(known_dn_oids[0]) ∧
         \result ≡ &known_dn_oids[i]);
    ensures \old(len) ≡ 0 ⇒ \result ≡ (_name_oid const *)0;
    ensures \old(buf) ≡ (u8 const *)0 ⇒ \result ≡ (_name_oid const *)0;
    assigns \nothing;
 */
static _name_oid const *find_dn_by_oid(u8 const *buf, u16 len)
{
  u8 k;
  _name_oid const *found = (_name_oid const *)0;
  _name_oid const *cur = (_name_oid const *)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) _LOR: goto out;
  k = (u8)0;
  /*@ loop invariant
        0 ≤ k ≤ sizeof(known_dn_oids) / sizeof(known_dn_oids[0]);
      loop invariant found ≡ (_name_oid const *)0;
      loop assigns cur, found, k;
      loop variant sizeof(known_dn_oids) / sizeof(known_dn_oids[0]) - k;
      loop unroll sizeof(known_dn_oids) / sizeof(known_dn_oids[0]);
  */
  while ((unsigned long)k < sizeof(known_dn_oids) / sizeof(known_dn_oids[0])) {
    {
      int ret;
      int tmp_0;
      int tmp;
      cur = & known_dn_oids[k];
      /*@ assert cur ≡ &known_dn_oids[k]; */ ;
      if ((int)cur->oid_len != (int)len) goto __Cont;
      /*@ assert \valid_read(buf + (0 .. len - 1)); */ ;
      tmp = bufs_differ(cur->oid,buf,(u16)cur->oid_len);
      if (tmp) tmp_0 = 0; else tmp_0 = 1;
      ret = tmp_0;
      if (ret) {
        found = cur;
        break;
      }
    }
    __Cont: k = (u8)((int)k + 1);
  }
  out: ;
  return found;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(eaten);
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \result ≡ 0 ⇒ 1 < *\old(eaten) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *eaten;
 */
static int parse_AttributeTypeAndValue(u8 const *buf, u16 len, u16 *eaten)
{
  u16 parsed;
  int ret;
  u16 hdr_len = (u16)0;
  u16 data_len = (u16)0;
  u16 oid_len = (u16)0;
  _name_oid const *cur = (_name_oid const *)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -3554;
              goto out;
            }
    }
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & hdr_len,& data_len);
  if (ret) goto out;
  parsed = (u16)((int)hdr_len + (int)data_len);
  /*@ assert parsed ≤ len; */ ;
  buf += (int)hdr_len;
  len = (u16)((int)len - (int)hdr_len);
  ret = parse_OID(buf,data_len,& oid_len);
  if (ret) goto out;
  cur = find_dn_by_oid(buf,oid_len);
  if (cur == (_name_oid const *)0) {
    ret = -3582;
    goto out;
  }
  data_len = (u16)((int)data_len - (int)oid_len);
  buf += (int)oid_len;
  /*@
  assert
  cur->parse_rdn_val ∈
  {&parse_rdn_val_cn, &parse_rdn_val_org, &parse_rdn_val_org_unit,
   &parse_rdn_val_title, &parse_rdn_val_dn_qual, &parse_rdn_val_pseudo,
   &parse_rdn_val_dc, &parse_rdn_val_x520name, &parse_rdn_val_serial,
   &parse_rdn_val_country, &parse_rdn_val_locality, &parse_rdn_val_state}; */
  ;
  /*@ calls parse_rdn_val_cn, parse_rdn_val_x520name, parse_rdn_val_serial,
            parse_rdn_val_country, parse_rdn_val_locality,
            parse_rdn_val_state, parse_rdn_val_org, parse_rdn_val_org_unit,
            parse_rdn_val_title, parse_rdn_val_dn_qual, parse_rdn_val_pseudo,
            parse_rdn_val_dc;
  */
  ret = (*(cur->parse_rdn_val))(buf,data_len);
  if (ret) goto out;
  *eaten = parsed;
  /*@ assert *eaten ≤ \at(len,Pre); */ ;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(eaten);
    requires \separated(eaten, buf + (..));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \result ≡ 0 ⇒ 1 < *\old(eaten) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *eaten;
 */
static int parse_RelativeDistinguishedName(u8 const *buf, u16 len, u16 *eaten)
{
  u16 rdn_remain;
  u16 saved_rdn_len;
  int ret;
  u16 hdr_len = (u16)0;
  u16 data_len = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -3641;
              goto out;
            }
    }
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SET,& hdr_len,
                     & data_len);
  if (ret) goto out;
  saved_rdn_len = (u16)((int)hdr_len + (int)data_len);
  buf += (int)hdr_len;
  rdn_remain = data_len;
  /*@ loop invariant \valid_read(buf + (0 .. rdn_remain - 1));
      loop assigns ret, buf, rdn_remain;
      loop variant rdn_remain;
  */
  while (rdn_remain) {
    u16 parsed = (u16)0;
    ret = parse_AttributeTypeAndValue(buf,rdn_remain,& parsed);
    if (ret) goto out;
    rdn_remain = (u16)((int)rdn_remain - (int)parsed);
    buf += (int)parsed;
  }
  *eaten = saved_rdn_len;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(eaten);
    requires \separated(eaten, empty, buf + (..));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \result ≡ 0 ⇒ 1 < *\old(eaten) ≤ \old(len);
    ensures \result ≡ 0 ⇒ *\old(empty) ≡ 0 ∨ *\old(empty) ≡ 1;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *eaten, *empty;
 */
static int parse_x509_Name(u8 const *buf, u16 len, u16 *eaten, int *empty)
{
  int ret;
  u16 name_hdr_len = (u16)0;
  u16 name_data_len = (u16)0;
  u16 remain = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -3775;
              goto out;
            }
    }
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & name_hdr_len,& name_data_len);
  if (ret) goto out;
  buf += (int)name_hdr_len;
  remain = name_data_len;
  /*@ loop invariant \valid_read(buf + (0 .. remain - 1));
      loop assigns ret, buf, remain;
      loop variant remain;
  */
  while (remain) {
    u16 parsed = (u16)0;
    ret = parse_RelativeDistinguishedName(buf,remain,& parsed);
    if (ret) goto out;
    buf += (int)parsed;
    remain = (u16)((int)remain - (int)parsed);
  }
  *eaten = (u16)((int)name_hdr_len + (int)name_data_len);
  *empty = ! name_data_len;
  /*@ assert *empty ≡ 0 ∨ *empty ≡ 1; */ ;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires 0x30 ≤ d ≤ 0x39;
    requires 0x30 ≤ u ≤ 0x39;
    ensures 0 ≤ \result ≤ 99;
    assigns \nothing;
 */
u8 compute_decimal(u8 d, u8 u)
{
  u8 __retres;
  __retres = (u8)(((int)d - 0x30) * 10 + ((int)u - 0x30));
  return __retres;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(eaten);
    requires \valid(eaten);
    requires \valid(year);
    requires \valid(month);
    requires \valid(day);
    requires \valid(hour);
    requires \valid(min);
    requires \valid(sec);
    requires
      \separated(
        eaten, year, month, day, hour, min, sec, buf + (0 .. len - 1)
        );
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \result ≡ 0 ⇒ *\old(eaten) ≤ \old(len);
    ensures \result ≡ 0 ⇒ *\old(eaten) ≡ 15;
    ensures \old(len) < 15 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *eaten, *year, *month, *day, *hour, *min, *sec;
 */
static int parse_UTCTime(u8 const *buf, u16 len, u16 *eaten, u16 *year,
                         u8 *month, u8 *day, u8 *hour, u8 *min, u8 *sec)
{
  u16 yyyy;
  u8 mo;
  u8 dd;
  u8 hh;
  u8 mm;
  u8 ss;
  u8 time_type;
  u16 time_len;
  u8 i;
  u8 tmp;
  u8 tmp_0;
  u8 const c_zero = (u8)'0';
  int ret = -3859;
  if (buf == (u8 const *)0) {
    ret = -3863;
    goto out;
  }
  if ((int)len < 15) {
    ret = -3876;
    goto out;
  }
  time_type = *(buf + 0);
  if ((int)time_type != ASN1_TYPE_UTCTime) {
    ret = -3883;
    goto out;
  }
  time_len = (u16)*(buf + 1);
  if ((int)time_len != (int)((u8)13)) {
    ret = -3890;
    goto out;
  }
  buf += 2;
  i = (u8)0;
  /*@ loop invariant \valid_read(buf + i);
      loop invariant ∀ ℤ x; 0 ≤ x < i ⇒ 0x30 ≤ *(buf + x) ≤ 0x39;
      loop assigns i;
      loop variant 12 - i;
      loop unroll 12;
  */
  while ((int)i < 12) {
    if ((int)c_zero > (int)*(buf + i)) {
      ret = -3909;
      goto out;
    }
    if ((int)*(buf + i) - (int)c_zero > 9) {
      ret = -3914;
      goto out;
    }
    /*@ assert 0 ≤ *(buf + i) - c_zero ≤ 9; */ ;
    i = (u8)((int)i + 1);
  }
  if ((int)*(buf + 12) != 'Z') {
    ret = -3921;
    goto out;
  }
  /*@ assert c_zero ≡ 0x30; */ ;
  /*@ assert ∀ ℤ x; 0 ≤ x < 12 ⇒ 0x30 ≤ *(buf + x) ≤ 0x39; */ ;
  tmp_0 = compute_decimal(*(buf + 0),*(buf + 1));
  yyyy = (u16)tmp_0;
  if ((int)yyyy >= 50) yyyy = (u16)((int)yyyy + 1900);
  else yyyy = (u16)((int)yyyy + 2000);
  mo = compute_decimal(*(buf + 2),*(buf + 3));
  dd = compute_decimal(*(buf + 4),*(buf + 5));
  hh = compute_decimal(*(buf + 6),*(buf + 7));
  mm = compute_decimal(*(buf + 8),*(buf + 9));
  ss = compute_decimal(*(buf + 10),*(buf + 11));
  tmp = (u8)0;
  tmp = (u8)((int)tmp | ((int)mo > 12));
  tmp = (u8)((int)tmp | ((int)dd > 31));
  tmp = (u8)((int)tmp | ((int)hh > 23));
  tmp = (u8)((int)tmp | ((int)mm > 59));
  tmp = (u8)((int)tmp | ((int)ss > 59));
  if (tmp) {
    ret = -3953;
    goto out;
  }
  *year = yyyy;
  *month = mo;
  *day = dd;
  *hour = hh;
  *min = mm;
  *sec = ss;
  ret = 0;
  out: if (! ret) *eaten = (u16)15;
  return ret;
}

/*@ requires 0x30 ≤ d1 ≤ 0x39;
    requires 0x30 ≤ d2 ≤ 0x39;
    requires 0x30 ≤ d3 ≤ 0x39;
    requires 0x30 ≤ d4 ≤ 0x39;
    ensures 0 ≤ \result ≤ 9999;
    assigns \nothing;
 */
u16 compute_year(u8 d1, u8 d2, u8 d3, u8 d4)
{
  u16 __retres;
  __retres = (u16)(((((int)((u16)d1) - (int)((u16)0x30)) * 1000 + ((int)((u16)d2) - (int)((u16)0x30)) * 100) + 
                    ((int)((u16)d3) - (int)((u16)0x30)) * 10) + ((int)((u16)d4) - (int)((u16)0x30)));
  return __retres;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(eaten);
    requires \valid(year);
    requires \valid(month);
    requires \valid(day);
    requires \valid(hour);
    requires \valid(min);
    requires \valid(sec);
    requires
      \separated(
        eaten, year, month, day, hour, min, sec, buf + (0 .. len - 1)
        );
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \result ≡ 0 ⇒ *\old(eaten) ≤ \old(len);
    ensures \result ≡ 0 ⇒ *\old(eaten) ≡ 17;
    ensures \old(len) < 17 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *eaten, *year, *month, *day, *hour, *min, *sec;
 */
static int parse_generalizedTime(u8 const *buf, u16 len, u16 *eaten,
                                 u16 *year, u8 *month, u8 *day, u8 *hour,
                                 u8 *min, u8 *sec)
{
  u16 yyyy;
  u8 mo;
  u8 dd;
  u8 hh;
  u8 mm;
  u8 ss;
  u8 time_type;
  u16 time_len;
  u8 i;
  u8 tmp;
  u8 const c_zero = (u8)'0';
  int ret = -4025;
  if (buf == (u8 const *)0) {
    ret = -4029;
    goto out;
  }
  if ((int)len < 17) {
    ret = -4042;
    goto out;
  }
  time_type = *(buf + 0);
  if ((int)time_type != ASN1_TYPE_GeneralizedTime) {
    ret = -4049;
    goto out;
  }
  time_len = (u16)*(buf + 1);
  if ((int)time_len != 15) {
    ret = -4056;
    goto out;
  }
  buf += 2;
  i = (u8)0;
  /*@ loop invariant \valid_read(buf + i);
      loop invariant ∀ ℤ x; 0 ≤ x < i ⇒ 0x30 ≤ *(buf + x) ≤ 0x39;
      loop assigns i;
      loop variant 14 - i;
  */
  while ((int)i < 14) {
    if ((int)c_zero > (int)*(buf + i)) {
      ret = -4075;
      goto out;
    }
    if ((int)*(buf + i) - (int)c_zero > 9) {
      ret = -4080;
      goto out;
    }
    i = (u8)((int)i + 1);
  }
  if ((int)*(buf + 14) != 'Z') {
    ret = -4086;
    goto out;
  }
  /*@ assert c_zero ≡ 0x30; */ ;
  /*@ assert ∀ ℤ x; 0 ≤ x < 12 ⇒ 0x30 ≤ *(buf + x) ≤ 0x39; */ ;
  yyyy = compute_year(*(buf + 0),*(buf + 1),*(buf + 2),*(buf + 3));
  mo = compute_decimal(*(buf + 4),*(buf + 5));
  dd = compute_decimal(*(buf + 6),*(buf + 7));
  hh = compute_decimal(*(buf + 8),*(buf + 9));
  mm = compute_decimal(*(buf + 10),*(buf + 11));
  ss = compute_decimal(*(buf + 12),*(buf + 13));
  tmp = (u8)0;
  tmp = (u8)((int)tmp | ((int)yyyy <= 2049));
  tmp = (u8)((int)tmp | ((int)mo > 12));
  tmp = (u8)((int)tmp | ((int)dd > 31));
  tmp = (u8)((int)tmp | ((int)hh > 23));
  tmp = (u8)((int)tmp | ((int)mm > 59));
  tmp = (u8)((int)tmp | ((int)ss > 59));
  if (tmp) {
    ret = -4113;
    goto out;
  }
  *year = yyyy;
  *month = mo;
  *day = dd;
  *hour = hh;
  *min = mm;
  *sec = ss;
  ret = 0;
  out: if (! ret) *eaten = (u16)17;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(eaten);
    requires \valid(eaten);
    requires \valid(year);
    requires \valid(month);
    requires \valid(day);
    requires \valid(hour);
    requires \valid(min);
    requires \valid(sec);
    requires
      \separated(t_type, eaten, year, month, day, hour, min, sec, buf + (..));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \result ≡ 0 ⇒ *\old(eaten) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *t_type, *eaten, *year, *month, *day, *hour, *min, *sec;
 */
static int parse_Time(u8 const *buf, u16 len, u8 *t_type, u16 *eaten,
                      u16 *year, u8 *month, u8 *day, u8 *hour, u8 *min,
                      u8 *sec)
{
  u8 time_type;
  int ret = -4165;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -4168;
              goto out;
            }
    }
  if ((int)len < 2) {
    ret = -4174;
    goto out;
  }
  time_type = *(buf + 0);
  switch ((int)time_type) {
    case ASN1_TYPE_UTCTime:
    ret = parse_UTCTime(buf,len,eaten,year,month,day,hour,min,sec);
    if (ret) ;
    break;
    case ASN1_TYPE_GeneralizedTime:
    ret = parse_generalizedTime(buf,len,eaten,year,month,day,hour,min,sec);
    if (ret) ;
    break;
    default: ret = -4196;
    break;
  }
  *t_type = time_type;
  out: ;
  if (ret) *eaten = (u16)0;
  return ret;
}

/*@ ensures \result < 0 ∨ \result ≡ 0;
    assigns \nothing; */
static int _verify_correct_time_use(u8 time_type, u16 yyyy)
{
  int ret;
  switch ((int)time_type) {
    case ASN1_TYPE_UTCTime: if ((int)yyyy <= 2049) ret = 0; else ret = -4227;
    break;
    case ASN1_TYPE_GeneralizedTime:
    if ((int)yyyy >= 2050) ret = 0; else ret = -4230;
    break;
    default: ret = -1;
    break;
  }
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(eaten);
    requires \separated(eaten, buf + (..));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \result ≡ 0 ⇒ *\old(eaten) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *eaten;
 */
static int parse_x509_Validity(u8 const *buf, u16 len, u16 *eaten)
{
  int ret;
  u16 hdr_len = (u16)0;
  u16 remain = (u16)0;
  u16 data_len = (u16)0;
  u16 nb_len = (u16)0;
  u16 na_len = (u16)0;
  u16 na_year = (u16)0;
  u16 nb_year = (u16)0;
  u8 na_month = (u8)0;
  u8 na_day = (u8)0;
  u8 na_hour = (u8)0;
  u8 na_min = (u8)0;
  u8 na_sec = (u8)0;
  u8 nb_month = (u8)0;
  u8 nb_day = (u8)0;
  u8 nb_hour = (u8)0;
  u8 nb_min = (u8)0;
  u8 nb_sec = (u8)0;
  u8 t_type = (u8)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -4271;
              goto out;
            }
    }
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & hdr_len,& data_len);
  if (ret) goto out;
  buf += (int)hdr_len;
  remain = data_len;
  ret = parse_Time(buf,remain,& t_type,& nb_len,& nb_year,& nb_month,
                   & nb_day,& nb_hour,& nb_min,& nb_sec);
  if (ret) goto out;
  ret = _verify_correct_time_use(t_type,nb_year);
  if (ret) goto out;
  remain = (u16)((int)remain - (int)nb_len);
  buf += (int)nb_len;
  ret = parse_Time(buf,remain,& t_type,& na_len,& na_year,& na_month,
                   & na_day,& na_hour,& na_min,& na_sec);
  if (ret) goto out;
  ret = _verify_correct_time_use(t_type,na_year);
  if (ret) goto out;
  remain = (u16)((int)remain - (int)na_len);
  if (remain) {
    ret = -4322;
    goto out;
  }
  if ((int)na_year < (int)nb_year) {
    ret = -4329;
    goto out;
  }
  else 
    if ((int)na_year == (int)nb_year) {
      u32 na_rem_secs;
      u32 nb_rem_secs;
      na_rem_secs = (u32)0;
      na_rem_secs += (u32)((int)na_month * (31 * (24 * (60 * 60))));
      na_rem_secs += (u32)((int)na_day * (24 * (60 * 60)));
      na_rem_secs += (u32)((int)na_hour * (60 * 60));
      na_rem_secs += (u32)((int)na_min * 60);
      na_rem_secs += (u32)na_sec;
      nb_rem_secs = (u32)0;
      nb_rem_secs += (u32)((int)nb_month * (31 * (24 * (60 * 60))));
      nb_rem_secs += (u32)((int)nb_day * (24 * (60 * 60)));
      nb_rem_secs += (u32)((int)nb_hour * (60 * 60));
      nb_rem_secs += (u32)((int)nb_min * 60);
      nb_rem_secs += (u32)nb_sec;
      if (na_rem_secs <= nb_rem_secs) {
        ret = -4355;
        goto out;
      }
    }
  *eaten = (u16)((int)hdr_len + (int)data_len);
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(eaten);
    requires \separated(eaten, buf + (..));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \result ≡ 0 ⇒ *\old(eaten) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *eaten;
 */
static int parse_x509_subjectPublicKeyInfo(u8 const *buf, u16 len, u16 *eaten)
{
  alg_param param;
  int ret;
  u16 hdr_len = (u16)0;
  u16 data_len = (u16)0;
  u16 parsed = (u16)0;
  u16 remain = (u16)0;
  _alg_id const *alg = (_alg_id const *)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -4395;
              goto out;
            }
    }
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & hdr_len,& data_len);
  if (ret) goto out;
  buf += (int)hdr_len;
  remain = data_len;
  param.curve_param = (_curve const *)0;
  param.null_param = (u8 const *)0;
  param.ecdsa_no_param = 0;
  param.unparsed_param = 0;
  ret = parse_x509_AlgorithmIdentifier(buf,remain,& alg,& param,& parsed);
  if (ret) goto out;
  if ((int)alg->alg_type != ALG_PUBKEY) {
    ret = -4425;
    goto out;
  }
  buf += (int)parsed;
  remain = (u16)((int)remain - (int)parsed);
  if (! alg->parse_subjectpubkey) {
    ret = -4438;
    goto out;
  }
  /*@
  assert
  alg->parse_subjectpubkey ∈
  {&parse_subjectpubkey_ec, &parse_subjectpubkey_rsa}; */
  ;
  /*@ calls parse_subjectpubkey_ec, parse_subjectpubkey_rsa; */
  ret = (*(alg->parse_subjectpubkey))(buf,remain,& param);
  if (ret) goto out;
  *eaten = (u16)((int)hdr_len + (int)data_len);
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(eaten);
    requires \separated(eaten, empty, buf + (..));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \result ≡ 0 ⇒ 1 < *\old(eaten) ≤ \old(len);
    ensures \result ≡ 0 ⇒ 0 ≤ *\old(empty) ≤ 1;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *eaten, *empty;
 */
static int parse_GeneralName(u8 const *buf, u16 len, u16 *eaten, int *empty)
{
  u8 name_type;
  int ret;
  u16 remain = (u16)0;
  u16 name_len = (u16)0;
  u16 name_hdr_len = (u16)0;
  u16 grabbed = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -4588;
              goto out;
            }
    }
  if ((int)len < 2) {
    ret = -4594;
    goto out;
  }
  remain = len;
  name_type = *(buf + 0);
  if (! ((int)name_type & 0x80)) {
    ret = -4607;
    goto out;
  }
  switch ((int)name_type) {
    case 0x81: case 0x82: case 0x86: buf ++;
    remain = (u16)((int)remain - 1);
    ret = get_length(buf,remain,& name_len,& grabbed);
    if (ret) goto out;
    buf += (int)grabbed;
    remain = (u16)((int)remain - (int)grabbed);
    if ((int)name_len > (int)remain) {
      ret = -4628;
      goto out;
    }
    ret = check_ia5_string(buf,name_len);
    if (ret) goto out;
    switch ((int)name_type) {
      case 0x81: break;
      case 0x82: break;
      case 0x86: break;
      default: break;
    }
    remain = (u16)((int)remain - (int)name_len);
    buf += (int)name_len;
    *eaten = (u16)(((int)name_len + (int)grabbed) + 1);
    *empty = ! name_len;
    /*@ assert *eaten > 1; */ ;
    break;
    case 0x87: buf ++;
    remain = (u16)((int)remain - 1);
    ret = get_length(buf,remain,& name_len,& grabbed);
    if (ret) goto out;
    buf += (int)grabbed;
    remain = (u16)((int)remain - (int)grabbed);
    if ((int)name_len > (int)remain) {
      ret = -4685;
      goto out;
    }
    remain = (u16)((int)remain - (int)name_len);
    buf += (int)name_len;
    *eaten = (u16)(((int)name_len + (int)grabbed) + 1);
    *empty = ! name_len;
    /*@ assert *eaten > 1; */ ;
    break;
    case 0xa0: ret = -4701;
    goto out;
    break;
    case 0xa3: ret = -4708;
    goto out;
    break;
    case 0xa4:
    ret = parse_id_len(buf,remain,CLASS_CONTEXT_SPECIFIC,(u32)4,
                       & name_hdr_len,& name_len);
    if (ret) goto out;
    buf += (int)name_hdr_len;
    remain = name_len;
    ret = parse_x509_Name(buf,remain,& grabbed,empty);
    if (ret) goto out;
    buf += (int)grabbed;
    remain = (u16)((int)remain - (int)grabbed);
    if (remain) {
      ret = -4734;
      goto out;
    }
    *eaten = (u16)((int)name_hdr_len + (int)name_len);
    /*@ assert *eaten > 1; */ ;
    break;
    case 0xa5: ret = -4745;
    goto out;
    break;
    case 0x88: ret = -4752;
    goto out;
    break;
    default: ret = -4758;
    goto out;
    break;
  }
  /*@ assert *eaten > 1; */ ;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(eaten);
    requires \separated(eaten, buf + (..));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \result ≡ 0 ⇒ 1 < *\old(eaten) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *eaten;
 */
static int parse_GeneralNames(u8 const *buf, u16 len, tag_class exp_class,
                              u32 exp_type, u16 *eaten)
{
  u16 remain;
  int ret;
  u16 parsed = (u16)0;
  u16 hdr_len = (u16)0;
  u16 data_len = (u16)0;
  int unused = 0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -4790;
              goto out;
            }
    }
  ret = parse_id_len(buf,len,exp_class,exp_type,& hdr_len,& data_len);
  if (ret) goto out;
  buf += (int)hdr_len;
  remain = data_len;
  /*@ loop invariant \valid_read(buf + (0 .. remain - 1));
      loop assigns ret, buf, remain, parsed, unused;
      loop variant remain;
  */
  while (remain) {
    ret = parse_GeneralName(buf,remain,& parsed,& unused);
    if (ret) goto out;
    remain = (u16)((int)remain - (int)parsed);
    buf += (int)parsed;
  }
  *eaten = (u16)((int)hdr_len + (int)data_len);
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \separated(eaten, buf + (..));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \result ≡ 0 ⇒ 1 < *\old(eaten) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *eaten;
 */
static int parse_AccessDescription(u8 const *buf, u16 len, u16 *eaten)
{
  u16 remain;
  int ret;
  int found;
  int unused;
  u8 const id_ad_caIssuers_oid[10] =
    {(u8)0x06,
     (u8)0x08,
     (u8)0x2b,
     (u8)0x06,
     (u8)0x01,
     (u8)0x05,
     (u8)0x05,
     (u8)0x07,
     (u8)0x30,
     (u8)0x01};
  u8 const id_ad_ocsp_oid[10] =
    {(u8)0x06,
     (u8)0x08,
     (u8)0x2b,
     (u8)0x06,
     (u8)0x01,
     (u8)0x05,
     (u8)0x05,
     (u8)0x07,
     (u8)0x30,
     (u8)0x02};
  u16 hdr_len = (u16)0;
  u16 data_len = (u16)0;
  u16 oid_len = (u16)0;
  u16 al_len = (u16)0;
  u16 saved_ad_len = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -4850;
              goto out;
            }
    }
  remain = len;
  ret = parse_id_len(buf,remain,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & hdr_len,& data_len);
  if (ret) goto out;
  saved_ad_len = (u16)((int)hdr_len + (int)data_len);
  /*@ assert saved_ad_len ≤ len; */ ;
  remain = (u16)((int)remain - (int)hdr_len);
  /*@ assert remain ≥ data_len; */ ;
  buf += (int)hdr_len;
  ret = parse_OID(buf,data_len,& oid_len);
  if (ret) goto out;
  found = 0;
  if ((unsigned long)oid_len == sizeof(id_ad_caIssuers_oid)) {
    int tmp_0;
    int tmp;
    tmp = bufs_differ(buf,id_ad_caIssuers_oid,oid_len);
    if (tmp) tmp_0 = 0; else tmp_0 = 1;
    found = tmp_0;
  }
  if (! found) 
    if ((unsigned long)oid_len == sizeof(id_ad_ocsp_oid)) {
      int tmp_2;
      int tmp_1;
      tmp_1 = bufs_differ(buf,id_ad_ocsp_oid,oid_len);
      if (tmp_1) tmp_2 = 0; else tmp_2 = 1;
      found = tmp_2;
    }
  if (! found) {
    ret = -4893;
    goto out;
  }
  buf += (int)oid_len;
  remain = (u16)((int)remain - (int)oid_len);
  data_len = (u16)((int)data_len - (int)oid_len);
  /*@ assert remain ≥ data_len; */ ;
  ret = parse_GeneralName(buf,data_len,& al_len,& unused);
  if (ret) goto out;
  buf += (int)al_len;
  /*@ assert remain ≥ data_len ≥ al_len; */ ;
  remain = (u16)((int)remain - (int)al_len);
  data_len = (u16)((int)data_len - (int)al_len);
  if (data_len) {
    ret = -4922;
    goto out;
  }
  *eaten = saved_ad_len;
  /*@ assert *eaten ≤ len; */ ;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(ctx);
    requires \separated(ctx, buf + (..));
    ensures \result ≤ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(critical) ≢ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int parse_ext_AIA(u8 const *buf, u16 len, int critical,
                         cert_parsing_ctx *ctx)
{
  u16 remain;
  int ret;
  u16 hdr_len = (u16)0;
  u16 data_len = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -4999;
              goto out;
            }
    }
  if (critical) {
    ret = -5009;
    goto out;
  }
  remain = len;
  ret = parse_id_len(buf,remain,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & hdr_len,& data_len);
  if (ret) goto out;
  buf += (int)hdr_len;
  remain = (u16)((int)remain - (int)hdr_len);
  if ((int)remain != (int)data_len) {
    ret = -5029;
    goto out;
  }
  if (! remain) {
    ret = -5039;
    goto out;
  }
  /*@ loop invariant \valid_read(buf + (0 .. remain - 1));
      loop assigns ret, buf, remain;
      loop variant remain;
  */
  while (remain) {
    u16 parsed = (u16)0;
    ret = parse_AccessDescription(buf,remain,& parsed);
    if (ret) {
      ret = -5059;
      goto out;
    }
    remain = (u16)((int)remain - (int)parsed);
    buf += (int)parsed;
  }
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(ctx);
    requires \separated(ctx, buf + (..));
    ensures \result ≤ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *ctx;
 */
static int parse_ext_AKI(u8 const *buf, u16 len, int critical,
                         cert_parsing_ctx *ctx)
{
  u16 remain;
  int ret;
  u16 hdr_len = (u16)0;
  u16 data_len = (u16)0;
  u16 key_id_hdr_len = (u16)0;
  u16 key_id_data_len = (u16)0;
  u16 parsed = (u16)0;
  int has_keyIdentifier = 0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -5107;
              goto out;
            }
    }
  if (critical) {
    ret = -5117;
    goto out;
  }
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & hdr_len,& data_len);
  if (ret) goto out;
  buf += (int)hdr_len;
  remain = data_len;
  if ((int)len != (int)hdr_len + (int)data_len) {
    ret = -5134;
    goto out;
  }
  ret = parse_id_len(buf,remain,CLASS_CONTEXT_SPECIFIC,(u32)0,
                     & key_id_hdr_len,& key_id_data_len);
  if (! ret) {
    if (! key_id_data_len) {
      ret = -5152;
      goto out;
    }
    buf += (int)key_id_hdr_len + (int)key_id_data_len;
    remain = (u16)((int)remain - ((int)key_id_hdr_len + (int)key_id_data_len));
    has_keyIdentifier = 1;
  }
  ret = parse_GeneralNames(buf,remain,CLASS_CONTEXT_SPECIFIC,(u32)1,& parsed);
  if (! ret) {
    u16 cert_serial_len = (u16)0;
    buf += (int)parsed;
    remain = (u16)((int)remain - (int)parsed);
    ret = parse_CertificateSerialNumber(buf,remain,CLASS_CONTEXT_SPECIFIC,
                                        (u32)2,& cert_serial_len);
    if (ret) goto out;
    buf += (int)cert_serial_len;
    remain = (u16)((int)remain - (int)cert_serial_len);
  }
  if (remain) {
    ret = -5190;
    goto out;
  }
  ctx->aki_has_keyIdentifier = has_keyIdentifier;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(ctx);
    requires \separated(ctx, buf + (..));
    ensures \result ≤ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *ctx;
 */
static int parse_ext_SKI(u8 const *buf, u16 len, int critical,
                         cert_parsing_ctx *ctx)
{
  u16 remain;
  int ret;
  u16 key_id_hdr_len = (u16)0;
  u16 key_id_data_len = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -5225;
              goto out;
            }
    }
  remain = len;
  if (critical) {
    ret = -5237;
    goto out;
  }
  ret = parse_id_len(buf,remain,CLASS_UNIVERSAL,(u32)ASN1_TYPE_OCTET_STRING,
                     & key_id_hdr_len,& key_id_data_len);
  if (ret) goto out;
  if ((int)len != (int)key_id_hdr_len + (int)key_id_data_len) {
    ret = -5250;
    goto out;
  }
  if (! key_id_data_len) {
    ret = -5257;
    goto out;
  }
  remain = (u16)((int)remain - ((int)key_id_hdr_len + (int)key_id_data_len));
  if (remain) {
    ret = -5264;
    goto out;
  }
  ctx->has_ski = 1;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \separated(val, buf + (..));
    ensures \result ≤ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *val;
 */
static int parse_nine_bit_named_bit_list(u8 const *buf, u16 len, u16 *val)
{
  u8 k;
  u8 non_signif;
  int ret;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -5310;
              goto out;
            }
    }
  if ((int)*(buf + 0) & 0xf8) {
    ret = -5317;
    goto out;
  }
  switch ((int)len) {
    case 1: ;
    if ((int)*(buf + 0) != 0) {
      ret = -5335;
      goto out;
    }
    else {
      ret = -5347;
      goto out;
    }
    break;
    case 2: ;
    if ((int)*(buf + 1) == 0) {
      ret = -5363;
      goto out;
    }
    non_signif = (u8)0;
    k = (u8)0;
    /*@ loop assigns k, non_signif;
        loop variant 8 - k; */
    while ((int)k < 8) {
      if (((int)*(buf + 1) >> (int)k) & 0x1) {
        non_signif = k;
        break;
      }
      k = (u8)((int)k + 1);
    }
    if ((int)*(buf + 0) != (int)non_signif) {
      ret = -5399;
      goto out;
    }
    *val = (u16)0;
    k = (u8)0;
    /*@ loop invariant 0 ≤ k ≤ 8;
        loop assigns k, *val;
        loop variant 8 - k;
    */
    while ((int)k < 8) {
      *val = (u16)((int)*val | ((((int)*(buf + 1) >> (int)k) & 0x1) << (
                                7 - (int)k)));
      k = (u8)((int)k + 1);
    }
    break;
    case 3: ;
    if ((int)*(buf + 0) != 7) goto _LOR_0;
    else 
      if ((int)*(buf + 2) != 0x80) {
        _LOR_0: {
                  ret = -5427;
                  goto out;
                }
      }
    *val = (u16)0;
    k = (u8)0;
    /*@ loop invariant 0 ≤ k ≤ 8;
        loop assigns k, *val;
        loop variant 8 - k;
    */
    while ((int)k < 8) {
      *val = (u16)((int)*val | ((((int)*(buf + 1) >> (int)k) & 0x1) << (
                                7 - (int)k)));
      k = (u8)((int)k + 1);
    }
    *val = (u16)((int)*val | ((int)*(buf + 2) >> 7));
    break;
    default: ret = -5450;
    goto out;
  }
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(ctx);
    requires \separated(ctx, buf + (..));
    ensures \result ≤ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *ctx;
 */
static int parse_ext_keyUsage(u8 const *buf, u16 len, int critical,
                              cert_parsing_ctx *ctx)
{
  int ret;
  u16 val = (u16)0;
  u16 hdr_len = (u16)0;
  u16 data_len = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -5513;
              goto out;
            }
    }
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_BIT_STRING,
                     & hdr_len,& data_len);
  if (ret) goto out;
  if ((int)len != (int)hdr_len + (int)data_len) {
    ret = -5534;
    goto out;
  }
  buf += (int)hdr_len;
  len = (u16)((int)len - (int)hdr_len);
  ret = parse_nine_bit_named_bit_list(buf,data_len,& val);
  if (ret) goto out;
  if ((int)val & 0x0100) 
    if (! ((int)val & 0x0010)) {
      ret = -5559;
      goto out;
    }
  if ((int)val & 0x0080) 
    if (! ((int)val & 0x0010)) {
      ret = -5570;
      goto out;
    }
  ctx->has_keyUsage = 1;
  ctx->keyCertSign_set = ! (! ((int)val & 0x0020));
  ctx->cRLSign_set = ! (! ((int)val & 0x0040));
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(eaten);
    requires \separated(eaten, buf + (..));
    ensures \result ≤ 0;
    ensures \result ≡ 0 ⇒ *\old(eaten) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *eaten;
 */
static int parse_CPSuri(u8 const *buf, u16 len, u16 *eaten)
{
  int ret;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -5602;
              goto out;
            }
    }
  ret = parse_ia5_string(buf,len,(u16)1,(u16)65534);
  if (ret) goto out;
  *eaten = len;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(eaten);
    requires \separated(eaten, buf + (..));
    ensures \result ≤ 0;
    ensures \result ≡ 0 ⇒ *\old(eaten) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *eaten;
 */
static int parse_DisplayText(u8 const *buf, u16 len, u16 *eaten)
{
  u8 str_type;
  u16 hdr_len = (u16)0;
  u16 data_len = (u16)0;
  int ret = -1;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -5646;
              goto out;
            }
    }
  str_type = *(buf + 0);
  switch ((int)str_type) {
    case 12: case 22: case 26: case 30:
    ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)str_type,& hdr_len,
                       & data_len);
    if (ret) goto out;
    buf += (int)hdr_len;
    switch ((int)str_type) {
      case 12: ret = check_utf8_string(buf,data_len);
      if (ret) goto out;
      break;
      case 22: ret = check_ia5_string(buf,data_len);
      if (ret) goto out;
      break;
      case 26: ret = check_visible_string(buf,data_len);
      if (ret) goto out;
      break;
      case 30: ret = check_bmp_string(buf,data_len);
      if (ret) goto out;
      break;
      default: ret = -5697;
      goto out;
      break;
    }
    *eaten = (u16)((int)hdr_len + (int)data_len);
    break;
    default: ret = -5707;
    goto out;
    break;
  }
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(eaten);
    requires \separated(eaten, buf + (..));
    ensures \result ≤ 0;
    ensures \result ≡ 0 ⇒ 1 < *\old(eaten) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *eaten;
 */
static int parse_NoticeReference(u8 const *buf, u16 len, u16 *eaten)
{
  u16 remain;
  int ret;
  u16 parsed = (u16)0;
  u16 saved_len = (u16)0;
  u16 hdr_len = (u16)0;
  u16 data_len = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -5746;
              goto out;
            }
    }
  remain = len;
  ret = parse_id_len(buf,remain,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & hdr_len,& data_len);
  if (ret) goto out;
  saved_len = (u16)((int)hdr_len + (int)data_len);
  remain = data_len;
  buf += (int)hdr_len;
  ret = parse_DisplayText(buf,remain,& parsed);
  if (ret) goto out;
  remain = (u16)((int)remain - (int)parsed);
  buf += (int)parsed;
  ret = parse_id_len(buf,remain,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & hdr_len,& data_len);
  if (ret) goto out;
  remain = (u16)((int)remain - (int)hdr_len);
  buf += (int)hdr_len;
  if ((int)remain != (int)data_len) {
    ret = -5794;
    goto out;
  }
  /*@ loop invariant \valid_read(buf + (0 .. remain - 1));
      loop assigns ret, buf, remain, parsed;
      loop variant remain;
  */
  while (remain) {
    ret = parse_integer(buf,remain,CLASS_UNIVERSAL,(u32)ASN1_TYPE_INTEGER,
                        & parsed);
    if (ret) goto out;
    remain = (u16)((int)remain - (int)parsed);
    buf += (int)parsed;
  }
  *eaten = saved_len;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(eaten);
    requires \separated(eaten, buf + (..));
    ensures \result ≤ 0;
    ensures \result ≡ 0 ⇒ *\old(eaten) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *eaten;
 */
static int parse_UserNotice(u8 const *buf, u16 len, u16 *eaten)
{
  int ret;
  u16 hdr_len = (u16)0;
  u16 data_len = (u16)0;
  u16 remain = (u16)0;
  u16 parsed = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -5860;
              goto out;
            }
    }
  remain = len;
  ret = parse_id_len(buf,remain,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & hdr_len,& data_len);
  if (ret) goto out;
  remain = (u16)((int)remain - (int)hdr_len);
  buf += (int)hdr_len;
  if (! data_len) {
    ret = -5880;
    goto out;
  }
  ret = parse_NoticeReference(buf,remain,& parsed);
  if (! ret) {
    remain = (u16)((int)remain - (int)parsed);
    buf += (int)parsed;
  }
  ret = parse_DisplayText(buf,remain,& parsed);
  if (! ret) {
    remain = (u16)((int)remain - (int)parsed);
    buf += (int)parsed;
  }
  if (remain) {
    ret = -5900;
    goto out;
  }
  *eaten = (u16)((int)hdr_len + (int)data_len);
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(eaten);
    requires \separated(eaten, buf + (..));
    ensures \result ≤ 0;
    ensures \result ≡ 0 ⇒ 1 < *\old(eaten) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *eaten;
 */
static int parse_policyQualifierInfo(u8 const *buf, u16 len, u16 *eaten)
{
  int ret;
  u16 hdr_len = (u16)0;
  u16 data_len = (u16)0;
  u16 oid_len = (u16)0;
  u16 remain = (u16)0;
  u8 id_qt_cps_oid[10] =
    {(u8)0x06,
     (u8)0x08,
     (u8)0x2b,
     (u8)0x06,
     (u8)0x01,
     (u8)0x05,
     (u8)0x05,
     (u8)0x07,
     (u8)0x02,
     (u8)0x01};
  u8 id_qt_unotice_oid[10] =
    {(u8)0x06,
     (u8)0x08,
     (u8)0x2b,
     (u8)0x06,
     (u8)0x01,
     (u8)0x05,
     (u8)0x05,
     (u8)0x07,
     (u8)0x02,
     (u8)0x02};
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -5947;
              goto out;
            }
    }
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & hdr_len,& data_len);
  if (ret) goto out;
  remain = data_len;
  buf += (int)hdr_len;
  ret = parse_OID(buf,remain,& oid_len);
  if (ret) goto out;
  if ((unsigned long)oid_len == sizeof(id_qt_cps_oid)) {
    int tmp_0;
    tmp_0 = bufs_differ(buf,(u8 const *)(id_qt_cps_oid),oid_len);
    if (tmp_0) goto _LAND_0;
    else {
      u16 cpsuri_len = (u16)0;
      buf += (int)oid_len;
      remain = (u16)((int)remain - (int)oid_len);
      ret = parse_CPSuri(buf,remain,& cpsuri_len);
      if (ret) goto out;
      remain = (u16)((int)remain - (int)cpsuri_len);
      buf += (int)cpsuri_len;
    }
  }
  else {
    _LAND_0: ;
    if ((unsigned long)oid_len == sizeof(id_qt_unotice_oid)) {
      int tmp;
      tmp = bufs_differ(buf,(u8 const *)(id_qt_unotice_oid),oid_len);
      if (tmp) goto _LAND;
      else {
        u16 cpsunotice_len = (u16)0;
        buf += (int)oid_len;
        remain = (u16)((int)remain - (int)oid_len);
        ret = parse_UserNotice(buf,remain,& cpsunotice_len);
        if (ret) goto out;
        remain = (u16)((int)remain - (int)cpsunotice_len);
        buf += (int)cpsunotice_len;
      }
    }
    else {
      _LAND: {
               ret = -6006;
               goto out;
             }
    }
  }
  *eaten = (u16)((int)hdr_len + (int)data_len);
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(eaten);
    requires \separated(eaten, buf + (..));
    ensures \result ≤ 0;
    ensures \result ≡ 0 ⇒ 1 < *\old(eaten) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *eaten;
 */
static int parse_PolicyInformation(u8 const *buf, u16 len, u16 *eaten)
{
  u16 saved_pi_len;
  u16 remain;
  int ret;
  u16 hdr_len = (u16)0;
  u16 data_len = (u16)0;
  u16 oid_len = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -6042;
              goto out;
            }
    }
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & hdr_len,& data_len);
  if (ret) goto out;
  saved_pi_len = (u16)((int)hdr_len + (int)data_len);
  remain = data_len;
  buf += (int)hdr_len;
  ret = parse_OID(buf,remain,& oid_len);
  if (ret) goto out;
  remain = (u16)((int)remain - (int)oid_len);
  buf += (int)oid_len;
  if (remain) {
    ret = parse_id_len(buf,remain,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                       & hdr_len,& data_len);
    if (ret) goto out;
    remain = (u16)((int)remain - (int)hdr_len);
    buf += (int)hdr_len;
    if ((int)remain != (int)data_len) {
      ret = -6085;
      goto out;
    }
    /*@ loop invariant \valid_read(buf + (0 .. remain - 1));
        loop assigns ret, buf, remain;
        loop variant remain;
    */
    while (remain) {
      u16 pqi_len = (u16)0;
      ret = parse_policyQualifierInfo(buf,remain,& pqi_len);
      if (ret) goto out;
      remain = (u16)((int)remain - (int)pqi_len);
      buf += (int)pqi_len;
    }
  }
  *eaten = saved_pi_len;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(ctx);
    requires \separated(ctx, buf + (..));
    ensures \result ≤ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int parse_ext_certPolicies(u8 const *buf, u16 len, int critical,
                                  cert_parsing_ctx *ctx)
{
  int ret;
  u16 remain = (u16)0;
  u16 data_len = (u16)0;
  u16 hdr_len = (u16)0;
  u16 eaten = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -6194;
              goto out;
            }
    }
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & hdr_len,& data_len);
  if (ret) goto out;
  buf += (int)hdr_len;
  remain = data_len;
  if ((int)len != (int)hdr_len + (int)data_len) {
    ret = -6226;
    goto out;
  }
  /*@ loop invariant \valid_read(buf + (0 .. remain - 1));
      loop assigns ret, buf, remain, eaten;
      loop variant remain;
  */
  while (remain) {
    ret = parse_PolicyInformation(buf,remain,& eaten);
    if (ret) goto out;
    remain = (u16)((int)remain - (int)eaten);
    buf += (int)eaten;
  }
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(ctx);
    requires \separated(ctx, buf + (..));
    ensures \result ≤ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int parse_ext_policyMapping(u8 const *buf, u16 len, int critical,
                                   cert_parsing_ctx *ctx)
{
  int ret;
  u16 remain = (u16)0;
  u16 data_len = (u16)0;
  u16 hdr_len = (u16)0;
  u16 eaten = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -6283;
              goto out;
            }
    }
  if (! critical) {
    ret = -6293;
    goto out;
  }
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & hdr_len,& data_len);
  if (ret) goto out;
  buf += (int)hdr_len;
  remain = data_len;
  if ((int)len != (int)hdr_len + (int)data_len) {
    ret = -6310;
    goto out;
  }
  /*@ loop invariant \valid_read(buf + (0 .. remain - 1));
      loop assigns ret, buf, remain, hdr_len, data_len, eaten;
      loop variant remain;
  */
  while (remain) {
    ret = parse_id_len(buf,remain,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                       & hdr_len,& data_len);
    if (ret) goto out;
    buf += (int)hdr_len;
    remain = (u16)((int)remain - (int)hdr_len);
    ret = parse_OID(buf,data_len,& eaten);
    if (ret) goto out;
    buf += (int)eaten;
    remain = (u16)((int)remain - (int)eaten);
    data_len = (u16)((int)data_len - (int)eaten);
    ret = parse_OID(buf,data_len,& eaten);
    if (ret) goto out;
    data_len = (u16)((int)data_len - (int)eaten);
    if (data_len) {
      ret = -6357;
      goto out;
    }
    buf += (int)eaten;
    remain = (u16)((int)remain - (int)eaten);
  }
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(ctx);
    requires \separated(ctx, buf + (..));
    ensures \result ≤ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *ctx;
 */
static int parse_ext_SAN(u8 const *buf, u16 len, int critical,
                         cert_parsing_ctx *ctx)
{
  int ret;
  int san_empty;
  int empty_gen_name;
  u16 data_len = (u16)0;
  u16 hdr_len = (u16)0;
  u16 remain = (u16)0;
  u16 eaten = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -6417;
              goto out;
            }
    }
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & hdr_len,& data_len);
  if (ret) goto out;
  if (! data_len) {
    ret = -6435;
    goto out;
  }
  buf += (int)hdr_len;
  remain = data_len;
  if ((int)len != (int)hdr_len + (int)data_len) {
    ret = -6444;
    goto out;
  }
  san_empty = (int)remain == 0;
  /*@ loop invariant \valid_read(buf + (0 .. remain - 1));
      loop assigns ret, buf, remain, eaten, empty_gen_name;
      loop variant remain;
  */
  while (remain) {
    empty_gen_name = 0;
    ret = parse_GeneralName(buf,remain,& eaten,& empty_gen_name);
    if (ret) goto out;
    if (empty_gen_name) {
      ret = -6470;
      goto out;
    }
    if ((int)*(buf + 0) == 0x87) 
      switch ((int)eaten) {
        case 6: break;
        case 18: break;
        default: ret = -6493;
        goto out;
        break;
      }
    remain = (u16)((int)remain - (int)eaten);
    buf += (int)eaten;
  }
  ctx->san_empty = san_empty;
  ctx->san_critical = critical;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(ctx);
    requires \separated(ctx, buf + (..));
    ensures \result ≤ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int parse_ext_IAN(u8 const *buf, u16 len, int critical,
                         cert_parsing_ctx *ctx)
{
  int ret;
  u16 data_len = (u16)0;
  u16 hdr_len = (u16)0;
  u16 remain = (u16)0;
  u16 eaten = (u16)0;
  int unused = 0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -6535;
              goto out;
            }
    }
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & hdr_len,& data_len);
  if (ret) goto out;
  if (! data_len) {
    ret = -6568;
    goto out;
  }
  buf += (int)hdr_len;
  remain = data_len;
  if ((int)len != (int)hdr_len + (int)data_len) {
    ret = -6577;
    goto out;
  }
  /*@ loop invariant \valid_read(buf + (0 .. remain - 1));
      loop assigns ret, buf, remain, eaten, unused;
      loop variant remain;
  */
  while (remain) {
    ret = parse_GeneralName(buf,remain,& eaten,& unused);
    if (ret) goto out;
    remain = (u16)((int)remain - (int)eaten);
    buf += (int)eaten;
  }
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(ctx);
    requires \separated(ctx, buf + (..));
    ensures \result ≤ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int parse_ext_subjectDirAttr(u8 const *buf, u16 len, int critical,
                                    cert_parsing_ctx *ctx)
{
  int ret;
  u16 hdr_len = (u16)0;
  u16 data_len = (u16)0;
  u16 oid_len = (u16)0;
  u16 remain = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -6639;
              goto out;
            }
    }
  if (critical) {
    ret = -6649;
    goto out;
  }
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & hdr_len,& data_len);
  if (ret) goto out;
  buf += (int)hdr_len;
  remain = data_len;
  if ((int)len != (int)hdr_len + (int)data_len) {
    ret = -6666;
    goto out;
  }
  /*@ loop invariant \valid_read(buf + (0 .. remain - 1));
      loop assigns ret, buf, remain, hdr_len, data_len, oid_len;
      loop variant remain;
  */
  while (remain) {
    ret = parse_id_len(buf,remain,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                       & hdr_len,& data_len);
    if (ret) goto out;
    buf += (int)hdr_len;
    remain = (u16)((int)remain - (int)hdr_len);
    ret = parse_OID(buf,data_len,& oid_len);
    if (ret) goto out;
    remain = (u16)((int)remain - (int)data_len);
    buf += (int)data_len;
  }
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(ctx);
    requires \separated(ctx, buf + (..));
    ensures \result ≤ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *ctx;
 */
static int parse_ext_basicConstraints(u8 const *buf, u16 len, int critical,
                                      cert_parsing_ctx *ctx)
{
  int ret;
  u16 hdr_len = (u16)0;
  u16 data_len = (u16)0;
  u8 const ca_true_wo_plc[3] = {(u8)0x01, (u8)0x01, (u8)0xff};
  u8 const ca_true_w_plc[5] =
    {(u8)0x01, (u8)0x01, (u8)0xff, (u8)0x02, (u8)0x01};
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -6736;
              goto out;
            }
    }
  ctx->bc_critical = critical;
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & hdr_len,& data_len);
  if (ret) goto out;
  buf += (int)hdr_len;
  if ((int)len != (int)hdr_len + (int)data_len) {
    ret = -6755;
    goto out;
  }
  switch ((int)data_len) {
    case 0: ret = 0;
    break;
    case 3: ret = bufs_differ(buf,ca_true_wo_plc,(u16)3);
    if (ret) {
      ret = -6786;
      goto out;
    }
    ctx->ca_true = 1;
    break;
    case 6: ret = bufs_differ(buf,ca_true_w_plc,(u16)5);
    if (ret) {
      ret = -6795;
      goto out;
    }
    if ((int)*(buf + 5) & 0x80) {
      ret = -6807;
      goto out;
    }
    ctx->ca_true = 1;
    ctx->pathLenConstraint_set = 1;
    break;
    default: ret = -6815;
    break;
  }
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    ensures \result ≤ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int parse_GeneralSubtrees(u8 const *buf, u16 len)
{
  int ret;
  u16 hdr_len = (u16)0;
  u16 remain = (u16)0;
  u16 grabbed = (u16)0;
  u16 data_len = (u16)0;
  int unused = 0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -6851;
              goto out;
            }
    }
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & hdr_len,& data_len);
  if (ret) goto out;
  buf += (int)hdr_len;
  remain = data_len;
  ret = parse_GeneralName(buf,remain,& grabbed,& unused);
  if (ret) goto out;
  buf += (int)grabbed;
  remain = (u16)((int)remain - (int)grabbed);
  ret = parse_id_len(buf,remain,CLASS_CONTEXT_SPECIFIC,(u32)0,& hdr_len,
                     & data_len);
  if (! ret) {
    ret = -6890;
    goto out;
  }
  ret = parse_id_len(buf,remain,CLASS_CONTEXT_SPECIFIC,(u32)1,& hdr_len,
                     & data_len);
  if (! ret) {
    ret = -6899;
    goto out;
  }
  if (remain) {
    ret = -6906;
    goto out;
  }
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(ctx);
    requires \separated(ctx, buf + (..));
    ensures \result < 0 ∨ \result ≡ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *ctx;
 */
static int parse_ext_nameConstraints(u8 const *buf, u16 len, int critical,
                                     cert_parsing_ctx *ctx)
{
  int ret;
  u16 remain = (u16)0;
  u16 hdr_len = (u16)0;
  u16 data_len = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -6935;
              goto out;
            }
    }
  if (! critical) {
    ret = -6945;
    goto out;
  }
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & hdr_len,& remain);
  if (ret) goto out;
  buf += (int)hdr_len;
  if (! remain) {
    ret = -6965;
    goto out;
  }
  ret = parse_id_len(buf,remain,CLASS_CONTEXT_SPECIFIC,(u32)0,& hdr_len,
                     & data_len);
  if (! ret) {
    buf += (int)hdr_len;
    remain = (u16)((int)remain - (int)hdr_len);
    ret = parse_GeneralSubtrees(buf,data_len);
    if (ret) goto out;
    buf += (int)data_len;
    remain = (u16)((int)remain - (int)data_len);
  }
  ret = parse_id_len(buf,remain,CLASS_CONTEXT_SPECIFIC,(u32)1,& hdr_len,
                     & data_len);
  if (! ret) {
    buf += (int)hdr_len;
    remain = (u16)((int)remain - (int)hdr_len);
    ret = parse_GeneralSubtrees(buf,data_len);
    if (ret) goto out;
    buf += (int)data_len;
    remain = (u16)((int)remain - (int)data_len);
  }
  if (remain) {
    ret = -7005;
    goto out;
  }
  ctx->has_name_constraints = 1;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(ctx);
    requires \separated(ctx, buf + (..));
    ensures \result ≤ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int parse_ext_policyConstraints(u8 const *buf, u16 len, int critical,
                                       cert_parsing_ctx *ctx)
{
  int ret;
  u16 data_len = (u16)0;
  u16 hdr_len = (u16)0;
  u16 remain = (u16)0;
  u16 parsed = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -7047;
              goto out;
            }
    }
  if (! critical) {
    ret = -7057;
    goto out;
  }
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & hdr_len,& data_len);
  if (ret) {
    ret = -7066;
    goto out;
  }
  if ((int)data_len == 0) {
    ret = -7076;
    goto out;
  }
  buf += (int)hdr_len;
  remain = data_len;
  ret = parse_integer(buf,remain,CLASS_CONTEXT_SPECIFIC,(u32)0,& parsed);
  if (! ret) {
    if ((int)parsed != 3) {
      ret = -7094;
      goto out;
    }
    buf += (int)parsed;
    remain = (u16)((int)remain - (int)parsed);
  }
  ret = parse_integer(buf,remain,CLASS_CONTEXT_SPECIFIC,(u32)1,& parsed);
  if (! ret) {
    if ((int)parsed != 3) {
      ret = -7113;
      goto out;
    }
    buf += (int)parsed;
    remain = (u16)((int)remain - (int)parsed);
  }
  if (remain) {
    ret = -7123;
    goto out;
  }
  ret = 0;
  out: ;
  return ret;
}

static u8 const _id_kp_anyEKU[10] =
  {(u8)0x06,
   (u8)0x08,
   (u8)0x2b,
   (u8)0x06,
   (u8)0x01,
   (u8)0x05,
   (u8)0x05,
   (u8)0x07,
   (u8)0x03,
   (u8)0x00};
static u8 const _id_kp_serverAuth[10] =
  {(u8)0x06,
   (u8)0x08,
   (u8)0x2b,
   (u8)0x06,
   (u8)0x01,
   (u8)0x05,
   (u8)0x05,
   (u8)0x07,
   (u8)0x03,
   (u8)0x01};
static u8 const _id_kp_clientAuth[10] =
  {(u8)0x06,
   (u8)0x08,
   (u8)0x2b,
   (u8)0x06,
   (u8)0x01,
   (u8)0x05,
   (u8)0x05,
   (u8)0x07,
   (u8)0x03,
   (u8)0x02};
static u8 const _id_kp_codeSigning[10] =
  {(u8)0x06,
   (u8)0x08,
   (u8)0x2b,
   (u8)0x06,
   (u8)0x01,
   (u8)0x05,
   (u8)0x05,
   (u8)0x07,
   (u8)0x03,
   (u8)0x03};
static u8 const _id_kp_emailProt[10] =
  {(u8)0x06,
   (u8)0x08,
   (u8)0x2b,
   (u8)0x06,
   (u8)0x01,
   (u8)0x05,
   (u8)0x05,
   (u8)0x07,
   (u8)0x03,
   (u8)0x04};
static u8 const _id_kp_timeStamping[10] =
  {(u8)0x06,
   (u8)0x08,
   (u8)0x2b,
   (u8)0x06,
   (u8)0x01,
   (u8)0x05,
   (u8)0x05,
   (u8)0x07,
   (u8)0x03,
   (u8)0x08};
static u8 const _id_kp_OCSPSigning[10] =
  {(u8)0x06,
   (u8)0x08,
   (u8)0x2b,
   (u8)0x06,
   (u8)0x01,
   (u8)0x05,
   (u8)0x05,
   (u8)0x07,
   (u8)0x03,
   (u8)0x09};
static _kp_oid const known_kp_oids[7] =
  {{.oid = _id_kp_anyEKU, .oid_len = (u8)sizeof(_id_kp_anyEKU)},
   {.oid = _id_kp_serverAuth, .oid_len = (u8)sizeof(_id_kp_serverAuth)},
   {.oid = _id_kp_clientAuth, .oid_len = (u8)sizeof(_id_kp_clientAuth)},
   {.oid = _id_kp_codeSigning, .oid_len = (u8)sizeof(_id_kp_codeSigning)},
   {.oid = _id_kp_emailProt, .oid_len = (u8)sizeof(_id_kp_emailProt)},
   {.oid = _id_kp_timeStamping, .oid_len = (u8)sizeof(_id_kp_timeStamping)},
   {.oid = _id_kp_OCSPSigning, .oid_len = (u8)sizeof(_id_kp_OCSPSigning)}};
/*@ requires len ≥ 0;
    requires
      len > 0 ∧ buf ≢ (u8 const *)0 ⇒ \valid_read(buf + (0 .. len - 1));
    ensures
      \result ≢ (_kp_oid const *)0 ⇒
      (∃ ℤ i;
         0 ≤ i < sizeof(known_kp_oids) / sizeof(known_kp_oids[0]) ∧
         \result ≡ &known_kp_oids[i]);
    ensures \old(len) ≡ 0 ⇒ \result ≡ (_kp_oid const *)0;
    ensures \old(buf) ≡ (u8 const *)0 ⇒ \result ≡ (_kp_oid const *)0;
    assigns \nothing;
 */
static _kp_oid const *find_kp_by_oid(u8 const *buf, u16 len)
{
  u8 k;
  _kp_oid const *found = (_kp_oid const *)0;
  _kp_oid const *cur = (_kp_oid const *)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) _LOR: goto out;
  k = (u8)0;
  /*@ loop invariant
        0 ≤ k ≤ sizeof(known_kp_oids) / sizeof(known_kp_oids[0]);
      loop invariant found ≡ (_kp_oid const *)0;
      loop assigns cur, found, k;
      loop variant sizeof(known_kp_oids) / sizeof(known_kp_oids[0]) - k;
  */
  while ((unsigned long)k < sizeof(known_kp_oids) / sizeof(known_kp_oids[0])) {
    {
      int ret;
      int tmp_0;
      int tmp;
      cur = & known_kp_oids[k];
      /*@ assert cur ≡ &known_kp_oids[k]; */ ;
      if ((int)cur->oid_len != (int)len) goto __Cont;
      /*@ assert \valid_read(buf + (0 .. len - 1)); */ ;
      tmp = bufs_differ(cur->oid,buf,(u16)cur->oid_len);
      if (tmp) tmp_0 = 0; else tmp_0 = 1;
      ret = tmp_0;
      if (ret) {
        found = cur;
        break;
      }
    }
    __Cont: k = (u8)((int)k + 1);
  }
  out: ;
  return found;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(ctx);
    requires \separated(ctx, buf + (..));
    ensures \result ≤ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int parse_ext_EKU(u8 const *buf, u16 len, int critical,
                         cert_parsing_ctx *ctx)
{
  int ret;
  u16 remain = (u16)0;
  u16 data_len = (u16)0;
  u16 hdr_len = (u16)0;
  u16 oid_len = (u16)0;
  _kp_oid const *kp = (_kp_oid const *)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -7262;
              goto out;
            }
    }
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & hdr_len,& data_len);
  if (ret) goto _LOR_0;
  else 
    if ((int)data_len == 0) {
      _LOR_0: {
                ret = -7270;
                goto out;
              }
    }
  buf += (int)hdr_len;
  remain = data_len;
  if ((int)len != (int)hdr_len + (int)data_len) {
    ret = -7279;
    goto out;
  }
  /*@ loop invariant \valid_read(buf + (0 .. remain - 1));
      loop assigns ret, oid_len, kp, buf, remain;
      loop variant remain;
  */
  while (remain) {
    ret = parse_OID(buf,remain,& oid_len);
    if (ret) goto out;
    kp = find_kp_by_oid(buf,oid_len);
    if (kp == (_kp_oid const *)0) {
      ret = -7299;
      goto out;
    }
    if (kp->oid == _id_kp_anyEKU) 
      if (critical) {
        ret = -7310;
        goto out;
      }
    buf += (int)oid_len;
    remain = (u16)((int)remain - (int)oid_len);
  }
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(eaten);
    requires \separated(eaten, buf + (..));
    ensures \result ≤ 0;
    ensures \result ≡ 0 ⇒ *\old(eaten) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *eaten;
 */
static int parse_crldp_reasons(u8 const *buf, u16 len, u16 *eaten)
{
  u16 val;
  int ret;
  u16 hdr_len = (u16)0;
  u16 data_len = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -7355;
              goto out;
            }
    }
  ret = parse_id_len(buf,len,CLASS_CONTEXT_SPECIFIC,(u32)1,& hdr_len,
                     & data_len);
  if (ret) goto out;
  buf += (int)hdr_len;
  len = (u16)((int)len - (int)hdr_len);
  ret = parse_nine_bit_named_bit_list(buf,data_len,& val);
  if (ret) goto out;
  *eaten = (u16)((int)hdr_len + (int)data_len);
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(eaten);
    requires \valid(ctx);
    requires \separated(eaten, ctx, buf + (..));
    ensures \result ≤ 0;
    ensures \result ≡ 0 ⇒ 0 < *\old(eaten) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *eaten, *ctx;
 */
static int parse_DistributionPoint(u8 const *buf, u16 len, u16 *eaten,
                                   cert_parsing_ctx *ctx)
{
  int ret;
  u16 hdr_len = (u16)0;
  u16 data_len = (u16)0;
  u16 remain = (u16)0;
  u16 total_len = (u16)0;
  int dp_or_issuer_present = 0;
  u16 parsed = (u16)0;
  int has_all_reasons = 0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -7426;
              goto out;
            }
    }
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & hdr_len,& data_len);
  if (ret) {
    ret = -7436;
    goto out;
  }
  total_len = (u16)((int)hdr_len + (int)data_len);
  /*@ assert total_len > 0; */ ;
  remain = data_len;
  buf += (int)hdr_len;
  ret = parse_id_len(buf,remain,CLASS_CONTEXT_SPECIFIC,(u32)0,& hdr_len,
                     & data_len);
  if (! ret) {
    u8 dpn_type;
    u16 dpn_remain = (u16)0;
    u16 dpn_eaten = (u16)0;
    buf += (int)hdr_len;
    remain = (u16)((int)remain - (int)hdr_len);
    dpn_remain = data_len;
    if ((int)data_len == 0) {
      ret = -7460;
      goto out;
    }
    dpn_type = *(buf + 0);
    switch ((int)dpn_type) {
      case 0xa0:
      ret = parse_GeneralNames(buf,dpn_remain,CLASS_CONTEXT_SPECIFIC,(u32)0,
                               & dpn_eaten);
      if (ret) goto out;
      dpn_remain = (u16)((int)dpn_remain - (int)dpn_eaten);
      buf += (int)dpn_eaten;
      break;
      case 0xa1: ret = -7493;
      goto out;
      break;
      default: ret = -7498;
      goto out;
      break;
    }
    if (dpn_remain) {
      ret = -7504;
      goto out;
    }
    dp_or_issuer_present |= 1;
    remain = (u16)((int)remain - (int)data_len);
  }
  ret = parse_id_len(buf,remain,CLASS_CONTEXT_SPECIFIC,(u32)1,& hdr_len,
                     & data_len);
  if (! ret) {
    ret = parse_crldp_reasons(buf,remain,& parsed);
    if (ret) goto out;
    buf += (int)parsed;
    remain = (u16)((int)remain - (int)parsed);
  }
  else has_all_reasons = 1;
  ret = parse_GeneralNames(buf,remain,CLASS_CONTEXT_SPECIFIC,(u32)2,& parsed);
  if (! ret) {
    dp_or_issuer_present |= 1;
    buf += (int)parsed;
    remain = (u16)((int)remain - (int)parsed);
  }
  if (remain) {
    ret = -7547;
    goto out;
  }
  if (! dp_or_issuer_present) {
    ret = -7558;
    goto out;
  }
  *eaten = total_len;
  ctx->one_crldp_has_all_reasons |= has_all_reasons;
  /*@ assert *eaten > 0; */ ;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(ctx);
    requires \separated(ctx, buf + (..));
    ensures \result ≤ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *ctx;
 */
static int parse_ext_CRLDP(u8 const *buf, u16 len, int critical,
                           cert_parsing_ctx *ctx)
{
  u16 remain;
  int ret;
  u16 hdr_len = (u16)0;
  u16 data_len = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -7604;
              goto out;
            }
    }
  if (critical) {
    ret = -7611;
    goto out;
  }
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & hdr_len,& data_len);
  if (ret) goto out;
  buf += (int)hdr_len;
  remain = data_len;
  if ((int)len != (int)hdr_len + (int)data_len) {
    ret = -7629;
    goto out;
  }
  ctx->has_crldp = 1;
  ctx->one_crldp_has_all_reasons = 0;
  /*@ loop invariant \valid_read(buf + (0 .. remain - 1));
      loop assigns ret, buf, remain, *ctx;
      loop variant remain;
  */
  while (remain) {
    u16 eaten = (u16)0;
    ret = parse_DistributionPoint(buf,remain,& eaten,ctx);
    if (ret) goto out;
    remain = (u16)((int)remain - (int)eaten);
    buf += (int)eaten;
  }
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(ctx);
    requires \separated(ctx, buf + (..));
    ensures \result ≤ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
static int parse_ext_inhibitAnyPolicy(u8 const *buf, u16 len, int critical,
                                      cert_parsing_ctx *ctx)
{
  int ret;
  u16 eaten = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -7687;
              goto out;
            }
    }
  if (! critical) {
    ret = -7697;
    goto out;
  }
  ret = parse_integer(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_INTEGER,& eaten);
  if (ret) {
    ret = -7705;
    goto out;
  }
  if ((int)eaten != 3) {
    ret = -7715;
    goto out;
  }
  if ((int)*(buf + 2) & 0x80) goto _LOR_0;
  else 
    if ((int)*(buf + 2) > 64) {
      _LOR_0: {
                ret = -7721;
                goto out;
              }
    }
  if ((int)eaten != (int)len) {
    ret = -7727;
    goto out;
  }
  ret = 0;
  out: ;
  return ret;
}

static u8 const _ext_oid_AIA[10] =
  {(u8)0x06,
   (u8)0x08,
   (u8)0x2b,
   (u8)0x06,
   (u8)0x01,
   (u8)0x05,
   (u8)0x05,
   (u8)0x07,
   (u8)0x01,
   (u8)0x01};
static u8 const _ext_oid_subjectDirAttr[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x1d, (u8)0x09};
static u8 const _ext_oid_SKI[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x1d, (u8)0x0e};
static u8 const _ext_oid_keyUsage[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x1d, (u8)0x0f};
static u8 const _ext_oid_SAN[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x1d, (u8)0x11};
static u8 const _ext_oid_IAN[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x1d, (u8)0x12};
static u8 const _ext_oid_basicConstraints[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x1d, (u8)0x13};
static u8 const _ext_oid_nameConstraints[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x1d, (u8)0x1e};
static u8 const _ext_oid_CRLDP[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x1d, (u8)0x1f};
static u8 const _ext_oid_certPolicies[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x1d, (u8)0x20};
static u8 const _ext_oid_policyMapping[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x1d, (u8)0x21};
static u8 const _ext_oid_AKI[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x1d, (u8)0x23};
static u8 const _ext_oid_policyConstraints[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x1d, (u8)0x24};
static u8 const _ext_oid_EKU[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x1d, (u8)0x25};
static u8 const _ext_oid_FreshestCRL[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x1d, (u8)0x2e};
static u8 const _ext_oid_inhibitAnyPolicy[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x1d, (u8)0x36};
/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(ctx);
    requires \separated(ctx, buf + (..));
    ensures \result ≤ 0;
    assigns \nothing;
 */
static int parse_ext_bad_oid(u8 const *buf, u16 len, int critical,
                             cert_parsing_ctx *ctx)
{
  int ret;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -7773;
              goto out;
            }
    }
  ret = 0;
  out: ;
  return ret;
}

static u8 const _ext_oid_bad_ct1[10] =
  {(u8)0x06,
   (u8)0x08,
   (u8)0x2b,
   (u8)0x06,
   (u8)0x01,
   (u8)0x05,
   (u8)0x05,
   (u8)0x07,
   (u8)0x01,
   (u8)0x01};
static u8 const _ext_oid_bad_ct_poison[12] =
  {(u8)0x06,
   (u8)0x0a,
   (u8)0x2b,
   (u8)0x06,
   (u8)0x01,
   (u8)0x04,
   (u8)0x01,
   (u8)0xd6,
   (u8)0x79,
   (u8)0x02,
   (u8)0x04,
   (u8)0x03};
static u8 const _ext_oid_bad_ct_enabled[12] =
  {(u8)0x06,
   (u8)0x0a,
   (u8)0x2b,
   (u8)0x06,
   (u8)0x01,
   (u8)0x04,
   (u8)0x01,
   (u8)0xd6,
   (u8)0x79,
   (u8)0x02,
   (u8)0x04,
   (u8)0x02};
static u8 const _ext_oid_bad_ns_cert_type[11] =
  {(u8)0x06,
   (u8)0x09,
   (u8)0x60,
   (u8)0x86,
   (u8)0x48,
   (u8)0x01,
   (u8)0x86,
   (u8)0xf8,
   (u8)0x42,
   (u8)0x01,
   (u8)0x01};
static u8 const _ext_oid_bad_szOID_ENROLL[11] =
  {(u8)0x06,
   (u8)0x09,
   (u8)0x2b,
   (u8)0x06,
   (u8)0x01,
   (u8)0x04,
   (u8)0x01,
   (u8)0x82,
   (u8)0x37,
   (u8)0x14,
   (u8)0x02};
static u8 const _ext_oid_bad_smime_cap[11] =
  {(u8)0x06,
   (u8)0x09,
   (u8)0x2a,
   (u8)0x86,
   (u8)0x48,
   (u8)0x86,
   (u8)0xf7,
   (u8)0x0d,
   (u8)0x01,
   (u8)0x09,
   (u8)0x0f};
static u8 const _ext_oid_bad_ns_comment[11] =
  {(u8)0x06,
   (u8)0x09,
   (u8)0x60,
   (u8)0x86,
   (u8)0x48,
   (u8)0x01,
   (u8)0x86,
   (u8)0xf8,
   (u8)0x42,
   (u8)0x01,
   (u8)0x0d};
static u8 const _ext_oid_bad_deprecated_AKI[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x1d, (u8)0x01};
static u8 const _ext_oid_bad_szOID_CERT_TEMPLATE[11] =
  {(u8)0x06,
   (u8)0x09,
   (u8)0x2b,
   (u8)0x06,
   (u8)0x01,
   (u8)0x04,
   (u8)0x01,
   (u8)0x82,
   (u8)0x37,
   (u8)0x15,
   (u8)0x07};
static u8 const _ext_oid_bad_pkixFixes[12] =
  {(u8)0x06,
   (u8)0x0a,
   (u8)0x2b,
   (u8)0x06,
   (u8)0x01,
   (u8)0x04,
   (u8)0x01,
   (u8)0x97,
   (u8)0x55,
   (u8)0x03,
   (u8)0x01,
   (u8)0x05};
static u8 const _ext_oid_bad_ns_ca_policy_url[11] =
  {(u8)0x06,
   (u8)0x09,
   (u8)0x60,
   (u8)0x86,
   (u8)0x48,
   (u8)0x01,
   (u8)0x86,
   (u8)0xf8,
   (u8)0x42,
   (u8)0x01,
   (u8)0x08};
static u8 const _ext_oid_bad_szOID_CERTSRV_CA_VERS[11] =
  {(u8)0x06,
   (u8)0x09,
   (u8)0x2b,
   (u8)0x06,
   (u8)0x01,
   (u8)0x04,
   (u8)0x01,
   (u8)0x82,
   (u8)0x37,
   (u8)0x15,
   (u8)0x01};
static u8 const _ext_oid_bad_szOID_APP_CERT_POL[5] =
  {(u8)0x06, (u8)0x03, (u8)0x55, (u8)0x1d, (u8)0x10};
static _ext_oid const known_ext_oids[29] =
  {{.oid = _ext_oid_AIA,
    .oid_len = (u8)sizeof(_ext_oid_AIA),
    .parse_ext_params = & parse_ext_AIA},
   {.oid = _ext_oid_AKI,
    .oid_len = (u8)sizeof(_ext_oid_AKI),
    .parse_ext_params = & parse_ext_AKI},
   {.oid = _ext_oid_SKI,
    .oid_len = (u8)sizeof(_ext_oid_SKI),
    .parse_ext_params = & parse_ext_SKI},
   {.oid = _ext_oid_keyUsage,
    .oid_len = (u8)sizeof(_ext_oid_keyUsage),
    .parse_ext_params = & parse_ext_keyUsage},
   {.oid = _ext_oid_certPolicies,
    .oid_len = (u8)sizeof(_ext_oid_certPolicies),
    .parse_ext_params = & parse_ext_certPolicies},
   {.oid = _ext_oid_policyMapping,
    .oid_len = (u8)sizeof(_ext_oid_policyMapping),
    .parse_ext_params = & parse_ext_policyMapping},
   {.oid = _ext_oid_SAN,
    .oid_len = (u8)sizeof(_ext_oid_SAN),
    .parse_ext_params = & parse_ext_SAN},
   {.oid = _ext_oid_IAN,
    .oid_len = (u8)sizeof(_ext_oid_IAN),
    .parse_ext_params = & parse_ext_IAN},
   {.oid = _ext_oid_subjectDirAttr,
    .oid_len = (u8)sizeof(_ext_oid_subjectDirAttr),
    .parse_ext_params = & parse_ext_subjectDirAttr},
   {.oid = _ext_oid_basicConstraints,
    .oid_len = (u8)sizeof(_ext_oid_basicConstraints),
    .parse_ext_params = & parse_ext_basicConstraints},
   {.oid = _ext_oid_nameConstraints,
    .oid_len = (u8)sizeof(_ext_oid_nameConstraints),
    .parse_ext_params = & parse_ext_nameConstraints},
   {.oid = _ext_oid_policyConstraints,
    .oid_len = (u8)sizeof(_ext_oid_policyConstraints),
    .parse_ext_params = & parse_ext_policyConstraints},
   {.oid = _ext_oid_EKU,
    .oid_len = (u8)sizeof(_ext_oid_EKU),
    .parse_ext_params = & parse_ext_EKU},
   {.oid = _ext_oid_CRLDP,
    .oid_len = (u8)sizeof(_ext_oid_CRLDP),
    .parse_ext_params = & parse_ext_CRLDP},
   {.oid = _ext_oid_inhibitAnyPolicy,
    .oid_len = (u8)sizeof(_ext_oid_inhibitAnyPolicy),
    .parse_ext_params = & parse_ext_inhibitAnyPolicy},
   {.oid = _ext_oid_FreshestCRL,
    .oid_len = (u8)sizeof(_ext_oid_FreshestCRL),
    .parse_ext_params = & parse_ext_CRLDP},
   {.oid = _ext_oid_bad_ct1,
    .oid_len = (u8)sizeof(_ext_oid_bad_ct1),
    .parse_ext_params = & parse_ext_bad_oid},
   {.oid = _ext_oid_bad_ct_poison,
    .oid_len = (u8)sizeof(_ext_oid_bad_ct_poison),
    .parse_ext_params = & parse_ext_bad_oid},
   {.oid = _ext_oid_bad_ct_enabled,
    .oid_len = (u8)sizeof(_ext_oid_bad_ct_enabled),
    .parse_ext_params = & parse_ext_bad_oid},
   {.oid = _ext_oid_bad_ns_cert_type,
    .oid_len = (u8)sizeof(_ext_oid_bad_ns_cert_type),
    .parse_ext_params = & parse_ext_bad_oid},
   {.oid = _ext_oid_bad_szOID_ENROLL,
    .oid_len = (u8)sizeof(_ext_oid_bad_szOID_ENROLL),
    .parse_ext_params = & parse_ext_bad_oid},
   {.oid = _ext_oid_bad_smime_cap,
    .oid_len = (u8)sizeof(_ext_oid_bad_smime_cap),
    .parse_ext_params = & parse_ext_bad_oid},
   {.oid = _ext_oid_bad_ns_comment,
    .oid_len = (u8)sizeof(_ext_oid_bad_ns_comment),
    .parse_ext_params = & parse_ext_bad_oid},
   {.oid = _ext_oid_bad_deprecated_AKI,
    .oid_len = (u8)sizeof(_ext_oid_bad_deprecated_AKI),
    .parse_ext_params = & parse_ext_bad_oid},
   {.oid = _ext_oid_bad_szOID_CERT_TEMPLATE,
    .oid_len = (u8)sizeof(_ext_oid_bad_szOID_CERT_TEMPLATE),
    .parse_ext_params = & parse_ext_bad_oid},
   {.oid = _ext_oid_bad_pkixFixes,
    .oid_len = (u8)sizeof(_ext_oid_bad_pkixFixes),
    .parse_ext_params = & parse_ext_bad_oid},
   {.oid = _ext_oid_bad_ns_ca_policy_url,
    .oid_len = (u8)sizeof(_ext_oid_bad_ns_ca_policy_url),
    .parse_ext_params = & parse_ext_bad_oid},
   {.oid = _ext_oid_bad_szOID_CERTSRV_CA_VERS,
    .oid_len = (u8)sizeof(_ext_oid_bad_szOID_CERTSRV_CA_VERS),
    .parse_ext_params = & parse_ext_bad_oid},
   {.oid = _ext_oid_bad_szOID_APP_CERT_POL,
    .oid_len = (u8)sizeof(_ext_oid_bad_szOID_APP_CERT_POL),
    .parse_ext_params = & parse_ext_bad_oid}};
/*@ requires len ≥ 0;
    requires
      len > 0 ∧ buf ≢ (u8 const *)0 ⇒ \valid_read(buf + (0 .. len - 1));
    ensures
      \result ≢ (_ext_oid const *)0 ⇒
      (∃ ℤ i;
         0 ≤ i < sizeof(known_ext_oids) / sizeof(known_ext_oids[0]) ∧
         \result ≡ &known_ext_oids[i]);
    ensures \old(len) ≡ 0 ⇒ \result ≡ (_ext_oid const *)0;
    ensures \old(buf) ≡ (u8 const *)0 ⇒ \result ≡ (_ext_oid const *)0;
    assigns \nothing;
 */
static _ext_oid const *find_ext_by_oid(u8 const *buf, u16 len)
{
  u8 k;
  _ext_oid const *found = (_ext_oid const *)0;
  _ext_oid const *cur = (_ext_oid const *)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) _LOR: goto out;
  k = (u8)0;
  /*@ loop invariant
        0 ≤ k ≤ sizeof(known_ext_oids) / sizeof(known_ext_oids[0]);
      loop invariant found ≡ (_ext_oid const *)0;
      loop assigns cur, found, k;
      loop variant sizeof(known_ext_oids) / sizeof(known_ext_oids[0]) - k;
      loop unroll sizeof(known_ext_oids) / sizeof(known_ext_oids[0]);
  */
  while ((unsigned long)k < sizeof(known_ext_oids) / sizeof(known_ext_oids[0])) {
    {
      int ret;
      int tmp_0;
      int tmp;
      cur = & known_ext_oids[k];
      /*@ assert cur ≡ &known_ext_oids[k]; */ ;
      if ((int)cur->oid_len != (int)len) goto __Cont;
      /*@ assert \valid_read(buf + (0 .. len - 1)); */ ;
      tmp = bufs_differ(cur->oid,buf,(u16)cur->oid_len);
      if (tmp) tmp_0 = 0; else tmp_0 = 1;
      ret = tmp_0;
      if (ret) {
        found = cur;
        break;
      }
    }
    __Cont: k = (u8)((int)k + 1);
  }
  out: ;
  return found;
}

/*@ requires ext ≢ \null;
    requires
      \valid(parsed_oid_list +
             (0 .. sizeof(known_ext_oids) / sizeof(known_ext_oids[0]) - 1));
    requires
      \initialized(parsed_oid_list +
                   (0 ..
                        sizeof(known_ext_oids) / sizeof(known_ext_oids[0]) -
                        1));
    ensures \result ≤ 0;
    assigns *(parsed_oid_list +
              (0 .. sizeof(known_ext_oids) / sizeof(known_ext_oids[0]) - 1));
 */
static int check_record_ext_unknown(_ext_oid const *ext,
                                    _ext_oid const **parsed_oid_list)
{
  int ret;
  u16 pos = (u16)0;
  /*@ loop invariant
        pos ≤ sizeof(known_ext_oids) / sizeof(known_ext_oids[0]);
      loop assigns ret, pos,
                   *(parsed_oid_list +
                     (0 ..
                          sizeof(known_ext_oids) / sizeof(known_ext_oids[0])
                          - 1));
      loop variant sizeof(known_ext_oids) / sizeof(known_ext_oids[0]) - pos;
  */
  while ((unsigned long)pos < sizeof(known_ext_oids) / sizeof(known_ext_oids[0])) {
    if (*(parsed_oid_list + pos) == (_ext_oid const *)0) {
      *(parsed_oid_list + pos) = ext;
      break;
    }
    if (ext == *(parsed_oid_list + pos)) {
      ret = -8134;
      goto out;
    }
    pos = (u16)((int)pos + 1);
  }
  if ((unsigned long)pos >= sizeof(known_ext_oids) / sizeof(known_ext_oids[0])) {
    ret = -8146;
    goto out;
  }
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(eaten);
    requires \valid(ctx);
    requires \valid(parsed_oid_list);
    requires
      \initialized(parsed_oid_list +
                   (0 ..
                        sizeof(known_ext_oids) / sizeof(known_ext_oids[0]) -
                        1));
    ensures \result ≤ 0;
    ensures \result ≡ 0 ⇒ 1 ≤ *\old(eaten) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *(parsed_oid_list +
              (0 .. sizeof(known_ext_oids) / sizeof(known_ext_oids[0]) - 1)),
            *eaten, *ctx;
 */
static int parse_x509_Extension(u8 const *buf, u16 len,
                                _ext_oid const **parsed_oid_list, u16 *eaten,
                                cert_parsing_ctx *ctx)
{
  int ret;
  u16 data_len = (u16)0;
  u16 hdr_len = (u16)0;
  u16 remain = (u16)0;
  u16 ext_hdr_len = (u16)0;
  u16 ext_data_len = (u16)0;
  u16 oid_len = (u16)0;
  u16 saved_ext_len = (u16)0;
  u16 parsed = (u16)0;
  _ext_oid const *ext = (_ext_oid const *)0;
  int critical = 0;
  /*@
  assert
  \initialized(parsed_oid_list +
               (0 .. sizeof(known_ext_oids) / sizeof(known_ext_oids[0]) - 1));
   */
  ;
  remain = len;
  ret = parse_id_len(buf,remain,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & ext_hdr_len,& ext_data_len);
  if (ret) goto out;
  buf += (int)ext_hdr_len;
  remain = (u16)((int)remain - (int)ext_hdr_len);
  saved_ext_len = (u16)((int)ext_hdr_len + (int)ext_data_len);
  /*@
  assert
  \initialized(parsed_oid_list +
               (0 .. sizeof(known_ext_oids) / sizeof(known_ext_oids[0]) - 1));
   */
  ;
  ret = parse_OID(buf,ext_data_len,& oid_len);
  if (ret) goto out;
  /*@
  assert
  \initialized(parsed_oid_list +
               (0 .. sizeof(known_ext_oids) / sizeof(known_ext_oids[0]) - 1));
   */
  ;
  ext = find_ext_by_oid(buf,oid_len);
  if (ext == (_ext_oid const *)0) {
    ret = -8226;
    goto out;
  }
  /*@
  assert
  \initialized(parsed_oid_list +
               (0 .. sizeof(known_ext_oids) / sizeof(known_ext_oids[0]) - 1));
   */
  ;
  ret = check_record_ext_unknown(ext,parsed_oid_list);
  if (ret) goto out;
  buf += (int)oid_len;
  ext_data_len = (u16)((int)ext_data_len - (int)oid_len);
  ret = parse_boolean(buf,ext_data_len,& parsed);
  if (! ret) {
    if ((int)parsed != 3) goto _LOR;
    else 
      if ((int)*(buf + 2) == 0x00) {
        _LOR: {
                ret = -8277;
                goto out;
              }
      }
    critical = 1;
    buf += (int)parsed;
    ext_data_len = (u16)((int)ext_data_len - (int)parsed);
  }
  ret = parse_id_len(buf,ext_data_len,CLASS_UNIVERSAL,
                     (u32)ASN1_TYPE_OCTET_STRING,& hdr_len,& data_len);
  if (ret) goto out;
  buf += (int)hdr_len;
  ext_data_len = (u16)((int)ext_data_len - (int)hdr_len);
  if ((int)data_len != (int)ext_data_len) {
    ret = -8309;
    goto out;
  }
  /*@
  assert
  ext->parse_ext_params ∈
  {&parse_ext_AIA, &parse_ext_AKI, &parse_ext_SKI, &parse_ext_keyUsage,
   &parse_ext_certPolicies, &parse_ext_policyMapping, &parse_ext_SAN,
   &parse_ext_IAN, &parse_ext_subjectDirAttr, &parse_ext_basicConstraints,
   &parse_ext_nameConstraints, &parse_ext_policyConstraints, &parse_ext_EKU,
   &parse_ext_CRLDP, &parse_ext_inhibitAnyPolicy, &parse_ext_bad_oid}; */
  ;
  /*@ calls parse_ext_AIA, parse_ext_AKI, parse_ext_SKI, parse_ext_keyUsage,
            parse_ext_certPolicies, parse_ext_policyMapping, parse_ext_SAN,
            parse_ext_IAN, parse_ext_subjectDirAttr,
            parse_ext_basicConstraints, parse_ext_nameConstraints,
            parse_ext_policyConstraints, parse_ext_EKU, parse_ext_CRLDP,
            parse_ext_inhibitAnyPolicy, parse_ext_bad_oid;
  */
  ret = (*(ext->parse_ext_params))(buf,ext_data_len,critical,ctx);
  if (ret) goto out;
  *eaten = saved_ext_len;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(eaten);
    requires \valid(ctx);
    requires \separated(eaten, ctx, buf + (..));
    ensures \result ≤ 0;
    ensures \result ≡ 0 ⇒ 1 ≤ *\old(eaten) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *eaten, *ctx;
 */
static int parse_x509_Extensions(u8 const *buf, u16 len, u16 *eaten,
                                 cert_parsing_ctx *ctx)
{
  _ext_oid const *parsed_oid_list[sizeof(known_ext_oids) / sizeof(known_ext_oids[0])];
  int ret;
  u16 i;
  u16 data_len = (u16)0;
  u16 hdr_len = (u16)0;
  u16 remain = (u16)0;
  u16 saved_len = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -8369;
              goto out;
            }
    }
  ret = parse_explicit_id_len(buf,len,(u32)3,CLASS_UNIVERSAL,
                              (u32)ASN1_TYPE_SEQUENCE,& hdr_len,& data_len);
  if (ret) goto out;
  remain = data_len;
  buf += (int)hdr_len;
  /*@ assert \valid_read(buf + (0 .. remain - 1)); */ ;
  saved_len = (u16)((int)hdr_len + (int)data_len);
  /*@ assert saved_len ≤ len; */ ;
  /*@ assert data_len ≤ saved_len; */ ;
  if ((int)data_len == 0) {
    ret = -8396;
    goto out;
  }
  i = (u16)0;
  /*@ loop invariant
        i < sizeof(known_ext_oids) / sizeof(known_ext_oids[0]) ⇒
        \valid(&parsed_oid_list[i]);
      loop assigns i,
                   parsed_oid_list[0 ..
                                       sizeof(known_ext_oids) /
                                       sizeof(known_ext_oids[0]) - 1];
      loop variant sizeof(known_ext_oids) / sizeof(known_ext_oids[0]) - i;
      loop unroll sizeof(known_ext_oids) / sizeof(known_ext_oids[0]);
  */
  while ((unsigned long)i < sizeof(known_ext_oids) / sizeof(known_ext_oids[0])) {
    parsed_oid_list[i] = (_ext_oid const *)0;
    i = (u16)((int)i + 1);
  }
  /*@
  assert
  \initialized(&parsed_oid_list[0 ..
                                    sizeof(known_ext_oids) /
                                    sizeof(known_ext_oids[0]) - 1]);
   */
  ;
  /*@ loop invariant remain ≢ 0 ⇒ \valid_read(buf + (0 .. remain - 1));
      loop assigns ret, buf, remain,
                   parsed_oid_list[0 ..
                                       sizeof(known_ext_oids) /
                                       sizeof(known_ext_oids[0]) - 1],
                   *ctx;
      loop variant remain;
  */
  while (remain) {
    u16 ext_len = (u16)0;
    ret = parse_x509_Extension(buf,remain,parsed_oid_list,& ext_len,ctx);
    if (ret) goto out;
    remain = (u16)((int)remain - (int)ext_len);
    buf += (int)ext_len;
  }
  if (ctx->empty_subject) {
    if (ctx->san_empty) {
      ret = -8439;
      goto out;
    }
    if (! ctx->san_critical) {
      ret = -8444;
      goto out;
    }
  }
  /*@ assert 1 ≤ saved_len ≤ len; */ ;
  *eaten = saved_len;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(eaten);
    requires \separated(sig_alg, eaten, buf + (..));
    ensures \result ≤ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    ensures \result ≡ 0 ⇒ 1 < *\old(eaten) ≤ \old(len);
    assigns *eaten, *sig_alg;
 */
static int parse_x509_tbsCertificate(u8 const *buf, u16 len,
                                     _alg_id const **sig_alg, u16 *eaten)
{
  u8 const *subject_ptr;
  u8 const *issuer_ptr;
  u16 subject_len;
  u16 issuer_len;
  alg_param param;
  cert_parsing_ctx ctx;
  int ret;
  u16 tbs_data_len = (u16)0;
  u16 tbs_hdr_len = (u16)0;
  u16 remain = (u16)0;
  u16 parsed = (u16)0;
  _alg_id const *alg = (_alg_id const *)0;
  int empty_issuer = 1;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -8509;
              goto out;
            }
    }
  ctx.empty_subject = 0;
  ctx.san_empty = 0;
  ctx.san_critical = 0;
  ctx.ca_true = 0;
  ctx.bc_critical = 0;
  ctx.has_ski = 0;
  ctx.has_keyUsage = 0;
  ctx.keyCertSign_set = 0;
  ctx.cRLSign_set = 0;
  ctx.pathLenConstraint_set = 0;
  ctx.has_name_constraints = 0;
  ctx.has_crldp = 0;
  ctx.one_crldp_has_all_reasons = 0;
  ctx.aki_has_keyIdentifier = 0;
  ctx.self_signed = 0;
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & tbs_hdr_len,& tbs_data_len);
  if (ret) goto out;
  buf += (int)tbs_hdr_len;
  remain = tbs_data_len;
  ret = parse_x509_Version(buf,remain,& parsed);
  if (ret) goto out;
  buf += (int)parsed;
  remain = (u16)((int)remain - (int)parsed);
  ret = parse_CertificateSerialNumber(buf,remain,CLASS_UNIVERSAL,
                                      (u32)ASN1_TYPE_INTEGER,& parsed);
  if (ret) goto out;
  buf += (int)parsed;
  remain = (u16)((int)remain - (int)parsed);
  ret = parse_x509_AlgorithmIdentifier(buf,remain,& alg,& param,& parsed);
  if (ret) goto out;
  if ((int)alg->alg_type != ALG_SIG) {
    ret = -8586;
    goto out;
  }
  buf += (int)parsed;
  remain = (u16)((int)remain - (int)parsed);
  ret = parse_x509_Name(buf,remain,& parsed,& empty_issuer);
  if (ret) goto out;
  /*@ assert empty_issuer ≡ 0 ∨ empty_issuer ≡ 1; */ ;
  if (empty_issuer) {
    ret = -8607;
    goto out;
  }
  issuer_ptr = buf;
  issuer_len = parsed;
  buf += (int)parsed;
  remain = (u16)((int)remain - (int)parsed);
  ret = parse_x509_Validity(buf,remain,& parsed);
  if (ret) goto out;
  buf += (int)parsed;
  remain = (u16)((int)remain - (int)parsed);
  ret = parse_x509_Name(buf,remain,& parsed,& ctx.empty_subject);
  if (ret) goto out;
  subject_ptr = buf;
  subject_len = parsed;
  buf += (int)parsed;
  remain = (u16)((int)remain - (int)parsed);
  ctx.self_signed = 0;
  if ((int)subject_len == (int)issuer_len) {
    int tmp_0;
    int tmp;
    tmp = bufs_differ(subject_ptr,issuer_ptr,issuer_len);
    if (tmp) tmp_0 = 0; else tmp_0 = 1;
    ctx.self_signed = tmp_0;
  }
  ret = parse_x509_subjectPublicKeyInfo(buf,remain,& parsed);
  if (ret) goto out;
  buf += (int)parsed;
  remain = (u16)((int)remain - (int)parsed);
  if (remain) {
    ret = parse_x509_Extensions(buf,remain,& parsed,& ctx);
    if (ret) goto out;
    buf += (int)parsed;
    remain = (u16)((int)remain - (int)parsed);
  }
  if ((int)remain != 0) {
    ret = -8701;
    goto out;
  }
  if (ctx.ca_true) 
    if (! ctx.has_ski) {
      ret = -8713;
      goto out;
    }
  if (ctx.keyCertSign_set) 
    if (! ctx.ca_true) goto _LOR_0;
    else 
      if (! ctx.bc_critical) {
        _LOR_0: {
                  ret = -8737;
                  goto out;
                }
      }
  if (ctx.cRLSign_set) 
    if (ctx.empty_subject) {
      ret = -8750;
      goto out;
    }
  if (ctx.pathLenConstraint_set) 
    if (! ctx.ca_true) goto _LOR_1;
    else 
      if (! ctx.keyCertSign_set) {
        _LOR_1: {
                  ret = -8762;
                  goto out;
                }
      }
  if (ctx.has_name_constraints) 
    if (! ctx.ca_true) {
      ret = -8772;
      goto out;
    }
  if (ctx.ca_true) 
    if (ctx.has_crldp) 
      if (! ctx.one_crldp_has_all_reasons) {
        ret = -8784;
        goto out;
      }
  if (! ctx.self_signed) 
    if (! ctx.aki_has_keyIdentifier) {
      ret = -8798;
      goto out;
    }
  /*@ assert 1 < tbs_hdr_len + tbs_data_len ≤ len; */ ;
  *eaten = (u16)((int)tbs_hdr_len + (int)tbs_data_len);
  *sig_alg = alg;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(eaten);
    requires \separated(eaten, buf + (..), exp_sig_alg);
    ensures \result ≤ 0;
    ensures \result ≡ 0 ⇒ 1 < *\old(eaten) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *eaten;
 */
static int parse_x509_signatureAlgorithm(u8 const *buf, u16 len,
                                         _alg_id const *exp_sig_alg,
                                         u16 *eaten)
{
  alg_param param;
  int ret;
  _alg_id const *alg = (_alg_id const *)0;
  u16 parsed = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -8833;
              goto out;
            }
    }
  ret = parse_x509_AlgorithmIdentifier(buf,len,& alg,& param,& parsed);
  if (ret) goto out;
  if ((int)alg->alg_type != ALG_SIG) {
    ret = -8846;
    goto out;
  }
  buf += (int)parsed;
  len = (u16)((int)len - (int)parsed);
  if (alg != exp_sig_alg) {
    ret = -8860;
    goto out;
  }
  *eaten = parsed;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(eaten);
    requires \separated(eaten, buf + (..));
    ensures \result ≤ 0;
    ensures \result ≡ 0 ⇒ *\old(eaten) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *eaten;
 */
static int parse_sig_generic(u8 const *buf, u16 len, u16 *eaten)
{
  int ret;
  u16 bs_hdr_len = (u16)0;
  u16 bs_data_len = (u16)0;
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_BIT_STRING,
                     & bs_hdr_len,& bs_data_len);
  if (ret) goto out;
  if ((int)bs_data_len == 0) {
    ret = -8904;
    goto out;
  }
  *eaten = (u16)((int)bs_hdr_len + (int)bs_data_len);
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \valid(eaten);
    requires \separated(eaten, buf + (..));
    ensures \result ≤ 0;
    ensures \result ≡ 0 ⇒ *\old(eaten) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *eaten;
 */
static int parse_sig_ecdsa(u8 const *buf, u16 len, u16 *eaten)
{
  int ret;
  u16 bs_hdr_len = (u16)0;
  u16 bs_data_len = (u16)0;
  u16 sig_len = (u16)0;
  u16 hdr_len = (u16)0;
  u16 data_len = (u16)0;
  u16 remain = (u16)0;
  u16 saved_sig_len = (u16)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -8936;
              goto out;
            }
    }
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_BIT_STRING,
                     & bs_hdr_len,& bs_data_len);
  if (ret) goto out;
  saved_sig_len = (u16)((int)bs_hdr_len + (int)bs_data_len);
  /*@ assert saved_sig_len ≤ len; */ ;
  buf += (int)bs_hdr_len;
  if ((int)bs_data_len == 0) {
    ret = -8958;
    goto out;
  }
  if ((int)*(buf + 0) != 0) {
    ret = -8987;
    goto out;
  }
  buf ++;
  sig_len = (u16)((int)bs_data_len - 1);
  ret = parse_id_len(buf,sig_len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & hdr_len,& data_len);
  if (ret) goto out;
  remain = (u16)((int)sig_len - (int)hdr_len);
  buf += (int)hdr_len;
  ret = parse_id_len(buf,remain,CLASS_UNIVERSAL,(u32)ASN1_TYPE_INTEGER,
                     & hdr_len,& data_len);
  if (ret) goto out;
  remain = (u16)((int)remain - ((int)hdr_len + (int)data_len));
  buf += (int)hdr_len + (int)data_len;
  ret = parse_id_len(buf,remain,CLASS_UNIVERSAL,(u32)ASN1_TYPE_INTEGER,
                     & hdr_len,& data_len);
  if (ret) goto out;
  remain = (u16)((int)remain - ((int)hdr_len + (int)data_len));
  buf += (int)hdr_len + (int)data_len;
  if ((int)remain != 0) {
    ret = -9036;
    goto out;
  }
  /*@ assert saved_sig_len ≤ len; */ ;
  *eaten = saved_sig_len;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires
      sig_alg ≢ \null ⇒
      \valid_read(sig_alg) ∧ \valid_function(sig_alg->parse_sig);
    requires \valid(eaten);
    ensures \result ≤ 0;
    ensures \result ≡ 0 ⇒ *\old(eaten) ≤ \old(len);
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns *eaten;
 */
static int parse_x509_signatureValue(u8 const *buf, u16 len,
                                     _alg_id const *sig_alg, u16 *eaten)
{
  int ret;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -9068;
              goto out;
            }
    }
  if (! sig_alg) {
    ret = -9074;
    goto out;
  }
  if (! sig_alg->parse_sig) {
    ret = -9080;
    goto out;
  }
  /*@ assert sig_alg->parse_sig ∈ {&parse_sig_ecdsa, &parse_sig_generic};
   */
  ;
  /*@ calls parse_sig_ecdsa, parse_sig_generic; */
  ret = (*(sig_alg->parse_sig))(buf,len,eaten);
  if (ret) goto out;
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    ensures \result ≤ 0;
    ensures \old(len) ≡ 0 ⇒ \result < 0;
    ensures \old(buf) ≡ \null ⇒ \result < 0;
    assigns \nothing;
 */
int parse_x509_cert(u8 const *buf, u16 len)
{
  int ret;
  u16 seq_data_len = (u16)0;
  u16 eaten = (u16)0;
  _alg_id const *sig_alg = (_alg_id const *)0;
  if (buf == (u8 const *)0) goto _LOR;
  else 
    if ((int)len == 0) {
      _LOR: {
              ret = -9114;
              goto out;
            }
    }
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,& eaten,
                     & seq_data_len);
  if (ret) goto out;
  len = (u16)((int)len - (int)eaten);
  buf += (int)eaten;
  if ((int)seq_data_len != (int)len) {
    ret = -9138;
    goto out;
  }
  ret = parse_x509_tbsCertificate(buf,len,& sig_alg,& eaten);
  if (ret) goto out;
  len = (u16)((int)len - (int)eaten);
  buf += (int)eaten;
  ret = parse_x509_signatureAlgorithm(buf,len,sig_alg,& eaten);
  if (ret) goto out;
  len = (u16)((int)len - (int)eaten);
  buf += (int)eaten;
  ret = parse_x509_signatureValue(buf,len,sig_alg,& eaten);
  if (ret) goto out;
  if ((int)len != (int)eaten) {
    ret = -9172;
    goto out;
  }
  ret = 0;
  out: ;
  return ret;
}

/*@ requires len ≥ 0;
    requires len > 0 ∧ buf ≢ \null ⇒ \valid_read(buf + (0 .. len - 1));
    requires \separated(eaten, buf + (..));
    requires \valid(eaten);
    ensures \result ≤ 1;
    ensures \result ≡ 0 ⇒ *\old(eaten) ≤ \old(len);
    ensures \result ≡ 0 ⇒ *\old(eaten) > 0;
    ensures \result < 0 ⇒ *\old(eaten) ≤ \old(len);
    ensures \result < 0 ⇒ *\old(eaten) > 0;
    assigns *eaten;
 */
int parse_x509_cert_relaxed(u8 const *buf, u16 len, u16 *eaten)
{
  int ret;
  u16 seq_data_len = (u16)0;
  u16 rbytes = (u16)0;
  ret = parse_id_len(buf,len,CLASS_UNIVERSAL,(u32)ASN1_TYPE_SEQUENCE,
                     & rbytes,& seq_data_len);
  if (ret) {
    ret = 1;
    goto out;
  }
  *eaten = (u16)((int)rbytes + (int)seq_data_len);
  ret = parse_x509_cert(buf,(u16)((int)rbytes + (int)seq_data_len));
  if (ret) goto out;
  ret = 0;
  out: ;
  return ret;
}

int main(int argc, char **argv)
{
  u8 buf[65535];
  u16 len;
  int ret;
  int tmp;
  /*@ assert \valid(&buf[0 .. 65535 - 1]); */ ;
  Frama_C_make_unknown((char *)(buf),(size_t)65535);
  tmp = Frama_C_interval(0,65535);
  len = (u16)tmp;
  /*@ assert 0 ≤ len ≤ 65535; */ ;
  ret = parse_x509_cert((u8 const *)(buf),len);
  return ret;
}


