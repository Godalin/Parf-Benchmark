/* Generated by Frama-C */
#include "__fc_builtin.h"
#include "errno.h"
#include "stdarg.h"
#include "stddef.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "strings.h"
typedef unsigned int ui32;
typedef unsigned short ui16;
struct __anonstruct_qlz_hash_compress_1 {
   unsigned char const *offset[16] ;
};
typedef struct __anonstruct_qlz_hash_compress_1 qlz_hash_compress;
struct __anonstruct_qlz_state_compress_3 {
   unsigned char stream_buffer[10000] ;
   size_t stream_counter ;
   qlz_hash_compress hash[4096] ;
   unsigned char hash_counter[4096] ;
};
typedef struct __anonstruct_qlz_state_compress_3 qlz_state_compress;
struct __anonstruct_qlz_state_decompress_4 {
   unsigned char stream_buffer[10000] ;
   size_t stream_counter ;
};
typedef struct __anonstruct_qlz_state_decompress_4 qlz_state_decompress;
size_t qlz_size_decompressed(char const *source);

size_t qlz_size_compressed(char const *source);

size_t qlz_compress(void const *source, char *destination, size_t size,
                    qlz_state_compress *state);

size_t qlz_decompress(char const *source, void *destination,
                      qlz_state_decompress *state);

int qlz_get_setting(int setting);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, param0;
 */
int printf_va_1(char const * restrict format, unsigned int param0,
                unsigned int param1);

int main(int argc, char **argv)
{
  int __retres;
  FILE *ifile;
  FILE *ofile;
  char *file_data;
  char *compressed;
  size_t d;
  size_t c;
  qlz_state_compress *state_compress = malloc(sizeof(qlz_state_compress));
  ifile = fopen((char const *)*(argv + 1),"rb");
  ofile = fopen((char const *)*(argv + 2),"wb");
  file_data = (char *)malloc((size_t)10000);
  compressed = (char *)malloc((size_t)(10000 + 400));
  memset((void *)state_compress,0,sizeof(qlz_state_compress));
  while (1) {
    int tmp_2;
    ;
    tmp_2 = rand();
    ;
    d = fread((void *)file_data,(size_t)1,(size_t)(tmp_2 % 10000 + 1),ifile);
    if (! (d != (size_t)0)) break;
    c = qlz_compress((void const *)file_data,compressed,d,state_compress);
    printf("%u bytes compressed into %u\n",d,c); /* printf_va_1 */
    fwrite((void const *)compressed,c,(size_t)1,ofile);
  }
  fclose(ifile);
  fclose(ofile);
  __retres = 0;
  return __retres;
}

int qlz_get_setting(int setting)
{
  int __retres;
  switch (setting) {
    case 0: __retres = 3;
    goto return_label;
    case 1: __retres = (int)sizeof(qlz_state_compress);
    goto return_label;
    case 2: __retres = (int)sizeof(qlz_state_decompress);
    goto return_label;
    case 3: __retres = 10000;
    goto return_label;
    case 6: __retres = 0;
    goto return_label;
    case 7: __retres = 1;
    goto return_label;
    case 8: __retres = 5;
    goto return_label;
    case 9: __retres = 0;
    goto return_label;
  }
  __retres = -1;
  return_label: return __retres;
}

static void reset_table_compress(qlz_state_compress *state)
{
  int i;
  i = 0;
  while (i < 4096) {
    state->hash_counter[i] = (unsigned char)0;
    i ++;
  }
  return;
}

static void reset_table_decompress(qlz_state_decompress *state)
{
  int i;
  int tmp = i;
  return;
}

__inline static ui32 hash_func(ui32 i)
{
  ui32 __retres;
  __retres = ((i >> 12) ^ i) & (unsigned int)(4096 - 1);
  return __retres;
}

__inline static ui32 fast_read(void const *src, ui32 bytes)
{
  ui32 __retres;
  if (bytes >= (ui32)1) 
    if (bytes <= (ui32)4) {
      __retres = *((ui32 *)src);
      goto return_label;
    }
    else {
      __retres = (ui32)0;
      goto return_label;
    }
  else {
    __retres = (ui32)0;
    goto return_label;
  }
  return_label: return __retres;
}

__inline static ui32 hashat(unsigned char const *src)
{
  ui32 fetch;
  ui32 hash;
  fetch = fast_read((void const *)src,(ui32)3);
  hash = hash_func(fetch);
  return hash;
}

__inline static void fast_write(ui32 f, void *dst, size_t bytes)
{
  switch (bytes) {
    case (size_t)4: *((ui32 *)dst) = f;
    goto return_label;
    case (size_t)3: *((ui32 *)dst) = f;
    goto return_label;
    case (size_t)2: *((ui16 *)dst) = (ui16)f;
    goto return_label;
    case (size_t)1: *((unsigned char *)dst) = (unsigned char)f;
    goto return_label;
  }
  return_label: return;
}

size_t qlz_size_decompressed(char const *source)
{
  ui32 n;
  ui32 r;
  if (((int)*source & 2) == 2) n = (ui32)4; else n = (ui32)1;
  r = fast_read((void const *)((source + 1) + n),n);
  r &= 0xffffffff >> ((ui32)4 - n) * (ui32)8;
  return r;
}

size_t qlz_size_compressed(char const *source)
{
  ui32 n;
  ui32 r;
  if (((int)*source & 2) == 2) n = (ui32)4; else n = (ui32)1;
  r = fast_read((void const *)(source + 1),n);
  r &= 0xffffffff >> ((ui32)4 - n) * (ui32)8;
  return r;
}

size_t qlz_size_header(char const *source)
{
  int tmp;
  if (((int)*source & 2) == 2) tmp = 4; else tmp = 1;
  size_t n = (size_t)(2 * tmp + 1);
  return n;
}

__inline static void memcpy_up(unsigned char *dst, unsigned char const *src,
                               ui32 n)
{
  ui32 f = (ui32)0;
  while (1) {
    *((ui32 *)(dst + f)) = *((ui32 *)(src + f));
    f += (ui32)(2 + 1);
    if (! (f < n)) break;
  }
  return;
}

__inline static void update_hash(qlz_state_decompress *state,
                                 unsigned char const *s)
{
  return;
}

static size_t qlz_compress_core(unsigned char const *source,
                                unsigned char *destination, size_t size,
                                qlz_state_compress *state)
{
  size_t __retres;
  int tmp_3_0;
  unsigned char const *last_byte = (source + size) - 1;
  unsigned char const *src = source;
  unsigned char *cword_ptr = destination;
  unsigned char *dst = destination + 4;
  ui32 cword_val = 1U << 31;
  unsigned char const *last_matchstart = (last_byte - 6) - 4;
  ui32 fetch = (ui32)0;
  unsigned int lits = (unsigned int)0;
  unsigned int tmp = lits;
  if (src <= last_matchstart) fetch = fast_read((void const *)src,(ui32)3);
  while (src <= last_matchstart) {
    if ((cword_val & (unsigned int)1) == (unsigned int)1) {
      if (src > source + (size >> 1)) 
        if (dst - destination > (src - source) - ((src - source) >> 5)) {
          __retres = (size_t)0;
          goto return_label;
        }
      fast_write((cword_val >> 1) | (1U << 31),(void *)cword_ptr,(size_t)4);
      cword_ptr = dst;
      dst += 4;
      cword_val = 1U << 31;
      fetch = fast_read((void const *)src,(ui32)3);
    }
    {
      unsigned char const *o;
      unsigned char const *offset2;
      ui32 hash;
      ui32 matchlen;
      ui32 k;
      ui32 m;
      unsigned char c;
      int tmp_0;
      ui32 best_k = (ui32)0;
      if (((last_byte - 4) - src) + 1 > 255) tmp_0 = 255;
      else tmp_0 = ((last_byte - 4) - src) + 1;
      size_t remaining = (size_t)tmp_0;
      ui32 tmp_3 = best_k;
      fetch = fast_read((void const *)src,(ui32)3);
      hash = hash_func(fetch);
      c = state->hash_counter[hash];
      offset2 = state->hash[hash].offset[0];
      if (offset2 < src - 2) 
        if ((int)c > 0) {
          ui32 tmp_0_0;
          tmp_0_0 = fast_read((void const *)offset2,(ui32)3);
          ;
          if (((tmp_0_0 ^ fetch) & (unsigned int)0xffffff) == (unsigned int)0) {
            matchlen = (ui32)3;
            if ((int)*(offset2 + matchlen) == (int)*(src + matchlen)) {
              matchlen = (ui32)4;
              while (1) {
                if ((int)*(offset2 + matchlen) == (int)*(src + matchlen)) {
                  if (! (matchlen < remaining)) break;
                }
                else break;
                matchlen ++;
              }
            }
          }
          else matchlen = (ui32)0;
        }
        else matchlen = (ui32)0;
      else matchlen = (ui32)0;
      k = (ui32)1;
      while (1) {
        if (k < (ui32)16) {
          if (! ((ui32)c > k)) break;
        }
        else break;
        {
          ui32 tmp_1;
          o = state->hash[hash].offset[k];
          tmp_1 = fast_read((void const *)o,(ui32)3);
          ;
          if (((tmp_1 ^ fetch) & (unsigned int)0xffffff) == (unsigned int)0) 
            if (o < src - 2) {
              m = (ui32)3;
              while (1) {
                if ((int)*(o + m) == (int)*(src + m)) {
                  if (! (m < remaining)) break;
                }
                else break;
                m ++;
              }
              if (m > matchlen) goto _LOR;
              else 
                if (m == matchlen) 
                  if (o > offset2) {
                    _LOR: {
                            offset2 = o;
                            matchlen = m;
                            best_k = k;
                          }
                  }
            }
        }
        k ++;
      }
      o = offset2;
      state->hash[hash].offset[(int)c & (16 - 1)] = src;
      c = (unsigned char)((int)c + 1);
      state->hash_counter[hash] = c;
      if (matchlen > (ui32)2) {
        if (src - o < 131071) {
          ui32 u;
          size_t offset = (size_t)(src - o);
          u = (ui32)1;
          while (u < matchlen) {
            {
              unsigned char tmp_2;
              hash = hashat(src + u);
              tmp_2 = state->hash_counter[hash];
              state->hash_counter[hash] = (unsigned char)((int)state->hash_counter[hash] + 1);
              c = tmp_2;
              state->hash[hash].offset[(int)c & (16 - 1)] = src + u;
            }
            u ++;
          }
          cword_val = (cword_val >> 1) | (1U << 31);
          src += matchlen;
          if (matchlen == (ui32)3) {
            if (offset <= (size_t)63) {
              *dst = (unsigned char)(offset << 2);
              dst ++;
            }
            else goto _LAND_1;
          }
          else {
            _LAND_1: ;
            if (matchlen == (ui32)3) {
              if (offset <= (size_t)16383) {
                ui32 f = (offset << 2) | (unsigned int)1;
                fast_write(f,(void *)dst,(size_t)2);
                dst += 2;
              }
              else goto _LAND_0;
            }
            else {
              _LAND_0: ;
              if (matchlen <= (ui32)18) {
                if (offset <= (size_t)1023) {
                  ui32 f_0 =
                    (((matchlen - (ui32)3) << 2) | (offset << 6)) | (unsigned int)2;
                  fast_write(f_0,(void *)dst,(size_t)2);
                  dst += 2;
                }
                else goto _LAND;
              }
              else {
                _LAND: ;
                if (matchlen <= (ui32)33) {
                  ui32 f_1 =
                    (((matchlen - (ui32)2) << 2) | (offset << 7)) | (unsigned int)3;
                  fast_write(f_1,(void *)dst,(size_t)3);
                  dst += 3;
                }
                else {
                  ui32 f_2 =
                    (((matchlen - (ui32)3) << 7) | (offset << 15)) | (unsigned int)3;
                  fast_write(f_2,(void *)dst,(size_t)4);
                  dst += 4;
                }
              }
            }
          }
        }
        else goto _LAND_2;
      }
      else {
        _LAND_2: {
                   *dst = *src;
                   src ++;
                   dst ++;
                   cword_val >>= 1;
                 }
      }
    }
  }
  while (src <= last_byte) {
    if ((cword_val & (unsigned int)1) == (unsigned int)1) {
      fast_write((cword_val >> 1) | (1U << 31),(void *)cword_ptr,(size_t)4);
      cword_ptr = dst;
      dst += 4;
      cword_val = 1U << 31;
    }
    *dst = *src;
    src ++;
    dst ++;
    cword_val >>= 1;
  }
  while ((cword_val & (unsigned int)1) != (unsigned int)1) cword_val >>= 1;
  fast_write((cword_val >> 1) | (1U << 31),(void *)cword_ptr,(size_t)4);
  if (dst - destination < 9) tmp_3_0 = 9; else tmp_3_0 = dst - destination;
  __retres = (size_t)tmp_3_0;
  return_label: return __retres;
}

static size_t qlz_decompress_core(unsigned char const *source,
                                  unsigned char *destination, size_t size,
                                  qlz_state_decompress *state,
                                  unsigned char const *history);

static ui32 const qlz_decompress_core_bitlut[16] =
  {(ui32)4,
   (ui32)0,
   (ui32)1,
   (ui32)0,
   (ui32)2,
   (ui32)0,
   (ui32)1,
   (ui32)0,
   (ui32)3,
   (ui32)0,
   (ui32)1,
   (ui32)0,
   (ui32)2,
   (ui32)0,
   (ui32)1,
   (ui32)0};
static size_t qlz_decompress_core(unsigned char const *source,
                                  unsigned char *destination, size_t size,
                                  qlz_state_decompress *state,
                                  unsigned char const *history)
{
  size_t __retres;
  size_t tmp;
  size_t tmp_0;
  tmp = qlz_size_header((char const *)source);
  unsigned char const *src = source + tmp;
  unsigned char *dst = destination;
  unsigned char const *last_destination_byte =
    (unsigned char const *)((destination + size) - 1);
  ui32 cword_val = (ui32)1;
  unsigned char const *last_matchstart = (last_destination_byte - 6) - 4;
  unsigned char *last_hashed = destination - 1;
  tmp_0 = qlz_size_compressed((char const *)source);
  unsigned char const *last_source_byte = (source + tmp_0) - 1;
  unsigned char const *tmp_2 = last_source_byte;
  unsigned char *tmp_4 = last_hashed;
  while (1) {
    ui32 fetch;
    if (cword_val == (ui32)1) {
      cword_val = fast_read((void const *)src,(ui32)4);
      src += 4;
    }
    fetch = fast_read((void const *)src,(ui32)4);
    if ((cword_val & (unsigned int)1) == (unsigned int)1) {
      ui32 matchlen;
      unsigned char const *offset2;
      ui32 offset;
      cword_val >>= 1;
      if ((fetch & (unsigned int)3) == (unsigned int)0) {
        offset = (fetch & (unsigned int)0xff) >> 2;
        matchlen = (ui32)3;
        src ++;
      }
      else 
        if ((fetch & (unsigned int)2) == (unsigned int)0) {
          offset = (fetch & (unsigned int)0xffff) >> 2;
          matchlen = (ui32)3;
          src += 2;
        }
        else 
          if ((fetch & (unsigned int)1) == (unsigned int)0) {
            offset = (fetch & (unsigned int)0xffff) >> 6;
            matchlen = ((fetch >> 2) & (unsigned int)15) + (unsigned int)3;
            src += 2;
          }
          else 
            if ((fetch & (unsigned int)127) != (unsigned int)3) {
              offset = (fetch >> 7) & (unsigned int)0x1ffff;
              matchlen = ((fetch >> 2) & (unsigned int)0x1f) + (unsigned int)2;
              src += 3;
            }
            else {
              offset = fetch >> 15;
              matchlen = ((fetch >> 7) & (unsigned int)255) + (unsigned int)3;
              src += 4;
            }
      offset2 = (unsigned char const *)(dst - offset);
      memcpy_up(dst,offset2,matchlen);
      dst += matchlen;
    }
    else 
      if ((void *)dst < (void *)last_matchstart) {
        unsigned int n =
          qlz_decompress_core_bitlut[cword_val & (unsigned int)0xf];
        *((ui32 *)dst) = *((ui32 *)src);
        cword_val >>= n;
        dst += n;
        src += n;
      }
      else {
        while ((void *)dst <= (void *)last_destination_byte) {
          if (cword_val == (ui32)1) {
            src += 4;
            cword_val = 1U << 31;
          }
          *dst = *src;
          dst ++;
          src ++;
          cword_val >>= 1;
        }
        __retres = size;
        goto return_label;
      }
  }
  return_label: return __retres;
}

size_t qlz_compress(void const *source, char *destination, size_t size,
                    qlz_state_compress *state)
{
  size_t __retres;
  size_t r;
  ui32 compressed;
  size_t base;
  int tmp_3;
  if (size == (size_t)0) {
    __retres = (size_t)0;
    goto return_label;
  }
  else 
    if (size > 0xffffffff - (unsigned int)400) {
      __retres = (size_t)0;
      goto return_label;
    }
  if (size < (size_t)216) base = (size_t)3; else base = (size_t)9;
  if ((state->stream_counter + size) - (size_t)1 >= (size_t)10000) {
    size_t tmp;
    reset_table_compress(state);
    tmp = qlz_compress_core((unsigned char const *)source,
                            (unsigned char *)destination + base,size,state);
    r = base + tmp;
    reset_table_compress(state);
    if (r == base) {
      memcpy((void *)(destination + base),source,size);
      r = size + base;
      compressed = (ui32)0;
    }
    else compressed = (ui32)1;
    state->stream_counter = (size_t)0;
  }
  else {
    size_t tmp_0;
    unsigned char *src = & state->stream_buffer[state->stream_counter];
    memcpy((void *)src,source,size);
    tmp_0 = qlz_compress_core((unsigned char const *)src,
                              (unsigned char *)destination + base,size,state);
    r = base + tmp_0;
    if (r == base) {
      memcpy((void *)(destination + base),(void const *)src,size);
      r = size + base;
      compressed = (ui32)0;
      reset_table_compress(state);
    }
    else compressed = (ui32)1;
    state->stream_counter += size;
  }
  if (base == (size_t)3) {
    *destination = (char)((unsigned char)((unsigned int)0 | compressed));
    *(destination + 1) = (char)((unsigned char)r);
    *(destination + 2) = (char)((unsigned char)size);
  }
  else {
    *destination = (char)((unsigned char)((unsigned int)2 | compressed));
    fast_write(r,(void *)(destination + 1),(size_t)4);
    fast_write(size,(void *)(destination + 5),(size_t)4);
  }
  *destination = (char)((int)*destination | (3 << 2));
  *destination = (char)((int)*destination | (1 << 6));
  if (10000 == 0) tmp_3 = 0;
  else {
    int tmp_2;
    if (10000 == 100000) tmp_2 = 1;
    else {
      int tmp_1;
      if (10000 == 1000000) tmp_1 = 2; else tmp_1 = 3;
      tmp_2 = tmp_1;
    }
    tmp_3 = tmp_2;
  }
  *destination = (char)((int)*destination | (tmp_3 << 4));
  __retres = r;
  return_label: return __retres;
}

size_t qlz_decompress(char const *source, void *destination,
                      qlz_state_decompress *state)
{
  size_t tmp_2;
  size_t dsiz = qlz_size_decompressed(source);
  tmp_2 = qlz_size_decompressed(source);
  ;
  if ((state->stream_counter + tmp_2) - (size_t)1 >= (size_t)10000) {
    if (((int)*source & 1) == 1) {
      reset_table_decompress(state);
      dsiz = qlz_decompress_core((unsigned char const *)source,
                                 (unsigned char *)destination,dsiz,state,
                                 (unsigned char const *)destination);
    }
    else {
      size_t tmp_0;
      ;
      tmp_0 = qlz_size_header(source);
      ;
      ;
      memcpy(destination,(void const *)(source + tmp_0),dsiz);
    }
    state->stream_counter = (size_t)0;
    reset_table_decompress(state);
  }
  else {
    unsigned char *dst = & state->stream_buffer[state->stream_counter];
    if (((int)*source & 1) == 1) dsiz = qlz_decompress_core((unsigned char const *)source,
                                                            dst,dsiz,state,
                                                            (unsigned char const *)(state->stream_buffer));
    else {
      size_t tmp_1;
      ;
      tmp_1 = qlz_size_header(source);
      ;
      ;
      memcpy((void *)dst,(void const *)(source + tmp_1),dsiz);
      reset_table_decompress(state);
    }
    memcpy(destination,(void const *)dst,dsiz);
    state->stream_counter += dsiz;
  }
  return dsiz;
}

int eva_main(void)
{
  char argv0[256];
  char argv1[256];
  char argv2[256];
  char argv3[256];
  char argv4[256];
  int tmp_0;
  int argc = Frama_C_interval(0,5);
  char *argv[6] = {argv0, argv1, argv2, argv3, argv4, (char *)0};
  {
    int i = 0;
    /*@ loop unroll 5; */
    while (i < 5) {
      Frama_C_make_unknown(argv[i],(size_t)255);
      *(argv[i] + 255) = (char)0;
      i ++;
    }
  }
  tmp_0 = main(argc,argv);
  return tmp_0;
}


