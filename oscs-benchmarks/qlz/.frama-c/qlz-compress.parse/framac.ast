/* Generated by Frama-C */
#include "__fc_builtin.h"
#include "errno.h"
#include "stdarg.h"
#include "stddef.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "strings.h"
typedef unsigned int ui32;
typedef unsigned short ui16;
struct __anonstruct_qlz_hash_compress_1 {
   ui32 cache ;
   unsigned int offset ;
};
typedef struct __anonstruct_qlz_hash_compress_1 qlz_hash_compress;
struct __anonstruct_qlz_hash_decompress_2 {
   unsigned char const *offset ;
};
typedef struct __anonstruct_qlz_hash_decompress_2 qlz_hash_decompress;
struct __anonstruct_qlz_state_compress_3 {
   size_t stream_counter ;
   qlz_hash_compress hash[4096] ;
   unsigned char hash_counter[4096] ;
};
typedef struct __anonstruct_qlz_state_compress_3 qlz_state_compress;
struct __anonstruct_qlz_state_decompress_4 {
   qlz_hash_decompress hash[4096] ;
   unsigned char hash_counter[4096] ;
   size_t stream_counter ;
};
typedef struct __anonstruct_qlz_state_decompress_4 qlz_state_decompress;
size_t qlz_size_decompressed(char const *source);

size_t qlz_size_compressed(char const *source);

size_t qlz_compress(void const *source, char *destination, size_t size,
                    qlz_state_compress *state);

size_t qlz_decompress(char const *source, void *destination,
                      qlz_state_decompress *state);

int qlz_get_setting(int setting);

int main(int argc, char **argv)
{
  int __retres;
  FILE *ifile;
  FILE *ofile;
  char *src;
  char *dst;
  size_t len;
  size_t len2;
  long tmp_0;
  qlz_state_compress *state_compress = malloc(sizeof(qlz_state_compress));
  ifile = fopen((char const *)*(argv + 1),"rb");
  ofile = fopen((char const *)*(argv + 2),"wb");
  fseek(ifile,(long)0,2);
  tmp_0 = ftell(ifile);
  len = (size_t)tmp_0;
  fseek(ifile,(long)0,0);
  src = (char *)malloc(len);
  fread((void *)src,(size_t)1,len,ifile);
  dst = (char *)malloc(len + (size_t)400);
  len2 = qlz_compress((void const *)src,dst,len,state_compress);
  fwrite((void const *)dst,len2,(size_t)1,ofile);
  fclose(ifile);
  fclose(ofile);
  __retres = 0;
  return __retres;
}

int qlz_get_setting(int setting)
{
  int __retres;
  switch (setting) {
    case 0: __retres = 1;
    goto return_label;
    case 1: __retres = (int)sizeof(qlz_state_compress);
    goto return_label;
    case 2: __retres = (int)sizeof(qlz_state_decompress);
    goto return_label;
    case 3: __retres = 0;
    goto return_label;
    case 6: __retres = 0;
    goto return_label;
    case 7: __retres = 1;
    goto return_label;
    case 8: __retres = 5;
    goto return_label;
    case 9: __retres = 0;
    goto return_label;
  }
  __retres = -1;
  return_label: return __retres;
}

static int same(unsigned char const *src, size_t n)
{
  int tmp;
  while (1) {
    if (n > (size_t)0) {
      if (! ((int)*(src + n) == (int)*src)) break;
    }
    else break;
    n --;
  }
  if (n == (size_t)0) tmp = 1; else tmp = 0;
  return tmp;
}

static void reset_table_compress(qlz_state_compress *state)
{
  int i;
  i = 0;
  while (i < 4096) {
    state->hash[i].offset = (unsigned int)0;
    i ++;
  }
  return;
}

static void reset_table_decompress(qlz_state_decompress *state)
{
  int i;
  int tmp = i;
  return;
}

__inline static ui32 hash_func(ui32 i)
{
  ui32 __retres;
  __retres = ((i >> 12) ^ i) & (unsigned int)(4096 - 1);
  return __retres;
}

__inline static ui32 fast_read(void const *src, ui32 bytes)
{
  ui32 __retres;
  if (bytes >= (ui32)1) 
    if (bytes <= (ui32)4) {
      __retres = *((ui32 *)src);
      goto return_label;
    }
    else {
      __retres = (ui32)0;
      goto return_label;
    }
  else {
    __retres = (ui32)0;
    goto return_label;
  }
  return_label: return __retres;
}

__inline static ui32 hashat(unsigned char const *src)
{
  ui32 fetch;
  ui32 hash;
  fetch = fast_read((void const *)src,(ui32)3);
  hash = hash_func(fetch);
  return hash;
}

__inline static void fast_write(ui32 f, void *dst, size_t bytes)
{
  switch (bytes) {
    case (size_t)4: *((ui32 *)dst) = f;
    goto return_label;
    case (size_t)3: *((ui32 *)dst) = f;
    goto return_label;
    case (size_t)2: *((ui16 *)dst) = (ui16)f;
    goto return_label;
    case (size_t)1: *((unsigned char *)dst) = (unsigned char)f;
    goto return_label;
  }
  return_label: return;
}

size_t qlz_size_decompressed(char const *source)
{
  ui32 n;
  ui32 r;
  if (((int)*source & 2) == 2) n = (ui32)4; else n = (ui32)1;
  r = fast_read((void const *)((source + 1) + n),n);
  r &= 0xffffffff >> ((ui32)4 - n) * (ui32)8;
  return r;
}

size_t qlz_size_compressed(char const *source)
{
  ui32 n;
  ui32 r;
  if (((int)*source & 2) == 2) n = (ui32)4; else n = (ui32)1;
  r = fast_read((void const *)(source + 1),n);
  r &= 0xffffffff >> ((ui32)4 - n) * (ui32)8;
  return r;
}

size_t qlz_size_header(char const *source)
{
  int tmp;
  if (((int)*source & 2) == 2) tmp = 4; else tmp = 1;
  size_t n = (size_t)(2 * tmp + 1);
  return n;
}

__inline static void memcpy_up(unsigned char *dst, unsigned char const *src,
                               ui32 n)
{
  ui32 f = (ui32)0;
  while (1) {
    *((ui32 *)(dst + f)) = *((ui32 *)(src + f));
    f += (ui32)(2 + 1);
    if (! (f < n)) break;
  }
  return;
}

__inline static void update_hash(qlz_state_decompress *state,
                                 unsigned char const *s)
{
  ui32 hash;
  hash = hashat(s);
  state->hash[hash].offset = s;
  state->hash_counter[hash] = (unsigned char)1;
  return;
}

static void update_hash_upto(qlz_state_decompress *state, unsigned char **lh,
                             unsigned char const *max)
{
  while ((void *)*lh < (void *)max) {
    (*lh) ++;
    update_hash(state,(unsigned char const *)*lh);
  }
  return;
}

static size_t qlz_compress_core(unsigned char const *source,
                                unsigned char *destination, size_t size,
                                qlz_state_compress *state)
{
  size_t __retres;
  int tmp_1;
  unsigned char const *last_byte = (source + size) - 1;
  unsigned char const *src = source;
  unsigned char *cword_ptr = destination;
  unsigned char *dst = destination + 4;
  ui32 cword_val = 1U << 31;
  unsigned char const *last_matchstart = (last_byte - 6) - 4;
  ui32 fetch = (ui32)0;
  unsigned int lits = (unsigned int)0;
  unsigned int tmp = lits;
  if (src <= last_matchstart) fetch = fast_read((void const *)src,(ui32)3);
  while (src <= last_matchstart) {
    if ((cword_val & (unsigned int)1) == (unsigned int)1) {
      if (src > source + (size >> 1)) 
        if (dst - destination > (src - source) - ((src - source) >> 5)) {
          __retres = (size_t)0;
          goto return_label;
        }
      fast_write((cword_val >> 1) | (1U << 31),(void *)cword_ptr,(size_t)4);
      cword_ptr = dst;
      dst += 4;
      cword_val = 1U << 31;
      fetch = fast_read((void const *)src,(ui32)3);
    }
    {
      unsigned char const *o;
      ui32 hash;
      ui32 cached;
      hash = hash_func(fetch);
      cached = fetch ^ state->hash[hash].cache;
      state->hash[hash].cache = fetch;
      o = source + state->hash[hash].offset;
      state->hash[hash].offset = (size_t)(src - source);
      if ((cached & (unsigned int)0xffffff) == (unsigned int)0) {
        if (o != source) {
          if (src - o > 2) goto _LOR;
          else 
            if (src == o + 1) {
              if (lits >= (unsigned int)3) {
                if (src > source + 3) {
                  int tmp_0_0;
                  tmp_0_0 = same(src - 3,(size_t)6);
                  if (tmp_0_0) {
                    _LOR:
                    {
                      if (cached != (ui32)0) {
                        hash <<= 4;
                        cword_val = (cword_val >> 1) | (1U << 31);
                        fast_write((unsigned int)(3 - 2) | hash,(void *)dst,
                                   (size_t)2);
                        src += 3;
                        dst += 2;
                      }
                      else {
                        size_t matchlen;
                        unsigned char const *old_src = src;
                        hash <<= 4;
                        cword_val = (cword_val >> 1) | (1U << 31);
                        src += 4;
                        if ((int)*(o + (src - old_src)) == (int)*src) {
                          src ++;
                          if ((int)*(o + (src - old_src)) == (int)*src) {
                            size_t tmp_0;
                            size_t q =
                              (size_t)(((last_byte - 4) - (src - 5)) + 1);
                            if (q > (size_t)255) tmp_0 = (size_t)255;
                            else tmp_0 = q;
                            size_t remaining = tmp_0;
                            src ++;
                            while (1) {
                              if ((int)*(o + (src - old_src)) == (int)*src) {
                                if (! ((size_t)(src - old_src) < remaining)) 
                                  break;
                              }
                              else break;
                              src ++;
                            }
                          }
                        }
                        matchlen = (size_t)(src - old_src);
                        if (matchlen < (size_t)18) {
                          fast_write((matchlen - (size_t)2) | hash,
                                     (void *)dst,(size_t)2);
                          dst += 2;
                        }
                        else {
                          fast_write((matchlen << 16) | hash,(void *)dst,
                                     (size_t)3);
                          dst += 3;
                        }
                      }
                      fetch = fast_read((void const *)src,(ui32)3);
                      lits = (unsigned int)0;
                    }
                  }
                  else goto _LAND_0;
                }
                else goto _LAND_0;
              }
              else goto _LAND_0;
            }
            else goto _LAND_0;
        }
        else goto _LAND_0;
      }
      else {
        _LAND_0:
        {
          lits ++;
          *dst = *src;
          src ++;
          dst ++;
          cword_val >>= 1;
          fetch = fast_read((void const *)src,(ui32)3);
        }
      }
    }
  }
  while (src <= last_byte) {
    if ((cword_val & (unsigned int)1) == (unsigned int)1) {
      fast_write((cword_val >> 1) | (1U << 31),(void *)cword_ptr,(size_t)4);
      cword_ptr = dst;
      dst += 4;
      cword_val = 1U << 31;
    }
    if (src <= last_byte - 3) {
      ui32 hash_0;
      ui32 fetch_0;
      fetch_0 = fast_read((void const *)src,(ui32)3);
      hash_0 = hash_func(fetch_0);
      state->hash[hash_0].offset = (size_t)(src - source);
      state->hash[hash_0].cache = fetch_0;
    }
    *dst = *src;
    src ++;
    dst ++;
    cword_val >>= 1;
  }
  while ((cword_val & (unsigned int)1) != (unsigned int)1) cword_val >>= 1;
  fast_write((cword_val >> 1) | (1U << 31),(void *)cword_ptr,(size_t)4);
  if (dst - destination < 9) tmp_1 = 9; else tmp_1 = dst - destination;
  __retres = (size_t)tmp_1;
  return_label: return __retres;
}

static size_t qlz_decompress_core(unsigned char const *source,
                                  unsigned char *destination, size_t size,
                                  qlz_state_decompress *state,
                                  unsigned char const *history);

static ui32 const qlz_decompress_core_bitlut[16] =
  {(ui32)4,
   (ui32)0,
   (ui32)1,
   (ui32)0,
   (ui32)2,
   (ui32)0,
   (ui32)1,
   (ui32)0,
   (ui32)3,
   (ui32)0,
   (ui32)1,
   (ui32)0,
   (ui32)2,
   (ui32)0,
   (ui32)1,
   (ui32)0};
static size_t qlz_decompress_core(unsigned char const *source,
                                  unsigned char *destination, size_t size,
                                  qlz_state_decompress *state,
                                  unsigned char const *history)
{
  size_t __retres;
  size_t tmp;
  size_t tmp_0;
  tmp = qlz_size_header((char const *)source);
  unsigned char const *src = source + tmp;
  unsigned char *dst = destination;
  unsigned char const *last_destination_byte =
    (unsigned char const *)((destination + size) - 1);
  ui32 cword_val = (ui32)1;
  unsigned char const *last_matchstart = (last_destination_byte - 6) - 4;
  unsigned char *last_hashed = destination - 1;
  tmp_0 = qlz_size_compressed((char const *)source);
  unsigned char const *last_source_byte = (source + tmp_0) - 1;
  unsigned char const *tmp_2 = last_source_byte;
  unsigned char *tmp_4 = last_hashed;
  while (1) {
    ui32 fetch;
    if (cword_val == (ui32)1) {
      cword_val = fast_read((void const *)src,(ui32)4);
      src += 4;
    }
    fetch = fast_read((void const *)src,(ui32)4);
    if ((cword_val & (unsigned int)1) == (unsigned int)1) {
      ui32 matchlen;
      unsigned char const *offset2;
      ui32 hash;
      cword_val >>= 1;
      hash = (fetch >> 4) & (unsigned int)0xfff;
      offset2 = state->hash[hash].offset;
      if ((fetch & (unsigned int)0xf) != (unsigned int)0) {
        matchlen = (fetch & (unsigned int)0xf) + (unsigned int)2;
        src += 2;
      }
      else {
        matchlen = (ui32)*(src + 2);
        src += 3;
      }
      memcpy_up(dst,offset2,matchlen);
      dst += matchlen;
      update_hash_upto(state,& last_hashed,
                       (unsigned char const *)(dst - matchlen));
      last_hashed = dst - 1;
    }
    else 
      if ((void *)dst < (void *)last_matchstart) {
        unsigned int n =
          qlz_decompress_core_bitlut[cword_val & (unsigned int)0xf];
        *((ui32 *)dst) = *((ui32 *)src);
        cword_val >>= n;
        dst += n;
        src += n;
        update_hash_upto(state,& last_hashed,
                         (unsigned char const *)(dst - 3));
      }
      else {
        while ((void *)dst <= (void *)last_destination_byte) {
          if (cword_val == (ui32)1) {
            src += 4;
            cword_val = 1U << 31;
          }
          *dst = *src;
          dst ++;
          src ++;
          cword_val >>= 1;
        }
        update_hash_upto(state,& last_hashed,last_destination_byte - 3);
        __retres = size;
        goto return_label;
      }
  }
  return_label: return __retres;
}

size_t qlz_compress(void const *source, char *destination, size_t size,
                    qlz_state_compress *state)
{
  size_t __retres;
  size_t r;
  ui32 compressed;
  size_t base;
  int tmp_0;
  if (size == (size_t)0) {
    __retres = (size_t)0;
    goto return_label;
  }
  else 
    if (size > 0xffffffff - (unsigned int)400) {
      __retres = (size_t)0;
      goto return_label;
    }
  if (size < (size_t)216) base = (size_t)3; else base = (size_t)9;
  {
    size_t tmp;
    reset_table_compress(state);
    tmp = qlz_compress_core((unsigned char const *)source,
                            (unsigned char *)destination + base,size,state);
    r = base + tmp;
    if (r == base) {
      memcpy((void *)(destination + base),source,size);
      r = size + base;
      compressed = (ui32)0;
    }
    else compressed = (ui32)1;
    state->stream_counter = (size_t)0;
  }
  if (base == (size_t)3) {
    *destination = (char)((unsigned char)((unsigned int)0 | compressed));
    *(destination + 1) = (char)((unsigned char)r);
    *(destination + 2) = (char)((unsigned char)size);
  }
  else {
    *destination = (char)((unsigned char)((unsigned int)2 | compressed));
    fast_write(r,(void *)(destination + 1),(size_t)4);
    fast_write(size,(void *)(destination + 5),(size_t)4);
  }
  *destination = (char)((int)*destination | (1 << 2));
  *destination = (char)((int)*destination | (1 << 6));
  if (0 == 0) tmp_0 = 0; else tmp_0 = 3;
  *destination = (char)((int)*destination | (tmp_0 << 4));
  __retres = r;
  return_label: return __retres;
}

size_t qlz_decompress(char const *source, void *destination,
                      qlz_state_decompress *state)
{
  size_t dsiz = qlz_size_decompressed(source);
  if (((int)*source & 1) == 1) {
    reset_table_decompress(state);
    dsiz = qlz_decompress_core((unsigned char const *)source,
                               (unsigned char *)destination,dsiz,state,
                               (unsigned char const *)destination);
  }
  else {
    size_t tmp_0;
    ;
    tmp_0 = qlz_size_header(source);
    ;
    ;
    memcpy(destination,(void const *)(source + tmp_0),dsiz);
  }
  state->stream_counter = (size_t)0;
  reset_table_decompress(state);
  return dsiz;
}

int eva_main(void)
{
  char argv0[256];
  char argv1[256];
  char argv2[256];
  char argv3[256];
  char argv4[256];
  int tmp_0;
  int argc = Frama_C_interval(0,5);
  char *argv[6] = {argv0, argv1, argv2, argv3, argv4, (char *)0};
  {
    int i = 0;
    /*@ loop unroll 5; */
    while (i < 5) {
      Frama_C_make_unknown(argv[i],(size_t)255);
      *(argv[i] + 255) = (char)0;
      i ++;
    }
  }
  tmp_0 = main(argc,argv);
  return tmp_0;
}


