/* Generated by Frama-C */
#include "__fc_builtin.h"
#include "assert.h"
#include "ctype.h"
#include "errno.h"
#include "fcntl.h"
#include "inttypes.h"
#include "math.h"
#include "netdb.c"
#include "netdb.h"
#include "netinet/in.h"
#include "poll.h"
#include "signal.h"
#include "stdarg.h"
#include "stddef.h"
#include "stdint.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.c"
#include "string.h"
#include "strings.h"
#include "sys/select.h"
#include "sys/socket.h"
#include "sys/time.h"
#include "sys/types.h"
#include "sys/uio.h"
#include "sys/un.h"
#include "unistd.h"
struct redisReadTask {
   int type ;
   int elements ;
   int idx ;
   void *obj ;
   struct redisReadTask *parent ;
   void *privdata ;
};
typedef struct redisReadTask redisReadTask;
struct redisReplyObjectFunctions {
   void *(*createString)(redisReadTask const *, char *, size_t ) ;
   void *(*createArray)(redisReadTask const *, size_t ) ;
   void *(*createInteger)(redisReadTask const *, long long ) ;
   void *(*createDouble)(redisReadTask const *, double , char *, size_t ) ;
   void *(*createNil)(redisReadTask const *) ;
   void *(*createBool)(redisReadTask const *, int ) ;
   void (*freeObject)(void *) ;
};
typedef struct redisReplyObjectFunctions redisReplyObjectFunctions;
struct redisReader {
   int err ;
   char errstr[128] ;
   char *buf ;
   size_t pos ;
   size_t len ;
   size_t maxbuf ;
   redisReadTask rstack[9] ;
   int ridx ;
   void *reply ;
   redisReplyObjectFunctions *fn ;
   void *privdata ;
};
typedef struct redisReader redisReader;
typedef char *sds;
struct sdshdr5 {
   unsigned char flags ;
   char buf[] ;
} __attribute__((__packed__));
struct sdshdr8 {
   uint8_t len ;
   uint8_t alloc ;
   unsigned char flags ;
   char buf[] ;
} __attribute__((__packed__));
struct sdshdr16 {
   uint16_t len ;
   uint16_t alloc ;
   unsigned char flags ;
   char buf[] ;
} __attribute__((__packed__));
struct sdshdr32 {
   uint32_t len ;
   uint32_t alloc ;
   unsigned char flags ;
   char buf[] ;
} __attribute__((__packed__));
struct sdshdr64 {
   uint64_t len ;
   uint64_t alloc ;
   unsigned char flags ;
   char buf[] ;
} __attribute__((__packed__));
struct redisReply {
   int type ;
   long long integer ;
   double dval ;
   size_t len ;
   char *str ;
   size_t elements ;
   struct redisReply **element ;
};
typedef struct redisReply redisReply;
enum redisConnectionType {
    REDIS_CONN_TCP = 0,
    REDIS_CONN_UNIX = 1,
    REDIS_CONN_USERFD = 2
};
typedef int redisFD;
struct __anonstruct_tcp_3 {
   char const *source_addr ;
   char const *ip ;
   int port ;
};
union __anonunion_endpoint_2 {
   struct __anonstruct_tcp_3 tcp ;
   char const *unix_socket ;
   redisFD fd ;
};
struct __anonstruct_redisOptions_1 {
   int type ;
   int options ;
   struct timeval const *timeout ;
   union __anonunion_endpoint_2 endpoint ;
};
typedef struct __anonstruct_redisOptions_1 redisOptions;
struct redisAsyncContext;
struct redisContext;
struct redisContextFuncs {
   void (*free_privdata)(void *) ;
   void (*async_read)(struct redisAsyncContext *) ;
   void (*async_write)(struct redisAsyncContext *) ;
   int (*read)(struct redisContext *, char *, size_t ) ;
   int (*write)(struct redisContext *) ;
};
typedef struct redisContextFuncs redisContextFuncs;
struct __anonstruct_tcp_4 {
   char *host ;
   char *source_addr ;
   int port ;
};
struct __anonstruct_unix_sock_5 {
   char *path ;
};
struct sockadr;
struct redisContext {
   redisContextFuncs const *funcs ;
   int err ;
   char errstr[128] ;
   redisFD fd ;
   int flags ;
   char *obuf ;
   redisReader *reader ;
   enum redisConnectionType connection_type ;
   struct timeval *timeout ;
   struct __anonstruct_tcp_4 tcp ;
   struct __anonstruct_unix_sock_5 unix_sock ;
   struct sockadr *saddr ;
   size_t addrlen ;
   void *privdata ;
};
typedef struct redisContext redisContext;
struct dict;
typedef void redisCallbackFn(struct redisAsyncContext *, void *, void *);
struct redisCallback {
   struct redisCallback *next ;
   redisCallbackFn *fn ;
   int pending_subs ;
   void *privdata ;
};
typedef struct redisCallback redisCallback;
struct redisCallbackList {
   redisCallback *head ;
   redisCallback *tail ;
};
typedef struct redisCallbackList redisCallbackList;
typedef void redisDisconnectCallback(struct redisAsyncContext const *,
                                     int status);
typedef void redisConnectCallback(struct redisAsyncContext const *,
                                  int status);
struct __anonstruct_ev_6 {
   void *data ;
   void (*addRead)(void *privdata) ;
   void (*delRead)(void *privdata) ;
   void (*addWrite)(void *privdata) ;
   void (*delWrite)(void *privdata) ;
   void (*cleanup)(void *privdata) ;
   void (*scheduleTimer)(void *privdata, struct timeval tv) ;
};
struct __anonstruct_sub_7 {
   redisCallbackList invalid ;
   struct dict *channels ;
   struct dict *patterns ;
};
struct redisAsyncContext {
   redisContext c ;
   int err ;
   char *errstr ;
   void *data ;
   struct __anonstruct_ev_6 ev ;
   redisDisconnectCallback *onDisconnect ;
   redisConnectCallback *onConnect ;
   redisCallbackList replies ;
   struct sockaddr *saddr ;
   size_t addrlen ;
   struct __anonstruct_sub_7 sub ;
};
typedef struct redisAsyncContext redisAsyncContext;
struct dictEntry {
   void *key ;
   void *val ;
   struct dictEntry *next ;
};
typedef struct dictEntry dictEntry;
struct dictType {
   unsigned int (*hashFunction)(void const *key) ;
   void *(*keyDup)(void *privdata, void const *key) ;
   void *(*valDup)(void *privdata, void const *obj) ;
   int (*keyCompare)(void *privdata, void const *key1, void const *key2) ;
   void (*keyDestructor)(void *privdata, void *key) ;
   void (*valDestructor)(void *privdata, void *obj) ;
};
typedef struct dictType dictType;
struct dict {
   dictEntry **table ;
   dictType *type ;
   unsigned long size ;
   unsigned long sizemask ;
   unsigned long used ;
   void *privdata ;
};
typedef struct dict dict;
struct dictIterator {
   dict *ht ;
   int index ;
   dictEntry *entry ;
   dictEntry *nextEntry ;
};
typedef struct dictIterator dictIterator;
enum connection_type {
    CONN_TCP = 0,
    CONN_UNIX = 1,
    CONN_FD = 2,
    CONN_SSL = 3
};
struct __anonstruct_tcp_6 {
   char const *host ;
   int port ;
   struct timeval timeout ;
};
struct __anonstruct_unix_sock_7 {
   char const *path ;
};
struct __anonstruct_ssl_8 {
   char const *host ;
   int port ;
   char const *ca_cert ;
   char const *cert ;
   char const *key ;
};
struct config {
   enum connection_type type ;
   struct __anonstruct_tcp_6 tcp ;
   struct __anonstruct_unix_sock_7 unix_sock ;
   struct __anonstruct_ssl_8 ssl ;
};
void *hi_malloc(size_t size);

void *hi_calloc(size_t nmemb, size_t size);

void *hi_realloc(void *ptr, size_t size);

char *hi_strdup(char const *str);

void *hi_malloc(size_t size)
{
  void *ptr = malloc(size);
  if (ptr == (void *)0) abort();
  return ptr;
}

void *hi_calloc(size_t nmemb, size_t size)
{
  void *ptr = calloc(nmemb,size);
  if (ptr == (void *)0) abort();
  return ptr;
}

void *hi_realloc(void *ptr, size_t size)
{
  void *newptr = realloc(ptr,size);
  if (newptr == (void *)0) abort();
  return newptr;
}

char *hi_strdup(char const *str)
{
  char *newstr = strdup(str);
  if (newstr == (char *)0) abort();
  return newstr;
}

redisReader *redisReaderCreateWithFunctions(redisReplyObjectFunctions *fn);

void redisReaderFree(redisReader *r);

int redisReaderFeed(redisReader *r, char const *buf, size_t len);

int redisReaderGetReply(redisReader *r, void **reply);

__inline static size_t sdslen(sds const s)
{
  size_t __retres;
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0: ;
    __retres = (size_t)((int)flags >> 3);
    goto return_label;
    case 1: ;
    __retres = (size_t)((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->len;
    goto return_label;
    case 2: ;
    __retres = (size_t)((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->len;
    goto return_label;
    case 3: ;
    __retres = ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->len;
    goto return_label;
    case 4: ;
    __retres = (size_t)((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->len;
    goto return_label;
  }
  __retres = (size_t)0;
  return_label: return __retres;
}

__inline static size_t sdsavail(sds const s)
{
  size_t __retres;
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0: {
              __retres = (size_t)0;
              goto return_label;
            }
    case 1:
    {
      struct sdshdr8 *sh = (struct sdshdr8 *)(s - sizeof(struct sdshdr8));
      __retres = (size_t)((int)sh->alloc - (int)sh->len);
      goto return_label;
    }
    case 2:
    {
      struct sdshdr16 *sh_0 =
        (struct sdshdr16 *)(s - sizeof(struct sdshdr16));
      __retres = (size_t)((int)sh_0->alloc - (int)sh_0->len);
      goto return_label;
    }
    case 3:
    {
      struct sdshdr32 *sh_1 =
        (struct sdshdr32 *)(s - sizeof(struct sdshdr32));
      __retres = sh_1->alloc - sh_1->len;
      goto return_label;
    }
    case 4:
    {
      struct sdshdr64 *sh_2 =
        (struct sdshdr64 *)(s - sizeof(struct sdshdr64));
      __retres = (size_t)(sh_2->alloc - sh_2->len);
      goto return_label;
    }
  }
  __retres = (size_t)0;
  return_label: return __retres;
}

__inline static void sdssetlen(sds s, size_t newlen)
{
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0:
    {
      unsigned char *fp = (unsigned char *)s - 1;
      *fp = (unsigned char)((unsigned int)0 | (newlen << 3));
    }
    break;
    case 1:
    ((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->len = (uint8_t)newlen;
    break;
    case 2:
    ((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->len = (uint16_t)newlen;
    break;
    case 3: ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->len = newlen;
    break;
    case 4:
    ((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->len = (uint64_t)newlen;
    break;
  }
  return;
}

__inline static void sdsinclen(sds s, size_t inc)
{
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0:
    {
      unsigned char *fp = (unsigned char *)s - 1;
      unsigned char newlen =
        (unsigned char)(((int)flags >> 3) + (int)((unsigned char)inc));
      *fp = (unsigned char)(0 | ((int)newlen << 3));
    }
    break;
    case 1:
    ((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->len = (uint8_t)(
    (int)((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->len + (int)((uint8_t)inc));
    break;
    case 2:
    ((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->len = (uint16_t)(
    (int)((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->len + (int)((uint16_t)inc));
    break;
    case 3: ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->len += inc;
    break;
    case 4:
    ((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->len += (uint64_t)inc;
    break;
  }
  return;
}

__inline static size_t sdsalloc(sds const s)
{
  size_t __retres;
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0: ;
    __retres = (size_t)((int)flags >> 3);
    goto return_label;
    case 1: ;
    __retres = (size_t)((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->alloc;
    goto return_label;
    case 2: ;
    __retres = (size_t)((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->alloc;
    goto return_label;
    case 3: ;
    __retres = ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->alloc;
    goto return_label;
    case 4: ;
    __retres = (size_t)((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->alloc;
    goto return_label;
  }
  __retres = (size_t)0;
  return_label: return __retres;
}

__inline static void sdssetalloc(sds s, size_t newlen)
{
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0: break;
    case 1:
    ((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->alloc = (uint8_t)newlen;
    break;
    case 2:
    ((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->alloc = (uint16_t)newlen;
    break;
    case 3:
    ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->alloc = newlen;
    break;
    case 4:
    ((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->alloc = (uint64_t)newlen;
    break;
  }
  return;
}

sds sdsnewlen(void const *init, size_t initlen);

sds sdsnew(char const *init);

sds sdsempty(void);

sds sdsdup(sds const s);

void sdsfree(sds s);

sds sdsgrowzero(sds s, size_t len);

sds sdscatlen(sds s, void const *t, size_t len);

sds sdscat(sds s, char const *t);

sds sdscatsds(sds s, sds const t);

sds sdscpylen(sds s, char const *t, size_t len);

sds sdscpy(sds s, char const *t);

sds sdscatvprintf(sds s, char const *fmt, va_list ap);

sds ( /* format attribute */ sdscatprintf)(sds s, char const *fmt,
                                           void * const *__va_params);

sds sdscatfmt(sds s, char const *fmt, void * const *__va_params);

sds sdstrim(sds s, char const *cset);

void sdsrange(sds s, int start, int end);

void sdsupdatelen(sds s);

void sdsclear(sds s);

int sdscmp(sds const s1, sds const s2);

sds *sdssplitlen(char const *s, int len, char const *sep, int seplen,
                 int *count);

void sdsfreesplitres(sds *tokens, int count);

void sdstolower(sds s);

void sdstoupper(sds s);

sds sdsfromlonglong(long long value);

sds sdscatrepr(sds s, char const *p, size_t len);

sds *sdssplitargs(char const *line, int *argc);

sds sdsmapchars(sds s, char const *from, char const *to, size_t setlen);

sds sdsjoin(char **argv, int argc, char *sep);

sds sdsjoinsds(sds *argv, int argc, char const *sep, size_t seplen);

sds sdsMakeRoomFor(sds s, size_t addlen);

void sdsIncrLen(sds s, int incr);

sds sdsRemoveFreeSpace(sds s);

size_t sdsAllocSize(sds s);

void *sdsAllocPtr(sds s);

void *sds_malloc(size_t size);

void *sds_realloc(void *ptr, size_t size);

void sds_free(void *ptr);

redisReader *redisReaderCreate(void);

void freeReplyObject(void *reply);

int redisvFormatCommand(char **target, char const *format, va_list ap);

int redisFormatCommand(char **target, char const *format,
                       void * const *__va_params);

int redisFormatCommandArgv(char **target, int argc, char const **argv,
                           size_t const *argvlen);

int redisFormatSdsCommandArgv(sds *target, int argc, char const **argv,
                              size_t const *argvlen);

void redisFreeCommand(char *cmd);

void redisFreeSdsCommand(sds cmd);

redisContext *redisConnectWithOptions(redisOptions const *options);

redisContext *redisConnect(char const *ip, int port);

redisContext *redisConnectWithTimeout(char const *ip, int port,
                                      struct timeval const tv);

redisContext *redisConnectNonBlock(char const *ip, int port);

redisContext *redisConnectBindNonBlock(char const *ip, int port,
                                       char const *source_addr);

redisContext *redisConnectBindNonBlockWithReuse(char const *ip, int port,
                                                char const *source_addr);

redisContext *redisConnectUnix(char const *path);

redisContext *redisConnectUnixWithTimeout(char const *path,
                                          struct timeval const tv);

redisContext *redisConnectUnixNonBlock(char const *path);

redisContext *redisConnectFd(redisFD fd);

int redisReconnect(redisContext *c);

int redisSetTimeout(redisContext *c, struct timeval const tv);

int redisEnableKeepAlive(redisContext *c);

void redisFree(redisContext *c);

redisFD redisFreeKeepFd(redisContext *c);

int redisBufferRead(redisContext *c);

int redisBufferWrite(redisContext *c, int *done);

int redisGetReply(redisContext *c, void **reply);

int redisGetReplyFromReader(redisContext *c, void **reply);

int redisAppendFormattedCommand(redisContext *c, char const *cmd, size_t len);

int redisvAppendCommand(redisContext *c, char const *format, va_list ap);

int redisAppendCommand(redisContext *c, char const *format,
                       void * const *__va_params);

int redisAppendCommandArgv(redisContext *c, int argc, char const **argv,
                           size_t const *argvlen);

void *redisvCommand(redisContext *c, char const *format, va_list ap);

void *redisCommand(redisContext *c, char const *format,
                   void * const *__va_params);

void *redisCommandArgv(redisContext *c, int argc, char const **argv,
                       size_t const *argvlen);

redisAsyncContext *redisAsyncConnectWithOptions(redisOptions const *options);

redisAsyncContext *redisAsyncConnect(char const *ip, int port);

redisAsyncContext *redisAsyncConnectBind(char const *ip, int port,
                                         char const *source_addr);

redisAsyncContext *redisAsyncConnectBindWithReuse(char const *ip, int port,
                                                  char const *source_addr);

redisAsyncContext *redisAsyncConnectUnix(char const *path);

int redisAsyncSetConnectCallback(redisAsyncContext *ac,
                                 redisConnectCallback *fn);

int redisAsyncSetDisconnectCallback(redisAsyncContext *ac,
                                    redisDisconnectCallback *fn);

void redisAsyncSetTimeout(redisAsyncContext *ac, struct timeval tv);

void redisAsyncDisconnect(redisAsyncContext *ac);

void redisAsyncFree(redisAsyncContext *ac);

void redisAsyncHandleRead(redisAsyncContext *ac);

void redisAsyncHandleWrite(redisAsyncContext *ac);

void redisAsyncHandleTimeout(redisAsyncContext *ac);

void redisAsyncRead(redisAsyncContext *ac);

void redisAsyncWrite(redisAsyncContext *ac);

int redisvAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn,
                       void *privdata, char const *format, va_list ap);

int redisAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn,
                      void *privdata, char const *format,
                      void * const *__va_params);

int redisAsyncCommandArgv(redisAsyncContext *ac, redisCallbackFn *fn,
                          void *privdata, int argc, char const **argv,
                          size_t const *argvlen);

int redisAsyncFormattedCommand(redisAsyncContext *ac, redisCallbackFn *fn,
                               void *privdata, char const *cmd, size_t len);

void redisNetClose(redisContext *c);

int redisNetRead(redisContext *c, char *buf, size_t bufcap);

int redisNetWrite(redisContext *c);

int redisCheckSocketError(redisContext *c);

int redisContextSetTimeout(redisContext *c, struct timeval const tv);

int redisContextConnectTcp(redisContext *c, char const *addr, int port,
                           struct timeval const *timeout);

int redisContextConnectBindTcp(redisContext *c, char const *addr, int port,
                               struct timeval const *timeout,
                               char const *source_addr);

int redisContextConnectUnix(redisContext *c, char const *path,
                            struct timeval const *timeout);

int redisKeepAlive(redisContext *c, int interval);

int redisCheckConnectDone(redisContext *c, int *completed);

static unsigned int dictGenHashFunction(unsigned char const *buf, int len);

static dict *dictCreate(dictType *type, void *privDataPtr);

static int dictExpand(dict *ht, unsigned long size);

static int dictAdd(dict *ht, void *key, void *val);

static int dictReplace(dict *ht, void *key, void *val);

static int dictDelete(dict *ht, void const *key);

static void dictRelease(dict *ht);

static dictEntry *dictFind(dict *ht, void const *key);

static dictIterator *dictGetIterator(dict *ht);

static dictEntry *dictNext(dictIterator *iter);

static void dictReleaseIterator(dictIterator *iter);

static int _dictExpandIfNeeded(dict *ht);

static unsigned long _dictNextPower(unsigned long size);

static int _dictKeyIndex(dict *ht, void const *key);

static int _dictInit(dict *ht, dictType *type, void *privDataPtr);

static unsigned int dictGenHashFunction(unsigned char const *buf, int len)
{
  unsigned int hash = (unsigned int)5381;
  while (1) {
    int tmp_0;
    unsigned char const *tmp;
    tmp_0 = len;
    len --;
    ;
    if (! tmp_0) break;
    tmp = buf;
    buf ++;
    hash = ((hash << 5) + hash) + (unsigned int)*tmp;
  }
  return hash;
}

static void _dictReset(dict *ht)
{
  ht->table = (dictEntry **)0;
  ht->size = (unsigned long)0;
  ht->sizemask = (unsigned long)0;
  ht->used = (unsigned long)0;
  return;
}

static dict *dictCreate(dictType *type, void *privDataPtr)
{
  dict *tmp_0;
  dict *ht = hi_malloc(sizeof(*tmp_0));
  _dictInit(ht,type,privDataPtr);
  return ht;
}

static int _dictInit(dict *ht, dictType *type, void *privDataPtr)
{
  int __retres;
  _dictReset(ht);
  ht->type = type;
  ht->privdata = privDataPtr;
  __retres = 0;
  return __retres;
}

static int dictExpand(dict *ht, unsigned long size)
{
  int __retres;
  dict n;
  unsigned long i;
  unsigned long realsize = _dictNextPower(size);
  if (ht->used > size) {
    __retres = 1;
    goto return_label;
  }
  _dictInit(& n,ht->type,ht->privdata);
  n.size = realsize;
  n.sizemask = realsize - (unsigned long)1;
  n.table = (dictEntry **)calloc((size_t)realsize,sizeof(dictEntry *));
  n.used = ht->used;
  i = (unsigned long)0;
  while (1) {
    if (i < ht->size) {
      if (! (ht->used > (unsigned long)0)) break;
    }
    else break;
    {
      dictEntry *he;
      dictEntry *nextHe;
      if (*(ht->table + i) == (dictEntry *)0) goto __Cont;
      he = *(ht->table + i);
      while (he) {
        unsigned int h;
        unsigned int tmp_0;
        nextHe = he->next;
        tmp_0 = (*((ht->type)->hashFunction))((void const *)he->key);
        h = (unsigned int)((unsigned long)tmp_0 & n.sizemask);
        he->next = *(n.table + h);
        *(n.table + h) = he;
        (ht->used) --;
        he = nextHe;
      }
    }
    __Cont: i ++;
  }
  __FC_assert((ht->used == (unsigned long)0) != 0,"dict.c",127,
              "ht->used == 0");
  free((void *)ht->table);
  *ht = n;
  __retres = 0;
  return_label: return __retres;
}

static int dictAdd(dict *ht, void *key, void *val)
{
  int __retres;
  int index_0;
  dictEntry *entry;
  index_0 = _dictKeyIndex(ht,(void const *)key);
  if (index_0 == -1) {
    __retres = 1;
    goto return_label;
  }
  entry = (dictEntry *)hi_malloc(sizeof(*entry));
  entry->next = *(ht->table + index_0);
  *(ht->table + index_0) = entry;
  if ((ht->type)->keyDup) entry->key = (*((ht->type)->keyDup))(ht->privdata,
                                                               (void const *)key);
  else entry->key = key;
  if ((ht->type)->valDup) entry->val = (*((ht->type)->valDup))(ht->privdata,
                                                               (void const *)val);
  else entry->val = val;
  (ht->used) ++;
  __retres = 0;
  return_label: return __retres;
}

static int dictReplace(dict *ht, void *key, void *val)
{
  int __retres;
  dictEntry *entry;
  dictEntry auxentry;
  int tmp;
  tmp = dictAdd(ht,key,val);
  if (tmp == 0) {
    __retres = 1;
    goto return_label;
  }
  entry = dictFind(ht,(void const *)key);
  auxentry = *entry;
  if ((ht->type)->valDup) entry->val = (*((ht->type)->valDup))(ht->privdata,
                                                               (void const *)val);
  else entry->val = val;
  if ((ht->type)->valDestructor) (*((ht->type)->valDestructor))(ht->privdata,
                                                                auxentry.val);
  __retres = 0;
  return_label: return __retres;
}

static int dictDelete(dict *ht, void const *key)
{
  int __retres;
  unsigned int h;
  dictEntry *de;
  dictEntry *prevde;
  unsigned int tmp;
  if (ht->size == (unsigned long)0) {
    __retres = 1;
    goto return_label;
  }
  tmp = (*((ht->type)->hashFunction))(key);
  h = (unsigned int)((unsigned long)tmp & ht->sizemask);
  de = *(ht->table + h);
  prevde = (dictEntry *)0;
  while (de) {
    int tmp_1;
    if ((ht->type)->keyCompare) tmp_1 = (*((ht->type)->keyCompare))(ht->privdata,
                                                                    key,
                                                                    (void const *)de->key);
    else tmp_1 = (void *)key == de->key;
    if (tmp_1) {
      if (prevde) prevde->next = de->next; else *(ht->table + h) = de->next;
      if ((ht->type)->keyDestructor) (*((ht->type)->keyDestructor))(ht->privdata,
                                                                    de->key);
      if ((ht->type)->valDestructor) (*((ht->type)->valDestructor))(ht->privdata,
                                                                    de->val);
      free((void *)de);
      (ht->used) --;
      __retres = 0;
      goto return_label;
    }
    prevde = de;
    de = de->next;
  }
  __retres = 1;
  return_label: return __retres;
}

static int _dictClear(dict *ht)
{
  int __retres;
  unsigned long i;
  i = (unsigned long)0;
  while (1) {
    if (i < ht->size) {
      if (! (ht->used > (unsigned long)0)) break;
    }
    else break;
    {
      dictEntry *he;
      dictEntry *nextHe;
      he = *(ht->table + i);
      if (he == (dictEntry *)0) goto __Cont;
      while (he) {
        nextHe = he->next;
        if ((ht->type)->keyDestructor) (*((ht->type)->keyDestructor))
                                       (ht->privdata,he->key);
        if ((ht->type)->valDestructor) (*((ht->type)->valDestructor))
                                       (ht->privdata,he->val);
        free((void *)he);
        (ht->used) --;
        he = nextHe;
      }
    }
    __Cont: i ++;
  }
  free((void *)ht->table);
  _dictReset(ht);
  __retres = 0;
  return __retres;
}

static void dictRelease(dict *ht)
{
  _dictClear(ht);
  free((void *)ht);
  return;
}

static dictEntry *dictFind(dict *ht, void const *key)
{
  dictEntry *__retres;
  dictEntry *he;
  unsigned int h;
  unsigned int tmp;
  if (ht->size == (unsigned long)0) {
    __retres = (dictEntry *)0;
    goto return_label;
  }
  tmp = (*((ht->type)->hashFunction))(key);
  h = (unsigned int)((unsigned long)tmp & ht->sizemask);
  he = *(ht->table + h);
  while (he) {
    int tmp_1;
    if ((ht->type)->keyCompare) tmp_1 = (*((ht->type)->keyCompare))(ht->privdata,
                                                                    key,
                                                                    (void const *)he->key);
    else tmp_1 = (void *)key == he->key;
    if (tmp_1) {
      __retres = he;
      goto return_label;
    }
    he = he->next;
  }
  __retres = (dictEntry *)0;
  return_label: return __retres;
}

static dictIterator *dictGetIterator(dict *ht)
{
  dictIterator *tmp_0;
  dictIterator *iter = hi_malloc(sizeof(*tmp_0));
  iter->ht = ht;
  iter->index = -1;
  iter->entry = (dictEntry *)0;
  iter->nextEntry = (dictEntry *)0;
  return iter;
}

static dictEntry *dictNext(dictIterator *iter)
{
  dictEntry *__retres;
  while (1) {
    if (iter->entry == (dictEntry *)0) {
      (iter->index) ++;
      if (iter->index >= (int)(iter->ht)->size) break;
      iter->entry = *((iter->ht)->table + iter->index);
    }
    else iter->entry = iter->nextEntry;
    if (iter->entry) {
      iter->nextEntry = (iter->entry)->next;
      __retres = iter->entry;
      goto return_label;
    }
  }
  __retres = (dictEntry *)0;
  return_label: return __retres;
}

static void dictReleaseIterator(dictIterator *iter)
{
  free((void *)iter);
  return;
}

static int _dictExpandIfNeeded(dict *ht)
{
  int __retres;
  if (ht->size == (unsigned long)0) {
    int tmp;
    tmp = dictExpand(ht,(unsigned long)4);
    __retres = tmp;
    goto return_label;
  }
  if (ht->used == ht->size) {
    int tmp_0;
    tmp_0 = dictExpand(ht,ht->size * (unsigned long)2);
    __retres = tmp_0;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static unsigned long _dictNextPower(unsigned long size)
{
  unsigned long __retres;
  unsigned long i = (unsigned long)4;
  if (size >= (unsigned long)2147483647L) {
    __retres = (unsigned long)2147483647L;
    goto return_label;
  }
  while (1) {
    if (i >= size) {
      __retres = i;
      goto return_label;
    }
    i *= (unsigned long)2;
  }
  return_label: return __retres;
}

static int _dictKeyIndex(dict *ht, void const *key)
{
  int __retres;
  unsigned int h;
  dictEntry *he;
  int tmp;
  unsigned int tmp_0;
  tmp = _dictExpandIfNeeded(ht);
  if (tmp == 1) {
    __retres = -1;
    goto return_label;
  }
  tmp_0 = (*((ht->type)->hashFunction))(key);
  h = (unsigned int)((unsigned long)tmp_0 & ht->sizemask);
  he = *(ht->table + h);
  while (he) {
    int tmp_2;
    if ((ht->type)->keyCompare) tmp_2 = (*((ht->type)->keyCompare))(ht->privdata,
                                                                    key,
                                                                    (void const *)he->key);
    else tmp_2 = (void *)key == he->key;
    if (tmp_2) {
      __retres = -1;
      goto return_label;
    }
    he = he->next;
  }
  __retres = (int)h;
  return_label: return __retres;
}

__inline static void refreshTimeout(redisAsyncContext *ctx)
{
  if (ctx->c.timeout) 
    if (ctx->ev.scheduleTimer) 
      if ((ctx->c.timeout)->tv_sec) goto _LOR;
      else 
        if ((ctx->c.timeout)->tv_usec) _LOR:
                                       (*(ctx->ev.scheduleTimer))(ctx->ev.data,
                                                                  *(ctx->c.timeout));
  return;
}

void __redisAsyncDisconnect(redisAsyncContext *ac);

void redisProcessCallbacks(redisAsyncContext *ac);

int __redisAppendCommand(redisContext *c, char const *cmd, size_t len);

static unsigned int callbackHash(void const *key)
{
  unsigned int tmp_0;
  size_t tmp;
  tmp = sdslen((sds)key);
  ;
  tmp_0 = dictGenHashFunction((unsigned char const *)key,(int)tmp);
  return tmp_0;
}

static void *callbackValDup(void *privdata, void const *src)
{
  void *__retres;
  redisCallback *tmp_0;
  redisCallback *dup_0 = hi_malloc(sizeof(*tmp_0));
  memcpy((void *)dup_0,src,sizeof(*dup_0));
  __retres = (void *)dup_0;
  return __retres;
}

static int callbackKeyCompare(void *privdata, void const *key1,
                              void const *key2)
{
  int __retres;
  int l1;
  int l2;
  size_t tmp;
  size_t tmp_0;
  int tmp_1;
  tmp = sdslen((sds)key1);
  l1 = (int)tmp;
  tmp_0 = sdslen((sds)key2);
  l2 = (int)tmp_0;
  if (l1 != l2) {
    __retres = 0;
    goto return_label;
  }
  tmp_1 = memcmp(key1,key2,(size_t)l1);
  __retres = tmp_1 == 0;
  return_label: return __retres;
}

static void callbackKeyDestructor(void *privdata, void *key)
{
  sdsfree((sds)key);
  return;
}

static void callbackValDestructor(void *privdata, void *val)
{
  free(val);
  return;
}

static dictType callbackDict =
  {.hashFunction = & callbackHash,
   .keyDup = (void *(*)(void *privdata, void const *key))0,
   .valDup = & callbackValDup,
   .keyCompare = & callbackKeyCompare,
   .keyDestructor = & callbackKeyDestructor,
   .valDestructor = & callbackValDestructor};
static redisAsyncContext *redisAsyncInitialize(redisContext *c)
{
  redisAsyncContext *__retres;
  redisAsyncContext *ac;
  ac = (redisAsyncContext *)realloc((void *)c,sizeof(redisAsyncContext));
  if (ac == (redisAsyncContext *)0) {
    __retres = (redisAsyncContext *)0;
    goto return_label;
  }
  c = & ac->c;
  c->flags &= ~ 0x2;
  ac->err = 0;
  ac->errstr = (char *)0;
  ac->data = (void *)0;
  ac->ev.data = (void *)0;
  ac->ev.addRead = (void (*)(void *privdata))0;
  ac->ev.delRead = (void (*)(void *privdata))0;
  ac->ev.addWrite = (void (*)(void *privdata))0;
  ac->ev.delWrite = (void (*)(void *privdata))0;
  ac->ev.cleanup = (void (*)(void *privdata))0;
  ac->ev.scheduleTimer = (void (*)(void *privdata, struct timeval tv))0;
  ac->onConnect = (redisConnectCallback *)0;
  ac->onDisconnect = (redisDisconnectCallback *)0;
  ac->replies.head = (redisCallback *)0;
  ac->replies.tail = (redisCallback *)0;
  ac->sub.invalid.head = (redisCallback *)0;
  ac->sub.invalid.tail = (redisCallback *)0;
  ac->sub.channels = dictCreate(& callbackDict,(void *)0);
  ac->sub.patterns = dictCreate(& callbackDict,(void *)0);
  __retres = ac;
  return_label: return __retres;
}

static void __redisAsyncCopyError(redisAsyncContext *ac)
{
  if (! ac) goto return_label;
  redisContext *c = & ac->c;
  ac->err = c->err;
  ac->errstr = c->errstr;
  return_label: return;
}

redisAsyncContext *redisAsyncConnectWithOptions(redisOptions const *options)
{
  redisAsyncContext *__retres;
  redisContext *c;
  redisAsyncContext *ac;
  redisOptions myOptions = *options;
  myOptions.options |= 0x01;
  c = redisConnectWithOptions((redisOptions const *)(& myOptions));
  if (c == (redisContext *)0) {
    __retres = (redisAsyncContext *)0;
    goto return_label;
  }
  ac = redisAsyncInitialize(c);
  if (ac == (redisAsyncContext *)0) {
    redisFree(c);
    __retres = (redisAsyncContext *)0;
    goto return_label;
  }
  __redisAsyncCopyError(ac);
  __retres = ac;
  return_label: return __retres;
}

redisAsyncContext *redisAsyncConnect(char const *ip, int port)
{
  redisAsyncContext *tmp;
  redisOptions options =
    {.type = 0,
     .options = 0,
     .timeout = (struct timeval const *)0,
     .endpoint = {.tcp = {.source_addr = (char const *)0,
                          .ip = (char const *)0,
                          .port = 0}}};
  options.type = REDIS_CONN_TCP;
  options.endpoint.tcp.ip = ip;
  options.endpoint.tcp.port = port;
  tmp = redisAsyncConnectWithOptions((redisOptions const *)(& options));
  return tmp;
}

redisAsyncContext *redisAsyncConnectBind(char const *ip, int port,
                                         char const *source_addr)
{
  redisAsyncContext *tmp;
  redisOptions options =
    {.type = 0,
     .options = 0,
     .timeout = (struct timeval const *)0,
     .endpoint = {.tcp = {.source_addr = (char const *)0,
                          .ip = (char const *)0,
                          .port = 0}}};
  options.type = REDIS_CONN_TCP;
  options.endpoint.tcp.ip = ip;
  options.endpoint.tcp.port = port;
  options.endpoint.tcp.source_addr = source_addr;
  tmp = redisAsyncConnectWithOptions((redisOptions const *)(& options));
  return tmp;
}

redisAsyncContext *redisAsyncConnectBindWithReuse(char const *ip, int port,
                                                  char const *source_addr)
{
  redisAsyncContext *tmp;
  redisOptions options =
    {.type = 0,
     .options = 0,
     .timeout = (struct timeval const *)0,
     .endpoint = {.tcp = {.source_addr = (char const *)0,
                          .ip = (char const *)0,
                          .port = 0}}};
  options.type = REDIS_CONN_TCP;
  options.endpoint.tcp.ip = ip;
  options.endpoint.tcp.port = port;
  options.options |= 0x02;
  options.endpoint.tcp.source_addr = source_addr;
  tmp = redisAsyncConnectWithOptions((redisOptions const *)(& options));
  return tmp;
}

redisAsyncContext *redisAsyncConnectUnix(char const *path)
{
  redisAsyncContext *tmp;
  redisOptions options =
    {.type = 0,
     .options = 0,
     .timeout = (struct timeval const *)0,
     .endpoint = {.tcp = {.source_addr = (char const *)0,
                          .ip = (char const *)0,
                          .port = 0}}};
  options.type = REDIS_CONN_UNIX;
  options.endpoint.unix_socket = path;
  tmp = redisAsyncConnectWithOptions((redisOptions const *)(& options));
  return tmp;
}

int redisAsyncSetConnectCallback(redisAsyncContext *ac,
                                 redisConnectCallback *fn)
{
  int __retres;
  if (ac->onConnect == (redisConnectCallback *)0) {
    ac->onConnect = fn;
    refreshTimeout(ac);
    if (ac->ev.addWrite) (*(ac->ev.addWrite))(ac->ev.data);
    __retres = 0;
    goto return_label;
  }
  __retres = -1;
  return_label: return __retres;
}

int redisAsyncSetDisconnectCallback(redisAsyncContext *ac,
                                    redisDisconnectCallback *fn)
{
  int __retres;
  if (ac->onDisconnect == (redisDisconnectCallback *)0) {
    ac->onDisconnect = fn;
    __retres = 0;
    goto return_label;
  }
  __retres = -1;
  return_label: return __retres;
}

static int __redisPushCallback(redisCallbackList *list, redisCallback *source)
{
  int __retres;
  redisCallback *cb;
  cb = (redisCallback *)malloc(sizeof(*cb));
  if (cb == (redisCallback *)0) {
    __retres = 5;
    goto return_label;
  }
  if (source != (redisCallback *)0) {
    memcpy((void *)cb,(void const *)source,sizeof(*cb));
    cb->next = (struct redisCallback *)0;
  }
  if (list->head == (redisCallback *)0) list->head = cb;
  if (list->tail != (redisCallback *)0) (list->tail)->next = cb;
  list->tail = cb;
  __retres = 0;
  return_label: return __retres;
}

static int __redisShiftCallback(redisCallbackList *list,
                                redisCallback *target)
{
  int __retres;
  redisCallback *cb = list->head;
  if (cb != (redisCallback *)0) {
    list->head = cb->next;
    if (cb == list->tail) list->tail = (redisCallback *)0;
    if (target != (redisCallback *)0) memcpy((void *)target,(void const *)cb,
                                             sizeof(*cb));
    free((void *)cb);
    __retres = 0;
    goto return_label;
  }
  __retres = -1;
  return_label: return __retres;
}

static void __redisRunCallback(redisAsyncContext *ac, redisCallback *cb,
                               redisReply *reply)
{
  redisContext *c = & ac->c;
  if (cb->fn != (redisCallbackFn *)0) {
    c->flags |= 0x10;
    (*(cb->fn))(ac,(void *)reply,cb->privdata);
    c->flags &= ~ 0x10;
  }
  return;
}

static void __redisAsyncFree(redisAsyncContext *ac)
{
  redisCallback cb;
  dictIterator *it;
  dictEntry *de;
  redisContext *c = & ac->c;
  while (1) {
    int tmp;
    tmp = __redisShiftCallback(& ac->replies,& cb);
    if (! (tmp == 0)) break;
    __redisRunCallback(ac,& cb,(redisReply *)0);
  }
  while (1) {
    int tmp_0;
    tmp_0 = __redisShiftCallback(& ac->sub.invalid,& cb);
    if (! (tmp_0 == 0)) break;
    __redisRunCallback(ac,& cb,(redisReply *)0);
  }
  it = dictGetIterator(ac->sub.channels);
  while (1) {
    de = dictNext(it);
    if (! (de != (dictEntry *)0)) break;
    __redisRunCallback(ac,(redisCallback *)de->val,(redisReply *)0);
  }
  dictReleaseIterator(it);
  dictRelease(ac->sub.channels);
  it = dictGetIterator(ac->sub.patterns);
  while (1) {
    de = dictNext(it);
    if (! (de != (dictEntry *)0)) break;
    __redisRunCallback(ac,(redisCallback *)de->val,(redisReply *)0);
  }
  dictReleaseIterator(it);
  dictRelease(ac->sub.patterns);
  if (ac->ev.cleanup) (*(ac->ev.cleanup))(ac->ev.data);
  ac->ev.cleanup = (void (*)(void *privdata))0;
  if (ac->onDisconnect) 
    if (c->flags & 0x2) 
      if (c->flags & 0x8) (*(ac->onDisconnect))((struct redisAsyncContext const *)ac,
                                                0);
      else {
        int tmp_1;
        if (ac->err == 0) tmp_1 = 0; else tmp_1 = -1;
        ;
        (*(ac->onDisconnect))((struct redisAsyncContext const *)ac,tmp_1);
      }
  redisFree(c);
  return;
}

void redisAsyncFree(redisAsyncContext *ac)
{
  redisContext *c = & ac->c;
  c->flags |= 0x8;
  if (! (c->flags & 0x10)) __redisAsyncFree(ac);
  return;
}

void __redisAsyncDisconnect(redisAsyncContext *ac)
{
  redisContext *c = & ac->c;
  __redisAsyncCopyError(ac);
  if (ac->err == 0) {
    int ret = __redisShiftCallback(& ac->replies,(redisCallback *)0);
    __FC_assert((ret == -1) != 0,"async.c",327,"ret == REDIS_ERR");
  }
  else c->flags |= 0x4;
  if (ac->ev.cleanup) (*(ac->ev.cleanup))(ac->ev.data);
  ac->ev.cleanup = (void (*)(void *privdata))0;
  if (! (c->flags & 0x200)) __redisAsyncFree(ac);
  return;
}

void redisAsyncDisconnect(redisAsyncContext *ac)
{
  redisContext *c = & ac->c;
  c->flags |= 0x4;
  c->flags &= ~ 0x200;
  if (! (c->flags & 0x10)) 
    if (ac->replies.head == (redisCallback *)0) __redisAsyncDisconnect(ac);
  return;
}

static int __redisGetSubscribeCallback(redisAsyncContext *ac,
                                       redisReply *reply,
                                       redisCallback *dstcb)
{
  int __retres;
  dict *callbacks;
  redisCallback *cb;
  dictEntry *de;
  int pvariant;
  char *stype;
  sds sname;
  redisContext *c = & ac->c;
  if (reply->type == 2) {
    int tmp;
    __FC_assert((reply->elements >= (size_t)2) != 0,"async.c",373,
                "reply->elements >= 2");
    __FC_assert(((*(reply->element + 0))->type == 1) != 0,"async.c",374,
                "reply->element[0]->type == REDIS_REPLY_STRING");
    stype = (*(reply->element + 0))->str;
    tmp = tolower((int)*(stype + 0));
    if (tmp == 'p') pvariant = 1; else pvariant = 0;
    if (pvariant) callbacks = ac->sub.patterns;
    else callbacks = ac->sub.channels;
    __FC_assert(((*(reply->element + 1))->type == 1) != 0,"async.c",384,
                "reply->element[1]->type == REDIS_REPLY_STRING");
    sname = sdsnewlen((void const *)(*(reply->element + 1))->str,
                      (*(reply->element + 1))->len);
    de = dictFind(callbacks,(void const *)sname);
    if (de != (dictEntry *)0) {
      int tmp_0;
      int tmp_1;
      cb = (redisCallback *)de->val;
      tmp_0 = strcasecmp((char const *)(stype + pvariant),"subscribe");
      if (tmp_0 == 0) (cb->pending_subs) --;
      memcpy((void *)dstcb,(void const *)cb,sizeof(*dstcb));
      tmp_1 = strcasecmp((char const *)(stype + pvariant),"unsubscribe");
      if (tmp_1 == 0) {
        if (cb->pending_subs == 0) dictDelete(callbacks,(void const *)sname);
        __FC_assert(((*(reply->element + 2))->type == 3) != 0,"async.c",404,
                    "reply->element[2]->type == REDIS_REPLY_INTEGER");
        if ((*(reply->element + 2))->integer == (long long)0) 
          if ((ac->sub.channels)->used == (unsigned long)0) 
            if ((ac->sub.patterns)->used == (unsigned long)0) c->flags &= ~ 0x20;
      }
    }
    sdsfree(sname);
  }
  else __redisShiftCallback(& ac->sub.invalid,dstcb);
  __retres = 0;
  return __retres;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) âˆ¨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int snprintf_va_1(char * restrict s, size_t n, char const * restrict format,
                  char *param0);

void redisProcessCallbacks(redisAsyncContext *ac)
{
  int status;
  redisContext *c = & ac->c;
  redisCallback cb =
    {.next = (struct redisCallback *)0,
     .fn = (redisCallbackFn *)0,
     .pending_subs = 0,
     .privdata = (void *)0};
  void *reply = (void *)0;
  while (1) {
    status = redisGetReply(c,& reply);
    if (! (status == 0)) break;
    {
      int tmp_1;
      if (reply == (void *)0) {
        if (c->flags & 0x4) {
          size_t tmp;
          tmp = sdslen(c->obuf);
          if (tmp == (size_t)0) 
            if (ac->replies.head == (redisCallback *)0) {
              __redisAsyncDisconnect(ac);
              goto return_label;
            }
        }
        if (c->flags & 0x40) __redisPushCallback(& ac->replies,& cb);
        break;
      }
      tmp_1 = __redisShiftCallback(& ac->replies,& cb);
      if (tmp_1 != 0) {
        int tmp_0;
        if (((redisReply *)reply)->type == 6) {
          c->err = 2;
          snprintf(c->errstr,sizeof(c->errstr),"%s",
                   ((redisReply *)reply)->str); /* snprintf_va_1 */
          (*(((c->reader)->fn)->freeObject))(reply);
          __redisAsyncDisconnect(ac);
          goto return_label;
        }
        if (c->flags & 0x20) tmp_0 = 1;
        else 
          if (c->flags & 0x40) tmp_0 = 1; else tmp_0 = 0;
        __FC_assert(tmp_0 != 0,"async.c",473,
                    "(c->flags & REDIS_SUBSCRIBED || c->flags & REDIS_MONITORING)");
        if (c->flags & 0x20) __redisGetSubscribeCallback(ac,
                                                         (redisReply *)reply,
                                                         & cb);
      }
      if (cb.fn != (redisCallbackFn *)0) {
        __redisRunCallback(ac,& cb,(redisReply *)reply);
        (*(((c->reader)->fn)->freeObject))(reply);
        if (c->flags & 0x8) {
          __redisAsyncFree(ac);
          goto return_label;
        }
      }
      else (*(((c->reader)->fn)->freeObject))(reply);
    }
  }
  if (status != 0) __redisAsyncDisconnect(ac);
  return_label: return;
}

static int __redisAsyncHandleConnect(redisAsyncContext *ac)
{
  int __retres;
  int tmp;
  int completed = 0;
  redisContext *c = & ac->c;
  tmp = redisCheckConnectDone(c,& completed);
  if (tmp == -1) {
    redisCheckSocketError(c);
    if (ac->onConnect) (*(ac->onConnect))((struct redisAsyncContext const *)ac,
                                          -1);
    __redisAsyncDisconnect(ac);
    __retres = -1;
    goto return_label;
  }
  else 
    if (completed == 1) {
      if (ac->onConnect) (*(ac->onConnect))((struct redisAsyncContext const *)ac,
                                            0);
      c->flags |= 0x2;
      __retres = 0;
      goto return_label;
    }
    else {
      __retres = 0;
      goto return_label;
    }
  return_label: return __retres;
}

void redisAsyncRead(redisAsyncContext *ac)
{
  int tmp;
  redisContext *c = & ac->c;
  tmp = redisBufferRead(c);
  if (tmp == -1) __redisAsyncDisconnect(ac);
  else {
    refreshTimeout(ac);
    if (ac->ev.addRead) (*(ac->ev.addRead))(ac->ev.data);
    redisProcessCallbacks(ac);
  }
  return;
}

void redisAsyncHandleRead(redisAsyncContext *ac)
{
  redisContext *c = & ac->c;
  if (! (c->flags & 0x2)) {
    int tmp;
    tmp = __redisAsyncHandleConnect(ac);
    if (tmp != 0) goto return_label;
    if (! (c->flags & 0x2)) goto return_label;
  }
  (*((c->funcs)->async_read))(ac);
  return_label: return;
}

void redisAsyncWrite(redisAsyncContext *ac)
{
  int tmp;
  redisContext *c = & ac->c;
  int done = 0;
  tmp = redisBufferWrite(c,& done);
  if (tmp == -1) __redisAsyncDisconnect(ac);
  else {
    if (! done) {
      refreshTimeout(ac);
      if (ac->ev.addWrite) (*(ac->ev.addWrite))(ac->ev.data);
    }
    else 
      if (ac->ev.delWrite) (*(ac->ev.delWrite))(ac->ev.data);
    refreshTimeout(ac);
    if (ac->ev.addRead) (*(ac->ev.addRead))(ac->ev.data);
  }
  return;
}

void redisAsyncHandleWrite(redisAsyncContext *ac)
{
  redisContext *c = & ac->c;
  if (! (c->flags & 0x2)) {
    int tmp;
    tmp = __redisAsyncHandleConnect(ac);
    if (tmp != 0) goto return_label;
    if (! (c->flags & 0x2)) goto return_label;
  }
  (*((c->funcs)->async_write))(ac);
  return_label: return;
}

void __redisSetError(redisContext *c, int type, char const *str);

void redisAsyncHandleTimeout(redisAsyncContext *ac)
{
  redisCallback cb;
  redisContext *c = & ac->c;
  if (c->flags & 0x2) 
    if (ac->replies.head == (redisCallback *)0) goto return_label;
  if (! c->err) __redisSetError(c,6,"Timeout");
  if (! (c->flags & 0x2)) 
    if (ac->onConnect) (*(ac->onConnect))((struct redisAsyncContext const *)ac,
                                          -1);
  while (1) {
    int tmp;
    tmp = __redisShiftCallback(& ac->replies,& cb);
    if (! (tmp == 0)) break;
    __redisRunCallback(ac,& cb,(redisReply *)0);
  }
  __redisAsyncDisconnect(ac);
  return_label: return;
}

static char const *nextArgument(char const *start, char const **str,
                                size_t *len)
{
  char const *__retres;
  long tmp;
  char const *p = start;
  if ((int)*(p + 0) != '$') {
    p = (char const *)strchr(p,'$');
    if (p == (char const *)0) {
      __retres = (char const *)0;
      goto return_label;
    }
  }
  tmp = strtol(p + 1,(char **)0,10);
  *len = (size_t)((int)tmp);
  p = (char const *)strchr(p,'\r');
  __FC_assert(p != (char const *)0,"async.c",627,"p");
  *str = p + 2;
  __retres = ((p + 2) + *len) + 2;
  return_label: return __retres;
}

static int __redisAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn,
                               void *privdata, char const *cmd, size_t len)
{
  int __retres;
  redisCallback cb;
  struct dict *cbdict;
  dictEntry *de;
  redisCallback *existcb;
  int pvariant;
  int hasnext;
  char const *cstr;
  char const *astr;
  size_t clen;
  size_t alen;
  char const *p;
  sds sname;
  int ret;
  int tmp;
  redisContext *c = & ac->c;
  if (c->flags & (0x4 | 0x8)) {
    __retres = -1;
    goto return_label;
  }
  cb.fn = fn;
  cb.privdata = privdata;
  cb.pending_subs = 1;
  p = nextArgument(cmd,& cstr,& clen);
  __FC_assert((p != (char const *)0) != 0,"async.c",658,"p != NULL");
  hasnext = (int)*(p + 0) == '$';
  tmp = tolower((int)*(cstr + 0));
  if (tmp == 'p') pvariant = 1; else pvariant = 0;
  cstr += pvariant;
  clen -= (size_t)pvariant;
  if (hasnext) {
    int tmp_2;
    tmp_2 = strncasecmp(cstr,"subscribe\r\n",(size_t)11);
    if (tmp_2 == 0) {
      c->flags |= 0x20;
      while (1) {
        p = nextArgument(p,& astr,& alen);
        if (! (p != (char const *)0)) break;
        sname = sdsnewlen((void const *)astr,alen);
        if (pvariant) cbdict = ac->sub.patterns;
        else cbdict = ac->sub.channels;
        de = dictFind(cbdict,(void const *)sname);
        if (de != (dictEntry *)0) {
          existcb = (redisCallback *)de->val;
          cb.pending_subs = existcb->pending_subs + 1;
        }
        ret = dictReplace(cbdict,(void *)sname,(void *)(& cb));
        if (ret == 0) sdsfree(sname);
      }
    }
    else goto _LAND;
  }
  else {
    int tmp_1;
    _LAND: tmp_1 = strncasecmp(cstr,"unsubscribe\r\n",(size_t)13);
    if (tmp_1 == 0) {
      if (! (c->flags & 0x20)) {
        __retres = -1;
        goto return_label;
      }
    }
    else {
      int tmp_0;
      tmp_0 = strncasecmp(cstr,"monitor\r\n",(size_t)9);
      if (tmp_0 == 0) {
        c->flags |= 0x40;
        __redisPushCallback(& ac->replies,& cb);
      }
      else 
        if (c->flags & 0x20) __redisPushCallback(& ac->sub.invalid,& cb);
        else __redisPushCallback(& ac->replies,& cb);
    }
  }
  __redisAppendCommand(c,cmd,len);
  refreshTimeout(ac);
  if (ac->ev.addWrite) (*(ac->ev.addWrite))(ac->ev.data);
  __retres = 0;
  return_label: return __retres;
}

int redisvAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn,
                       void *privdata, char const *format, va_list ap)
{
  int __retres;
  char *cmd;
  int len;
  int status;
  len = redisvFormatCommand(& cmd,format,ap);
  if (len < 0) {
    __retres = -1;
    goto return_label;
  }
  status = __redisAsyncCommand(ac,fn,privdata,(char const *)cmd,(size_t)len);
  free((void *)cmd);
  __retres = status;
  return_label: return __retres;
}

int redisAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn,
                      void *privdata, char const *format,
                      void * const *__va_params)
{
  va_list ap;
  int status;
  ap = __va_params;
  status = redisvAsyncCommand(ac,fn,privdata,format,ap);
  return status;
}

int redisAsyncCommandArgv(redisAsyncContext *ac, redisCallbackFn *fn,
                          void *privdata, int argc, char const **argv,
                          size_t const *argvlen)
{
  int __retres;
  sds cmd;
  int len;
  int status;
  len = redisFormatSdsCommandArgv(& cmd,argc,argv,argvlen);
  if (len < 0) {
    __retres = -1;
    goto return_label;
  }
  status = __redisAsyncCommand(ac,fn,privdata,(char const *)cmd,(size_t)len);
  sdsfree(cmd);
  __retres = status;
  return_label: return __retres;
}

int redisAsyncFormattedCommand(redisAsyncContext *ac, redisCallbackFn *fn,
                               void *privdata, char const *cmd, size_t len)
{
  int status = __redisAsyncCommand(ac,fn,privdata,cmd,len);
  return status;
}

void redisAsyncSetTimeout(redisAsyncContext *ac, struct timeval tv)
{
  if (! ac->c.timeout) ac->c.timeout = (struct timeval *)hi_calloc((size_t)1,
                                                                   sizeof(tv));
  if (tv.tv_sec == (ac->c.timeout)->tv_sec) 
    if (tv.tv_usec == (ac->c.timeout)->tv_usec) goto return_label;
  *(ac->c.timeout) = tv;
  return_label: return;
}

static unsigned int dictGenHashFunction_0(unsigned char const *buf, int len);

static dict *dictCreate_0(dictType *type, void *privDataPtr);

static int dictExpand_0(dict *ht, unsigned long size);

static int dictAdd_0(dict *ht, void *key, void *val);

static int dictReplace_0(dict *ht, void *key, void *val);

static int dictDelete_0(dict *ht, void const *key);

static void dictRelease_0(dict *ht);

static dictEntry *dictFind_0(dict *ht, void const *key);

static dictIterator *dictGetIterator_0(dict *ht);

static dictEntry *dictNext_0(dictIterator *iter);

static void dictReleaseIterator_0(dictIterator *iter);

static int _dictExpandIfNeeded_0(dict *ht);

static unsigned long _dictNextPower_0(unsigned long size);

static int _dictKeyIndex_0(dict *ht, void const *key);

static int _dictInit_0(dict *ht, dictType *type, void *privDataPtr);

static unsigned int dictGenHashFunction_0(unsigned char const *buf, int len)
{
  unsigned int hash = (unsigned int)5381;
  while (1) {
    int tmp_0;
    unsigned char const *tmp;
    tmp_0 = len;
    len --;
    ;
    if (! tmp_0) break;
    tmp = buf;
    buf ++;
    hash = ((hash << 5) + hash) + (unsigned int)*tmp;
  }
  return hash;
}

static void _dictReset_0(dict *ht)
{
  ht->table = (dictEntry **)0;
  ht->size = (unsigned long)0;
  ht->sizemask = (unsigned long)0;
  ht->used = (unsigned long)0;
  return;
}

static dict *dictCreate_0(dictType *type, void *privDataPtr)
{
  dict *tmp_0;
  dict *ht = hi_malloc(sizeof(*tmp_0));
  _dictInit_0(ht,type,privDataPtr);
  return ht;
}

static int _dictInit_0(dict *ht, dictType *type, void *privDataPtr)
{
  int __retres;
  _dictReset_0(ht);
  ht->type = type;
  ht->privdata = privDataPtr;
  __retres = 0;
  return __retres;
}

static int dictExpand_0(dict *ht, unsigned long size)
{
  int __retres;
  dict n;
  unsigned long i;
  unsigned long realsize = _dictNextPower_0(size);
  if (ht->used > size) {
    __retres = 1;
    goto return_label;
  }
  _dictInit_0(& n,ht->type,ht->privdata);
  n.size = realsize;
  n.sizemask = realsize - (unsigned long)1;
  n.table = (dictEntry **)calloc((size_t)realsize,sizeof(dictEntry *));
  n.used = ht->used;
  i = (unsigned long)0;
  while (1) {
    if (i < ht->size) {
      if (! (ht->used > (unsigned long)0)) break;
    }
    else break;
    {
      dictEntry *he;
      dictEntry *nextHe;
      if (*(ht->table + i) == (dictEntry *)0) goto __Cont;
      he = *(ht->table + i);
      while (he) {
        unsigned int h;
        unsigned int tmp_0;
        nextHe = he->next;
        tmp_0 = (*((ht->type)->hashFunction))((void const *)he->key);
        h = (unsigned int)((unsigned long)tmp_0 & n.sizemask);
        he->next = *(n.table + h);
        *(n.table + h) = he;
        (ht->used) --;
        he = nextHe;
      }
    }
    __Cont: i ++;
  }
  __FC_assert((ht->used == (unsigned long)0) != 0,"dict.c",127,
              "ht->used == 0");
  free((void *)ht->table);
  *ht = n;
  __retres = 0;
  return_label: return __retres;
}

static int dictAdd_0(dict *ht, void *key, void *val)
{
  int __retres;
  int index_0;
  dictEntry *entry;
  index_0 = _dictKeyIndex_0(ht,(void const *)key);
  if (index_0 == -1) {
    __retres = 1;
    goto return_label;
  }
  entry = (dictEntry *)hi_malloc(sizeof(*entry));
  entry->next = *(ht->table + index_0);
  *(ht->table + index_0) = entry;
  if ((ht->type)->keyDup) entry->key = (*((ht->type)->keyDup))(ht->privdata,
                                                               (void const *)key);
  else entry->key = key;
  if ((ht->type)->valDup) entry->val = (*((ht->type)->valDup))(ht->privdata,
                                                               (void const *)val);
  else entry->val = val;
  (ht->used) ++;
  __retres = 0;
  return_label: return __retres;
}

static int dictReplace_0(dict *ht, void *key, void *val)
{
  int __retres;
  dictEntry *entry;
  dictEntry auxentry;
  int tmp;
  tmp = dictAdd_0(ht,key,val);
  if (tmp == 0) {
    __retres = 1;
    goto return_label;
  }
  entry = dictFind_0(ht,(void const *)key);
  auxentry = *entry;
  if ((ht->type)->valDup) entry->val = (*((ht->type)->valDup))(ht->privdata,
                                                               (void const *)val);
  else entry->val = val;
  if ((ht->type)->valDestructor) (*((ht->type)->valDestructor))(ht->privdata,
                                                                auxentry.val);
  __retres = 0;
  return_label: return __retres;
}

static int dictDelete_0(dict *ht, void const *key)
{
  int __retres;
  unsigned int h;
  dictEntry *de;
  dictEntry *prevde;
  unsigned int tmp;
  if (ht->size == (unsigned long)0) {
    __retres = 1;
    goto return_label;
  }
  tmp = (*((ht->type)->hashFunction))(key);
  h = (unsigned int)((unsigned long)tmp & ht->sizemask);
  de = *(ht->table + h);
  prevde = (dictEntry *)0;
  while (de) {
    int tmp_1;
    if ((ht->type)->keyCompare) tmp_1 = (*((ht->type)->keyCompare))(ht->privdata,
                                                                    key,
                                                                    (void const *)de->key);
    else tmp_1 = (void *)key == de->key;
    if (tmp_1) {
      if (prevde) prevde->next = de->next; else *(ht->table + h) = de->next;
      if ((ht->type)->keyDestructor) (*((ht->type)->keyDestructor))(ht->privdata,
                                                                    de->key);
      if ((ht->type)->valDestructor) (*((ht->type)->valDestructor))(ht->privdata,
                                                                    de->val);
      free((void *)de);
      (ht->used) --;
      __retres = 0;
      goto return_label;
    }
    prevde = de;
    de = de->next;
  }
  __retres = 1;
  return_label: return __retres;
}

static int _dictClear_0(dict *ht)
{
  int __retres;
  unsigned long i;
  i = (unsigned long)0;
  while (1) {
    if (i < ht->size) {
      if (! (ht->used > (unsigned long)0)) break;
    }
    else break;
    {
      dictEntry *he;
      dictEntry *nextHe;
      he = *(ht->table + i);
      if (he == (dictEntry *)0) goto __Cont;
      while (he) {
        nextHe = he->next;
        if ((ht->type)->keyDestructor) (*((ht->type)->keyDestructor))
                                       (ht->privdata,he->key);
        if ((ht->type)->valDestructor) (*((ht->type)->valDestructor))
                                       (ht->privdata,he->val);
        free((void *)he);
        (ht->used) --;
        he = nextHe;
      }
    }
    __Cont: i ++;
  }
  free((void *)ht->table);
  _dictReset_0(ht);
  __retres = 0;
  return __retres;
}

static void dictRelease_0(dict *ht)
{
  _dictClear_0(ht);
  free((void *)ht);
  return;
}

static dictEntry *dictFind_0(dict *ht, void const *key)
{
  dictEntry *__retres;
  dictEntry *he;
  unsigned int h;
  unsigned int tmp;
  if (ht->size == (unsigned long)0) {
    __retres = (dictEntry *)0;
    goto return_label;
  }
  tmp = (*((ht->type)->hashFunction))(key);
  h = (unsigned int)((unsigned long)tmp & ht->sizemask);
  he = *(ht->table + h);
  while (he) {
    int tmp_1;
    if ((ht->type)->keyCompare) tmp_1 = (*((ht->type)->keyCompare))(ht->privdata,
                                                                    key,
                                                                    (void const *)he->key);
    else tmp_1 = (void *)key == he->key;
    if (tmp_1) {
      __retres = he;
      goto return_label;
    }
    he = he->next;
  }
  __retres = (dictEntry *)0;
  return_label: return __retres;
}

static dictIterator *dictGetIterator_0(dict *ht)
{
  dictIterator *tmp_0;
  dictIterator *iter = hi_malloc(sizeof(*tmp_0));
  iter->ht = ht;
  iter->index = -1;
  iter->entry = (dictEntry *)0;
  iter->nextEntry = (dictEntry *)0;
  return iter;
}

static dictEntry *dictNext_0(dictIterator *iter)
{
  dictEntry *__retres;
  while (1) {
    if (iter->entry == (dictEntry *)0) {
      (iter->index) ++;
      if (iter->index >= (int)(iter->ht)->size) break;
      iter->entry = *((iter->ht)->table + iter->index);
    }
    else iter->entry = iter->nextEntry;
    if (iter->entry) {
      iter->nextEntry = (iter->entry)->next;
      __retres = iter->entry;
      goto return_label;
    }
  }
  __retres = (dictEntry *)0;
  return_label: return __retres;
}

static void dictReleaseIterator_0(dictIterator *iter)
{
  free((void *)iter);
  return;
}

static int _dictExpandIfNeeded_0(dict *ht)
{
  int __retres;
  if (ht->size == (unsigned long)0) {
    int tmp;
    tmp = dictExpand_0(ht,(unsigned long)4);
    __retres = tmp;
    goto return_label;
  }
  if (ht->used == ht->size) {
    int tmp_0;
    tmp_0 = dictExpand_0(ht,ht->size * (unsigned long)2);
    __retres = tmp_0;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static unsigned long _dictNextPower_0(unsigned long size)
{
  unsigned long __retres;
  unsigned long i = (unsigned long)4;
  if (size >= (unsigned long)2147483647L) {
    __retres = (unsigned long)2147483647L;
    goto return_label;
  }
  while (1) {
    if (i >= size) {
      __retres = i;
      goto return_label;
    }
    i *= (unsigned long)2;
  }
  return_label: return __retres;
}

static int _dictKeyIndex_0(dict *ht, void const *key)
{
  int __retres;
  unsigned int h;
  dictEntry *he;
  int tmp;
  unsigned int tmp_0;
  tmp = _dictExpandIfNeeded_0(ht);
  if (tmp == 1) {
    __retres = -1;
    goto return_label;
  }
  tmp_0 = (*((ht->type)->hashFunction))(key);
  h = (unsigned int)((unsigned long)tmp_0 & ht->sizemask);
  he = *(ht->table + h);
  while (he) {
    int tmp_2;
    if ((ht->type)->keyCompare) tmp_2 = (*((ht->type)->keyCompare))(ht->privdata,
                                                                    key,
                                                                    (void const *)he->key);
    else tmp_2 = (void *)key == he->key;
    if (tmp_2) {
      __retres = -1;
      goto return_label;
    }
    he = he->next;
  }
  __retres = (int)h;
  return_label: return __retres;
}

__inline static size_t sdslen_0(sds const s)
{
  size_t __retres;
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0: ;
    __retres = (size_t)((int)flags >> 3);
    goto return_label;
    case 1: ;
    __retres = (size_t)((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->len;
    goto return_label;
    case 2: ;
    __retres = (size_t)((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->len;
    goto return_label;
    case 3: ;
    __retres = ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->len;
    goto return_label;
    case 4: ;
    __retres = (size_t)((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->len;
    goto return_label;
  }
  __retres = (size_t)0;
  return_label: return __retres;
}

__inline static size_t sdsavail_0(sds const s)
{
  size_t __retres;
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0: {
              __retres = (size_t)0;
              goto return_label;
            }
    case 1:
    {
      struct sdshdr8 *sh = (struct sdshdr8 *)(s - sizeof(struct sdshdr8));
      __retres = (size_t)((int)sh->alloc - (int)sh->len);
      goto return_label;
    }
    case 2:
    {
      struct sdshdr16 *sh_0 =
        (struct sdshdr16 *)(s - sizeof(struct sdshdr16));
      __retres = (size_t)((int)sh_0->alloc - (int)sh_0->len);
      goto return_label;
    }
    case 3:
    {
      struct sdshdr32 *sh_1 =
        (struct sdshdr32 *)(s - sizeof(struct sdshdr32));
      __retres = sh_1->alloc - sh_1->len;
      goto return_label;
    }
    case 4:
    {
      struct sdshdr64 *sh_2 =
        (struct sdshdr64 *)(s - sizeof(struct sdshdr64));
      __retres = (size_t)(sh_2->alloc - sh_2->len);
      goto return_label;
    }
  }
  __retres = (size_t)0;
  return_label: return __retres;
}

__inline static void sdssetlen_0(sds s, size_t newlen)
{
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0:
    {
      unsigned char *fp = (unsigned char *)s - 1;
      *fp = (unsigned char)((unsigned int)0 | (newlen << 3));
    }
    break;
    case 1:
    ((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->len = (uint8_t)newlen;
    break;
    case 2:
    ((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->len = (uint16_t)newlen;
    break;
    case 3: ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->len = newlen;
    break;
    case 4:
    ((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->len = (uint64_t)newlen;
    break;
  }
  return;
}

__inline static void sdsinclen_0(sds s, size_t inc)
{
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0:
    {
      unsigned char *fp = (unsigned char *)s - 1;
      unsigned char newlen =
        (unsigned char)(((int)flags >> 3) + (int)((unsigned char)inc));
      *fp = (unsigned char)(0 | ((int)newlen << 3));
    }
    break;
    case 1:
    ((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->len = (uint8_t)(
    (int)((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->len + (int)((uint8_t)inc));
    break;
    case 2:
    ((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->len = (uint16_t)(
    (int)((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->len + (int)((uint16_t)inc));
    break;
    case 3: ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->len += inc;
    break;
    case 4:
    ((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->len += (uint64_t)inc;
    break;
  }
  return;
}

__inline static size_t sdsalloc_0(sds const s)
{
  size_t __retres;
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0: ;
    __retres = (size_t)((int)flags >> 3);
    goto return_label;
    case 1: ;
    __retres = (size_t)((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->alloc;
    goto return_label;
    case 2: ;
    __retres = (size_t)((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->alloc;
    goto return_label;
    case 3: ;
    __retres = ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->alloc;
    goto return_label;
    case 4: ;
    __retres = (size_t)((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->alloc;
    goto return_label;
  }
  __retres = (size_t)0;
  return_label: return __retres;
}

__inline static void sdssetalloc_0(sds s, size_t newlen)
{
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0: break;
    case 1:
    ((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->alloc = (uint8_t)newlen;
    break;
    case 2:
    ((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->alloc = (uint16_t)newlen;
    break;
    case 3:
    ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->alloc = newlen;
    break;
    case 4:
    ((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->alloc = (uint64_t)newlen;
    break;
  }
  return;
}

static redisContextFuncs redisContextDefaultFuncs =
  {.free_privdata = (void (*)(void *))0,
   .async_read = & redisAsyncRead,
   .async_write = & redisAsyncWrite,
   .read = & redisNetRead,
   .write = & redisNetWrite};
static redisReply *createReplyObject(int type);

static void *createStringObject(redisReadTask const *task, char *str,
                                size_t len);

static void *createArrayObject(redisReadTask const *task, size_t elements);

static void *createIntegerObject(redisReadTask const *task, long long value);

static void *createDoubleObject(redisReadTask const *task, double value,
                                char *str, size_t len);

static void *createNilObject(redisReadTask const *task);

static void *createBoolObject(redisReadTask const *task, int bval);

static redisReplyObjectFunctions defaultFunctions =
  {.createString = & createStringObject,
   .createArray = & createArrayObject,
   .createInteger = & createIntegerObject,
   .createDouble = & createDoubleObject,
   .createNil = & createNilObject,
   .createBool = & createBoolObject,
   .freeObject = & freeReplyObject};
static redisReply *createReplyObject(int type)
{
  redisReply *__retres;
  redisReply *tmp_0;
  redisReply *r = calloc((size_t)1,sizeof(*tmp_0));
  if (r == (redisReply *)0) {
    __retres = (redisReply *)0;
    goto return_label;
  }
  r->type = type;
  __retres = r;
  return_label: return __retres;
}

void freeReplyObject(void *reply)
{
  size_t j;
  redisReply *r = (redisReply *)reply;
  if (r == (redisReply *)0) goto return_label;
  switch (r->type) {
    case 3: break;
    case 2: case 9: case 10: ;
    if (r->element != (struct redisReply **)0) ;
    break;
    case 6: case 5: case 1: case 7: free((void *)r->str);
    break;
  }
  free((void *)r);
  return_label: return;
}

static void *createStringObject(redisReadTask const *task, char *str,
                                size_t len)
{
  void *__retres;
  redisReply *r;
  redisReply *parent;
  char *buf;
  int tmp;
  r = createReplyObject(task->type);
  if (r == (redisReply *)0) {
    __retres = (void *)0;
    goto return_label;
  }
  buf = (char *)malloc(len + (size_t)1);
  if (buf == (char *)0) {
    freeReplyObject((void *)r);
    __retres = (void *)0;
    goto return_label;
  }
  if (task->type == 6) tmp = 1;
  else 
    if (task->type == 5) tmp = 1;
    else 
      if (task->type == 1) tmp = 1; else tmp = 0;
  __FC_assert(tmp != 0,"hiredis.c",133,
              "task->type == REDIS_REPLY_ERROR || task->type == REDIS_REPLY_STATUS || task->type == REDIS_REPLY_STRING");
  memcpy((void *)buf,(void const *)str,len);
  *(buf + len) = (char)'\000';
  r->str = buf;
  r->len = len;
  if (task->parent) {
    int tmp_0;
    parent = (redisReply *)(task->parent)->obj;
    if (parent->type == 2) tmp_0 = 1;
    else 
      if (parent->type == 9) tmp_0 = 1;
      else 
        if (parent->type == 10) tmp_0 = 1; else tmp_0 = 0;
    __FC_assert(tmp_0 != 0,"hiredis.c",145,
                "parent->type == REDIS_REPLY_ARRAY || parent->type == REDIS_REPLY_MAP || parent->type == REDIS_REPLY_SET");
    *(parent->element + task->idx) = r;
  }
  __retres = (void *)r;
  return_label: return __retres;
}

static void *createArrayObject(redisReadTask const *task, size_t elements)
{
  void *__retres;
  redisReply *r;
  redisReply *parent;
  r = createReplyObject(task->type);
  if (r == (redisReply *)0) {
    __retres = (void *)0;
    goto return_label;
  }
  if (elements > (size_t)0) {
    r->element = (struct redisReply **)calloc(elements,sizeof(redisReply *));
    if (r->element == (struct redisReply **)0) {
      freeReplyObject((void *)r);
      __retres = (void *)0;
      goto return_label;
    }
  }
  r->elements = elements;
  if (task->parent) {
    int tmp;
    parent = (redisReply *)(task->parent)->obj;
    if (parent->type == 2) tmp = 1;
    else 
      if (parent->type == 9) tmp = 1;
      else 
        if (parent->type == 10) tmp = 1; else tmp = 0;
    __FC_assert(tmp != 0,"hiredis.c",172,
                "parent->type == REDIS_REPLY_ARRAY || parent->type == REDIS_REPLY_MAP || parent->type == REDIS_REPLY_SET");
    *(parent->element + task->idx) = r;
  }
  __retres = (void *)r;
  return_label: return __retres;
}

static void *createIntegerObject(redisReadTask const *task, long long value)
{
  void *__retres;
  redisReply *r;
  redisReply *parent;
  r = createReplyObject(3);
  if (r == (redisReply *)0) {
    __retres = (void *)0;
    goto return_label;
  }
  r->integer = value;
  if (task->parent) {
    int tmp;
    parent = (redisReply *)(task->parent)->obj;
    if (parent->type == 2) tmp = 1;
    else 
      if (parent->type == 9) tmp = 1;
      else 
        if (parent->type == 10) tmp = 1; else tmp = 0;
    __FC_assert(tmp != 0,"hiredis.c",191,
                "parent->type == REDIS_REPLY_ARRAY || parent->type == REDIS_REPLY_MAP || parent->type == REDIS_REPLY_SET");
    *(parent->element + task->idx) = r;
  }
  __retres = (void *)r;
  return_label: return __retres;
}

static void *createDoubleObject(redisReadTask const *task, double value,
                                char *str, size_t len)
{
  void *__retres;
  redisReply *r;
  redisReply *parent;
  r = createReplyObject(7);
  if (r == (redisReply *)0) {
    __retres = (void *)0;
    goto return_label;
  }
  r->dval = value;
  r->str = (char *)malloc(len + (size_t)1);
  if (r->str == (char *)0) {
    freeReplyObject((void *)r);
    __retres = (void *)0;
    goto return_label;
  }
  memcpy((void *)r->str,(void const *)str,len);
  *(r->str + len) = (char)'\000';
  if (task->parent) {
    int tmp;
    parent = (redisReply *)(task->parent)->obj;
    if (parent->type == 2) tmp = 1;
    else 
      if (parent->type == 9) tmp = 1;
      else 
        if (parent->type == 10) tmp = 1; else tmp = 0;
    __FC_assert(tmp != 0,"hiredis.c",223,
                "parent->type == REDIS_REPLY_ARRAY || parent->type == REDIS_REPLY_MAP || parent->type == REDIS_REPLY_SET");
    *(parent->element + task->idx) = r;
  }
  __retres = (void *)r;
  return_label: return __retres;
}

static void *createNilObject(redisReadTask const *task)
{
  void *__retres;
  redisReply *r;
  redisReply *parent;
  r = createReplyObject(4);
  if (r == (redisReply *)0) {
    __retres = (void *)0;
    goto return_label;
  }
  if (task->parent) {
    int tmp;
    parent = (redisReply *)(task->parent)->obj;
    if (parent->type == 2) tmp = 1;
    else 
      if (parent->type == 9) tmp = 1;
      else 
        if (parent->type == 10) tmp = 1; else tmp = 0;
    __FC_assert(tmp != 0,"hiredis.c",240,
                "parent->type == REDIS_REPLY_ARRAY || parent->type == REDIS_REPLY_MAP || parent->type == REDIS_REPLY_SET");
    *(parent->element + task->idx) = r;
  }
  __retres = (void *)r;
  return_label: return __retres;
}

static void *createBoolObject(redisReadTask const *task, int bval)
{
  void *__retres;
  redisReply *r;
  redisReply *parent;
  r = createReplyObject(8);
  if (r == (redisReply *)0) {
    __retres = (void *)0;
    goto return_label;
  }
  r->integer = (long long)(bval != 0);
  if (task->parent) {
    int tmp;
    parent = (redisReply *)(task->parent)->obj;
    if (parent->type == 2) tmp = 1;
    else 
      if (parent->type == 9) tmp = 1;
      else 
        if (parent->type == 10) tmp = 1; else tmp = 0;
    __FC_assert(tmp != 0,"hiredis.c",259,
                "parent->type == REDIS_REPLY_ARRAY || parent->type == REDIS_REPLY_MAP || parent->type == REDIS_REPLY_SET");
    *(parent->element + task->idx) = r;
  }
  __retres = (void *)r;
  return_label: return __retres;
}

static uint32_t countDigits(uint64_t v)
{
  uint32_t __retres;
  uint32_t result = (uint32_t)1;
  while (1) {
    if (v < (uint64_t)10) {
      __retres = result;
      goto return_label;
    }
    if (v < (uint64_t)100) {
      __retres = result + (uint32_t)1;
      goto return_label;
    }
    if (v < (uint64_t)1000) {
      __retres = result + (uint32_t)2;
      goto return_label;
    }
    if (v < (uint64_t)10000) {
      __retres = result + (uint32_t)3;
      goto return_label;
    }
    v /= (uint64_t)10000U;
    result += (uint32_t)4;
  }
  return_label: return __retres;
}

static size_t bulklen(size_t len)
{
  size_t __retres;
  uint32_t tmp;
  tmp = countDigits((uint64_t)len);
  ;
  __retres = ((((uint32_t)1 + tmp) + (uint32_t)2) + len) + (uint32_t)2;
  return __retres;
}

static char const redisvFormatCommand_intfmts[7] =
  {(char)'d',
   (char)'i',
   (char)'o',
   (char)'u',
   (char)'x',
   (char)'X',
   (char)'\000'};
static char const redisvFormatCommand_flags[6] =
  {(char)'#', (char)'0', (char)'-', (char)'+', (char)' ', (char)'\000'};
/*@ requires valid_read_string(format);
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: *(format + (0 ..))), (indirect: param0);
    assigns *(s + (0 ..)) \from (indirect: *(format + (0 ..))), param0;
 */
int sprintf_va_1(char * restrict s, char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: *(format + (0 ..))), (indirect: param0);
    assigns *(s + (0 ..)) \from (indirect: *(format + (0 ..))), param0;
 */
int sprintf_va_2(char * restrict s, char const * restrict format,
                 size_t param0);

int redisvFormatCommand(char **target, char const *format, va_list ap)
{
  int __retres;
  int pos;
  sds curarg;
  sds newarg;
  int j;
  uint32_t tmp_20;
  char const *c = format;
  char *cmd = (char *)0;
  int touched = 0;
  char **curargv = (char **)0;
  char **newargv = (char **)0;
  int argc = 0;
  int totlen = 0;
  int error_type = 0;
  if (target == (char **)0) {
    __retres = -1;
    goto return_label;
  }
  curarg = sdsempty();
  if (curarg == (sds)0) {
    __retres = -1;
    goto return_label;
  }
  while ((int)*c != '\000') {
    if ((int)*c != '%') goto _LOR;
    else 
      if ((int)*(c + 1) == '\000') 
        _LOR:
        if ((int)*c == ' ') {
          if (touched) {
            int tmp;
            size_t tmp_1;
            size_t tmp_0;
            newargv = (char **)realloc((void *)curargv,
                                       sizeof(char *) * (unsigned int)(
                                       argc + 1));
            if (newargv == (char **)0) goto memory_err;
            curargv = newargv;
            tmp = argc;
            argc ++;
            *(curargv + tmp) = curarg;
            tmp_0 = sdslen_0(curarg);
            tmp_1 = bulklen(tmp_0);
            totlen = (int)((size_t)totlen + tmp_1);
            curarg = sdsempty();
            if (curarg == (sds)0) goto memory_err;
            touched = 0;
          }
        }
        else {
          newarg = sdscatlen(curarg,(void const *)c,(size_t)1);
          if (newarg == (sds)0) goto memory_err;
          curarg = newarg;
          touched = 1;
        }
      else {
        char *arg;
        size_t size;
        newarg = curarg;
        switch ((int)*(c + 1)) {
          case 's': {
                      arg = *((char **)*ap);
                      ap ++;
                    }
          size = strlen((char const *)arg);
          if (size > (size_t)0) newarg = sdscatlen(curarg,(void const *)arg,
                                                   size);
          break;
          case 'b': {
                      arg = *((char **)*ap);
                      ap ++;
                    }
          size = *((size_t *)*ap);
          ap ++;
          if (size > (size_t)0) newarg = sdscatlen(curarg,(void const *)arg,
                                                   size);
          break;
          case '%': newarg = sdscat(curarg,"%");
          break;
          default:
          {
            char _format[16];
            va_list _cpy;
            char *tmp_6;
            char *tmp_8;
            char const *_p = c + 1;
            size_t _l = (size_t)0;
            while (1) {
              if ((int)*_p != '\000') {
                char *tmp_2;
                tmp_2 = strchr(redisvFormatCommand_flags,(int)*_p);
                if (! (tmp_2 != (char *)0)) break;
              }
              else break;
              _p ++;
            }
            while (1) {
              if ((int)*_p != '\000') {
                int tmp_3;
                tmp_3 = isdigit((int)*_p);
                if (! tmp_3) break;
              }
              else break;
              _p ++;
            }
            if ((int)*_p == '.') {
              _p ++;
              while (1) {
                if ((int)*_p != '\000') {
                  int tmp_4;
                  tmp_4 = isdigit((int)*_p);
                  if (! tmp_4) break;
                }
                else break;
                _p ++;
              }
            }
            _cpy = ap;
            tmp_6 = strchr(redisvFormatCommand_intfmts,(int)*_p);
            if (tmp_6 != (char *)0) {
              int tmp_5;
              tmp_5 = *((int *)*ap);
              ap ++;
              goto fmt_valid;
            }
            tmp_8 = strchr("eEfFgGaA",(int)*_p);
            if (tmp_8 != (char *)0) {
              double tmp_7;
              tmp_7 = *((double *)*ap);
              ap ++;
              goto fmt_valid;
            }
            if ((int)*(_p + 0) == 'h') 
              if ((int)*(_p + 1) == 'h') {
                _p += 2;
                if ((int)*_p != '\000') {
                  char *tmp_10;
                  tmp_10 = strchr(redisvFormatCommand_intfmts,(int)*_p);
                  if (tmp_10 != (char *)0) {
                    int tmp_9;
                    tmp_9 = *((int *)*ap);
                    ap ++;
                    goto fmt_valid;
                  }
                }
                goto fmt_invalid;
              }
            if ((int)*(_p + 0) == 'h') {
              _p ++;
              if ((int)*_p != '\000') {
                char *tmp_12;
                tmp_12 = strchr(redisvFormatCommand_intfmts,(int)*_p);
                if (tmp_12 != (char *)0) {
                  int tmp_11;
                  tmp_11 = *((int *)*ap);
                  ap ++;
                  goto fmt_valid;
                }
              }
              goto fmt_invalid;
            }
            if ((int)*(_p + 0) == 'l') 
              if ((int)*(_p + 1) == 'l') {
                _p += 2;
                if ((int)*_p != '\000') {
                  char *tmp_14;
                  tmp_14 = strchr(redisvFormatCommand_intfmts,(int)*_p);
                  if (tmp_14 != (char *)0) {
                    long long tmp_13;
                    tmp_13 = *((long long *)*ap);
                    ap ++;
                    goto fmt_valid;
                  }
                }
                goto fmt_invalid;
              }
            if ((int)*(_p + 0) == 'l') {
              _p ++;
              if ((int)*_p != '\000') {
                char *tmp_16;
                tmp_16 = strchr(redisvFormatCommand_intfmts,(int)*_p);
                if (tmp_16 != (char *)0) {
                  long tmp_15;
                  tmp_15 = *((long *)*ap);
                  ap ++;
                  goto fmt_valid;
                }
              }
              goto fmt_invalid;
            }
            fmt_invalid: ;
            goto format_err;
            fmt_valid: _l = (size_t)((_p + 1) - c);
            if (_l < sizeof(_format) - (unsigned int)2) {
              memcpy((void *)(_format),(void const *)c,_l);
              _format[_l] = (char)'\000';
              newarg = sdscatvprintf(curarg,(char const *)(_format),_cpy);
              c = _p - 1;
            }
            break;
          }
        }
        if (newarg == (sds)0) goto memory_err;
        curarg = newarg;
        touched = 1;
        c ++;
      }
    c ++;
  }
  if (touched) {
    int tmp_17;
    size_t tmp_19;
    size_t tmp_18;
    newargv = (char **)realloc((void *)curargv,
                               sizeof(char *) * (unsigned int)(argc + 1));
    if (newargv == (char **)0) goto memory_err;
    curargv = newargv;
    tmp_17 = argc;
    argc ++;
    *(curargv + tmp_17) = curarg;
    tmp_18 = sdslen_0(curarg);
    tmp_19 = bulklen(tmp_18);
    totlen = (int)((size_t)totlen + tmp_19);
  }
  else sdsfree(curarg);
  curarg = (sds)0;
  tmp_20 = countDigits((uint64_t)argc);
  totlen = (int)((uint32_t)totlen + (((uint32_t)1 + tmp_20) + (uint32_t)2));
  cmd = (char *)malloc((size_t)(totlen + 1));
  if (cmd == (char *)0) goto memory_err;
  pos = sprintf(cmd,"*%d\r\n",argc); /* sprintf_va_1 */
  j = 0;
  while (j < argc) {
    {
      int tmp_22;
      size_t tmp_21;
      size_t tmp_23;
      size_t tmp_24;
      int tmp_25;
      int tmp_26;
      tmp_21 = sdslen_0(*(curargv + j));
      ;
      tmp_22 = sprintf(cmd + pos,"$%zu\r\n",tmp_21); /* sprintf_va_2 */
      pos += tmp_22;
      tmp_23 = sdslen_0(*(curargv + j));
      ;
      ;
      memcpy((void *)(cmd + pos),(void const *)*(curargv + j),tmp_23);
      tmp_24 = sdslen_0(*(curargv + j));
      pos = (int)((size_t)pos + tmp_24);
      sdsfree(*(curargv + j));
      tmp_25 = pos;
      pos ++;
      *(cmd + tmp_25) = (char)'\r';
      tmp_26 = pos;
      pos ++;
      *(cmd + tmp_26) = (char)'\n';
    }
    j ++;
  }
  __FC_assert((pos == totlen) != 0,"hiredis.c",488,"pos == totlen");
  *(cmd + pos) = (char)'\000';
  free((void *)curargv);
  *target = cmd;
  __retres = totlen;
  goto return_label;
  format_err: error_type = -2;
  goto cleanup;
  memory_err: error_type = -1;
  goto cleanup;
  cleanup: ;
  if (curargv) {
    while (1) {
      int tmp_27;
      tmp_27 = argc;
      argc --;
      ;
      if (! tmp_27) break;
      sdsfree(*(curargv + argc));
    }
    free((void *)curargv);
  }
  sdsfree(curarg);
  free((void *)cmd);
  __retres = error_type;
  return_label: return __retres;
}

int redisFormatCommand(char **target, char const *format,
                       void * const *__va_params)
{
  va_list ap;
  int len;
  ap = __va_params;
  len = redisvFormatCommand(target,format,ap);
  if (len < 0) len = -1;
  return len;
}

int redisFormatSdsCommandArgv(sds *target, int argc, char const **argv,
                              size_t const *argvlen)
{
  int __retres;
  sds cmd;
  unsigned long long totlen;
  int j;
  size_t len;
  uint32_t tmp;
  size_t tmp_3;
  if (target == (sds *)0) {
    __retres = -1;
    goto return_label;
  }
  tmp = countDigits((uint64_t)argc);
  totlen = (unsigned long long)(((uint32_t)1 + tmp) + (uint32_t)2);
  j = 0;
  while (j < argc) {
    {
      size_t tmp_1;
      if (argvlen) len = *(argvlen + j); else len = strlen(*(argv + j));
      tmp_1 = bulklen(len);
      totlen += (unsigned long long)tmp_1;
    }
    j ++;
  }
  cmd = sdsempty();
  if (cmd == (sds)0) {
    __retres = -1;
    goto return_label;
  }
  cmd = sdsMakeRoomFor(cmd,(size_t)totlen);
  if (cmd == (sds)0) {
    __retres = -1;
    goto return_label;
  }
  {
    int __va_arg0 = argc;
    void *__va_args[1] = {& __va_arg0};
    cmd = sdscatfmt(cmd,"*%i\r\n",(void * const *)(__va_args));
  }
  j = 0;
  while (j < argc) {
    if (argvlen) len = *(argvlen + j); else len = strlen(*(argv + j));
    {
      size_t __va_arg0_17 = len;
      void *__va_args_19[1] = {& __va_arg0_17};
      cmd = sdscatfmt(cmd,"$%u\r\n",(void * const *)(__va_args_19));
    }
    cmd = sdscatlen(cmd,(void const *)*(argv + j),len);
    cmd = sdscatlen(cmd,(void const *)"\r\n",
                    sizeof("\r\n") - (unsigned int)1);
    j ++;
  }
  tmp_3 = sdslen_0(cmd);
  ;
  __FC_assert(((unsigned long long)tmp_3 == totlen) != 0,"hiredis.c",587,
              "sdslen(cmd)==totlen");
  *target = cmd;
  __retres = (int)totlen;
  return_label: return __retres;
}

void redisFreeSdsCommand(sds cmd)
{
  sdsfree(cmd);
  return;
}

/*@ requires valid_read_string(format);
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: *(format + (0 ..))), (indirect: param0);
    assigns *(s + (0 ..)) \from (indirect: *(format + (0 ..))), param0;
 */
int sprintf_va_3(char * restrict s, char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: *(format + (0 ..))), (indirect: param0);
    assigns *(s + (0 ..)) \from (indirect: *(format + (0 ..))), param0;
 */
int sprintf_va_4(char * restrict s, char const * restrict format,
                 size_t param0);

int redisFormatCommandArgv(char **target, int argc, char const **argv,
                           size_t const *argvlen)
{
  int __retres;
  int pos;
  size_t len;
  int totlen;
  int j;
  uint32_t tmp;
  char *cmd = (char *)0;
  if (target == (char **)0) {
    __retres = -1;
    goto return_label;
  }
  tmp = countDigits((uint64_t)argc);
  totlen = (int)(((uint32_t)1 + tmp) + (uint32_t)2);
  j = 0;
  while (j < argc) {
    {
      size_t tmp_1;
      if (argvlen) len = *(argvlen + j); else len = strlen(*(argv + j));
      tmp_1 = bulklen(len);
      totlen = (int)((size_t)totlen + tmp_1);
    }
    j ++;
  }
  cmd = (char *)malloc((size_t)(totlen + 1));
  if (cmd == (char *)0) {
    __retres = -1;
    goto return_label;
  }
  pos = sprintf(cmd,"*%d\r\n",argc); /* sprintf_va_3 */
  j = 0;
  while (j < argc) {
    {
      int tmp_3;
      int tmp_4;
      int tmp_5;
      if (argvlen) len = *(argvlen + j); else len = strlen(*(argv + j));
      tmp_3 = sprintf(cmd + pos,"$%zu\r\n",len); /* sprintf_va_4 */
      pos += tmp_3;
      memcpy((void *)(cmd + pos),(void const *)*(argv + j),len);
      pos = (int)((size_t)pos + len);
      tmp_4 = pos;
      pos ++;
      *(cmd + tmp_4) = (char)'\r';
      tmp_5 = pos;
      pos ++;
      *(cmd + tmp_5) = (char)'\n';
    }
    j ++;
  }
  __FC_assert((pos == totlen) != 0,"hiredis.c",633,"pos == totlen");
  *(cmd + pos) = (char)'\000';
  *target = cmd;
  __retres = totlen;
  return_label: return __retres;
}

void redisFreeCommand(char *cmd)
{
  free((void *)cmd);
  return;
}

void __redisSetError(redisContext *c, int type, char const *str)
{
  size_t len;
  c->err = type;
  if (str != (char const *)0) {
    len = strlen(str);
    if (len < sizeof(c->errstr) - (unsigned int)1) len = len;
    else len = sizeof(c->errstr) - (unsigned int)1;
    memcpy((void *)(c->errstr),(void const *)str,len);
    c->errstr[len] = (char)'\000';
  }
  else {
    __FC_assert((type == 1) != 0,"hiredis.c",655,"type == REDIS_ERR_IO");
    strerror_r(__fc_errno,c->errstr,sizeof(c->errstr));
  }
  return;
}

redisReader *redisReaderCreate(void)
{
  redisReader *tmp;
  tmp = redisReaderCreateWithFunctions(& defaultFunctions);
  return tmp;
}

static redisContext *redisContextInit(redisOptions const *options)
{
  redisContext *__retres;
  redisContext *c;
  c = (redisContext *)calloc((size_t)1,sizeof(*c));
  if (c == (redisContext *)0) {
    __retres = (redisContext *)0;
    goto return_label;
  }
  c->funcs = (redisContextFuncs const *)(& redisContextDefaultFuncs);
  c->obuf = sdsempty();
  c->reader = redisReaderCreate();
  c->fd = -1;
  if (c->obuf == (char *)0) goto _LOR;
  else 
    if (c->reader == (redisReader *)0) {
      _LOR:
      {
        redisFree(c);
        __retres = (redisContext *)0;
        goto return_label;
      }
    }
  __retres = c;
  return_label: return __retres;
}

void redisFree(redisContext *c)
{
  if (c == (redisContext *)0) goto return_label;
  redisNetClose(c);
  sdsfree(c->obuf);
  redisReaderFree(c->reader);
  free((void *)c->tcp.host);
  free((void *)c->tcp.source_addr);
  free((void *)c->unix_sock.path);
  free((void *)c->timeout);
  free((void *)c->saddr);
  if ((c->funcs)->free_privdata) (*((c->funcs)->free_privdata))(c->privdata);
  memset((void *)c,0xff,sizeof(*c));
  free((void *)c);
  return_label: return;
}

redisFD redisFreeKeepFd(redisContext *c)
{
  redisFD fd = c->fd;
  c->fd = -1;
  redisFree(c);
  return fd;
}

int redisReconnect(redisContext *c)
{
  int __retres;
  size_t tmp;
  c->err = 0;
  tmp = strlen((char const *)(c->errstr));
  ;
  memset((void *)(c->errstr),'\000',tmp);
  if (c->privdata) 
    if ((c->funcs)->free_privdata) {
      (*((c->funcs)->free_privdata))(c->privdata);
      c->privdata = (void *)0;
    }
  redisNetClose(c);
  sdsfree(c->obuf);
  redisReaderFree(c->reader);
  c->obuf = sdsempty();
  c->reader = redisReaderCreate();
  if (c->connection_type == (unsigned int)REDIS_CONN_TCP) {
    int tmp_0;
    tmp_0 = redisContextConnectBindTcp(c,(char const *)c->tcp.host,
                                       c->tcp.port,
                                       (struct timeval const *)c->timeout,
                                       (char const *)c->tcp.source_addr);
    __retres = tmp_0;
    goto return_label;
  }
  else 
    if (c->connection_type == (unsigned int)REDIS_CONN_UNIX) {
      int tmp_1;
      tmp_1 = redisContextConnectUnix(c,(char const *)c->unix_sock.path,
                                      (struct timeval const *)c->timeout);
      __retres = tmp_1;
      goto return_label;
    }
    else __redisSetError(c,2,"Not enough information to reconnect");
  __retres = -1;
  return_label: return __retres;
}

redisContext *redisConnectWithOptions(redisOptions const *options)
{
  redisContext *__retres;
  redisContext *c = redisContextInit(options);
  if (c == (redisContext *)0) {
    __retres = (redisContext *)0;
    goto return_label;
  }
  if (! (options->options & 0x01)) c->flags |= 0x1;
  if (options->options & 0x02) c->flags |= 0x80;
  if (options->options & 0x04) c->flags |= 0x200;
  if (options->type == REDIS_CONN_TCP) redisContextConnectBindTcp(c,
                                                                  options->endpoint.tcp.ip,
                                                                  options->endpoint.tcp.port,
                                                                  options->timeout,
                                                                  options->endpoint.tcp.source_addr);
  else 
    if (options->type == REDIS_CONN_UNIX) redisContextConnectUnix(c,
                                                                  options->endpoint.unix_socket,
                                                                  options->timeout);
    else 
      if (options->type == REDIS_CONN_USERFD) {
        c->fd = options->endpoint.fd;
        c->flags |= 0x2;
      }
      else {
        __retres = (redisContext *)0;
        goto return_label;
      }
  if (options->timeout != (struct timeval const *)0) 
    if (c->flags & 0x1) 
      if (c->fd != -1) redisContextSetTimeout(c,*(options->timeout));
  __retres = c;
  return_label: return __retres;
}

redisContext *redisConnect(char const *ip, int port)
{
  redisContext *tmp;
  redisOptions options =
    {.type = 0,
     .options = 0,
     .timeout = (struct timeval const *)0,
     .endpoint = {.tcp = {.source_addr = (char const *)0,
                          .ip = (char const *)0,
                          .port = 0}}};
  options.type = REDIS_CONN_TCP;
  options.endpoint.tcp.ip = ip;
  options.endpoint.tcp.port = port;
  tmp = redisConnectWithOptions((redisOptions const *)(& options));
  return tmp;
}

redisContext *redisConnectWithTimeout(char const *ip, int port,
                                      struct timeval const tv)
{
  redisContext *tmp;
  redisOptions options =
    {.type = 0,
     .options = 0,
     .timeout = (struct timeval const *)0,
     .endpoint = {.tcp = {.source_addr = (char const *)0,
                          .ip = (char const *)0,
                          .port = 0}}};
  options.type = REDIS_CONN_TCP;
  options.endpoint.tcp.ip = ip;
  options.endpoint.tcp.port = port;
  options.timeout = & tv;
  tmp = redisConnectWithOptions((redisOptions const *)(& options));
  return tmp;
}

redisContext *redisConnectNonBlock(char const *ip, int port)
{
  redisContext *tmp;
  redisOptions options =
    {.type = 0,
     .options = 0,
     .timeout = (struct timeval const *)0,
     .endpoint = {.tcp = {.source_addr = (char const *)0,
                          .ip = (char const *)0,
                          .port = 0}}};
  options.type = REDIS_CONN_TCP;
  options.endpoint.tcp.ip = ip;
  options.endpoint.tcp.port = port;
  options.options |= 0x01;
  tmp = redisConnectWithOptions((redisOptions const *)(& options));
  return tmp;
}

redisContext *redisConnectBindNonBlock(char const *ip, int port,
                                       char const *source_addr)
{
  redisContext *tmp;
  redisOptions options =
    {.type = 0,
     .options = 0,
     .timeout = (struct timeval const *)0,
     .endpoint = {.tcp = {.source_addr = (char const *)0,
                          .ip = (char const *)0,
                          .port = 0}}};
  options.type = REDIS_CONN_TCP;
  options.endpoint.tcp.ip = ip;
  options.endpoint.tcp.port = port;
  options.endpoint.tcp.source_addr = source_addr;
  options.options |= 0x01;
  tmp = redisConnectWithOptions((redisOptions const *)(& options));
  return tmp;
}

redisContext *redisConnectBindNonBlockWithReuse(char const *ip, int port,
                                                char const *source_addr)
{
  redisContext *tmp;
  redisOptions options =
    {.type = 0,
     .options = 0,
     .timeout = (struct timeval const *)0,
     .endpoint = {.tcp = {.source_addr = (char const *)0,
                          .ip = (char const *)0,
                          .port = 0}}};
  options.type = REDIS_CONN_TCP;
  options.endpoint.tcp.ip = ip;
  options.endpoint.tcp.port = port;
  options.endpoint.tcp.source_addr = source_addr;
  options.options |= 0x01 | 0x02;
  tmp = redisConnectWithOptions((redisOptions const *)(& options));
  return tmp;
}

redisContext *redisConnectUnix(char const *path)
{
  redisContext *tmp;
  redisOptions options =
    {.type = 0,
     .options = 0,
     .timeout = (struct timeval const *)0,
     .endpoint = {.tcp = {.source_addr = (char const *)0,
                          .ip = (char const *)0,
                          .port = 0}}};
  options.type = REDIS_CONN_UNIX;
  options.endpoint.unix_socket = path;
  tmp = redisConnectWithOptions((redisOptions const *)(& options));
  return tmp;
}

redisContext *redisConnectUnixWithTimeout(char const *path,
                                          struct timeval const tv)
{
  redisContext *tmp;
  redisOptions options =
    {.type = 0,
     .options = 0,
     .timeout = (struct timeval const *)0,
     .endpoint = {.tcp = {.source_addr = (char const *)0,
                          .ip = (char const *)0,
                          .port = 0}}};
  options.type = REDIS_CONN_UNIX;
  options.endpoint.unix_socket = path;
  options.timeout = & tv;
  tmp = redisConnectWithOptions((redisOptions const *)(& options));
  return tmp;
}

redisContext *redisConnectUnixNonBlock(char const *path)
{
  redisContext *tmp;
  redisOptions options =
    {.type = 0,
     .options = 0,
     .timeout = (struct timeval const *)0,
     .endpoint = {.tcp = {.source_addr = (char const *)0,
                          .ip = (char const *)0,
                          .port = 0}}};
  options.type = REDIS_CONN_UNIX;
  options.endpoint.unix_socket = path;
  options.options |= 0x01;
  tmp = redisConnectWithOptions((redisOptions const *)(& options));
  return tmp;
}

redisContext *redisConnectFd(redisFD fd)
{
  redisContext *tmp;
  redisOptions options =
    {.type = 0,
     .options = 0,
     .timeout = (struct timeval const *)0,
     .endpoint = {.tcp = {.source_addr = (char const *)0,
                          .ip = (char const *)0,
                          .port = 0}}};
  options.type = REDIS_CONN_USERFD;
  options.endpoint.fd = fd;
  tmp = redisConnectWithOptions((redisOptions const *)(& options));
  return tmp;
}

int redisSetTimeout(redisContext *c, struct timeval const tv)
{
  int __retres;
  if (c->flags & 0x1) {
    int tmp;
    tmp = redisContextSetTimeout(c,tv);
    __retres = tmp;
    goto return_label;
  }
  __retres = -1;
  return_label: return __retres;
}

int redisEnableKeepAlive(redisContext *c)
{
  int __retres;
  int tmp;
  tmp = redisKeepAlive(c,15);
  if (tmp != 0) {
    __retres = -1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int redisBufferRead(redisContext *c)
{
  int __retres;
  char buf[1024 * 16];
  int nread;
  if (c->err) {
    __retres = -1;
    goto return_label;
  }
  nread = (*((c->funcs)->read))(c,buf,sizeof(buf));
  if (nread > 0) {
    int tmp;
    tmp = redisReaderFeed(c->reader,(char const *)(buf),(size_t)nread);
    if (tmp != 0) {
      __redisSetError(c,(c->reader)->err,(char const *)((c->reader)->errstr));
      __retres = -1;
      goto return_label;
    }
  }
  else 
    if (nread < 0) {
      __retres = -1;
      goto return_label;
    }
  __retres = 0;
  return_label: return __retres;
}

int redisBufferWrite(redisContext *c, int *done)
{
  int __retres;
  size_t tmp_1;
  if (c->err) {
    __retres = -1;
    goto return_label;
  }
  tmp_1 = sdslen_0(c->obuf);
  if (tmp_1 > (size_t)0) {
    int tmp;
    tmp = (*((c->funcs)->write))(c);
    int nwritten = tmp;
    if (nwritten < 0) {
      __retres = -1;
      goto return_label;
    }
    else 
      if (nwritten > 0) {
        size_t tmp_0;
        tmp_0 = sdslen_0(c->obuf);
        ;
        if (nwritten == (int)tmp_0) {
          sdsfree(c->obuf);
          c->obuf = sdsempty();
        }
        else sdsrange(c->obuf,nwritten,-1);
      }
  }
  if (done != (int *)0) {
    size_t tmp_2;
    tmp_2 = sdslen_0(c->obuf);
    *done = tmp_2 == (size_t)0;
  }
  __retres = 0;
  return_label: return __retres;
}

int redisGetReplyFromReader(redisContext *c, void **reply)
{
  int __retres;
  int tmp;
  tmp = redisReaderGetReply(c->reader,reply);
  if (tmp == -1) {
    __redisSetError(c,(c->reader)->err,(char const *)((c->reader)->errstr));
    __retres = -1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int redisGetReply(redisContext *c, void **reply)
{
  int __retres;
  int tmp;
  int wdone = 0;
  void *aux = (void *)0;
  tmp = redisGetReplyFromReader(c,& aux);
  if (tmp == -1) {
    __retres = -1;
    goto return_label;
  }
  if (aux == (void *)0) 
    if (c->flags & 0x1) {
      while (1) {
        {
          int tmp_0;
          tmp_0 = redisBufferWrite(c,& wdone);
          if (tmp_0 == -1) {
            __retres = -1;
            goto return_label;
          }
        }
        if (! (! wdone)) break;
      }
      while (1) {
        {
          int tmp_1;
          int tmp_2;
          tmp_1 = redisBufferRead(c);
          if (tmp_1 == -1) {
            __retres = -1;
            goto return_label;
          }
          tmp_2 = redisGetReplyFromReader(c,& aux);
          if (tmp_2 == -1) {
            __retres = -1;
            goto return_label;
          }
        }
        if (! (aux == (void *)0)) break;
      }
    }
  if (reply != (void **)0) *reply = aux; else freeReplyObject(aux);
  __retres = 0;
  return_label: return __retres;
}

int __redisAppendCommand(redisContext *c, char const *cmd, size_t len)
{
  int __retres;
  sds newbuf;
  newbuf = sdscatlen(c->obuf,(void const *)cmd,len);
  if (newbuf == (sds)0) {
    __redisSetError(c,5,"Out of memory");
    __retres = -1;
    goto return_label;
  }
  c->obuf = newbuf;
  __retres = 0;
  return_label: return __retres;
}

int redisAppendFormattedCommand(redisContext *c, char const *cmd, size_t len)
{
  int __retres;
  int tmp;
  tmp = __redisAppendCommand(c,cmd,len);
  if (tmp != 0) {
    __retres = -1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int redisvAppendCommand(redisContext *c, char const *format, va_list ap)
{
  int __retres;
  char *cmd;
  int len;
  int tmp;
  len = redisvFormatCommand(& cmd,format,ap);
  if (len == -1) {
    __redisSetError(c,5,"Out of memory");
    __retres = -1;
    goto return_label;
  }
  else 
    if (len == -2) {
      __redisSetError(c,2,"Invalid format string");
      __retres = -1;
      goto return_label;
    }
  tmp = __redisAppendCommand(c,(char const *)cmd,(size_t)len);
  if (tmp != 0) {
    free((void *)cmd);
    __retres = -1;
    goto return_label;
  }
  free((void *)cmd);
  __retres = 0;
  return_label: return __retres;
}

int redisAppendCommand(redisContext *c, char const *format,
                       void * const *__va_params)
{
  va_list ap;
  int ret;
  ap = __va_params;
  ret = redisvAppendCommand(c,format,ap);
  return ret;
}

int redisAppendCommandArgv(redisContext *c, int argc, char const **argv,
                           size_t const *argvlen)
{
  int __retres;
  sds cmd;
  int len;
  int tmp;
  len = redisFormatSdsCommandArgv(& cmd,argc,argv,argvlen);
  if (len == -1) {
    __redisSetError(c,5,"Out of memory");
    __retres = -1;
    goto return_label;
  }
  tmp = __redisAppendCommand(c,(char const *)cmd,(size_t)len);
  if (tmp != 0) {
    sdsfree(cmd);
    __retres = -1;
    goto return_label;
  }
  sdsfree(cmd);
  __retres = 0;
  return_label: return __retres;
}

static void *__redisBlockForReply(redisContext *c)
{
  void *__retres;
  void *reply;
  if (c->flags & 0x1) {
    int tmp;
    tmp = redisGetReply(c,& reply);
    if (tmp != 0) {
      __retres = (void *)0;
      goto return_label;
    }
    __retres = reply;
    goto return_label;
  }
  __retres = (void *)0;
  return_label: return __retres;
}

void *redisvCommand(redisContext *c, char const *format, va_list ap)
{
  void *__retres;
  int tmp;
  void *tmp_0;
  tmp = redisvAppendCommand(c,format,ap);
  if (tmp != 0) {
    __retres = (void *)0;
    goto return_label;
  }
  tmp_0 = __redisBlockForReply(c);
  __retres = tmp_0;
  return_label: return __retres;
}

void *redisCommand(redisContext *c, char const *format,
                   void * const *__va_params)
{
  va_list ap;
  ap = __va_params;
  void *reply = redisvCommand(c,format,ap);
  return reply;
}

void *redisCommandArgv(redisContext *c, int argc, char const **argv,
                       size_t const *argvlen)
{
  void *__retres;
  int tmp;
  void *tmp_0;
  tmp = redisAppendCommandArgv(c,argc,argv,argvlen);
  if (tmp != 0) {
    __retres = (void *)0;
    goto return_label;
  }
  tmp_0 = __redisBlockForReply(c);
  __retres = tmp_0;
  return_label: return __retres;
}

__inline static size_t sdslen_1(sds const s)
{
  size_t __retres;
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0: ;
    __retres = (size_t)((int)flags >> 3);
    goto return_label;
    case 1: ;
    __retres = (size_t)((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->len;
    goto return_label;
    case 2: ;
    __retres = (size_t)((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->len;
    goto return_label;
    case 3: ;
    __retres = ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->len;
    goto return_label;
    case 4: ;
    __retres = (size_t)((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->len;
    goto return_label;
  }
  __retres = (size_t)0;
  return_label: return __retres;
}

__inline static size_t sdsavail_1(sds const s)
{
  size_t __retres;
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0: {
              __retres = (size_t)0;
              goto return_label;
            }
    case 1:
    {
      struct sdshdr8 *sh = (struct sdshdr8 *)(s - sizeof(struct sdshdr8));
      __retres = (size_t)((int)sh->alloc - (int)sh->len);
      goto return_label;
    }
    case 2:
    {
      struct sdshdr16 *sh_0 =
        (struct sdshdr16 *)(s - sizeof(struct sdshdr16));
      __retres = (size_t)((int)sh_0->alloc - (int)sh_0->len);
      goto return_label;
    }
    case 3:
    {
      struct sdshdr32 *sh_1 =
        (struct sdshdr32 *)(s - sizeof(struct sdshdr32));
      __retres = sh_1->alloc - sh_1->len;
      goto return_label;
    }
    case 4:
    {
      struct sdshdr64 *sh_2 =
        (struct sdshdr64 *)(s - sizeof(struct sdshdr64));
      __retres = (size_t)(sh_2->alloc - sh_2->len);
      goto return_label;
    }
  }
  __retres = (size_t)0;
  return_label: return __retres;
}

__inline static void sdssetlen_1(sds s, size_t newlen)
{
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0:
    {
      unsigned char *fp = (unsigned char *)s - 1;
      *fp = (unsigned char)((unsigned int)0 | (newlen << 3));
    }
    break;
    case 1:
    ((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->len = (uint8_t)newlen;
    break;
    case 2:
    ((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->len = (uint16_t)newlen;
    break;
    case 3: ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->len = newlen;
    break;
    case 4:
    ((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->len = (uint64_t)newlen;
    break;
  }
  return;
}

__inline static void sdsinclen_1(sds s, size_t inc)
{
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0:
    {
      unsigned char *fp = (unsigned char *)s - 1;
      unsigned char newlen =
        (unsigned char)(((int)flags >> 3) + (int)((unsigned char)inc));
      *fp = (unsigned char)(0 | ((int)newlen << 3));
    }
    break;
    case 1:
    ((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->len = (uint8_t)(
    (int)((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->len + (int)((uint8_t)inc));
    break;
    case 2:
    ((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->len = (uint16_t)(
    (int)((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->len + (int)((uint16_t)inc));
    break;
    case 3: ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->len += inc;
    break;
    case 4:
    ((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->len += (uint64_t)inc;
    break;
  }
  return;
}

__inline static size_t sdsalloc_1(sds const s)
{
  size_t __retres;
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0: ;
    __retres = (size_t)((int)flags >> 3);
    goto return_label;
    case 1: ;
    __retres = (size_t)((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->alloc;
    goto return_label;
    case 2: ;
    __retres = (size_t)((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->alloc;
    goto return_label;
    case 3: ;
    __retres = ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->alloc;
    goto return_label;
    case 4: ;
    __retres = (size_t)((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->alloc;
    goto return_label;
  }
  __retres = (size_t)0;
  return_label: return __retres;
}

__inline static void sdssetalloc_1(sds s, size_t newlen)
{
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0: break;
    case 1:
    ((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->alloc = (uint8_t)newlen;
    break;
    case 2:
    ((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->alloc = (uint16_t)newlen;
    break;
    case 3:
    ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->alloc = newlen;
    break;
    case 4:
    ((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->alloc = (uint64_t)newlen;
    break;
  }
  return;
}

void redisNetClose(redisContext *c)
{
  if (c) 
    if (c->fd != -1) {
      close(c->fd);
      c->fd = -1;
    }
  return;
}

int redisNetRead(redisContext *c, char *buf, size_t bufcap)
{
  int __retres;
  int nread = recv(c->fd,(void *)buf,bufcap,0);
  if (nread == -1) 
    if (__fc_errno == 11) {
      if (! (c->flags & 0x1)) goto _LOR; else goto _LAND_0;
    }
    else {
      _LAND_0: ;
      if (__fc_errno == 4) {
        _LOR: {
                __retres = 0;
                goto return_label;
              }
      }
      else 
        if (__fc_errno == 110) {
          if (c->flags & 0x1) {
            __redisSetError(c,6,"recv timeout");
            __retres = -1;
            goto return_label;
          }
          else goto _LAND;
        }
        else {
          _LAND:
          {
            __redisSetError(c,1,(char const *)0);
            __retres = -1;
            goto return_label;
          }
        }
    }
  else 
    if (nread == 0) {
      __redisSetError(c,3,"Server closed the connection");
      __retres = -1;
      goto return_label;
    }
    else {
      __retres = nread;
      goto return_label;
    }
  return_label: return __retres;
}

int redisNetWrite(redisContext *c)
{
  int __retres;
  int tmp_0;
  size_t tmp;
  tmp = sdslen_1(c->obuf);
  ;
  ;
  tmp_0 = send(c->fd,(void const *)c->obuf,tmp,0);
  int nwritten = tmp_0;
  if (nwritten < 0) 
    if (__fc_errno == 11) {
      if (! (c->flags & 0x1)) goto _LOR; else goto _LAND;
    }
    else {
      _LAND: ;
      if (__fc_errno == 4) _LOR: ;
      else {
        __redisSetError(c,1,(char const *)0);
        __retres = -1;
        goto return_label;
      }
    }
  __retres = nwritten;
  return_label: return __retres;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) âˆ¨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int snprintf_va_2(char * restrict s, size_t n, char const * restrict format,
                  char *param0);

static void __redisSetErrorFromErrno(redisContext *c, int type,
                                     char const *prefix)
{
  int errorno = __fc_errno;
  char buf[128] = {(char)0};
  size_t len = (size_t)0;
  if (prefix != (char const *)0) {
    int tmp;
    tmp = snprintf(buf,sizeof(buf),"%s: ",(char *)prefix); /* snprintf_va_2 */
    len = (size_t)tmp;
  }
  strerror_r(errorno,& buf[len],sizeof(buf) - len);
  __redisSetError(c,type,(char const *)(buf));
  return;
}

static int redisSetReuseAddr(redisContext *c)
{
  int __retres;
  int tmp;
  int on = 1;
  tmp = setsockopt(c->fd,1,2,(void const *)(& on),sizeof(on));
  if (tmp == -1) {
    __redisSetErrorFromErrno(c,1,(char const *)0);
    redisNetClose(c);
    __retres = -1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static int redisCreateSocket(redisContext *c, int type)
{
  int __retres;
  redisFD s;
  s = socket(type,1,0);
  if (s == -1) {
    __redisSetErrorFromErrno(c,1,(char const *)0);
    __retres = -1;
    goto return_label;
  }
  c->fd = s;
  if (type == 2) {
    int tmp;
    tmp = redisSetReuseAddr(c);
    if (tmp == -1) {
      __retres = -1;
      goto return_label;
    }
  }
  __retres = 0;
  return_label: return __retres;
}

static int redisSetBlocking(redisContext *c, int blocking)
{
  int __retres;
  int flags;
  int tmp;
  flags = fcntl(c->fd,3); /* __va_fcntl_void */
  if (flags == -1) {
    __redisSetErrorFromErrno(c,1,"fcntl(F_GETFL)");
    redisNetClose(c);
    __retres = -1;
    goto return_label;
  }
  if (blocking) flags &= ~ 0x800; else flags |= 0x800;
  tmp = fcntl(c->fd,4,flags); /* __va_fcntl_int */
  if (tmp == -1) {
    __redisSetErrorFromErrno(c,1,"fcntl(F_SETFL)");
    redisNetClose(c);
    __retres = -1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int redisKeepAlive(redisContext *c, int interval)
{
  int __retres;
  int tmp_0;
  int val = 1;
  redisFD fd = c->fd;
  tmp_0 = setsockopt(fd,1,9,(void const *)(& val),sizeof(val));
  if (tmp_0 == -1) {
    char *tmp;
    tmp = strerror(__fc_errno);
    ;
    __redisSetError(c,2,(char const *)tmp);
    __retres = -1;
    goto return_label;
  }
  val = interval;
  __retres = 0;
  return_label: return __retres;
}

static int redisSetTcpNoDelay(redisContext *c)
{
  int __retres;
  int tmp;
  int yes = 1;
  tmp = setsockopt(c->fd,IPPROTO_TCP,1,(void const *)(& yes),sizeof(yes));
  if (tmp == -1) {
    __redisSetErrorFromErrno(c,1,"setsockopt(TCP_NODELAY)");
    redisNetClose(c);
    __retres = -1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static int redisContextTimeoutMsec(redisContext *c, long *result)
{
  int __retres;
  struct timeval const *timeout = (struct timeval const *)c->timeout;
  long msec = (long)(-1);
  if (timeout != (struct timeval const *)0) {
    if (timeout->tv_usec > 1000000) goto _LOR;
    else 
      if (timeout->tv_sec > (2147483647L - (long)999) / (long)1000) {
        _LOR: {
                *result = msec;
                __retres = -1;
                goto return_label;
              }
      }
    msec = timeout->tv_sec * (time_t)1000 + (time_t)((timeout->tv_usec + 999) / 1000);
    if (msec < (long)0) goto _LOR_0;
    else 
      if (msec > (long)2147483647) _LOR_0: msec = (long)2147483647;
  }
  *result = msec;
  __retres = 0;
  return_label: return __retres;
}

static int redisContextWaitReady(redisContext *c, long msec)
{
  int __retres;
  struct pollfd wfd[1];
  wfd[0].fd = c->fd;
  wfd[0].events = (short)0x004;
  if (__fc_errno == 115) {
    int res;
    int tmp;
    res = poll(wfd,(nfds_t)1,(int)msec);
    if (res == -1) {
      __redisSetErrorFromErrno(c,1,"poll(2)");
      redisNetClose(c);
      __retres = -1;
      goto return_label;
    }
    else 
      if (res == 0) {
        __fc_errno = 110;
        __redisSetErrorFromErrno(c,1,(char const *)0);
        redisNetClose(c);
        __retres = -1;
        goto return_label;
      }
    tmp = redisCheckConnectDone(c,& res);
    if (tmp != 0) goto _LOR;
    else 
      if (res == 0) {
        _LOR: {
                redisCheckSocketError(c);
                __retres = -1;
                goto return_label;
              }
      }
    __retres = 0;
    goto return_label;
  }
  __redisSetErrorFromErrno(c,1,(char const *)0);
  redisNetClose(c);
  __retres = -1;
  return_label: return __retres;
}

int redisCheckConnectDone(redisContext *c, int *completed)
{
  int __retres;
  int rc = connect(c->fd,(struct sockaddr const *)c->saddr,c->addrlen);
  if (rc == 0) {
    *completed = 1;
    __retres = 0;
    goto return_label;
  }
  switch (__fc_errno) {
    case 106: *completed = 1;
    __retres = 0;
    goto return_label;
    case 114: case 115: case 11: *completed = 0;
    __retres = 0;
    goto return_label;
    default: __retres = -1;
    goto return_label;
  }
  return_label: return __retres;
}

int redisCheckSocketError(redisContext *c)
{
  int __retres;
  int tmp;
  int err = 0;
  int errno_saved = __fc_errno;
  socklen_t errlen = sizeof(err);
  tmp = getsockopt(c->fd,1,4,(void *)(& err),& errlen);
  if (tmp == -1) {
    __redisSetErrorFromErrno(c,1,"getsockopt(SO_ERROR)");
    __retres = -1;
    goto return_label;
  }
  if (err == 0) err = errno_saved;
  if (err) {
    __fc_errno = err;
    __redisSetErrorFromErrno(c,1,(char const *)0);
    __retres = -1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int redisContextSetTimeout(redisContext *c, struct timeval const tv)
{
  int __retres;
  int tmp;
  int tmp_0;
  void const *to_ptr = (void const *)(& tv);
  size_t to_sz = sizeof(tv);
  tmp = setsockopt(c->fd,1,20,to_ptr,to_sz);
  if (tmp == -1) {
    __redisSetErrorFromErrno(c,1,"setsockopt(SO_RCVTIMEO)");
    __retres = -1;
    goto return_label;
  }
  tmp_0 = setsockopt(c->fd,1,21,to_ptr,to_sz);
  if (tmp_0 == -1) {
    __redisSetErrorFromErrno(c,1,"setsockopt(SO_SNDTIMEO)");
    __retres = -1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) âˆ¨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))), (indirect: param0);
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param0;
 */
int snprintf_va_3(char * restrict s, size_t n, char const * restrict format,
                  int param0);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) âˆ¨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int snprintf_va_4(char * restrict s, size_t n, char const * restrict format,
                  char *param0);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) âˆ¨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int snprintf_va_5(char * restrict s, size_t n, char const * restrict format,
                  char *param0);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) âˆ¨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int snprintf_va_6(char * restrict s, size_t n, char const * restrict format,
                  char *param0);

static int _redisContextConnectTcp(redisContext *c, char const *addr,
                                   int port, struct timeval const *timeout,
                                   char const *source_addr)
{
  int __retres;
  redisFD s;
  int rv;
  int n;
  char _port[6];
  struct addrinfo hints;
  struct addrinfo *servinfo;
  struct addrinfo *bservinfo;
  struct addrinfo *p;
  struct addrinfo *b;
  int tmp;
  int blocking = c->flags & 0x1;
  int reuseaddr = c->flags & 0x80;
  int reuses = 0;
  long timeout_msec = (long)(-1);
  servinfo = (struct addrinfo *)0;
  c->connection_type = REDIS_CONN_TCP;
  c->tcp.port = port;
  if ((void *)c->tcp.host != (void *)addr) {
    free((void *)c->tcp.host);
    c->tcp.host = hi_strdup(addr);
  }
  if (timeout) {
    if ((void *)c->timeout != (void *)timeout) {
      if (c->timeout == (struct timeval *)0) c->timeout = (struct timeval *)hi_malloc
                                             (sizeof(struct timeval));
      memcpy((void *)c->timeout,(void const *)timeout,sizeof(struct timeval));
    }
  }
  else {
    free((void *)c->timeout);
    c->timeout = (struct timeval *)0;
  }
  tmp = redisContextTimeoutMsec(c,& timeout_msec);
  if (tmp != 0) {
    __redisSetError(c,1,"Invalid timeout specified");
    goto error;
  }
  if (source_addr == (char const *)0) {
    free((void *)c->tcp.source_addr);
    c->tcp.source_addr = (char *)0;
  }
  else 
    if ((void *)c->tcp.source_addr != (void *)source_addr) {
      free((void *)c->tcp.source_addr);
      c->tcp.source_addr = hi_strdup(source_addr);
    }
  snprintf(_port,(size_t)6,"%d",port); /* snprintf_va_3 */
  memset((void *)(& hints),0,sizeof(hints));
  hints.ai_family = 2;
  hints.ai_socktype = 1;
  rv = getaddrinfo((char const *)c->tcp.host,(char const *)(_port),
                   (struct addrinfo const *)(& hints),& servinfo);
  if (rv != 0) {
    hints.ai_family = 10;
    rv = getaddrinfo(addr,(char const *)(_port),
                     (struct addrinfo const *)(& hints),& servinfo);
    if (rv != 0) {
      char const *tmp_0;
      tmp_0 = gai_strerror(rv);
      ;
      __redisSetError(c,2,tmp_0);
      __retres = -1;
      goto return_label;
    }
  }
  p = servinfo;
  while (p != (struct addrinfo *)0) {
    {
      int tmp_1;
      int tmp_7;
      int tmp_9;
      addrretry: s = socket(p->ai_family,p->ai_socktype,p->ai_protocol);
      if (s == -1) goto __Cont;
      c->fd = s;
      tmp_1 = redisSetBlocking(c,0);
      if (tmp_1 != 0) goto error;
      if (c->tcp.source_addr) {
        int bound = 0;
        rv = getaddrinfo((char const *)c->tcp.source_addr,(char const *)0,
                         (struct addrinfo const *)(& hints),& bservinfo);
        if (rv != 0) {
          char buf[128];
          char const *tmp_2;
          tmp_2 = gai_strerror(rv);
          snprintf(buf,sizeof(buf),"Can\'t get addr: %s",(char *)tmp_2); /* snprintf_va_4 */
          __redisSetError(c,2,(char const *)(buf));
          goto error;
        }
        if (reuseaddr) {
          int tmp_3;
          n = 1;
          tmp_3 = setsockopt(s,1,2,(void const *)(& n),sizeof(n));
          if (tmp_3 < 0) {
            freeaddrinfo(bservinfo);
            goto error;
          }
        }
        b = bservinfo;
        while (b != (struct addrinfo *)0) {
          {
            int tmp_4;
            tmp_4 = bind(s,(struct sockaddr const *)b->ai_addr,b->ai_addrlen);
            if (tmp_4 != -1) {
              bound = 1;
              break;
            }
          }
          b = b->ai_next;
        }
        freeaddrinfo(bservinfo);
        if (! bound) {
          char buf_0[128];
          char *tmp_5;
          tmp_5 = strerror(__fc_errno);
          snprintf(buf_0,sizeof(buf_0),"Can\'t bind socket: %s",tmp_5); /* snprintf_va_5 */
          __redisSetError(c,2,(char const *)(buf_0));
          goto error;
        }
      }
      free((void *)c->saddr);
      c->saddr = (struct sockadr *)hi_malloc(p->ai_addrlen);
      memcpy((void *)c->saddr,(void const *)p->ai_addr,p->ai_addrlen);
      c->addrlen = p->ai_addrlen;
      tmp_7 = connect(s,(struct sockaddr const *)p->ai_addr,p->ai_addrlen);
      if (tmp_7 == -1) 
        if (__fc_errno == 113) {
          redisNetClose(c);
          goto __Cont;
        }
        else 
          if (__fc_errno == 115) {
            if (blocking) goto wait_for_ready;
          }
          else 
            if (__fc_errno == 99) {
              if (reuseaddr) {
                reuses ++;
                if (reuses >= 10) goto error;
                else {
                  redisNetClose(c);
                  goto addrretry;
                }
              }
              else goto _LAND;
            }
            else {
              _LAND:
              {
                int tmp_6;
                wait_for_ready:
                tmp_6 = redisContextWaitReady(c,timeout_msec);
                if (tmp_6 != 0) goto error;
              }
            }
      if (blocking) {
        int tmp_8;
        tmp_8 = redisSetBlocking(c,1);
        if (tmp_8 != 0) goto error;
      }
      tmp_9 = redisSetTcpNoDelay(c);
      if (tmp_9 != 0) goto error;
      c->flags |= 0x2;
      rv = 0;
      goto end;
    }
    __Cont: p = p->ai_next;
  }
  if (p == (struct addrinfo *)0) {
    char buf_1[128];
    char *tmp_10;
    tmp_10 = strerror(__fc_errno);
    snprintf(buf_1,sizeof(buf_1),"Can\'t create socket: %s",tmp_10); /* snprintf_va_6 */
    __redisSetError(c,2,(char const *)(buf_1));
    goto error;
  }
  error: rv = -1;
  end: ;
  if (servinfo) freeaddrinfo(servinfo);
  __retres = rv;
  return_label: return __retres;
}

int redisContextConnectTcp(redisContext *c, char const *addr, int port,
                           struct timeval const *timeout)
{
  int tmp;
  tmp = _redisContextConnectTcp(c,addr,port,timeout,(char const *)0);
  return tmp;
}

int redisContextConnectBindTcp(redisContext *c, char const *addr, int port,
                               struct timeval const *timeout,
                               char const *source_addr)
{
  int tmp;
  tmp = _redisContextConnectTcp(c,addr,port,timeout,source_addr);
  return tmp;
}

int redisContextConnectUnix(redisContext *c, char const *path,
                            struct timeval const *timeout)
{
  int __retres;
  struct sockaddr_un *sa;
  int tmp;
  int tmp_0;
  int tmp_1;
  struct sockadr *tmp_2;
  int tmp_4;
  int blocking = c->flags & 0x1;
  long timeout_msec = (long)(-1);
  tmp = redisCreateSocket(c,1);
  if (tmp < 0) {
    __retres = -1;
    goto return_label;
  }
  tmp_0 = redisSetBlocking(c,0);
  if (tmp_0 != 0) {
    __retres = -1;
    goto return_label;
  }
  c->connection_type = REDIS_CONN_UNIX;
  if ((void *)c->unix_sock.path != (void *)path) c->unix_sock.path = hi_strdup
                                                 (path);
  if (timeout) {
    if ((void *)c->timeout != (void *)timeout) {
      if (c->timeout == (struct timeval *)0) c->timeout = (struct timeval *)hi_malloc
                                             (sizeof(struct timeval));
      memcpy((void *)c->timeout,(void const *)timeout,sizeof(struct timeval));
    }
  }
  else {
    free((void *)c->timeout);
    c->timeout = (struct timeval *)0;
  }
  tmp_1 = redisContextTimeoutMsec(c,& timeout_msec);
  if (tmp_1 != 0) {
    __retres = -1;
    goto return_label;
  }
  tmp_2 = (struct sockadr *)hi_malloc(sizeof(struct sockaddr_un));
  c->saddr = tmp_2;
  sa = (struct sockaddr_un *)tmp_2;
  c->addrlen = sizeof(struct sockaddr_un);
  sa->sun_family = (sa_family_t)1;
  strncpy(sa->sun_path,path,sizeof(sa->sun_path) - (unsigned int)1);
  tmp_4 = connect(c->fd,(struct sockaddr const *)sa,sizeof(*sa));
  if (tmp_4 == -1) 
    if (__fc_errno == 115) {
      if (! (! blocking)) goto _LAND;
    }
    else {
      _LAND:
      {
        int tmp_3;
        tmp_3 = redisContextWaitReady(c,timeout_msec);
        if (tmp_3 != 0) {
          __retres = -1;
          goto return_label;
        }
      }
    }
  if (blocking) {
    int tmp_5;
    tmp_5 = redisSetBlocking(c,1);
    if (tmp_5 != 0) {
      __retres = -1;
      goto return_label;
    }
  }
  c->flags |= 0x2;
  __retres = 0;
  return_label: return __retres;
}

__inline static size_t sdslen_2(sds const s)
{
  size_t __retres;
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0: ;
    __retres = (size_t)((int)flags >> 3);
    goto return_label;
    case 1: ;
    __retres = (size_t)((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->len;
    goto return_label;
    case 2: ;
    __retres = (size_t)((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->len;
    goto return_label;
    case 3: ;
    __retres = ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->len;
    goto return_label;
    case 4: ;
    __retres = (size_t)((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->len;
    goto return_label;
  }
  __retres = (size_t)0;
  return_label: return __retres;
}

__inline static size_t sdsavail_2(sds const s)
{
  size_t __retres;
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0: {
              __retres = (size_t)0;
              goto return_label;
            }
    case 1:
    {
      struct sdshdr8 *sh = (struct sdshdr8 *)(s - sizeof(struct sdshdr8));
      __retres = (size_t)((int)sh->alloc - (int)sh->len);
      goto return_label;
    }
    case 2:
    {
      struct sdshdr16 *sh_0 =
        (struct sdshdr16 *)(s - sizeof(struct sdshdr16));
      __retres = (size_t)((int)sh_0->alloc - (int)sh_0->len);
      goto return_label;
    }
    case 3:
    {
      struct sdshdr32 *sh_1 =
        (struct sdshdr32 *)(s - sizeof(struct sdshdr32));
      __retres = sh_1->alloc - sh_1->len;
      goto return_label;
    }
    case 4:
    {
      struct sdshdr64 *sh_2 =
        (struct sdshdr64 *)(s - sizeof(struct sdshdr64));
      __retres = (size_t)(sh_2->alloc - sh_2->len);
      goto return_label;
    }
  }
  __retres = (size_t)0;
  return_label: return __retres;
}

__inline static void sdssetlen_2(sds s, size_t newlen)
{
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0:
    {
      unsigned char *fp = (unsigned char *)s - 1;
      *fp = (unsigned char)((unsigned int)0 | (newlen << 3));
    }
    break;
    case 1:
    ((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->len = (uint8_t)newlen;
    break;
    case 2:
    ((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->len = (uint16_t)newlen;
    break;
    case 3: ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->len = newlen;
    break;
    case 4:
    ((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->len = (uint64_t)newlen;
    break;
  }
  return;
}

__inline static void sdsinclen_2(sds s, size_t inc)
{
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0:
    {
      unsigned char *fp = (unsigned char *)s - 1;
      unsigned char newlen =
        (unsigned char)(((int)flags >> 3) + (int)((unsigned char)inc));
      *fp = (unsigned char)(0 | ((int)newlen << 3));
    }
    break;
    case 1:
    ((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->len = (uint8_t)(
    (int)((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->len + (int)((uint8_t)inc));
    break;
    case 2:
    ((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->len = (uint16_t)(
    (int)((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->len + (int)((uint16_t)inc));
    break;
    case 3: ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->len += inc;
    break;
    case 4:
    ((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->len += (uint64_t)inc;
    break;
  }
  return;
}

__inline static size_t sdsalloc_2(sds const s)
{
  size_t __retres;
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0: ;
    __retres = (size_t)((int)flags >> 3);
    goto return_label;
    case 1: ;
    __retres = (size_t)((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->alloc;
    goto return_label;
    case 2: ;
    __retres = (size_t)((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->alloc;
    goto return_label;
    case 3: ;
    __retres = ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->alloc;
    goto return_label;
    case 4: ;
    __retres = (size_t)((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->alloc;
    goto return_label;
  }
  __retres = (size_t)0;
  return_label: return __retres;
}

__inline static void sdssetalloc_2(sds s, size_t newlen)
{
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0: break;
    case 1:
    ((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->alloc = (uint8_t)newlen;
    break;
    case 2:
    ((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->alloc = (uint16_t)newlen;
    break;
    case 3:
    ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->alloc = newlen;
    break;
    case 4:
    ((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->alloc = (uint64_t)newlen;
    break;
  }
  return;
}

static void __redisReaderSetError(redisReader *r, int type, char const *str)
{
  size_t len;
  size_t tmp;
  if (r->reply != (void *)0) 
    if (r->fn) 
      if ((r->fn)->freeObject) {
        (*((r->fn)->freeObject))(r->reply);
        r->reply = (void *)0;
      }
  sdsfree(r->buf);
  r->buf = (char *)0;
  tmp = (size_t)0;
  r->len = tmp;
  r->pos = tmp;
  r->ridx = -1;
  r->err = type;
  len = strlen(str);
  if (len < sizeof(r->errstr) - (unsigned int)1) len = len;
  else len = sizeof(r->errstr) - (unsigned int)1;
  memcpy((void *)(r->errstr),(void const *)str,len);
  r->errstr[len] = (char)'\000';
  return;
}

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) âˆ¨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))), (indirect: param0);
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param0;
 */
int snprintf_va_7(char * restrict s, size_t n, char const * restrict format,
                  int param0);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) âˆ¨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_8(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) âˆ¨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_9(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) âˆ¨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_10(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) âˆ¨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_11(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) âˆ¨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_12(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) âˆ¨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))), (indirect: param0);
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param0;
 */
int snprintf_va_13(char * restrict s, size_t n, char const * restrict format,
                   int param0);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) âˆ¨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))), (indirect: param0);
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param0;
 */
int snprintf_va_14(char * restrict s, size_t n, char const * restrict format,
                   unsigned int param0);

static size_t chrtos(char *buf, size_t size, char byte)
{
  size_t len = (size_t)0;
  switch ((int)byte) {
    int tmp;
    int tmp_0;
    int tmp_1;
    int tmp_2;
    int tmp_3;
    int tmp_4;
    int tmp_7;
    case '\\': case '\"':
    { /* sequence */
      tmp = snprintf(buf,size,"\"\\%c\"",(int)byte); /* snprintf_va_7 */
      len = (size_t)tmp;
    }
    break;
    case '\n':
    { /* sequence */
      tmp_0 = snprintf(buf,size,"\"\\n\""); /* snprintf_va_8 */
      len = (size_t)tmp_0;
    }
    break;
    case '\r':
    { /* sequence */
      tmp_1 = snprintf(buf,size,"\"\\r\""); /* snprintf_va_9 */
      len = (size_t)tmp_1;
    }
    break;
    case '\t':
    { /* sequence */
      tmp_2 = snprintf(buf,size,"\"\\t\""); /* snprintf_va_10 */
      len = (size_t)tmp_2;
    }
    break;
    case '\a':
    { /* sequence */
      tmp_3 = snprintf(buf,size,"\"\\a\""); /* snprintf_va_11 */
      len = (size_t)tmp_3;
    }
    break;
    case '\b':
    { /* sequence */
      tmp_4 = snprintf(buf,size,"\"\\b\""); /* snprintf_va_12 */
      len = (size_t)tmp_4;
    }
    break;
    default: tmp_7 = isprint((int)byte);
    if (tmp_7) {
      int tmp_5;
      tmp_5 = snprintf(buf,size,"\"%c\"",(int)byte); /* snprintf_va_13 */
      len = (size_t)tmp_5;
    }
    else {
      int tmp_6;
      tmp_6 = snprintf(buf,size,"\"\\x%02x\"",
                       (unsigned int)((int)((unsigned char)byte))); /* snprintf_va_14 */
      len = (size_t)tmp_6;
    }
    break;
  }
  return len;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) âˆ¨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int snprintf_va_15(char * restrict s, size_t n, char const * restrict format,
                   char *param0);

static void __redisReaderSetErrorProtocolByte(redisReader *r, char byte)
{
  char cbuf[8];
  char sbuf[128];
  chrtos(cbuf,sizeof(cbuf),byte);
  snprintf(sbuf,sizeof(sbuf),"Protocol error, got %s as reply type byte",
           cbuf); /* snprintf_va_15 */
  __redisReaderSetError(r,4,(char const *)(sbuf));
  return;
}

static void __redisReaderSetErrorOOM(redisReader *r)
{
  __redisReaderSetError(r,5,"Out of memory");
  return;
}

static char *readBytes(redisReader *r, unsigned int bytes)
{
  char *__retres;
  char *p;
  if (r->len - r->pos >= bytes) {
    p = r->buf + r->pos;
    r->pos += bytes;
    __retres = p;
    goto return_label;
  }
  __retres = (char *)0;
  return_label: return __retres;
}

static char *seekNewline(char *s, size_t len)
{
  char *__retres;
  int pos = 0;
  int _len = (int)(len - (size_t)1);
  while (pos < _len) {
    while (1) {
      if (pos < _len) {
        if (! ((int)*(s + pos) != '\r')) break;
      }
      else break;
      pos ++;
    }
    if (pos == _len) {
      __retres = (char *)0;
      goto return_label;
    }
    else 
      if ((int)*(s + (pos + 1)) == '\n') {
        __retres = s + pos;
        goto return_label;
      }
      else pos ++;
  }
  __retres = (char *)0;
  return_label: return __retres;
}

static int string2ll(char const *s, size_t slen, long long *value)
{
  int __retres;
  unsigned long long v;
  char const *p = s;
  size_t plen = (size_t)0;
  int negative = 0;
  if (plen == slen) {
    __retres = -1;
    goto return_label;
  }
  if (slen == (size_t)1) 
    if ((int)*(p + 0) == '0') {
      if (value != (long long *)0) *value = (long long)0;
      __retres = 0;
      goto return_label;
    }
  if ((int)*(p + 0) == '-') {
    negative = 1;
    p ++;
    plen ++;
    if (plen == slen) {
      __retres = -1;
      goto return_label;
    }
  }
  if ((int)*(p + 0) >= '1') {
    if ((int)*(p + 0) <= '9') {
      v = (unsigned long long)((int)*(p + 0) - '0');
      p ++;
      plen ++;
    }
    else goto _LAND_0;
  }
  else {
    _LAND_0: ;
    if ((int)*(p + 0) == '0') {
      if (slen == (size_t)1) {
        *value = (long long)0;
        __retres = 0;
        goto return_label;
      }
      else goto _LAND;
    }
    else {
      _LAND: {
               __retres = -1;
               goto return_label;
             }
    }
  }
  while (1) {
    if (plen < slen) 
      if ((int)*(p + 0) >= '0') {
        if (! ((int)*(p + 0) <= '9')) break;
      }
      else break;
    else break;
    if (v > 18446744073709551615ULL / (unsigned long long)10) {
      __retres = -1;
      goto return_label;
    }
    v *= (unsigned long long)10;
    if (v > 18446744073709551615ULL - (unsigned long long)((int)*(p + 0) - '0')) {
      __retres = -1;
      goto return_label;
    }
    v += (unsigned long long)((int)*(p + 0) - '0');
    p ++;
    plen ++;
  }
  if (plen < slen) {
    __retres = -1;
    goto return_label;
  }
  if (negative) {
    if (v > (unsigned long long)(- ((-9223372036854775807LL - 1LL) + (long long)1)) + (unsigned long long)1) {
      __retres = -1;
      goto return_label;
    }
    if (value != (long long *)0) *value = (long long)(- v);
  }
  else {
    if (v > (unsigned long long)9223372036854775807LL) {
      __retres = -1;
      goto return_label;
    }
    if (value != (long long *)0) *value = (long long)v;
  }
  __retres = 0;
  return_label: return __retres;
}

static char *readLine(redisReader *r, int *_len)
{
  char *__retres;
  char *p;
  char *s;
  int len;
  p = r->buf + r->pos;
  s = seekNewline(p,r->len - r->pos);
  if (s != (char *)0) {
    len = s - (r->buf + r->pos);
    r->pos += (size_t)(len + 2);
    if (_len) *_len = len;
    __retres = p;
    goto return_label;
  }
  __retres = (char *)0;
  return_label: return __retres;
}

static void moveToNextTask(redisReader *r)
{
  redisReadTask *cur;
  redisReadTask *prv;
  while (r->ridx >= 0) {
    int tmp;
    if (r->ridx == 0) {
      (r->ridx) --;
      goto return_label;
    }
    cur = & r->rstack[r->ridx];
    prv = & r->rstack[r->ridx - 1];
    if (prv->type == 2) tmp = 1;
    else 
      if (prv->type == 9) tmp = 1;
      else 
        if (prv->type == 10) tmp = 1; else tmp = 0;
    __FC_assert(tmp != 0,"read.c",248,
                "prv->type == REDIS_REPLY_ARRAY || prv->type == REDIS_REPLY_MAP || prv->type == REDIS_REPLY_SET");
    if (cur->idx == prv->elements - 1) (r->ridx) --;
    else {
      __FC_assert((cur->idx < prv->elements) != 0,"read.c",255,
                  "cur->idx < prv->elements");
      cur->type = -1;
      cur->elements = -1;
      (cur->idx) ++;
      goto return_label;
    }
  }
  return_label: return;
}

static int processLineItem(redisReader *r)
{
  int __retres;
  void *obj;
  char *p;
  int len;
  redisReadTask *cur = & r->rstack[r->ridx];
  p = readLine(r,& len);
  if (p != (char *)0) {
    if (cur->type == 3) 
      if (r->fn) {
        if ((r->fn)->createInteger) {
          long long v;
          int tmp;
          tmp = string2ll((char const *)p,(size_t)len,& v);
          if (tmp == -1) {
            __redisReaderSetError(r,4,"Bad integer value");
            __retres = -1;
            goto return_label;
          }
          obj = (*((r->fn)->createInteger))((redisReadTask const *)cur,v);
        }
        else goto _LAND;
      }
      else _LAND: obj = (void *)3;
    else 
      if (cur->type == 7) 
        if (r->fn) {
          if ((r->fn)->createDouble) {
            char buf[326];
            char *eptr;
            double d;
            int tmp_4;
            if ((size_t)len >= sizeof(buf)) {
              __redisReaderSetError(r,4,"Double value is too large");
              __retres = -1;
              goto return_label;
            }
            memcpy((void *)(buf),(void const *)p,(size_t)len);
            buf[len] = (char)'\000';
            tmp_4 = strcasecmp((char const *)(buf),",inf");
            if (tmp_4 == 0) d = (double)INFINITY;
            else {
              int tmp_3;
              tmp_3 = strcasecmp((char const *)(buf),",-inf");
              if (tmp_3 == 0) d = (double)(- INFINITY);
              else {
                d = strtod((char const *)(buf),& eptr);
                if ((int)buf[0] == '\000') goto _LOR;
                else 
                  if ((int)*(eptr + 0) != '\000') goto _LOR;
                  else {
                    int tmp_2;
                    if (sizeof(d) == sizeof(float)) {
                      int tmp_0;
                      tmp_0 = __fc_fpclassifyf((float)d);
                      tmp_2 = tmp_0 == 0;
                    }
                    else {
                      int tmp_1;
                      tmp_1 = __fc_fpclassify(d);
                      tmp_2 = tmp_1 == 0;
                    }
                    if (tmp_2) {
                      _LOR:
                      {
                        __redisReaderSetError(r,4,"Bad double value");
                        __retres = -1;
                        goto return_label;
                      }
                    }
                  }
              }
            }
            obj = (*((r->fn)->createDouble))((redisReadTask const *)cur,d,
                                             buf,(size_t)len);
          }
          else goto _LAND_0;
        }
        else _LAND_0: obj = (void *)7;
      else 
        if (cur->type == 4) 
          if (r->fn) 
            if ((r->fn)->createNil) obj = (*((r->fn)->createNil))((redisReadTask const *)cur);
            else obj = (void *)4;
          else obj = (void *)4;
        else 
          if (cur->type == 8) {
            int tmp_5;
            if ((int)*(p + 0) == 't') tmp_5 = 1;
            else 
              if ((int)*(p + 0) == 'T') tmp_5 = 1; else tmp_5 = 0;
            int bval = tmp_5;
            if (r->fn) 
              if ((r->fn)->createBool) obj = (*((r->fn)->createBool))
                                       ((redisReadTask const *)cur,bval);
              else obj = (void *)8;
            else obj = (void *)8;
          }
          else 
            if (r->fn) 
              if ((r->fn)->createString) obj = (*((r->fn)->createString))
                                         ((redisReadTask const *)cur,p,
                                          (size_t)len);
              else obj = (void *)((size_t)cur->type);
            else obj = (void *)((size_t)cur->type);
    if (obj == (void *)0) {
      __redisReaderSetErrorOOM(r);
      __retres = -1;
      goto return_label;
    }
    if (r->ridx == 0) r->reply = obj;
    moveToNextTask(r);
    __retres = 0;
    goto return_label;
  }
  __retres = -1;
  return_label: return __retres;
}

static int processBulkItem(redisReader *r)
{
  int __retres;
  char *p;
  char *s;
  long long len;
  unsigned long bytelen;
  redisReadTask *cur = & r->rstack[r->ridx];
  void *obj = (void *)0;
  int success = 0;
  p = r->buf + r->pos;
  s = seekNewline(p,r->len - r->pos);
  if (s != (char *)0) {
    int tmp;
    p = r->buf + r->pos;
    bytelen = (unsigned long)((s - (r->buf + r->pos)) + 2);
    tmp = string2ll((char const *)p,(size_t)(bytelen - (unsigned long)2),
                    & len);
    if (tmp == -1) {
      __redisReaderSetError(r,4,"Bad bulk string length");
      __retres = -1;
      goto return_label;
    }
    if (len < (long long)(-1)) goto _LOR;
    else 
      if (9223372036854775807LL > (long long)4294967295U) 
        if (len > (long long)4294967295U) {
          _LOR:
          {
            __redisReaderSetError(r,4,"Bulk string length out of range");
            __retres = -1;
            goto return_label;
          }
        }
    if (len == (long long)(-1)) {
      if (r->fn) 
        if ((r->fn)->createNil) obj = (*((r->fn)->createNil))((redisReadTask const *)cur);
        else obj = (void *)4;
      else obj = (void *)4;
      success = 1;
    }
    else {
      bytelen = (unsigned long)((long long)bytelen + (len + (long long)2));
      if ((unsigned long)r->pos + bytelen <= (unsigned long)r->len) {
        if (r->fn) 
          if ((r->fn)->createString) obj = (*((r->fn)->createString))
                                     ((redisReadTask const *)cur,s + 2,
                                      (size_t)len);
          else obj = (void *)1;
        else obj = (void *)1;
        success = 1;
      }
    }
    if (success) {
      if (obj == (void *)0) {
        __redisReaderSetErrorOOM(r);
        __retres = -1;
        goto return_label;
      }
      r->pos = (size_t)((unsigned long)r->pos + bytelen);
      if (r->ridx == 0) r->reply = obj;
      moveToNextTask(r);
      __retres = 0;
      goto return_label;
    }
  }
  __retres = -1;
  return_label: return __retres;
}

static int processAggregateItem(redisReader *r)
{
  int __retres;
  void *obj;
  char *p;
  long long elements;
  int len;
  redisReadTask *cur = & r->rstack[r->ridx];
  int root = 0;
  if (r->ridx == 8) {
    __redisReaderSetError(r,4,
                          "No support for nested multi bulk replies with depth > 7");
    __retres = -1;
    goto return_label;
  }
  p = readLine(r,& len);
  if (p != (char *)0) {
    int tmp;
    tmp = string2ll((char const *)p,(size_t)len,& elements);
    if (tmp == -1) {
      __redisReaderSetError(r,4,"Bad multi-bulk length");
      __retres = -1;
      goto return_label;
    }
    root = r->ridx == 0;
    if (elements < (long long)(-1)) goto _LOR;
    else 
      if (9223372036854775807LL > (long long)4294967295U) 
        if (elements > (long long)4294967295U) {
          _LOR:
          {
            __redisReaderSetError(r,4,"Multi-bulk length out of range");
            __retres = -1;
            goto return_label;
          }
        }
    if (elements == (long long)(-1)) {
      if (r->fn) 
        if ((r->fn)->createNil) obj = (*((r->fn)->createNil))((redisReadTask const *)cur);
        else obj = (void *)4;
      else obj = (void *)4;
      if (obj == (void *)0) {
        __redisReaderSetErrorOOM(r);
        __retres = -1;
        goto return_label;
      }
      moveToNextTask(r);
    }
    else {
      if (cur->type == 9) elements *= (long long)2;
      if (r->fn) 
        if ((r->fn)->createArray) obj = (*((r->fn)->createArray))((redisReadTask const *)cur,
                                                                  (size_t)elements);
        else obj = (void *)((long)cur->type);
      else obj = (void *)((long)cur->type);
      if (obj == (void *)0) {
        __redisReaderSetErrorOOM(r);
        __retres = -1;
        goto return_label;
      }
      if (elements > (long long)0) {
        cur->elements = (int)elements;
        cur->obj = obj;
        (r->ridx) ++;
        r->rstack[r->ridx].type = -1;
        r->rstack[r->ridx].elements = -1;
        r->rstack[r->ridx].idx = 0;
        r->rstack[r->ridx].obj = (void *)0;
        r->rstack[r->ridx].parent = cur;
        r->rstack[r->ridx].privdata = r->privdata;
      }
      else moveToNextTask(r);
    }
    if (root) r->reply = obj;
    __retres = 0;
    goto return_label;
  }
  __retres = -1;
  return_label: return __retres;
}

static int processItem(redisReader *r)
{
  int __retres;
  char *p;
  redisReadTask *cur = & r->rstack[r->ridx];
  if (cur->type < 0) {
    p = readBytes(r,(unsigned int)1);
    if (p != (char *)0) 
      switch ((int)*(p + 0)) {
        case '-': cur->type = 6;
        break;
        case '+': cur->type = 5;
        break;
        case ':': cur->type = 3;
        break;
        case ',': cur->type = 7;
        break;
        case '_': cur->type = 4;
        break;
        case '$': cur->type = 1;
        break;
        case '*': cur->type = 2;
        break;
        case '%': cur->type = 9;
        break;
        case '~': cur->type = 10;
        break;
        case '#': cur->type = 8;
        break;
        default: __redisReaderSetErrorProtocolByte(r,*p);
        __retres = -1;
        goto return_label;
      }
    else {
      __retres = -1;
      goto return_label;
    }
  }
  switch (cur->type) {
    int tmp;
    int tmp_0;
    int tmp_1;
    case 6: case 5: case 3: case 7: case 4: case 8: tmp = processLineItem(r);
    __retres = tmp;
    goto return_label;
    case 1: tmp_0 = processBulkItem(r);
    __retres = tmp_0;
    goto return_label;
    case 2: case 9: case 10: tmp_1 = processAggregateItem(r);
    __retres = tmp_1;
    goto return_label;
    default: __FC_assert((void *)0 != (void *)0,"read.c",553,"NULL");
    __retres = -1;
    goto return_label;
  }
  return_label: return __retres;
}

redisReader *redisReaderCreateWithFunctions(redisReplyObjectFunctions *fn)
{
  redisReader *__retres;
  redisReader *r;
  r = (redisReader *)calloc((size_t)1,sizeof(redisReader));
  if (r == (redisReader *)0) {
    __retres = (redisReader *)0;
    goto return_label;
  }
  r->fn = fn;
  r->buf = sdsempty();
  r->maxbuf = (size_t)(1024 * 16);
  if (r->buf == (char *)0) {
    free((void *)r);
    __retres = (redisReader *)0;
    goto return_label;
  }
  r->ridx = -1;
  __retres = r;
  return_label: return __retres;
}

void redisReaderFree(redisReader *r)
{
  if (r == (redisReader *)0) goto return_label;
  if (r->reply != (void *)0) 
    if (r->fn) 
      if ((r->fn)->freeObject) (*((r->fn)->freeObject))(r->reply);
  sdsfree(r->buf);
  free((void *)r);
  return_label: return;
}

int redisReaderFeed(redisReader *r, char const *buf, size_t len)
{
  int __retres;
  sds newbuf;
  if (r->err) {
    __retres = -1;
    goto return_label;
  }
  if (buf != (char const *)0) 
    if (len >= (size_t)1) {
      if (r->len == (size_t)0) 
        if (r->maxbuf != (size_t)0) {
          size_t tmp;
          tmp = sdsavail_2(r->buf);
          ;
          if (tmp > r->maxbuf) {
            sdsfree(r->buf);
            r->buf = sdsempty();
            r->pos = (size_t)0;
            __FC_assert((r->buf != (char *)0) != 0,"read.c",602,
                        "r->buf != NULL");
          }
        }
      newbuf = sdscatlen(r->buf,(void const *)buf,len);
      if (newbuf == (sds)0) {
        __redisReaderSetErrorOOM(r);
        __retres = -1;
        goto return_label;
      }
      r->buf = newbuf;
      r->len = sdslen_2(r->buf);
    }
  __retres = 0;
  return_label: return __retres;
}

int redisReaderGetReply(redisReader *r, void **reply)
{
  int __retres;
  if (reply != (void **)0) *reply = (void *)0;
  if (r->err) {
    __retres = -1;
    goto return_label;
  }
  if (r->len == (size_t)0) {
    __retres = 0;
    goto return_label;
  }
  if (r->ridx == -1) {
    r->rstack[0].type = -1;
    r->rstack[0].elements = -1;
    r->rstack[0].idx = -1;
    r->rstack[0].obj = (void *)0;
    r->rstack[0].parent = (struct redisReadTask *)0;
    r->rstack[0].privdata = r->privdata;
    r->ridx = 0;
  }
  while (r->ridx >= 0) {
    int tmp;
    tmp = processItem(r);
    if (tmp != 0) break;
  }
  if (r->err) {
    __retres = -1;
    goto return_label;
  }
  if (r->pos >= (size_t)1024) {
    sdsrange(r->buf,(int)r->pos,-1);
    r->pos = (size_t)0;
    r->len = sdslen_2(r->buf);
  }
  if (r->ridx == -1) {
    if (reply != (void **)0) *reply = r->reply;
    else 
      if (r->reply != (void *)0) 
        if (r->fn) 
          if ((r->fn)->freeObject) (*((r->fn)->freeObject))(r->reply);
    r->reply = (void *)0;
  }
  __retres = 0;
  return_label: return __retres;
}

__inline static size_t sdslen_3(sds const s)
{
  size_t __retres;
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0: ;
    __retres = (size_t)((int)flags >> 3);
    goto return_label;
    case 1: ;
    __retres = (size_t)((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->len;
    goto return_label;
    case 2: ;
    __retres = (size_t)((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->len;
    goto return_label;
    case 3: ;
    __retres = ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->len;
    goto return_label;
    case 4: ;
    __retres = (size_t)((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->len;
    goto return_label;
  }
  __retres = (size_t)0;
  return_label: return __retres;
}

__inline static size_t sdsavail_3(sds const s)
{
  size_t __retres;
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0: {
              __retres = (size_t)0;
              goto return_label;
            }
    case 1:
    {
      struct sdshdr8 *sh = (struct sdshdr8 *)(s - sizeof(struct sdshdr8));
      __retres = (size_t)((int)sh->alloc - (int)sh->len);
      goto return_label;
    }
    case 2:
    {
      struct sdshdr16 *sh_0 =
        (struct sdshdr16 *)(s - sizeof(struct sdshdr16));
      __retres = (size_t)((int)sh_0->alloc - (int)sh_0->len);
      goto return_label;
    }
    case 3:
    {
      struct sdshdr32 *sh_1 =
        (struct sdshdr32 *)(s - sizeof(struct sdshdr32));
      __retres = sh_1->alloc - sh_1->len;
      goto return_label;
    }
    case 4:
    {
      struct sdshdr64 *sh_2 =
        (struct sdshdr64 *)(s - sizeof(struct sdshdr64));
      __retres = (size_t)(sh_2->alloc - sh_2->len);
      goto return_label;
    }
  }
  __retres = (size_t)0;
  return_label: return __retres;
}

__inline static void sdssetlen_3(sds s, size_t newlen)
{
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0:
    {
      unsigned char *fp = (unsigned char *)s - 1;
      *fp = (unsigned char)((unsigned int)0 | (newlen << 3));
    }
    break;
    case 1:
    ((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->len = (uint8_t)newlen;
    break;
    case 2:
    ((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->len = (uint16_t)newlen;
    break;
    case 3: ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->len = newlen;
    break;
    case 4:
    ((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->len = (uint64_t)newlen;
    break;
  }
  return;
}

__inline static void sdsinclen_3(sds s, size_t inc)
{
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0:
    {
      unsigned char *fp = (unsigned char *)s - 1;
      unsigned char newlen =
        (unsigned char)(((int)flags >> 3) + (int)((unsigned char)inc));
      *fp = (unsigned char)(0 | ((int)newlen << 3));
    }
    break;
    case 1:
    ((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->len = (uint8_t)(
    (int)((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->len + (int)((uint8_t)inc));
    break;
    case 2:
    ((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->len = (uint16_t)(
    (int)((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->len + (int)((uint16_t)inc));
    break;
    case 3: ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->len += inc;
    break;
    case 4:
    ((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->len += (uint64_t)inc;
    break;
  }
  return;
}

__inline static size_t sdsalloc_3(sds const s)
{
  size_t __retres;
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0: ;
    __retres = (size_t)((int)flags >> 3);
    goto return_label;
    case 1: ;
    __retres = (size_t)((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->alloc;
    goto return_label;
    case 2: ;
    __retres = (size_t)((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->alloc;
    goto return_label;
    case 3: ;
    __retres = ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->alloc;
    goto return_label;
    case 4: ;
    __retres = (size_t)((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->alloc;
    goto return_label;
  }
  __retres = (size_t)0;
  return_label: return __retres;
}

__inline static void sdssetalloc_3(sds s, size_t newlen)
{
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0: break;
    case 1:
    ((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->alloc = (uint8_t)newlen;
    break;
    case 2:
    ((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->alloc = (uint16_t)newlen;
    break;
    case 3:
    ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->alloc = newlen;
    break;
    case 4:
    ((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->alloc = (uint64_t)newlen;
    break;
  }
  return;
}

__inline static int sdsHdrSize(char type)
{
  int __retres;
  switch ((int)type & 7) {
    case 0: __retres = (int)sizeof(struct sdshdr5);
    goto return_label;
    case 1: __retres = (int)sizeof(struct sdshdr8);
    goto return_label;
    case 2: __retres = (int)sizeof(struct sdshdr16);
    goto return_label;
    case 3: __retres = (int)sizeof(struct sdshdr32);
    goto return_label;
    case 4: __retres = (int)sizeof(struct sdshdr64);
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

__inline static char sdsReqType(size_t string_size)
{
  char __retres;
  if (string_size < (size_t)32) {
    __retres = (char)0;
    goto return_label;
  }
  if (string_size < (size_t)0xff) {
    __retres = (char)1;
    goto return_label;
  }
  if (string_size < (size_t)0xffff) {
    __retres = (char)2;
    goto return_label;
  }
  if (string_size < 0xffffffff) {
    __retres = (char)3;
    goto return_label;
  }
  __retres = (char)4;
  return_label: return __retres;
}

sds sdsnewlen(void const *init, size_t initlen)
{
  sds __retres;
  void *sh;
  sds s;
  unsigned char *fp;
  char type = sdsReqType(initlen);
  if ((int)type == 0) 
    if (initlen == (size_t)0) type = (char)1;
  int hdrlen = sdsHdrSize(type);
  sh = malloc(((size_t)hdrlen + initlen) + (size_t)1);
  if (sh == (void *)0) {
    __retres = (sds)0;
    goto return_label;
  }
  if (! init) memset(sh,0,((size_t)hdrlen + initlen) + (size_t)1);
  s = (char *)sh + hdrlen;
  fp = (unsigned char *)s - 1;
  switch ((int)type) {
    case 0:
    {
      *fp = (unsigned char)((unsigned int)type | (initlen << 3));
      break;
    }
    case 1:
    {
      struct sdshdr8 *sh_0 = (struct sdshdr8 *)(s - sizeof(struct sdshdr8));
      sh_0->len = (uint8_t)initlen;
      sh_0->alloc = (uint8_t)initlen;
      *fp = (unsigned char)type;
      break;
    }
    case 2:
    {
      struct sdshdr16 *sh_1 =
        (struct sdshdr16 *)(s - sizeof(struct sdshdr16));
      sh_1->len = (uint16_t)initlen;
      sh_1->alloc = (uint16_t)initlen;
      *fp = (unsigned char)type;
      break;
    }
    case 3:
    {
      struct sdshdr32 *sh_2 =
        (struct sdshdr32 *)(s - sizeof(struct sdshdr32));
      sh_2->len = initlen;
      sh_2->alloc = initlen;
      *fp = (unsigned char)type;
      break;
    }
    case 4:
    {
      struct sdshdr64 *sh_3 =
        (struct sdshdr64 *)(s - sizeof(struct sdshdr64));
      sh_3->len = (uint64_t)initlen;
      sh_3->alloc = (uint64_t)initlen;
      *fp = (unsigned char)type;
      break;
    }
  }
  if (initlen) 
    if (init) memcpy((void *)s,init,initlen);
  *(s + initlen) = (char)'\000';
  __retres = s;
  return_label: return __retres;
}

sds sdsempty(void)
{
  sds tmp;
  tmp = sdsnewlen((void const *)"",(size_t)0);
  return tmp;
}

sds sdsnew(char const *init)
{
  size_t tmp_0;
  sds tmp_1;
  if (init == (char const *)0) tmp_0 = (size_t)0; else tmp_0 = strlen(init);
  size_t initlen = tmp_0;
  tmp_1 = sdsnewlen((void const *)init,initlen);
  return tmp_1;
}

sds sdsdup(sds const s)
{
  sds tmp_0;
  size_t tmp;
  tmp = sdslen_3(s);
  ;
  tmp_0 = sdsnewlen((void const *)s,tmp);
  return tmp_0;
}

void sdsfree(sds s)
{
  int tmp;
  if (s == (sds)0) goto return_label;
  tmp = sdsHdrSize(*(s + -1));
  ;
  free((void *)(s - tmp));
  return_label: return;
}

void sdsupdatelen(sds s)
{
  size_t tmp;
  tmp = strlen((char const *)s);
  int reallen = (int)tmp;
  sdssetlen_3(s,(size_t)reallen);
  return;
}

void sdsclear(sds s)
{
  sdssetlen_3(s,(size_t)0);
  *(s + 0) = (char)'\000';
  return;
}

sds sdsMakeRoomFor(sds s, size_t addlen)
{
  sds __retres;
  void *sh;
  void *newsh;
  size_t len;
  size_t newlen;
  char type;
  int hdrlen;
  int tmp_0;
  size_t avail = sdsavail_3(s);
  char oldtype = (char)((int)*(s + -1) & 7);
  if (avail >= addlen) {
    __retres = s;
    goto return_label;
  }
  len = sdslen_3(s);
  tmp_0 = sdsHdrSize(oldtype);
  sh = (void *)(s - tmp_0);
  newlen = len + addlen;
  if (newlen < (size_t)(1024 * 1024)) newlen *= (size_t)2;
  else newlen += (size_t)(1024 * 1024);
  type = sdsReqType(newlen);
  if ((int)type == 0) type = (char)1;
  hdrlen = sdsHdrSize(type);
  if ((int)oldtype == (int)type) {
    newsh = realloc(sh,((size_t)hdrlen + newlen) + (size_t)1);
    if (newsh == (void *)0) {
      free(sh);
      __retres = (sds)0;
      goto return_label;
    }
    s = (char *)newsh + hdrlen;
  }
  else {
    newsh = malloc(((size_t)hdrlen + newlen) + (size_t)1);
    if (newsh == (void *)0) {
      __retres = (sds)0;
      goto return_label;
    }
    memcpy((void *)((char *)newsh + hdrlen),(void const *)s,len + (size_t)1);
    free(sh);
    s = (char *)newsh + hdrlen;
    *(s + -1) = type;
    sdssetlen_3(s,len);
  }
  sdssetalloc_3(s,newlen);
  __retres = s;
  return_label: return __retres;
}

sds sdsRemoveFreeSpace(sds s)
{
  sds __retres;
  void *sh;
  void *newsh;
  char type;
  int hdrlen;
  int tmp_0;
  char oldtype = (char)((int)*(s + -1) & 7);
  size_t len = sdslen_3(s);
  tmp_0 = sdsHdrSize(oldtype);
  sh = (void *)(s - tmp_0);
  type = sdsReqType(len);
  hdrlen = sdsHdrSize(type);
  if ((int)oldtype == (int)type) {
    newsh = realloc(sh,((size_t)hdrlen + len) + (size_t)1);
    if (newsh == (void *)0) {
      __retres = (sds)0;
      goto return_label;
    }
    s = (char *)newsh + hdrlen;
  }
  else {
    newsh = malloc(((size_t)hdrlen + len) + (size_t)1);
    if (newsh == (void *)0) {
      __retres = (sds)0;
      goto return_label;
    }
    memcpy((void *)((char *)newsh + hdrlen),(void const *)s,len + (size_t)1);
    free(sh);
    s = (char *)newsh + hdrlen;
    *(s + -1) = type;
    sdssetlen_3(s,len);
  }
  sdssetalloc_3(s,len);
  __retres = s;
  return_label: return __retres;
}

size_t sdsAllocSize(sds s)
{
  size_t __retres;
  int tmp_0;
  size_t alloc = sdsalloc_3(s);
  tmp_0 = sdsHdrSize(*(s + -1));
  ;
  __retres = ((size_t)tmp_0 + alloc) + (size_t)1;
  return __retres;
}

void *sdsAllocPtr(sds s)
{
  void *__retres;
  int tmp;
  tmp = sdsHdrSize(*(s + -1));
  ;
  __retres = (void *)(s - tmp);
  return __retres;
}

void sdsIncrLen(sds s, int incr)
{
  size_t len;
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0:
    {
      int tmp;
      unsigned char *fp = (unsigned char *)s - 1;
      unsigned char oldlen = (unsigned char)((int)flags >> 3);
      if (incr > 0) {
        if ((int)oldlen + incr < 32) tmp = 1; else goto _LAND;
      }
      else {
        _LAND: ;
        if (incr < 0) 
          if ((unsigned int)oldlen >= (unsigned int)(- incr)) tmp = 1;
          else tmp = 0;
        else tmp = 0;
      }
      __FC_assert(tmp != 0,"sds.c",322,
                  "(incr > 0 && oldlen+incr < 32) || (incr < 0 && oldlen >= (unsigned int)(-incr))");
      *fp = (unsigned char)(0 | (((int)oldlen + incr) << 3));
      len = (size_t)((int)oldlen + incr);
      break;
    }
    case 1:
    {
      int tmp_0;
      struct sdshdr8 *sh = (struct sdshdr8 *)(s - sizeof(struct sdshdr8));
      if (incr >= 0) {
        if ((int)sh->alloc - (int)sh->len >= incr) tmp_0 = 1;
        else goto _LAND_0;
      }
      else {
        _LAND_0: ;
        if (incr < 0) 
          if ((unsigned int)sh->len >= (unsigned int)(- incr)) tmp_0 = 1;
          else tmp_0 = 0;
        else tmp_0 = 0;
      }
      __FC_assert(tmp_0 != 0,"sds.c",329,
                  "(incr >= 0 && sh->alloc-sh->len >= incr) || (incr < 0 && sh->len >= (unsigned int)(-incr))");
      sh->len = (uint8_t)((int)sh->len + incr);
      len = (size_t)sh->len;
      break;
    }
    case 2:
    {
      int tmp_1;
      struct sdshdr16 *sh_0 =
        (struct sdshdr16 *)(s - sizeof(struct sdshdr16));
      if (incr >= 0) {
        if ((int)sh_0->alloc - (int)sh_0->len >= incr) tmp_1 = 1;
        else goto _LAND_1;
      }
      else {
        _LAND_1: ;
        if (incr < 0) 
          if ((unsigned int)sh_0->len >= (unsigned int)(- incr)) tmp_1 = 1;
          else tmp_1 = 0;
        else tmp_1 = 0;
      }
      __FC_assert(tmp_1 != 0,"sds.c",335,
                  "(incr >= 0 && sh->alloc-sh->len >= incr) || (incr < 0 && sh->len >= (unsigned int)(-incr))");
      sh_0->len = (uint16_t)((int)sh_0->len + incr);
      len = (size_t)sh_0->len;
      break;
    }
    case 3:
    {
      int tmp_2;
      struct sdshdr32 *sh_1 =
        (struct sdshdr32 *)(s - sizeof(struct sdshdr32));
      if (incr >= 0) {
        if (sh_1->alloc - sh_1->len >= (unsigned int)incr) tmp_2 = 1;
        else goto _LAND_2;
      }
      else {
        _LAND_2: ;
        if (incr < 0) 
          if (sh_1->len >= (unsigned int)(- incr)) tmp_2 = 1; else tmp_2 = 0;
        else tmp_2 = 0;
      }
      __FC_assert(tmp_2 != 0,"sds.c",341,
                  "(incr >= 0 && sh->alloc-sh->len >= (unsigned int)incr) || (incr < 0 && sh->len >= (unsigned int)(-incr))");
      sh_1->len += (uint32_t)incr;
      len = sh_1->len;
      break;
    }
    case 4:
    {
      int tmp_3;
      struct sdshdr64 *sh_2 =
        (struct sdshdr64 *)(s - sizeof(struct sdshdr64));
      if (incr >= 0) {
        if (sh_2->alloc - sh_2->len >= (uint64_t)incr) tmp_3 = 1;
        else goto _LAND_3;
      }
      else {
        _LAND_3: ;
        if (incr < 0) 
          if (sh_2->len >= (uint64_t)(- incr)) tmp_3 = 1; else tmp_3 = 0;
        else tmp_3 = 0;
      }
      __FC_assert(tmp_3 != 0,"sds.c",347,
                  "(incr >= 0 && sh->alloc-sh->len >= (uint64_t)incr) || (incr < 0 && sh->len >= (uint64_t)(-incr))");
      sh_2->len += (uint64_t)incr;
      len = (size_t)sh_2->len;
      break;
    }
    default: len = (size_t)0;
  }
  *(s + len) = (char)'\000';
  return;
}

sds sdsgrowzero(sds s, size_t len)
{
  sds __retres;
  size_t curlen = sdslen_3(s);
  if (len <= curlen) {
    __retres = s;
    goto return_label;
  }
  s = sdsMakeRoomFor(s,len - curlen);
  if (s == (sds)0) {
    __retres = (sds)0;
    goto return_label;
  }
  memset((void *)(s + curlen),0,(len - curlen) + (size_t)1);
  sdssetlen_3(s,len);
  __retres = s;
  return_label: return __retres;
}

sds sdscatlen(sds s, void const *t, size_t len)
{
  sds __retres;
  size_t curlen = sdslen_3(s);
  s = sdsMakeRoomFor(s,len);
  if (s == (sds)0) {
    __retres = (sds)0;
    goto return_label;
  }
  memcpy((void *)(s + curlen),t,len);
  sdssetlen_3(s,curlen + len);
  *(s + (curlen + len)) = (char)'\000';
  __retres = s;
  return_label: return __retres;
}

sds sdscat(sds s, char const *t)
{
  sds tmp_0;
  size_t tmp;
  tmp = strlen(t);
  ;
  ;
  tmp_0 = sdscatlen(s,(void const *)t,tmp);
  return tmp_0;
}

sds sdscatsds(sds s, sds const t)
{
  sds tmp_0;
  size_t tmp;
  tmp = sdslen_3(t);
  ;
  ;
  tmp_0 = sdscatlen(s,(void const *)t,tmp);
  return tmp_0;
}

sds sdscpylen(sds s, char const *t, size_t len)
{
  sds __retres;
  size_t tmp_0;
  tmp_0 = sdsalloc_3(s);
  ;
  if (tmp_0 < len) {
    size_t tmp;
    tmp = sdslen_3(s);
    ;
    s = sdsMakeRoomFor(s,len - tmp);
    if (s == (sds)0) {
      __retres = (sds)0;
      goto return_label;
    }
  }
  memcpy((void *)s,(void const *)t,len);
  *(s + len) = (char)'\000';
  sdssetlen_3(s,len);
  __retres = s;
  return_label: return __retres;
}

sds sdscpy(sds s, char const *t)
{
  sds tmp_0;
  size_t tmp;
  tmp = strlen(t);
  ;
  ;
  tmp_0 = sdscpylen(s,t,tmp);
  return tmp_0;
}

int sdsll2str(char *s, long long value)
{
  int __retres;
  char *p;
  char aux;
  unsigned long long v;
  size_t l;
  if (value < (long long)0) v = (unsigned long long)(- value);
  else v = (unsigned long long)value;
  p = s;
  while (1) {
    {
      char *tmp;
      tmp = p;
      p ++;
      *tmp = (char)((unsigned long long)'0' + v % (unsigned long long)10);
      v /= (unsigned long long)10;
    }
    if (! v) break;
  }
  if (value < (long long)0) {
    char *tmp_0;
    tmp_0 = p;
    p ++;
    *tmp_0 = (char)'-';
  }
  l = (size_t)(p - s);
  *p = (char)'\000';
  p --;
  while (s < p) {
    aux = *s;
    *s = *p;
    *p = aux;
    s ++;
    p --;
  }
  __retres = (int)l;
  return __retres;
}

int sdsull2str(char *s, unsigned long long v)
{
  int __retres;
  char *p;
  char aux;
  size_t l;
  p = s;
  while (1) {
    {
      char *tmp;
      tmp = p;
      p ++;
      *tmp = (char)((unsigned long long)'0' + v % (unsigned long long)10);
      v /= (unsigned long long)10;
    }
    if (! v) break;
  }
  l = (size_t)(p - s);
  *p = (char)'\000';
  p --;
  while (s < p) {
    aux = *s;
    *s = *p;
    *p = aux;
    s ++;
    p --;
  }
  __retres = (int)l;
  return __retres;
}

sds sdsfromlonglong(long long value)
{
  char buf[21];
  sds tmp_0;
  int len = sdsll2str(buf,value);
  tmp_0 = sdsnewlen((void const *)(buf),(size_t)len);
  return tmp_0;
}

sds sdscatvprintf(sds s, char const *fmt, va_list ap)
{
  sds __retres;
  va_list cpy;
  char staticbuf[1024];
  char *t;
  size_t tmp;
  char *buf = staticbuf;
  tmp = strlen(fmt);
  size_t buflen = tmp * (size_t)2;
  if (buflen > sizeof(staticbuf)) {
    buf = (char *)malloc(buflen);
    if (buf == (char *)0) {
      __retres = (sds)0;
      goto return_label;
    }
  }
  else buflen = sizeof(staticbuf);
  while (1) {
    *(buf + (buflen - (size_t)2)) = (char)'\000';
    cpy = ap;
    vsnprintf(buf,buflen,fmt,cpy);
    if ((int)*(buf + (buflen - (size_t)2)) != '\000') {
      if (buf != staticbuf) free((void *)buf);
      buflen *= (size_t)2;
      buf = (char *)malloc(buflen);
      if (buf == (char *)0) {
        __retres = (sds)0;
        goto return_label;
      }
      continue;
    }
    break;
  }
  t = sdscat(s,(char const *)buf);
  if (buf != staticbuf) free((void *)buf);
  __retres = t;
  return_label: return __retres;
}

sds ( /* format attribute */ sdscatprintf)(sds s, char const *fmt,
                                           void * const *__va_params)
{
  va_list ap;
  char *t;
  ap = __va_params;
  t = sdscatvprintf(s,fmt,ap);
  return t;
}

sds sdscatfmt(sds s, char const *fmt, void * const *__va_params)
{
  sds __retres;
  int i;
  va_list ap;
  size_t tmp;
  char const *f = fmt;
  ap = __va_params;
  tmp = sdslen_3(s);
  i = (int)tmp;
  while (*f) {
    char next;
    char *str;
    size_t l;
    long long num;
    unsigned long long unum;
    size_t tmp_0;
    tmp_0 = sdsavail_3(s);
    if (tmp_0 == (size_t)0) {
      s = sdsMakeRoomFor(s,(size_t)1);
      if (s == (sds)0) goto fmt_error;
    }
    switch ((int)*f) {
      int tmp_9;
      case '%': next = *(f + 1);
      f ++;
      switch ((int)next) {
        size_t tmp_3;
        int tmp_8;
        case 's': case 'S': {
                              str = *((char **)*ap);
                              ap ++;
                            }
        if ((int)next == 's') l = strlen((char const *)str);
        else l = sdslen_3(str);
        tmp_3 = sdsavail_3(s);
        ;
        if (tmp_3 < l) {
          s = sdsMakeRoomFor(s,l);
          if (s == (sds)0) goto fmt_error;
        }
        memcpy((void *)(s + i),(void const *)str,l);
        sdsinclen_3(s,l);
        i = (int)((size_t)i + l);
        break;
        case 'i': case 'I': ;
        if ((int)next == 'i') {
          num = (long long)*((int *)*ap);
          ap ++;
        }
        else {
          num = *((long long *)*ap);
          ap ++;
        }
        {
          char buf[21];
          int tmp_4;
          size_t tmp_5;
          tmp_4 = sdsll2str(buf,num);
          l = (size_t)tmp_4;
          tmp_5 = sdsavail_3(s);
          ;
          if (tmp_5 < l) {
            s = sdsMakeRoomFor(s,l);
            if (s == (sds)0) goto fmt_error;
          }
          memcpy((void *)(s + i),(void const *)(buf),l);
          sdsinclen_3(s,l);
          i = (int)((size_t)i + l);
        }
        break;
        case 'u': case 'U': ;
        if ((int)next == 'u') {
          unum = (unsigned long long)*((unsigned int *)*ap);
          ap ++;
        }
        else {
          unum = *((unsigned long long *)*ap);
          ap ++;
        }
        {
          char buf_0[21];
          int tmp_6;
          size_t tmp_7;
          tmp_6 = sdsull2str(buf_0,unum);
          l = (size_t)tmp_6;
          tmp_7 = sdsavail_3(s);
          ;
          if (tmp_7 < l) {
            s = sdsMakeRoomFor(s,l);
            if (s == (sds)0) goto fmt_error;
          }
          memcpy((void *)(s + i),(void const *)(buf_0),l);
          sdsinclen_3(s,l);
          i = (int)((size_t)i + l);
        }
        break;
        default: { /* sequence */
                   tmp_8 = i;
                   i ++;
                   *(s + tmp_8) = next;
                 }
        sdsinclen_3(s,(size_t)1);
        break;
      }
      break;
      default: { /* sequence */
                 tmp_9 = i;
                 i ++;
                 *(s + tmp_9) = *f;
               }
      sdsinclen_3(s,(size_t)1);
      break;
    }
    f ++;
  }
  *(s + i) = (char)'\000';
  __retres = s;
  goto return_label;
  fmt_error: ;
  __retres = (sds)0;
  return_label: return __retres;
}

sds sdstrim(sds s, char const *cset)
{
  char *start;
  char *end;
  char *sp;
  char *ep;
  size_t len;
  size_t tmp;
  start = s;
  sp = start;
  tmp = sdslen_3(s);
  end = (s + tmp) - 1;
  ep = end;
  while (1) {
    if (sp <= end) {
      char *tmp_0;
      tmp_0 = strchr(cset,(int)*sp);
      if (! tmp_0) break;
    }
    else break;
    sp ++;
  }
  while (1) {
    if (ep > sp) {
      char *tmp_1;
      tmp_1 = strchr(cset,(int)*ep);
      if (! tmp_1) break;
    }
    else break;
    ep --;
  }
  if (sp > ep) len = (size_t)0; else len = (size_t)((ep - sp) + 1);
  if (s != sp) memmove((void *)s,(void const *)sp,len);
  *(s + len) = (char)'\000';
  sdssetlen_3(s,len);
  return s;
}

void sdsrange(sds s, int start, int end)
{
  size_t newlen;
  size_t len = sdslen_3(s);
  if (len == (size_t)0) goto return_label;
  if (start < 0) {
    start = (int)(len + (size_t)start);
    if (start < 0) start = 0;
  }
  if (end < 0) {
    end = (int)(len + (size_t)end);
    if (end < 0) end = 0;
  }
  if (start > end) newlen = (size_t)0;
  else newlen = (size_t)((end - start) + 1);
  if (newlen != (size_t)0) {
    if (start >= (int)len) newlen = (size_t)0;
    else 
      if (end >= (int)len) {
        end = (int)(len - (size_t)1);
        if (start > end) newlen = (size_t)0;
        else newlen = (size_t)((end - start) + 1);
      }
  }
  else start = 0;
  if (start) 
    if (newlen) memmove((void *)s,(void const *)(s + start),newlen);
  *(s + newlen) = (char)0;
  sdssetlen_3(s,newlen);
  return_label: return;
}

void sdstolower(sds s)
{
  size_t tmp;
  int j;
  tmp = sdslen_3(s);
  int len = (int)tmp;
  j = 0;
  while (j < len) {
    int tmp_0;
    tmp_0 = tolower((int)*(s + j));
    *(s + j) = (char)tmp_0;
    j ++;
  }
  return;
}

void sdstoupper(sds s)
{
  size_t tmp;
  int j;
  tmp = sdslen_3(s);
  int len = (int)tmp;
  j = 0;
  while (j < len) {
    int tmp_0;
    tmp_0 = toupper((int)*(s + j));
    *(s + j) = (char)tmp_0;
    j ++;
  }
  return;
}

int sdscmp(sds const s1, sds const s2)
{
  int __retres;
  size_t l1;
  size_t l2;
  size_t minlen;
  int cmp;
  l1 = sdslen_3(s1);
  l2 = sdslen_3(s2);
  if (l1 < l2) minlen = l1; else minlen = l2;
  cmp = memcmp((void const *)s1,(void const *)s2,minlen);
  if (cmp == 0) {
    __retres = (int)(l1 - l2);
    goto return_label;
  }
  __retres = cmp;
  return_label: return __retres;
}

sds *sdssplitlen(char const *s, int len, char const *sep, int seplen,
                 int *count)
{
  sds *__retres;
  int j;
  sds *tokens;
  int elements = 0;
  int slots = 5;
  int start = 0;
  if (seplen < 1) {
    __retres = (sds *)0;
    goto return_label;
  }
  else 
    if (len < 0) {
      __retres = (sds *)0;
      goto return_label;
    }
  tokens = (sds *)malloc(sizeof(sds) * (unsigned int)slots);
  if (tokens == (sds *)0) {
    __retres = (sds *)0;
    goto return_label;
  }
  if (len == 0) {
    *count = 0;
    __retres = tokens;
    goto return_label;
  }
  j = 0;
  while (j < len - (seplen - 1)) {
    if (slots < elements + 2) {
      sds *newtokens;
      slots *= 2;
      newtokens = (sds *)realloc((void *)tokens,
                                 sizeof(sds) * (unsigned int)slots);
      if (newtokens == (sds *)0) goto cleanup;
      tokens = newtokens;
    }
    if (seplen == 1) {
      if ((int)*(s + j) == (int)*(sep + 0)) goto _LOR; else goto _LAND;
    }
    else {
      int tmp;
      _LAND:
      tmp = memcmp((void const *)(s + j),(void const *)sep,(size_t)seplen);
      if (tmp == 0) {
        _LOR:
        {
          *(tokens + elements) = sdsnewlen((void const *)(s + start),
                                           (size_t)(j - start));
          if (*(tokens + elements) == (sds)0) goto cleanup;
          elements ++;
          start = j + seplen;
          j = (j + seplen) - 1;
        }
      }
    }
    j ++;
  }
  *(tokens + elements) = sdsnewlen((void const *)(s + start),
                                   (size_t)(len - start));
  if (*(tokens + elements) == (sds)0) goto cleanup;
  elements ++;
  *count = elements;
  __retres = tokens;
  goto return_label;
  cleanup:
  {
    int i;
    i = 0;
    while (i < elements) {
      sdsfree(*(tokens + i));
      i ++;
    }
    free((void *)tokens);
    *count = 0;
    __retres = (sds *)0;
    return_label: return __retres;
  }
}

void sdsfreesplitres(sds *tokens, int count)
{
  if (! tokens) goto return_label;
  while (1) {
    int tmp;
    tmp = count;
    count --;
    ;
    if (! tmp) break;
    sdsfree(*(tokens + count));
  }
  free((void *)tokens);
  return_label: return;
}

sds sdscatrepr(sds s, char const *p, size_t len)
{
  sds tmp_1;
  s = sdscatlen(s,(void const *)"\"",(size_t)1);
  while (1) {
    size_t tmp_0;
    tmp_0 = len;
    len --;
    ;
    if (! tmp_0) break;
    switch ((int)*p) {
      int tmp;
      case '\\': case '\"':
      {
        int __va_arg0 = (int)*p;
        void *__va_args[1] = {& __va_arg0};
        s = sdscatprintf(s,"\\%c",(void * const *)(__va_args));
      }
      break;
      case '\n': s = sdscatlen(s,(void const *)"\\n",(size_t)2);
      break;
      case '\r': s = sdscatlen(s,(void const *)"\\r",(size_t)2);
      break;
      case '\t': s = sdscatlen(s,(void const *)"\\t",(size_t)2);
      break;
      case '\a': s = sdscatlen(s,(void const *)"\\a",(size_t)2);
      break;
      case '\b': s = sdscatlen(s,(void const *)"\\b",(size_t)2);
      break;
      default: tmp = isprint((int)*p);
      if (tmp) {
        {
          int __va_arg0_10 = (int)*p;
          void *__va_args_12[1] = {& __va_arg0_10};
          s = sdscatprintf(s,"%c",(void * const *)(__va_args_12));
        }
      }
      else {
        {
          int __va_arg0_14 = (int)((unsigned char)*p);
          void *__va_args_16[1] = {& __va_arg0_14};
          s = sdscatprintf(s,"\\x%02x",(void * const *)(__va_args_16));
        }
      }
      break;
    }
    p ++;
  }
  tmp_1 = sdscatlen(s,(void const *)"\"",(size_t)1);
  return tmp_1;
}

int is_hex_digit(char c)
{
  int tmp;
  if ((int)c >= '0') {
    if ((int)c <= '9') tmp = 1; else goto _LAND_0;
  }
  else {
    _LAND_0: ;
    if ((int)c >= 'a') {
      if ((int)c <= 'f') tmp = 1; else goto _LAND;
    }
    else {
      _LAND: ;
      if ((int)c >= 'A') 
        if ((int)c <= 'F') tmp = 1; else tmp = 0;
      else tmp = 0;
    }
  }
  return tmp;
}

int hex_digit_to_int(char c)
{
  int __retres;
  switch ((int)c) {
    case '0': __retres = 0;
    goto return_label;
    case '1': __retres = 1;
    goto return_label;
    case '2': __retres = 2;
    goto return_label;
    case '3': __retres = 3;
    goto return_label;
    case '4': __retres = 4;
    goto return_label;
    case '5': __retres = 5;
    goto return_label;
    case '6': __retres = 6;
    goto return_label;
    case '7': __retres = 7;
    goto return_label;
    case '8': __retres = 8;
    goto return_label;
    case '9': __retres = 9;
    goto return_label;
    case 'a': case 'A': __retres = 10;
    goto return_label;
    case 'b': case 'B': __retres = 11;
    goto return_label;
    case 'c': case 'C': __retres = 12;
    goto return_label;
    case 'd': case 'D': __retres = 13;
    goto return_label;
    case 'e': case 'E': __retres = 14;
    goto return_label;
    case 'f': case 'F': __retres = 15;
    goto return_label;
    default: __retres = 0;
    goto return_label;
  }
  return_label: return __retres;
}

sds *sdssplitargs(char const *line, int *argc)
{
  sds *__retres;
  char const *p = line;
  char *current = (char *)0;
  char **vector = (char **)0;
  *argc = 0;
  while (1) {
    while (1) {
      if (*p) {
        int tmp;
        tmp = isspace((int)*p);
        if (! tmp) break;
      }
      else break;
      p ++;
    }
    if (*p) {
      int inq = 0;
      int insq = 0;
      int done = 0;
      if (current == (char *)0) current = sdsempty();
      while (! done) {
        if (inq) 
          if ((int)*p == '\\') {
            if ((int)*(p + 1) == 'x') {
              int tmp_3;
              tmp_3 = is_hex_digit(*(p + 2));
              if (tmp_3) {
                int tmp_4;
                tmp_4 = is_hex_digit(*(p + 3));
                if (tmp_4) {
                  unsigned char byte;
                  int tmp_0;
                  int tmp_1;
                  tmp_0 = hex_digit_to_int(*(p + 2));
                  tmp_1 = hex_digit_to_int(*(p + 3));
                  byte = (unsigned char)(tmp_0 * 16 + tmp_1);
                  current = sdscatlen(current,(void const *)(& byte),
                                      (size_t)1);
                  p += 3;
                }
                else goto _LAND_2;
              }
              else goto _LAND_2;
            }
            else goto _LAND_2;
          }
          else {
            _LAND_2: ;
            if ((int)*p == '\\') {
              if (*(p + 1)) {
                char c;
                p ++;
                switch ((int)*p) {
                  case 'n': c = (char)'\n';
                  break;
                  case 'r': c = (char)'\r';
                  break;
                  case 't': c = (char)'\t';
                  break;
                  case 'b': c = (char)'\b';
                  break;
                  case 'a': c = (char)'\a';
                  break;
                  default: c = *p;
                  break;
                }
                current = sdscatlen(current,(void const *)(& c),(size_t)1);
              }
              else goto _LAND;
            }
            else {
              _LAND: ;
              if ((int)*p == '\"') {
                if (*(p + 1)) {
                  int tmp_2;
                  tmp_2 = isspace((int)*(p + 1));
                  if (! tmp_2) goto err;
                }
                done = 1;
              }
              else 
                if (! *p) goto err;
                else current = sdscatlen(current,(void const *)p,(size_t)1);
            }
          }
        else 
          if (insq) 
            if ((int)*p == '\\') {
              if ((int)*(p + 1) == '\'') {
                p ++;
                current = sdscatlen(current,(void const *)"\'",(size_t)1);
              }
              else goto _LAND_3;
            }
            else {
              _LAND_3: ;
              if ((int)*p == '\'') {
                if (*(p + 1)) {
                  int tmp_5;
                  tmp_5 = isspace((int)*(p + 1));
                  if (! tmp_5) goto err;
                }
                done = 1;
              }
              else 
                if (! *p) goto err;
                else current = sdscatlen(current,(void const *)p,(size_t)1);
            }
          else 
            switch ((int)*p) {
              case ' ': case '\n': case '\r': case '\t': case '\000':
              done = 1;
              break;
              case '\"': inq = 1;
              break;
              case '\'': insq = 1;
              break;
              default:
              current = sdscatlen(current,(void const *)p,(size_t)1);
              break;
            }
        if (*p) p ++;
      }
      {
        char **new_vector =
          realloc((void *)vector,(unsigned int)(*argc + 1) * sizeof(char *));
        if (new_vector == (char **)0) {
          free((void *)vector);
          __retres = (sds *)0;
          goto return_label;
        }
        vector = new_vector;
        *(vector + *argc) = current;
        (*argc) ++;
        current = (char *)0;
      }
    }
    else {
      if (vector == (char **)0) vector = (char **)malloc(sizeof(void *));
      __retres = vector;
      goto return_label;
    }
  }
  err:
  while (1) {
    int tmp_7;
    tmp_7 = *argc;
    (*argc) --;
    ;
    if (! tmp_7) break;
    sdsfree(*(vector + *argc));
  }
  free((void *)vector);
  if (current) sdsfree(current);
  *argc = 0;
  __retres = (sds *)0;
  return_label: return __retres;
}

sds sdsmapchars(sds s, char const *from, char const *to, size_t setlen)
{
  size_t j;
  size_t i;
  size_t l = sdslen_3(s);
  j = (size_t)0;
  while (j < l) {
    i = (size_t)0;
    while (i < setlen) {
      if ((int)*(s + j) == (int)*(from + i)) {
        *(s + j) = *(to + i);
        break;
      }
      i ++;
    }
    j ++;
  }
  return s;
}

sds sdsjoin(char **argv, int argc, char *sep)
{
  int j;
  sds join = sdsempty();
  j = 0;
  while (j < argc) {
    join = sdscat(join,(char const *)*(argv + j));
    if (j != argc - 1) join = sdscat(join,(char const *)sep);
    j ++;
  }
  return join;
}

sds sdsjoinsds(sds *argv, int argc, char const *sep, size_t seplen)
{
  int j;
  sds join = sdsempty();
  j = 0;
  while (j < argc) {
    join = sdscatsds(join,*(argv + j));
    if (j != argc - 1) join = sdscatlen(join,(void const *)sep,seplen);
    j ++;
  }
  return join;
}

void *sds_malloc(size_t size)
{
  void *tmp;
  tmp = malloc(size);
  return tmp;
}

void *sds_realloc(void *ptr, size_t size)
{
  void *tmp;
  tmp = realloc(ptr,size);
  return tmp;
}

void sds_free(void *ptr)
{
  free(ptr);
  return;
}

__inline static size_t sdslen_4(sds const s)
{
  size_t __retres;
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0: ;
    __retres = (size_t)((int)flags >> 3);
    goto return_label;
    case 1: ;
    __retres = (size_t)((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->len;
    goto return_label;
    case 2: ;
    __retres = (size_t)((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->len;
    goto return_label;
    case 3: ;
    __retres = ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->len;
    goto return_label;
    case 4: ;
    __retres = (size_t)((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->len;
    goto return_label;
  }
  __retres = (size_t)0;
  return_label: return __retres;
}

__inline static size_t sdsavail_4(sds const s)
{
  size_t __retres;
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0: {
              __retres = (size_t)0;
              goto return_label;
            }
    case 1:
    {
      struct sdshdr8 *sh = (struct sdshdr8 *)(s - sizeof(struct sdshdr8));
      __retres = (size_t)((int)sh->alloc - (int)sh->len);
      goto return_label;
    }
    case 2:
    {
      struct sdshdr16 *sh_0 =
        (struct sdshdr16 *)(s - sizeof(struct sdshdr16));
      __retres = (size_t)((int)sh_0->alloc - (int)sh_0->len);
      goto return_label;
    }
    case 3:
    {
      struct sdshdr32 *sh_1 =
        (struct sdshdr32 *)(s - sizeof(struct sdshdr32));
      __retres = sh_1->alloc - sh_1->len;
      goto return_label;
    }
    case 4:
    {
      struct sdshdr64 *sh_2 =
        (struct sdshdr64 *)(s - sizeof(struct sdshdr64));
      __retres = (size_t)(sh_2->alloc - sh_2->len);
      goto return_label;
    }
  }
  __retres = (size_t)0;
  return_label: return __retres;
}

__inline static void sdssetlen_4(sds s, size_t newlen)
{
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0:
    {
      unsigned char *fp = (unsigned char *)s - 1;
      *fp = (unsigned char)((unsigned int)0 | (newlen << 3));
    }
    break;
    case 1:
    ((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->len = (uint8_t)newlen;
    break;
    case 2:
    ((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->len = (uint16_t)newlen;
    break;
    case 3: ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->len = newlen;
    break;
    case 4:
    ((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->len = (uint64_t)newlen;
    break;
  }
  return;
}

__inline static void sdsinclen_4(sds s, size_t inc)
{
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0:
    {
      unsigned char *fp = (unsigned char *)s - 1;
      unsigned char newlen =
        (unsigned char)(((int)flags >> 3) + (int)((unsigned char)inc));
      *fp = (unsigned char)(0 | ((int)newlen << 3));
    }
    break;
    case 1:
    ((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->len = (uint8_t)(
    (int)((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->len + (int)((uint8_t)inc));
    break;
    case 2:
    ((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->len = (uint16_t)(
    (int)((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->len + (int)((uint16_t)inc));
    break;
    case 3: ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->len += inc;
    break;
    case 4:
    ((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->len += (uint64_t)inc;
    break;
  }
  return;
}

__inline static size_t sdsalloc_4(sds const s)
{
  size_t __retres;
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0: ;
    __retres = (size_t)((int)flags >> 3);
    goto return_label;
    case 1: ;
    __retres = (size_t)((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->alloc;
    goto return_label;
    case 2: ;
    __retres = (size_t)((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->alloc;
    goto return_label;
    case 3: ;
    __retres = ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->alloc;
    goto return_label;
    case 4: ;
    __retres = (size_t)((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->alloc;
    goto return_label;
  }
  __retres = (size_t)0;
  return_label: return __retres;
}

__inline static void sdssetalloc_4(sds s, size_t newlen)
{
  unsigned char flags = (unsigned char)*(s + -1);
  switch ((int)flags & 7) {
    case 0: break;
    case 1:
    ((struct sdshdr8 *)(s - sizeof(struct sdshdr8)))->alloc = (uint8_t)newlen;
    break;
    case 2:
    ((struct sdshdr16 *)(s - sizeof(struct sdshdr16)))->alloc = (uint16_t)newlen;
    break;
    case 3:
    ((struct sdshdr32 *)(s - sizeof(struct sdshdr32)))->alloc = newlen;
    break;
    case 4:
    ((struct sdshdr64 *)(s - sizeof(struct sdshdr64)))->alloc = (uint64_t)newlen;
    break;
  }
  return;
}

static int tests = 0;
static int fails = 0;
static int skips = 0;
static long long usec(void)
{
  long long __retres;
  struct timeval tv;
  gettimeofday(& tv,(void *)0);
  __retres = (long long)tv.tv_sec * (long long)1000000 + (long long)tv.tv_usec;
  return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_1(char const * restrict format);

static redisContext *select_database(redisContext *c)
{
  redisReply *reply;
  {
    void *__va_args[1] = {(void *)0};
    reply = (redisReply *)redisCommand(c,"SELECT 9",
                                       (void * const *)(__va_args));
  }
  __FC_assert((reply != (redisReply *)0) != 0,"test.c",81,"reply != NULL");
  freeReplyObject((void *)reply);
  {
    void *__va_args_5[1] = {(void *)0};
    reply = (redisReply *)redisCommand(c,"DBSIZE",
                                       (void * const *)(__va_args_5));
  }
  __FC_assert((reply != (redisReply *)0) != 0,"test.c",86,"reply != NULL");
  if (reply->type == 3) {
    if (reply->integer == (long long)0) freeReplyObject((void *)reply);
    else goto _LAND;
  }
  else {
    _LAND:
    {
      printf("Database #9 is not empty, test can not continue\n"); /* printf_va_1 */
      exit(1);
    }
  }
  return c;
}

static int disconnect(redisContext *c, int keep_fd)
{
  int __retres;
  redisReply *reply;
  {
    void *__va_args[1] = {(void *)0};
    reply = (redisReply *)redisCommand(c,"SELECT 9",
                                       (void * const *)(__va_args));
  }
  __FC_assert((reply != (redisReply *)0) != 0,"test.c",103,"reply != NULL");
  freeReplyObject((void *)reply);
  {
    void *__va_args_7[1] = {(void *)0};
    reply = (redisReply *)redisCommand(c,"FLUSHDB",
                                       (void * const *)(__va_args_7));
  }
  __FC_assert((reply != (redisReply *)0) != 0,"test.c",106,"reply != NULL");
  freeReplyObject((void *)reply);
  if (keep_fd) {
    int tmp;
    tmp = redisFreeKeepFd(c);
    __retres = tmp;
    goto return_label;
  }
  redisFree(c);
  __retres = -1;
  return_label: return __retres;
}

static void do_ssl_handshake(redisContext *c, struct config config)
{
  return;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_2(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_3(char const * restrict format);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_4(char const * restrict format, char *param0);

static redisContext *do_connect(struct config config)
{
  redisContext *tmp_1;
  redisContext *c = (redisContext *)0;
  if (config.type == (unsigned int)CONN_TCP) c = redisConnect(config.tcp.host,
                                                              config.tcp.port);
  else 
    if (config.type == (unsigned int)CONN_SSL) c = redisConnect(config.ssl.host,
                                                                config.ssl.port);
    else 
      if (config.type == (unsigned int)CONN_UNIX) c = redisConnectUnix
                                                  (config.unix_sock.path);
      else 
        if (config.type == (unsigned int)CONN_FD) {
          redisContext *dummy_ctx = redisConnectUnix(config.unix_sock.path);
          if (dummy_ctx) {
            int fd = disconnect(dummy_ctx,1);
            printf("Connecting to inherited fd %d\n",fd); /* printf_va_2 */
            c = redisConnectFd(fd);
          }
        }
        else __FC_assert((void *)0 != (void *)0,"test.c",148,"NULL");
  if (c == (redisContext *)0) {
    printf("Connection error: can\'t allocate redis context\n"); /* printf_va_3 */
    exit(1);
  }
  else 
    if (c->err) {
      printf("Connection error: %s\n",c->errstr); /* printf_va_4 */
      redisFree(c);
      exit(1);
    }
  if (config.type == (unsigned int)CONN_SSL) do_ssl_handshake(c,config);
  tmp_1 = select_database(c);
  return tmp_1;
}

static void do_reconnect(redisContext *c, struct config config)
{
  redisReconnect(c);
  if (config.type == (unsigned int)CONN_SSL) do_ssl_handshake(c,config);
  return;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_5(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_6(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_7(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_8(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_9(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_10(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_11(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_12(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_13(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_14(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_15(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_16(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_17(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_18(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_19(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_20(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_21(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_22(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_23(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_24(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_25(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_26(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_27(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_28(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_29(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_30(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_31(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_32(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_33(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_34(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_35(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_36(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_37(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_38(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_39(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_40(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_41(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_42(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_43(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_44(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_45(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_46(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_47(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_48(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_49(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_50(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_51(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_52(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_53(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_54(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_55(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_56(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_57(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_58(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_59(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_60(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_61(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_62(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_63(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_64(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_65(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_66(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_67(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_68(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_69(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_70(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_71(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_72(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_73(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_74(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_75(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_76(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_77(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_78(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_79(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_80(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_81(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_82(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_83(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_84(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_85(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_86(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_87(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_88(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_89(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_90(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_91(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_92(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_93(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_94(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_95(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_96(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_97(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_98(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_99(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_100(char const * restrict format);

static void test_format_commands(void)
{
  char *cmd;
  int len;
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  int tmp_4;
  int tmp_5;
  char const *argv[3];
  int tmp_18;
  int tmp_19;
  sds sds_cmd;
  int tmp_20;
  int tmp_21;
  tests ++;
  printf("#%02d ",tests); /* printf_va_5 */
  printf("Format command without interpolation: "); /* printf_va_6 */
  {
    void *__va_args[1] = {(void *)0};
    len = redisFormatCommand(& cmd,"SET foo bar",(void * const *)(__va_args));
  }
  tmp = strncmp((char const *)cmd,
                "*3\r\n$3\r\nSET\r\n$3\r\nfoo\r\n$3\r\nbar\r\n",(size_t)len);
  if (tmp == 0) {
    if (len == (((((4 + 4) + (3 + 2)) + 4) + (3 + 2)) + 4) + (3 + 2)) 
      printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_7 */
    else goto _LAND;
  }
  else {
    _LAND:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_8 */
      fails ++;
    }
  }
  free((void *)cmd);
  tests ++;
  printf("#%02d ",tests); /* printf_va_9 */
  printf("Format command with %%s string interpolation: "); /* printf_va_10 */
  {
    char const *__va_arg0 = "foo";
    char const *__va_arg1 = "bar";
    void *__va_args_46[2] = {& __va_arg0, & __va_arg1};
    len = redisFormatCommand(& cmd,"SET %s %s",
                             (void * const *)(__va_args_46));
  }
  tmp_0 = strncmp((char const *)cmd,
                  "*3\r\n$3\r\nSET\r\n$3\r\nfoo\r\n$3\r\nbar\r\n",
                  (size_t)len);
  if (tmp_0 == 0) {
    if (len == (((((4 + 4) + (3 + 2)) + 4) + (3 + 2)) + 4) + (3 + 2)) 
      printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_11 */
    else goto _LAND_0;
  }
  else {
    _LAND_0:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_12 */
      fails ++;
    }
  }
  free((void *)cmd);
  tests ++;
  printf("#%02d ",tests); /* printf_va_13 */
  printf("Format command with %%s and an empty string: "); /* printf_va_14 */
  {
    char const *__va_arg0_48 = "foo";
    char const *__va_arg1_50 = "";
    void *__va_args_52[2] = {& __va_arg0_48, & __va_arg1_50};
    len = redisFormatCommand(& cmd,"SET %s %s",
                             (void * const *)(__va_args_52));
  }
  tmp_1 = strncmp((char const *)cmd,
                  "*3\r\n$3\r\nSET\r\n$3\r\nfoo\r\n$0\r\n\r\n",(size_t)len);
  if (tmp_1 == 0) {
    if (len == (((((4 + 4) + (3 + 2)) + 4) + (3 + 2)) + 4) + (0 + 2)) 
      printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_15 */
    else goto _LAND_1;
  }
  else {
    _LAND_1:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_16 */
      fails ++;
    }
  }
  free((void *)cmd);
  tests ++;
  printf("#%02d ",tests); /* printf_va_17 */
  printf("Format command with an empty string in between proper interpolations: "); /* printf_va_18 */
  {
    char const *__va_arg0_54 = "";
    char const *__va_arg1_56 = "foo";
    void *__va_args_58[2] = {& __va_arg0_54, & __va_arg1_56};
    len = redisFormatCommand(& cmd,"SET %s %s",
                             (void * const *)(__va_args_58));
  }
  tmp_2 = strncmp((char const *)cmd,
                  "*3\r\n$3\r\nSET\r\n$0\r\n\r\n$3\r\nfoo\r\n",(size_t)len);
  if (tmp_2 == 0) {
    if (len == (((((4 + 4) + (3 + 2)) + 4) + (0 + 2)) + 4) + (3 + 2)) 
      printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_19 */
    else goto _LAND_2;
  }
  else {
    _LAND_2:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_20 */
      fails ++;
    }
  }
  free((void *)cmd);
  tests ++;
  printf("#%02d ",tests); /* printf_va_21 */
  printf("Format command with %%b string interpolation: "); /* printf_va_22 */
  {
    char const *__va_arg0_60 = "foo";
    size_t __va_arg1_62 = (size_t)3;
    char const *__va_arg2 = "b\000r";
    size_t __va_arg3 = (size_t)3;
    void *__va_args_66[4] =
      {& __va_arg0_60, & __va_arg1_62, & __va_arg2, & __va_arg3};
    len = redisFormatCommand(& cmd,"SET %b %b",
                             (void * const *)(__va_args_66));
  }
  tmp_3 = strncmp((char const *)cmd,
                  "*3\r\n$3\r\nSET\r\n$3\r\nfoo\r\n$3\r\nb\000r\r\n",
                  (size_t)len);
  if (tmp_3 == 0) {
    if (len == (((((4 + 4) + (3 + 2)) + 4) + (3 + 2)) + 4) + (3 + 2)) 
      printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_23 */
    else goto _LAND_3;
  }
  else {
    _LAND_3:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_24 */
      fails ++;
    }
  }
  free((void *)cmd);
  tests ++;
  printf("#%02d ",tests); /* printf_va_25 */
  printf("Format command with %%b and an empty string: "); /* printf_va_26 */
  {
    char const *__va_arg0_68 = "foo";
    size_t __va_arg1_70 = (size_t)3;
    char const *__va_arg2_72 = "";
    size_t __va_arg3_74 = (size_t)0;
    void *__va_args_76[4] =
      {& __va_arg0_68, & __va_arg1_70, & __va_arg2_72, & __va_arg3_74};
    len = redisFormatCommand(& cmd,"SET %b %b",
                             (void * const *)(__va_args_76));
  }
  tmp_4 = strncmp((char const *)cmd,
                  "*3\r\n$3\r\nSET\r\n$3\r\nfoo\r\n$0\r\n\r\n",(size_t)len);
  if (tmp_4 == 0) {
    if (len == (((((4 + 4) + (3 + 2)) + 4) + (3 + 2)) + 4) + (0 + 2)) 
      printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_27 */
    else goto _LAND_4;
  }
  else {
    _LAND_4:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_28 */
      fails ++;
    }
  }
  free((void *)cmd);
  tests ++;
  printf("#%02d ",tests); /* printf_va_29 */
  printf("Format command with literal %%: "); /* printf_va_30 */
  {
    void *__va_args_78[1] = {(void *)0};
    len = redisFormatCommand(& cmd,"SET %% %%",
                             (void * const *)(__va_args_78));
  }
  tmp_5 = strncmp((char const *)cmd,
                  "*3\r\n$3\r\nSET\r\n$1\r\n%\r\n$1\r\n%\r\n",(size_t)len);
  if (tmp_5 == 0) {
    if (len == (((((4 + 4) + (3 + 2)) + 4) + (1 + 2)) + 4) + (1 + 2)) 
      printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_31 */
    else goto _LAND_5;
  }
  else {
    _LAND_5:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_32 */
      fails ++;
    }
  }
  free((void *)cmd);
  {
    int tmp_6;
    int value = 123;
    tests ++;
    printf("#%02d ",tests); /* printf_va_33 */
    printf("Format command with printf-delegation (int): "); /* printf_va_34 */
    {
      int __va_arg0_80 = value;
      char const *__va_arg1_82 = "hello";
      void *__va_args_84[2] = {& __va_arg0_80, & __va_arg1_82};
      len = redisFormatCommand(& cmd,"key:%08d str:%s",
                               (void * const *)(__va_args_84));
    }
    tmp_6 = strncmp((char const *)cmd,
                    "*2\r\n$12\r\nkey:00000123\r\n$9\r\nstr:hello\r\n",
                    (size_t)len);
    if (tmp_6 == 0) {
      if (len == (((4 + 5) + (12 + 2)) + 4) + (9 + 2)) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_35 */
      else goto _LAND_6;
    }
    else {
      _LAND_6:
      {
        printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_36 */
        fails ++;
      }
    }
    free((void *)cmd);
  }
  {
    int tmp_7;
    char value_0 = (char)123;
    tests ++;
    printf("#%02d ",tests); /* printf_va_37 */
    printf("Format command with printf-delegation (char): "); /* printf_va_38 */
    {
      int __va_arg0_86 = (int)value_0;
      char const *__va_arg1_88 = "hello";
      void *__va_args_90[2] = {& __va_arg0_86, & __va_arg1_88};
      len = redisFormatCommand(& cmd,"key:%08hhd str:%s",
                               (void * const *)(__va_args_90));
    }
    tmp_7 = strncmp((char const *)cmd,
                    "*2\r\n$12\r\nkey:00000123\r\n$9\r\nstr:hello\r\n",
                    (size_t)len);
    if (tmp_7 == 0) {
      if (len == (((4 + 5) + (12 + 2)) + 4) + (9 + 2)) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_39 */
      else goto _LAND_7;
    }
    else {
      _LAND_7:
      {
        printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_40 */
        fails ++;
      }
    }
    free((void *)cmd);
  }
  {
    int tmp_8;
    short value_1 = (short)123;
    tests ++;
    printf("#%02d ",tests); /* printf_va_41 */
    printf("Format command with printf-delegation (short): "); /* printf_va_42 */
    {
      int __va_arg0_92 = (int)value_1;
      char const *__va_arg1_94 = "hello";
      void *__va_args_96[2] = {& __va_arg0_92, & __va_arg1_94};
      len = redisFormatCommand(& cmd,"key:%08hd str:%s",
                               (void * const *)(__va_args_96));
    }
    tmp_8 = strncmp((char const *)cmd,
                    "*2\r\n$12\r\nkey:00000123\r\n$9\r\nstr:hello\r\n",
                    (size_t)len);
    if (tmp_8 == 0) {
      if (len == (((4 + 5) + (12 + 2)) + 4) + (9 + 2)) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_43 */
      else goto _LAND_8;
    }
    else {
      _LAND_8:
      {
        printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_44 */
        fails ++;
      }
    }
    free((void *)cmd);
  }
  {
    int tmp_9;
    long value_2 = (long)123;
    tests ++;
    printf("#%02d ",tests); /* printf_va_45 */
    printf("Format command with printf-delegation (long): "); /* printf_va_46 */
    {
      long __va_arg0_98 = value_2;
      char const *__va_arg1_100 = "hello";
      void *__va_args_102[2] = {& __va_arg0_98, & __va_arg1_100};
      len = redisFormatCommand(& cmd,"key:%08ld str:%s",
                               (void * const *)(__va_args_102));
    }
    tmp_9 = strncmp((char const *)cmd,
                    "*2\r\n$12\r\nkey:00000123\r\n$9\r\nstr:hello\r\n",
                    (size_t)len);
    if (tmp_9 == 0) {
      if (len == (((4 + 5) + (12 + 2)) + 4) + (9 + 2)) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_47 */
      else goto _LAND_9;
    }
    else {
      _LAND_9:
      {
        printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_48 */
        fails ++;
      }
    }
    free((void *)cmd);
  }
  {
    int tmp_10;
    long long value_3 = (long long)123;
    tests ++;
    printf("#%02d ",tests); /* printf_va_49 */
    printf("Format command with printf-delegation (long long): "); /* printf_va_50 */
    {
      long long __va_arg0_104 = value_3;
      char const *__va_arg1_106 = "hello";
      void *__va_args_108[2] = {& __va_arg0_104, & __va_arg1_106};
      len = redisFormatCommand(& cmd,"key:%08lld str:%s",
                               (void * const *)(__va_args_108));
    }
    tmp_10 = strncmp((char const *)cmd,
                     "*2\r\n$12\r\nkey:00000123\r\n$9\r\nstr:hello\r\n",
                     (size_t)len);
    if (tmp_10 == 0) {
      if (len == (((4 + 5) + (12 + 2)) + 4) + (9 + 2)) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_51 */
      else goto _LAND_10;
    }
    else {
      _LAND_10:
      {
        printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_52 */
        fails ++;
      }
    }
    free((void *)cmd);
  }
  {
    int tmp_11;
    unsigned int value_4 = (unsigned int)123;
    tests ++;
    printf("#%02d ",tests); /* printf_va_53 */
    printf("Format command with printf-delegation (unsigned int): "); /* printf_va_54 */
    {
      unsigned int __va_arg0_110 = value_4;
      char const *__va_arg1_112 = "hello";
      void *__va_args_114[2] = {& __va_arg0_110, & __va_arg1_112};
      len = redisFormatCommand(& cmd,"key:%08u str:%s",
                               (void * const *)(__va_args_114));
    }
    tmp_11 = strncmp((char const *)cmd,
                     "*2\r\n$12\r\nkey:00000123\r\n$9\r\nstr:hello\r\n",
                     (size_t)len);
    if (tmp_11 == 0) {
      if (len == (((4 + 5) + (12 + 2)) + 4) + (9 + 2)) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_55 */
      else goto _LAND_11;
    }
    else {
      _LAND_11:
      {
        printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_56 */
        fails ++;
      }
    }
    free((void *)cmd);
  }
  {
    int tmp_12;
    unsigned char value_5 = (unsigned char)123;
    tests ++;
    printf("#%02d ",tests); /* printf_va_57 */
    printf("Format command with printf-delegation (unsigned char): "); /* printf_va_58 */
    {
      int __va_arg0_116 = (int)value_5;
      char const *__va_arg1_118 = "hello";
      void *__va_args_120[2] = {& __va_arg0_116, & __va_arg1_118};
      len = redisFormatCommand(& cmd,"key:%08hhu str:%s",
                               (void * const *)(__va_args_120));
    }
    tmp_12 = strncmp((char const *)cmd,
                     "*2\r\n$12\r\nkey:00000123\r\n$9\r\nstr:hello\r\n",
                     (size_t)len);
    if (tmp_12 == 0) {
      if (len == (((4 + 5) + (12 + 2)) + 4) + (9 + 2)) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_59 */
      else goto _LAND_12;
    }
    else {
      _LAND_12:
      {
        printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_60 */
        fails ++;
      }
    }
    free((void *)cmd);
  }
  {
    int tmp_13;
    unsigned short value_6 = (unsigned short)123;
    tests ++;
    printf("#%02d ",tests); /* printf_va_61 */
    printf("Format command with printf-delegation (unsigned short): "); /* printf_va_62 */
    {
      int __va_arg0_122 = (int)value_6;
      char const *__va_arg1_124 = "hello";
      void *__va_args_126[2] = {& __va_arg0_122, & __va_arg1_124};
      len = redisFormatCommand(& cmd,"key:%08hu str:%s",
                               (void * const *)(__va_args_126));
    }
    tmp_13 = strncmp((char const *)cmd,
                     "*2\r\n$12\r\nkey:00000123\r\n$9\r\nstr:hello\r\n",
                     (size_t)len);
    if (tmp_13 == 0) {
      if (len == (((4 + 5) + (12 + 2)) + 4) + (9 + 2)) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_63 */
      else goto _LAND_13;
    }
    else {
      _LAND_13:
      {
        printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_64 */
        fails ++;
      }
    }
    free((void *)cmd);
  }
  {
    int tmp_14;
    unsigned long value_7 = (unsigned long)123;
    tests ++;
    printf("#%02d ",tests); /* printf_va_65 */
    printf("Format command with printf-delegation (unsigned long): "); /* printf_va_66 */
    {
      unsigned long __va_arg0_128 = value_7;
      char const *__va_arg1_130 = "hello";
      void *__va_args_132[2] = {& __va_arg0_128, & __va_arg1_130};
      len = redisFormatCommand(& cmd,"key:%08lu str:%s",
                               (void * const *)(__va_args_132));
    }
    tmp_14 = strncmp((char const *)cmd,
                     "*2\r\n$12\r\nkey:00000123\r\n$9\r\nstr:hello\r\n",
                     (size_t)len);
    if (tmp_14 == 0) {
      if (len == (((4 + 5) + (12 + 2)) + 4) + (9 + 2)) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_67 */
      else goto _LAND_14;
    }
    else {
      _LAND_14:
      {
        printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_68 */
        fails ++;
      }
    }
    free((void *)cmd);
  }
  {
    int tmp_15;
    unsigned long long value_8 = (unsigned long long)123;
    tests ++;
    printf("#%02d ",tests); /* printf_va_69 */
    printf("Format command with printf-delegation (unsigned long long): "); /* printf_va_70 */
    {
      unsigned long long __va_arg0_134 = value_8;
      char const *__va_arg1_136 = "hello";
      void *__va_args_138[2] = {& __va_arg0_134, & __va_arg1_136};
      len = redisFormatCommand(& cmd,"key:%08llu str:%s",
                               (void * const *)(__va_args_138));
    }
    tmp_15 = strncmp((char const *)cmd,
                     "*2\r\n$12\r\nkey:00000123\r\n$9\r\nstr:hello\r\n",
                     (size_t)len);
    if (tmp_15 == 0) {
      if (len == (((4 + 5) + (12 + 2)) + 4) + (9 + 2)) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_71 */
      else goto _LAND_15;
    }
    else {
      _LAND_15:
      {
        printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_72 */
        fails ++;
      }
    }
    free((void *)cmd);
  }
  {
    int tmp_16;
    float value_9 = (float)123.0;
    tests ++;
    printf("#%02d ",tests); /* printf_va_73 */
    printf("Format command with printf-delegation (float): "); /* printf_va_74 */
    {
      double __va_arg0_140 = (double)value_9;
      char const *__va_arg1_142 = "hello";
      void *__va_args_144[2] = {& __va_arg0_140, & __va_arg1_142};
      len = redisFormatCommand(& cmd,"key:%08.3f str:%s",
                               (void * const *)(__va_args_144));
    }
    tmp_16 = strncmp((char const *)cmd,
                     "*2\r\n$12\r\nkey:0123.000\r\n$9\r\nstr:hello\r\n",
                     (size_t)len);
    if (tmp_16 == 0) {
      if (len == (((4 + 5) + (12 + 2)) + 4) + (9 + 2)) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_75 */
      else goto _LAND_16;
    }
    else {
      _LAND_16:
      {
        printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_76 */
        fails ++;
      }
    }
    free((void *)cmd);
  }
  {
    int tmp_17;
    double value_10 = 123.0;
    tests ++;
    printf("#%02d ",tests); /* printf_va_77 */
    printf("Format command with printf-delegation (double): "); /* printf_va_78 */
    {
      double __va_arg0_146 = value_10;
      char const *__va_arg1_148 = "hello";
      void *__va_args_150[2] = {& __va_arg0_146, & __va_arg1_148};
      len = redisFormatCommand(& cmd,"key:%08.3f str:%s",
                               (void * const *)(__va_args_150));
    }
    tmp_17 = strncmp((char const *)cmd,
                     "*2\r\n$12\r\nkey:0123.000\r\n$9\r\nstr:hello\r\n",
                     (size_t)len);
    if (tmp_17 == 0) {
      if (len == (((4 + 5) + (12 + 2)) + 4) + (9 + 2)) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_79 */
      else goto _LAND_17;
    }
    else {
      _LAND_17:
      {
        printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_80 */
        fails ++;
      }
    }
    free((void *)cmd);
  }
  tests ++;
  printf("#%02d ",tests); /* printf_va_81 */
  printf("Format command with invalid printf format: "); /* printf_va_82 */
  {
    void *__va_arg0_152 = (void *)1234;
    char const *__va_arg1_154 = "foo";
    size_t __va_arg2_156 = (size_t)3;
    void *__va_args_158[3] =
      {& __va_arg0_152, & __va_arg1_154, & __va_arg2_156};
    len = redisFormatCommand(& cmd,"key:%08p %b",
                             (void * const *)(__va_args_158));
  }
  if (len == -1) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_83 */
  else {
    printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_84 */
    fails ++;
  }
  argv[0] = "SET";
  argv[1] = "foo\000xxx";
  argv[2] = "bar";
  size_t lens[3] = {(size_t)3, (size_t)7, (size_t)3};
  int argc = 3;
  tests ++;
  printf("#%02d ",tests); /* printf_va_85 */
  printf("Format command by passing argc/argv without lengths: "); /* printf_va_86 */
  len = redisFormatCommandArgv(& cmd,argc,argv,(size_t const *)0);
  tmp_18 = strncmp((char const *)cmd,
                   "*3\r\n$3\r\nSET\r\n$3\r\nfoo\r\n$3\r\nbar\r\n",
                   (size_t)len);
  if (tmp_18 == 0) {
    if (len == (((((4 + 4) + (3 + 2)) + 4) + (3 + 2)) + 4) + (3 + 2)) 
      printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_87 */
    else goto _LAND_18;
  }
  else {
    _LAND_18:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_88 */
      fails ++;
    }
  }
  free((void *)cmd);
  tests ++;
  printf("#%02d ",tests); /* printf_va_89 */
  printf("Format command by passing argc/argv with lengths: "); /* printf_va_90 */
  len = redisFormatCommandArgv(& cmd,argc,argv,(size_t const *)(lens));
  tmp_19 = strncmp((char const *)cmd,
                   "*3\r\n$3\r\nSET\r\n$7\r\nfoo\000xxx\r\n$3\r\nbar\r\n",
                   (size_t)len);
  if (tmp_19 == 0) {
    if (len == (((((4 + 4) + (3 + 2)) + 4) + (7 + 2)) + 4) + (3 + 2)) 
      printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_91 */
    else goto _LAND_19;
  }
  else {
    _LAND_19:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_92 */
      fails ++;
    }
  }
  free((void *)cmd);
  sds_cmd = (sds)0;
  tests ++;
  printf("#%02d ",tests); /* printf_va_93 */
  printf("Format command into sds by passing argc/argv without lengths: "); /* printf_va_94 */
  len = redisFormatSdsCommandArgv(& sds_cmd,argc,argv,(size_t const *)0);
  tmp_20 = strncmp((char const *)sds_cmd,
                   "*3\r\n$3\r\nSET\r\n$3\r\nfoo\r\n$3\r\nbar\r\n",
                   (size_t)len);
  if (tmp_20 == 0) {
    if (len == (((((4 + 4) + (3 + 2)) + 4) + (3 + 2)) + 4) + (3 + 2)) 
      printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_95 */
    else goto _LAND_20;
  }
  else {
    _LAND_20:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_96 */
      fails ++;
    }
  }
  sdsfree(sds_cmd);
  sds_cmd = (sds)0;
  tests ++;
  printf("#%02d ",tests); /* printf_va_97 */
  printf("Format command into sds by passing argc/argv with lengths: "); /* printf_va_98 */
  len = redisFormatSdsCommandArgv(& sds_cmd,argc,argv,(size_t const *)(lens));
  tmp_21 = strncmp((char const *)sds_cmd,
                   "*3\r\n$3\r\nSET\r\n$7\r\nfoo\000xxx\r\n$3\r\nbar\r\n",
                   (size_t)len);
  if (tmp_21 == 0) {
    if (len == (((((4 + 4) + (3 + 2)) + 4) + (7 + 2)) + 4) + (3 + 2)) 
      printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_99 */
    else goto _LAND_21;
  }
  else {
    _LAND_21:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_100 */
      fails ++;
    }
  }
  sdsfree(sds_cmd);
  return;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_101(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_102(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_103(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_104(char const * restrict format);

static void test_append_formatted_commands(struct config config)
{
  redisContext *c;
  redisReply *reply;
  char *cmd;
  int len;
  int tmp;
  int tmp_0;
  c = do_connect(config);
  tests ++;
  printf("#%02d ",tests); /* printf_va_101 */
  printf("Append format command: "); /* printf_va_102 */
  {
    void *__va_args[1] = {(void *)0};
    len = redisFormatCommand(& cmd,"SET foo bar",(void * const *)(__va_args));
  }
  tmp = redisAppendFormattedCommand(c,(char const *)cmd,(size_t)len);
  if (tmp == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_103 */
  else {
    printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_104 */
    fails ++;
  }
  tmp_0 = redisGetReply(c,(void **)(& reply));
  __FC_assert((tmp_0 == 0) != 0,"test.c",309,
              "redisGetReply(c, (void*)&reply) == REDIS_OK");
  free((void *)cmd);
  freeReplyObject((void *)reply);
  disconnect(c,0);
  return;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_105(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_106(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_107(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_108(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_109(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_110(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_111(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_112(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_113(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_114(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_115(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_116(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_117(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_118(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_119(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_120(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_121(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_122(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_123(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_124(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_125(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_126(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_127(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_128(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_129(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_130(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_131(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_132(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_133(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_134(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_135(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_136(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_137(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_138(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_139(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_140(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_141(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_142(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_143(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_144(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_145(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_146(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_147(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_148(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_149(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_150(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_151(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_152(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_153(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_154(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_155(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_156(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_157(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_158(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_159(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_160(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_161(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_162(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_163(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_164(char const * restrict format);

static void test_reply_reader(void)
{
  redisReader *reader;
  void *reply;
  int ret;
  int i;
  int tmp_8;
  tests ++;
  printf("#%02d ",tests); /* printf_va_105 */
  printf("Error handling in reply parser: "); /* printf_va_106 */
  reader = redisReaderCreate();
  redisReaderFeed(reader,"@foo\r\n",(size_t)6);
  ret = redisReaderGetReply(reader,(void **)0);
  if (ret == -1) {
    int tmp;
    tmp = strcasecmp((char const *)(reader->errstr),
                     "Protocol error, got \"@\" as reply type byte");
    if (tmp == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_107 */
    else goto _LAND;
  }
  else {
    _LAND:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_108 */
      fails ++;
    }
  }
  redisReaderFree(reader);
  tests ++;
  printf("#%02d ",tests); /* printf_va_109 */
  printf("Memory cleanup in reply parser: "); /* printf_va_110 */
  reader = redisReaderCreate();
  redisReaderFeed(reader,"*2\r\n",(size_t)4);
  redisReaderFeed(reader,"$5\r\nhello\r\n",(size_t)11);
  redisReaderFeed(reader,"@foo\r\n",(size_t)6);
  ret = redisReaderGetReply(reader,(void **)0);
  if (ret == -1) {
    int tmp_0;
    tmp_0 = strcasecmp((char const *)(reader->errstr),
                       "Protocol error, got \"@\" as reply type byte");
    if (tmp_0 == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_111 */
    else goto _LAND_0;
  }
  else {
    _LAND_0:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_112 */
      fails ++;
    }
  }
  redisReaderFree(reader);
  tests ++;
  printf("#%02d ",tests); /* printf_va_113 */
  printf("Set error on nested multi bulks with depth > 7: "); /* printf_va_114 */
  reader = redisReaderCreate();
  i = 0;
  while (i < 9) {
    redisReaderFeed(reader,"*1\r\n",(size_t)4);
    i ++;
  }
  ret = redisReaderGetReply(reader,(void **)0);
  if (ret == -1) {
    int tmp_1;
    tmp_1 = strncasecmp((char const *)(reader->errstr),"No support for",
                        (size_t)14);
    if (tmp_1 == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_115 */
    else goto _LAND_1;
  }
  else {
    _LAND_1:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_116 */
      fails ++;
    }
  }
  redisReaderFree(reader);
  tests ++;
  printf("#%02d ",tests); /* printf_va_117 */
  printf("Correctly parses LLONG_MAX: "); /* printf_va_118 */
  reader = redisReaderCreate();
  redisReaderFeed(reader,":9223372036854775807\r\n",(size_t)22);
  ret = redisReaderGetReply(reader,& reply);
  if (ret == 0) {
    if (((redisReply *)reply)->type == 3) {
      if (((redisReply *)reply)->integer == 9223372036854775807LL) printf
                                                                   ("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_119 */
      else goto _LAND_3;
    }
    else goto _LAND_3;
  }
  else {
    _LAND_3:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_120 */
      fails ++;
    }
  }
  freeReplyObject(reply);
  redisReaderFree(reader);
  tests ++;
  printf("#%02d ",tests); /* printf_va_121 */
  printf("Set error when > LLONG_MAX: "); /* printf_va_122 */
  reader = redisReaderCreate();
  redisReaderFeed(reader,":9223372036854775808\r\n",(size_t)22);
  ret = redisReaderGetReply(reader,& reply);
  if (ret == -1) {
    int tmp_2;
    tmp_2 = strcasecmp((char const *)(reader->errstr),"Bad integer value");
    if (tmp_2 == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_123 */
    else goto _LAND_4;
  }
  else {
    _LAND_4:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_124 */
      fails ++;
    }
  }
  freeReplyObject(reply);
  redisReaderFree(reader);
  tests ++;
  printf("#%02d ",tests); /* printf_va_125 */
  printf("Correctly parses LLONG_MIN: "); /* printf_va_126 */
  reader = redisReaderCreate();
  redisReaderFeed(reader,":-9223372036854775808\r\n",(size_t)23);
  ret = redisReaderGetReply(reader,& reply);
  if (ret == 0) {
    if (((redisReply *)reply)->type == 3) {
      if (((redisReply *)reply)->integer == -9223372036854775807LL - 1LL) 
        printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_127 */
      else goto _LAND_6;
    }
    else goto _LAND_6;
  }
  else {
    _LAND_6:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_128 */
      fails ++;
    }
  }
  freeReplyObject(reply);
  redisReaderFree(reader);
  tests ++;
  printf("#%02d ",tests); /* printf_va_129 */
  printf("Set error when < LLONG_MIN: "); /* printf_va_130 */
  reader = redisReaderCreate();
  redisReaderFeed(reader,":-9223372036854775809\r\n",(size_t)23);
  ret = redisReaderGetReply(reader,& reply);
  if (ret == -1) {
    int tmp_3;
    tmp_3 = strcasecmp((char const *)(reader->errstr),"Bad integer value");
    if (tmp_3 == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_131 */
    else goto _LAND_7;
  }
  else {
    _LAND_7:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_132 */
      fails ++;
    }
  }
  freeReplyObject(reply);
  redisReaderFree(reader);
  tests ++;
  printf("#%02d ",tests); /* printf_va_133 */
  printf("Set error when array < -1: "); /* printf_va_134 */
  reader = redisReaderCreate();
  redisReaderFeed(reader,"*-2\r\n+asdf\r\n",(size_t)12);
  ret = redisReaderGetReply(reader,& reply);
  if (ret == -1) {
    int tmp_4;
    tmp_4 = strcasecmp((char const *)(reader->errstr),
                       "Multi-bulk length out of range");
    if (tmp_4 == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_135 */
    else goto _LAND_8;
  }
  else {
    _LAND_8:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_136 */
      fails ++;
    }
  }
  freeReplyObject(reply);
  redisReaderFree(reader);
  tests ++;
  printf("#%02d ",tests); /* printf_va_137 */
  printf("Set error when bulk < -1: "); /* printf_va_138 */
  reader = redisReaderCreate();
  redisReaderFeed(reader,"$-2\r\nasdf\r\n",(size_t)11);
  ret = redisReaderGetReply(reader,& reply);
  if (ret == -1) {
    int tmp_5;
    tmp_5 = strcasecmp((char const *)(reader->errstr),
                       "Bulk string length out of range");
    if (tmp_5 == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_139 */
    else goto _LAND_9;
  }
  else {
    _LAND_9:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_140 */
      fails ++;
    }
  }
  freeReplyObject(reply);
  redisReaderFree(reader);
  tests ++;
  printf("#%02d ",tests); /* printf_va_141 */
  printf("Set error when array > SIZE_MAX: "); /* printf_va_142 */
  reader = redisReaderCreate();
  redisReaderFeed(reader,"*9223372036854775807\r\n+asdf\r\n",(size_t)29);
  ret = redisReaderGetReply(reader,& reply);
  if (ret == -1) {
    int tmp_6;
    tmp_6 = strcasecmp((char const *)(reader->errstr),
                       "Multi-bulk length out of range");
    if (tmp_6 == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_143 */
    else goto _LAND_10;
  }
  else {
    _LAND_10:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_144 */
      fails ++;
    }
  }
  freeReplyObject(reply);
  redisReaderFree(reader);
  tests ++;
  printf("#%02d ",tests); /* printf_va_145 */
  printf("Set error when bulk > SIZE_MAX: "); /* printf_va_146 */
  reader = redisReaderCreate();
  redisReaderFeed(reader,"$9223372036854775807\r\nasdf\r\n",(size_t)28);
  ret = redisReaderGetReply(reader,& reply);
  if (ret == -1) {
    int tmp_7;
    tmp_7 = strcasecmp((char const *)(reader->errstr),
                       "Bulk string length out of range");
    if (tmp_7 == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_147 */
    else goto _LAND_11;
  }
  else {
    _LAND_11:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_148 */
      fails ++;
    }
  }
  freeReplyObject(reply);
  redisReaderFree(reader);
  tests ++;
  printf("#%02d ",tests); /* printf_va_149 */
  printf("Works with NULL functions for reply: "); /* printf_va_150 */
  reader = redisReaderCreate();
  reader->fn = (redisReplyObjectFunctions *)0;
  redisReaderFeed(reader,"+OK\r\n",(size_t)5);
  ret = redisReaderGetReply(reader,& reply);
  if (ret == 0) {
    if (reply == (void *)5) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_151 */
    else goto _LAND_12;
  }
  else {
    _LAND_12:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_152 */
      fails ++;
    }
  }
  redisReaderFree(reader);
  tests ++;
  printf("#%02d ",tests); /* printf_va_153 */
  printf("Works when a single newline (\\r\\n) covers two calls to feed: "); /* printf_va_154 */
  reader = redisReaderCreate();
  reader->fn = (redisReplyObjectFunctions *)0;
  redisReaderFeed(reader,"+OK\r",(size_t)4);
  ret = redisReaderGetReply(reader,& reply);
  if (ret == 0) 
    if (reply == (void *)0) tmp_8 = 1; else tmp_8 = 0;
  else tmp_8 = 0;
  __FC_assert(tmp_8 != 0,"test.c",444,"ret == REDIS_OK && reply == NULL");
  redisReaderFeed(reader,"\n",(size_t)1);
  ret = redisReaderGetReply(reader,& reply);
  if (ret == 0) {
    if (reply == (void *)5) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_155 */
    else goto _LAND_13;
  }
  else {
    _LAND_13:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_156 */
      fails ++;
    }
  }
  redisReaderFree(reader);
  tests ++;
  printf("#%02d ",tests); /* printf_va_157 */
  printf("Don\'t reset state after protocol error: "); /* printf_va_158 */
  reader = redisReaderCreate();
  reader->fn = (redisReplyObjectFunctions *)0;
  redisReaderFeed(reader,"x",(size_t)1);
  ret = redisReaderGetReply(reader,& reply);
  __FC_assert((ret == -1) != 0,"test.c",455,"ret == REDIS_ERR");
  ret = redisReaderGetReply(reader,& reply);
  if (ret == -1) {
    if (reply == (void *)0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_159 */
    else goto _LAND_14;
  }
  else {
    _LAND_14:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_160 */
      fails ++;
    }
  }
  redisReaderFree(reader);
  tests ++;
  printf("#%02d ",tests); /* printf_va_161 */
  printf("Don\'t do empty allocation for empty multi bulk: "); /* printf_va_162 */
  reader = redisReaderCreate();
  redisReaderFeed(reader,"*0\r\n",(size_t)4);
  ret = redisReaderGetReply(reader,& reply);
  if (ret == 0) {
    if (((redisReply *)reply)->type == 2) {
      if (((redisReply *)reply)->elements == (size_t)0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_163 */
      else goto _LAND_16;
    }
    else goto _LAND_16;
  }
  else {
    _LAND_16:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_164 */
      fails ++;
    }
  }
  freeReplyObject(reply);
  redisReaderFree(reader);
  return;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_165(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_166(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_167(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_168(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_169(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_170(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_171(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_172(char const * restrict format);

static void test_free_null(void)
{
  void *redisCtx = (void *)0;
  void *reply = (void *)0;
  tests ++;
  printf("#%02d ",tests); /* printf_va_165 */
  printf("Don\'t fail when redisFree is passed a NULL value: "); /* printf_va_166 */
  redisFree((redisContext *)redisCtx);
  if (redisCtx == (void *)0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_167 */
  else {
    printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_168 */
    fails ++;
  }
  tests ++;
  printf("#%02d ",tests); /* printf_va_169 */
  printf("Don\'t fail when freeReplyObject is passed a NULL value: "); /* printf_va_170 */
  freeReplyObject(reply);
  if (reply == (void *)0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_171 */
  else {
    printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_172 */
    fails ++;
  }
  return;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_173(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_174(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_175(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_176(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_177(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_178(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_179(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_180(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_181(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_182(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_183(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_184(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_185(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_186(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_187(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_188(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_189(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_190(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_191(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_192(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_193(char const * restrict format);

static void test_blocking_connection_errors(void)
{
  redisContext *c;
  struct addrinfo hints =
    {.ai_flags = 0,
     .ai_family = 2,
     .ai_socktype = 0,
     .ai_protocol = 0,
     .ai_addrlen = 0U,
     .ai_addr = (struct sockaddr *)0,
     .ai_canonname = (char *)0,
     .ai_next = (struct addrinfo *)0};
  struct addrinfo *ai_tmp = (struct addrinfo *)0;
  int rv =
    getaddrinfo("idontexist-noreally.com","6379",
                (struct addrinfo const *)(& hints),& ai_tmp);
  if (rv != 0) {
    tests ++;
    printf("#%02d ",tests); /* printf_va_173 */
    printf("Returns error when host cannot be resolved: "); /* printf_va_174 */
    c = redisConnect("idontexist-noreally.com",6379);
    if (c->err == 2) {
      int tmp_0;
      tmp_0 = strcmp((char const *)(c->errstr),"Name or service not known");
      if (tmp_0 == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_175 */
      else {
        int tmp_1;
        tmp_1 = strcmp((char const *)(c->errstr),
                       "Can\'t resolve: idontexist-noreally.com");
        if (tmp_1 == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_176 */
        else {
          int tmp_2;
          tmp_2 = strcmp((char const *)(c->errstr),"Name does not resolve");
          if (tmp_2 == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_177 */
          else {
            int tmp_3;
            tmp_3 = strcmp((char const *)(c->errstr),
                           "nodename nor servname provided, or not known");
            if (tmp_3 == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_178 */
            else {
              int tmp_4;
              tmp_4 = strcmp((char const *)(c->errstr),
                             "No address associated with hostname");
              if (tmp_4 == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_179 */
              else {
                int tmp_5;
                tmp_5 = strcmp((char const *)(c->errstr),
                               "Temporary failure in name resolution");
                if (tmp_5 == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_180 */
                else {
                  int tmp_6;
                  tmp_6 = strcmp((char const *)(c->errstr),
                                 "hostname nor servname provided, or not known");
                  if (tmp_6 == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_181 */
                  else {
                    int tmp_7;
                    tmp_7 = strcmp((char const *)(c->errstr),
                                   "no address associated with name");
                    if (tmp_7 == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_182 */
                    else {
                      int tmp_8;
                      tmp_8 = strcmp((char const *)(c->errstr),
                                     "No such host is known. ");
                      if (tmp_8 == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_183 */
                      else goto _LAND;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    else {
      _LAND:
      {
        printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_184 */
        fails ++;
      }
    }
    redisFree(c);
  }
  else {
    printf("Skipping NXDOMAIN test. Found evil ISP!\n"); /* printf_va_185 */
    freeaddrinfo(ai_tmp);
  }
  tests ++;
  printf("#%02d ",tests); /* printf_va_186 */
  printf("Returns error when the port is not open: "); /* printf_va_187 */
  c = redisConnect("localhost",1);
  if (c->err == 1) {
    int tmp_9;
    tmp_9 = strcmp((char const *)(c->errstr),"Connection refused");
    if (tmp_9 == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_188 */
    else goto _LAND_0;
  }
  else {
    _LAND_0:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_189 */
      fails ++;
    }
  }
  redisFree(c);
  tests ++;
  printf("#%02d ",tests); /* printf_va_190 */
  printf("Returns error when the unix_sock socket path doesn\'t accept connections: "); /* printf_va_191 */
  c = redisConnectUnix("/tmp/idontexist.sock");
  if (c->err == 1) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_192 */
  else {
    printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_193 */
    fails ++;
  }
  redisFree(c);
  return;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_194(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_195(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_196(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_197(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_198(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_199(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_200(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_201(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_202(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_203(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_204(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_205(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_206(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_207(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_208(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_209(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_210(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_211(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_212(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_213(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_214(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_215(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_216(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_217(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_218(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_219(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_220(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_221(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_222(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_223(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_224(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_225(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_226(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_227(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_228(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_229(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_230(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_231(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_232(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_233(char const * restrict format);

static void test_blocking_connection(struct config config)
{
  redisContext *c;
  redisReply *reply;
  void *tmp_3;
  void *tmp_4;
  void *tmp_7;
  void *tmp_8;
  void *tmp_9;
  int tmp_13;
  int tmp_14;
  c = do_connect(config);
  tests ++;
  printf("#%02d ",tests); /* printf_va_194 */
  printf("Is able to deliver commands: "); /* printf_va_195 */
  {
    void *__va_args[1] = {(void *)0};
    reply = (redisReply *)redisCommand(c,"PING",(void * const *)(__va_args));
  }
  if (reply->type == 5) {
    int tmp;
    tmp = strcasecmp((char const *)reply->str,"pong");
    if (tmp == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_196 */
    else goto _LAND;
  }
  else {
    _LAND:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_197 */
      fails ++;
    }
  }
  freeReplyObject((void *)reply);
  tests ++;
  printf("#%02d ",tests); /* printf_va_198 */
  printf("Is a able to send commands verbatim: "); /* printf_va_199 */
  {
    void *__va_args_22[1] = {(void *)0};
    reply = (redisReply *)redisCommand(c,"SET foo bar",
                                       (void * const *)(__va_args_22));
  }
  if (reply->type == 5) {
    int tmp_0;
    tmp_0 = strcasecmp((char const *)reply->str,"ok");
    if (tmp_0 == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_200 */
    else goto _LAND_0;
  }
  else {
    _LAND_0:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_201 */
      fails ++;
    }
  }
  freeReplyObject((void *)reply);
  tests ++;
  printf("#%02d ",tests); /* printf_va_202 */
  printf("%%s String interpolation works: "); /* printf_va_203 */
  {
    char const *__va_arg0 = "foo";
    char const *__va_arg1 = "hello world";
    void *__va_args_26[2] = {& __va_arg0, & __va_arg1};
    reply = (redisReply *)redisCommand(c,"SET %s %s",
                                       (void * const *)(__va_args_26));
  }
  freeReplyObject((void *)reply);
  {
    void *__va_args_28[1] = {(void *)0};
    reply = (redisReply *)redisCommand(c,"GET foo",
                                       (void * const *)(__va_args_28));
  }
  if (reply->type == 1) {
    int tmp_1;
    tmp_1 = strcmp((char const *)reply->str,"hello world");
    if (tmp_1 == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_204 */
    else goto _LAND_1;
  }
  else {
    _LAND_1:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_205 */
      fails ++;
    }
  }
  freeReplyObject((void *)reply);
  tests ++;
  printf("#%02d ",tests); /* printf_va_206 */
  printf("%%b String interpolation works: "); /* printf_va_207 */
  {
    char const *__va_arg0_30 = "foo";
    size_t __va_arg1_32 = (size_t)3;
    char const *__va_arg2 = "hello\000world";
    size_t __va_arg3 = (size_t)11;
    void *__va_args_36[4] =
      {& __va_arg0_30, & __va_arg1_32, & __va_arg2, & __va_arg3};
    reply = (redisReply *)redisCommand(c,"SET %b %b",
                                       (void * const *)(__va_args_36));
  }
  freeReplyObject((void *)reply);
  {
    void *__va_args_38[1] = {(void *)0};
    reply = (redisReply *)redisCommand(c,"GET foo",
                                       (void * const *)(__va_args_38));
  }
  if (reply->type == 1) {
    int tmp_2;
    tmp_2 = memcmp((void const *)reply->str,(void const *)"hello\000world",
                   (size_t)11);
    if (tmp_2 == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_208 */
    else goto _LAND_2;
  }
  else {
    _LAND_2:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_209 */
      fails ++;
    }
  }
  tests ++;
  printf("#%02d ",tests); /* printf_va_210 */
  printf("Binary reply length is correct: "); /* printf_va_211 */
  if (reply->len == (size_t)11) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_212 */
  else {
    printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_213 */
    fails ++;
  }
  freeReplyObject((void *)reply);
  tests ++;
  printf("#%02d ",tests); /* printf_va_214 */
  printf("Can parse nil replies: "); /* printf_va_215 */
  {
    void *__va_args_40[1] = {(void *)0};
    reply = (redisReply *)redisCommand(c,"GET nokey",
                                       (void * const *)(__va_args_40));
  }
  if (reply->type == 4) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_216 */
  else {
    printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_217 */
    fails ++;
  }
  freeReplyObject((void *)reply);
  tests ++;
  printf("#%02d ",tests); /* printf_va_218 */
  printf("Can parse integer replies: "); /* printf_va_219 */
  {
    void *__va_args_42[1] = {(void *)0};
    reply = (redisReply *)redisCommand(c,"INCR mycounter",
                                       (void * const *)(__va_args_42));
  }
  if (reply->type == 3) {
    if (reply->integer == (long long)1) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_220 */
    else goto _LAND_3;
  }
  else {
    _LAND_3:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_221 */
      fails ++;
    }
  }
  freeReplyObject((void *)reply);
  tests ++;
  printf("#%02d ",tests); /* printf_va_222 */
  printf("Can parse multi bulk replies: "); /* printf_va_223 */
  {
    void *__va_args_44[1] = {(void *)0};
    tmp_3 = redisCommand(c,"LPUSH mylist foo",(void * const *)(__va_args_44));
  }
  freeReplyObject(tmp_3);
  {
    void *__va_args_46[1] = {(void *)0};
    tmp_4 = redisCommand(c,"LPUSH mylist bar",(void * const *)(__va_args_46));
  }
  freeReplyObject(tmp_4);
  {
    void *__va_args_48[1] = {(void *)0};
    reply = (redisReply *)redisCommand(c,"LRANGE mylist 0 -1",
                                       (void * const *)(__va_args_48));
  }
  if (reply->type == 2) {
    if (reply->elements == (size_t)2) {
      int tmp_5;
      tmp_5 = memcmp((void const *)(*(reply->element + 0))->str,
                     (void const *)"bar",(size_t)3);
      if (tmp_5) goto _LAND_6;
      else {
        int tmp_6;
        tmp_6 = memcmp((void const *)(*(reply->element + 1))->str,
                       (void const *)"foo",(size_t)3);
        if (tmp_6) goto _LAND_6;
        else printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_224 */
      }
    }
    else goto _LAND_6;
  }
  else {
    _LAND_6:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_225 */
      fails ++;
    }
  }
  freeReplyObject((void *)reply);
  tests ++;
  printf("#%02d ",tests); /* printf_va_226 */
  printf("Can handle nested multi bulk replies: "); /* printf_va_227 */
  {
    void *__va_args_50[1] = {(void *)0};
    tmp_7 = redisCommand(c,"MULTI",(void * const *)(__va_args_50));
  }
  freeReplyObject(tmp_7);
  {
    void *__va_args_52[1] = {(void *)0};
    tmp_8 = redisCommand(c,"LRANGE mylist 0 -1",
                         (void * const *)(__va_args_52));
  }
  freeReplyObject(tmp_8);
  {
    void *__va_args_54[1] = {(void *)0};
    tmp_9 = redisCommand(c,"PING",(void * const *)(__va_args_54));
  }
  freeReplyObject(tmp_9);
  {
    void *__va_args_56[1] = {(void *)0};
    reply = (redisReply *)redisCommand(c,"EXEC",
                                       (void * const *)(__va_args_56));
  }
  if (reply->type == 2) {
    if (reply->elements == (size_t)2) {
      if ((*(reply->element + 0))->type == 2) {
        if ((*(reply->element + 0))->elements == (size_t)2) {
          int tmp_10;
          tmp_10 = memcmp((void const *)(*((*(reply->element + 0))->element + 0))->str,
                          (void const *)"bar",(size_t)3);
          if (tmp_10) goto _LAND_13;
          else {
            int tmp_11;
            tmp_11 = memcmp((void const *)(*((*(reply->element + 0))->element + 1))->str,
                            (void const *)"foo",(size_t)3);
            if (tmp_11) goto _LAND_13;
            else 
              if ((*(reply->element + 1))->type == 5) {
                int tmp_12;
                tmp_12 = strcasecmp((char const *)(*(reply->element + 1))->str,
                                    "pong");
                if (tmp_12 == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_228 */
                else goto _LAND_13;
              }
              else goto _LAND_13;
          }
        }
        else goto _LAND_13;
      }
      else goto _LAND_13;
    }
    else goto _LAND_13;
  }
  else {
    _LAND_13:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_229 */
      fails ++;
    }
  }
  freeReplyObject((void *)reply);
  tests ++;
  printf("#%02d ",tests); /* printf_va_230 */
  printf("Can pass NULL to redisGetReply: "); /* printf_va_231 */
  {
    void *__va_args_58[1] = {(void *)0};
    tmp_13 = redisAppendCommand(c,"PING",(void * const *)(__va_args_58));
  }
  __FC_assert((tmp_13 == 0) != 0,"test.c",605,
              "redisAppendCommand(c, \"PING\") == REDIS_OK");
  tmp_14 = redisGetReply(c,(void **)0);
  if (tmp_14 == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_232 */
  else {
    printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_233 */
    fails ++;
  }
  disconnect(c,0);
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_1(FILE * restrict stream, char const * restrict format,
                 char *param0);

static int detect_debug_sleep(redisContext *c)
{
  int detected;
  void *__va_args[1] = {(void *)0};
  redisReply *reply =
    redisCommand(c,"DEBUG SLEEP 0\r\n",(void * const *)(__va_args));
  if (reply == (redisReply *)0) goto _LOR;
  else 
    if (c->err) {
      _LOR:
      {
        char const *tmp_0;
        if (c->err) tmp_0 = (char const *)(c->errstr); else tmp_0 = "(none)";
        char const *cause = tmp_0;
        fprintf(__fc_stderr,
                "Error testing for DEBUG SLEEP (Redis error: %s), exiting\n",
                (char *)cause); /* fprintf_va_1 */
        exit(-1);
      }
    }
  detected = reply->type == 5;
  freeReplyObject((void *)reply);
  return detected;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_234(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_235(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_236(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_237(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_238(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_239(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_240(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_241(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_242(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_243(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_244(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_245(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_246(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_247(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_248(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_249(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_250(char const * restrict format);

static void test_blocking_connection_timeouts(struct config config)
{
  redisContext *c;
  redisReply *reply;
  ssize_t s;
  struct timeval tv;
  int tmp_2;
  char const *sleep_cmd = "DEBUG SLEEP 3\r\n";
  c = do_connect(config);
  tests ++;
  printf("#%02d ",tests); /* printf_va_234 */
  printf("Successfully completes a command when the timeout is not exceeded: "); /* printf_va_235 */
  {
    void *__va_args[1] = {(void *)0};
    reply = (redisReply *)redisCommand(c,"SET foo fast",
                                       (void * const *)(__va_args));
  }
  freeReplyObject((void *)reply);
  tv.tv_sec = (time_t)0;
  tv.tv_usec = 10000;
  redisSetTimeout(c,tv);
  {
    void *__va_args_15[1] = {(void *)0};
    reply = (redisReply *)redisCommand(c,"GET foo",
                                       (void * const *)(__va_args_15));
  }
  if (reply != (redisReply *)0) {
    if (reply->type == 1) {
      int tmp;
      tmp = memcmp((void const *)reply->str,(void const *)"fast",(size_t)4);
      if (tmp == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_236 */
      else goto _LAND_0;
    }
    else goto _LAND_0;
  }
  else {
    _LAND_0:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_237 */
      fails ++;
    }
  }
  freeReplyObject((void *)reply);
  disconnect(c,0);
  c = do_connect(config);
  tests ++;
  printf("#%02d ",tests); /* printf_va_238 */
  printf("Does not return a reply when the command times out: "); /* printf_va_239 */
  tmp_2 = detect_debug_sleep(c);
  if (tmp_2) {
    size_t tmp_0;
    tmp_0 = strlen(sleep_cmd);
    ;
    ;
    redisAppendFormattedCommand(c,sleep_cmd,tmp_0);
    s = (*((c->funcs)->write))(c);
    tv.tv_sec = (time_t)0;
    tv.tv_usec = 10000;
    redisSetTimeout(c,tv);
    {
      void *__va_args_17[1] = {(void *)0};
      reply = (redisReply *)redisCommand(c,"GET foo",
                                         (void * const *)(__va_args_17));
    }
    if (s > 0) {
      if (reply == (redisReply *)0) {
        if (c->err == 1) {
          int tmp_1;
          tmp_1 = strcmp((char const *)(c->errstr),
                         "Resource temporarily unavailable");
          if (tmp_1 == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_240 */
          else goto _LAND_3;
        }
        else goto _LAND_3;
      }
      else goto _LAND_3;
    }
    else {
      _LAND_3:
      {
        printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_241 */
        fails ++;
      }
    }
    freeReplyObject((void *)reply);
  }
  else {
    printf("\033[01;33mSKIPPED\033[0;0m\n"); /* printf_va_242 */
    skips ++;
  }
  tests ++;
  printf("#%02d ",tests); /* printf_va_243 */
  printf("Reconnect properly reconnects after a timeout: "); /* printf_va_244 */
  do_reconnect(c,config);
  {
    void *__va_args_19[1] = {(void *)0};
    reply = (redisReply *)redisCommand(c,"PING",
                                       (void * const *)(__va_args_19));
  }
  if (reply != (redisReply *)0) {
    if (reply->type == 5) {
      int tmp_3;
      tmp_3 = strcmp((char const *)reply->str,"PONG");
      if (tmp_3 == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_245 */
      else goto _LAND_5;
    }
    else goto _LAND_5;
  }
  else {
    _LAND_5:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_246 */
      fails ++;
    }
  }
  freeReplyObject((void *)reply);
  tests ++;
  printf("#%02d ",tests); /* printf_va_247 */
  printf("Reconnect properly uses owned parameters: "); /* printf_va_248 */
  config.tcp.host = "foo";
  config.unix_sock.path = "foo";
  do_reconnect(c,config);
  {
    void *__va_args_21[1] = {(void *)0};
    reply = (redisReply *)redisCommand(c,"PING",
                                       (void * const *)(__va_args_21));
  }
  if (reply != (redisReply *)0) {
    if (reply->type == 5) {
      int tmp_4;
      tmp_4 = strcmp((char const *)reply->str,"PONG");
      if (tmp_4 == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_249 */
      else goto _LAND_7;
    }
    else goto _LAND_7;
  }
  else {
    _LAND_7:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_250 */
      fails ++;
    }
  }
  freeReplyObject((void *)reply);
  disconnect(c,0);
  return;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_251(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_252(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_253(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_254(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_255(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_256(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_257(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_258(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_259(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_260(char const * restrict format);

static void test_blocking_io_errors(struct config config)
{
  redisContext *c;
  redisReply *reply;
  void *_reply;
  int major;
  int minor;
  int tmp_3;
  int tmp_4;
  c = do_connect(config);
  {
    char *p;
    char *eptr;
    size_t tmp;
    char const *field = "redis_version:";
    {
      void *__va_args[1] = {(void *)0};
      reply = (redisReply *)redisCommand(c,"INFO",
                                         (void * const *)(__va_args));
    }
    p = strstr((char const *)reply->str,field);
    tmp = strlen(field);
    ;
    major = (int)strtol((char const *)(p + tmp),& eptr,10);
    p = eptr + 1;
    minor = (int)strtol((char const *)p,& eptr,10);
    freeReplyObject((void *)reply);
  }
  tests ++;
  printf("#%02d ",tests); /* printf_va_251 */
  printf("Returns I/O error when the connection is lost: "); /* printf_va_252 */
  {
    void *__va_args_21[1] = {(void *)0};
    reply = (redisReply *)redisCommand(c,"QUIT",
                                       (void * const *)(__va_args_21));
  }
  if (major > 2) goto _LOR;
  else 
    if (major == 2) {
      if (minor > 0) {
        _LOR:
        {
          int tmp_0;
          tmp_0 = strcasecmp((char const *)reply->str,"OK");
          if (tmp_0 == 0) {
            int tmp_1;
            tmp_1 = redisGetReply(c,& _reply);
            if (tmp_1 == -1) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_253 */
            else goto _LAND;
          }
          else {
            _LAND:
            {
              printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_254 */
              fails ++;
            }
          }
          freeReplyObject((void *)reply);
        }
      }
      else goto _LAND_0;
    }
    else 
      _LAND_0:
      if (reply == (redisReply *)0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_255 */
      else {
        printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_256 */
        fails ++;
      }
  if (c->err == 3) {
    int tmp_2;
    tmp_2 = strcmp((char const *)(c->errstr),"Server closed the connection");
    if (tmp_2 == 0) tmp_3 = 1; else tmp_3 = 0;
  }
  else tmp_3 = 0;
  __FC_assert(tmp_3 != 0,"test.c",724,
              "c->err == REDIS_ERR_EOF && strcmp(c->errstr,\"Server closed the connection\") == 0");
  redisFree(c);
  c = do_connect(config);
  tests ++;
  printf("#%02d ",tests); /* printf_va_257 */
  printf("Returns I/O error on socket timeout: "); /* printf_va_258 */
  struct timeval tv = {.tv_sec = (time_t)0, .tv_usec = 1000};
  tmp_4 = redisSetTimeout(c,tv);
  __FC_assert((tmp_4 == 0) != 0,"test.c",732,
              "redisSetTimeout(c,tv) == REDIS_OK");
  int respcode = redisGetReply(c,& _reply);
  if (respcode == -1) {
    if (c->err == 1) {
      if (__fc_errno == 11) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_259 */
      else goto _LAND_2;
    }
    else goto _LAND_2;
  }
  else {
    _LAND_2:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_260 */
      fails ++;
    }
  }
  redisFree(c);
  return;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_261(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_262(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_263(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_264(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_265(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_266(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_267(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_268(char const * restrict format);

static void test_invalid_timeout_errors(struct config config)
{
  redisContext *c;
  tests ++;
  printf("#%02d ",tests); /* printf_va_261 */
  printf("Set error when an invalid timeout usec value is given to redisConnectWithTimeout: "); /* printf_va_262 */
  config.tcp.timeout.tv_sec = (time_t)0;
  config.tcp.timeout.tv_usec = 10000001;
  c = redisConnectWithTimeout(config.tcp.host,config.tcp.port,
                              config.tcp.timeout);
  if (c->err == 1) {
    int tmp;
    tmp = strcmp((char const *)(c->errstr),"Invalid timeout specified");
    if (tmp == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_263 */
    else goto _LAND;
  }
  else {
    _LAND:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_264 */
      fails ++;
    }
  }
  redisFree(c);
  tests ++;
  printf("#%02d ",tests); /* printf_va_265 */
  printf("Set error when an invalid timeout sec value is given to redisConnectWithTimeout: "); /* printf_va_266 */
  config.tcp.timeout.tv_sec = (2147483647L - (long)999) / (long)1000 + (long)1;
  config.tcp.timeout.tv_usec = 0;
  c = redisConnectWithTimeout(config.tcp.host,config.tcp.port,
                              config.tcp.timeout);
  if (c->err == 1) {
    int tmp_0;
    tmp_0 = strcmp((char const *)(c->errstr),"Invalid timeout specified");
    if (tmp_0 == 0) printf("\033[0;32mPASSED\033[0;0m\n"); /* printf_va_267 */
    else goto _LAND_0;
  }
  else {
    _LAND_0:
    {
      printf("\033[0;31mFAILED\033[0;0m\n"); /* printf_va_268 */
      fails ++;
    }
  }
  redisFree(c);
  return;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_269(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_270(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, param0;
 */
int printf_va_271(char const * restrict format, int param0, double param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, param0;
 */
int printf_va_272(char const * restrict format, int param0, double param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, param0;
 */
int printf_va_273(char const * restrict format, int param0, double param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, param0;
 */
int printf_va_274(char const * restrict format, int param0, double param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, param0;
 */
int printf_va_275(char const * restrict format, int param0, double param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, param0;
 */
int printf_va_276(char const * restrict format, int param0, double param1);

static void test_throughput(struct config config)
{
  redisReply **replies;
  int i;
  int num;
  long long t1;
  long long t2;
  redisContext *c = do_connect(config);
  tests ++;
  printf("#%02d ",tests); /* printf_va_269 */
  printf("Throughput:\n"); /* printf_va_270 */
  i = 0;
  while (i < 500) {
    void *tmp_0;
    {
      void *__va_args[1] = {(void *)0};
      tmp_0 = redisCommand(c,"LPUSH mylist foo",(void * const *)(__va_args));
    }
    freeReplyObject(tmp_0);
    i ++;
  }
  num = 1000;
  replies = (redisReply **)malloc(sizeof(redisReply *) * (unsigned int)num);
  t1 = usec();
  i = 0;
  while (i < num) {
    {
      int tmp_1;
      {
        void *__va_args_23[1] = {(void *)0};
        *(replies + i) = (redisReply *)redisCommand(c,"PING",
                                                    (void * const *)(__va_args_23));
      }
      if (*(replies + i) != (redisReply *)0) 
        if ((*(replies + i))->type == 5) tmp_1 = 1; else tmp_1 = 0;
      else tmp_1 = 0;
      __FC_assert(tmp_1 != 0,"test.c",781,
                  "replies[i] != NULL && replies[i]->type == REDIS_REPLY_STATUS");
    }
    i ++;
  }
  t2 = usec();
  i = 0;
  while (i < num) {
    freeReplyObject((void *)*(replies + i));
    i ++;
  }
  free((void *)replies);
  printf("\t(%dx PING: %.3fs)\n",num,(double)(t2 - t1) / 1000000.0); /* printf_va_271 */
  replies = (redisReply **)malloc(sizeof(redisReply *) * (unsigned int)num);
  t1 = usec();
  i = 0;
  while (i < num) {
    {
      int tmp_2;
      int tmp_3;
      {
        void *__va_args_25[1] = {(void *)0};
        *(replies + i) = (redisReply *)redisCommand(c,"LRANGE mylist 0 499",
                                                    (void * const *)(__va_args_25));
      }
      if (*(replies + i) != (redisReply *)0) 
        if ((*(replies + i))->type == 2) tmp_2 = 1; else tmp_2 = 0;
      else tmp_2 = 0;
      __FC_assert(tmp_2 != 0,"test.c",792,
                  "replies[i] != NULL && replies[i]->type == REDIS_REPLY_ARRAY");
      if (*(replies + i) != (redisReply *)0) 
        if ((*(replies + i))->elements == (size_t)500) tmp_3 = 1;
        else tmp_3 = 0;
      else tmp_3 = 0;
      __FC_assert(tmp_3 != 0,"test.c",793,
                  "replies[i] != NULL && replies[i]->elements == 500");
    }
    i ++;
  }
  t2 = usec();
  i = 0;
  while (i < num) {
    freeReplyObject((void *)*(replies + i));
    i ++;
  }
  free((void *)replies);
  printf("\t(%dx LRANGE with 500 elements: %.3fs)\n",num,
         (double)(t2 - t1) / 1000000.0); /* printf_va_272 */
  replies = (redisReply **)malloc(sizeof(redisReply *) * (unsigned int)num);
  t1 = usec();
  i = 0;
  while (i < num) {
    {
      int tmp_4;
      {
        int __va_arg0 = 1000000;
        void *__va_args_28[1] = {& __va_arg0};
        *(replies + i) = (redisReply *)redisCommand(c,"INCRBY incrkey %d",
                                                    (void * const *)(__va_args_28));
      }
      if (*(replies + i) != (redisReply *)0) 
        if ((*(replies + i))->type == 3) tmp_4 = 1; else tmp_4 = 0;
      else tmp_4 = 0;
      __FC_assert(tmp_4 != 0,"test.c",804,
                  "replies[i] != NULL && replies[i]->type == REDIS_REPLY_INTEGER");
    }
    i ++;
  }
  t2 = usec();
  i = 0;
  while (i < num) {
    freeReplyObject((void *)*(replies + i));
    i ++;
  }
  free((void *)replies);
  printf("\t(%dx INCRBY: %.3fs)\n",num,(double)(t2 - t1) / 1000000.0); /* printf_va_273 */
  num = 10000;
  replies = (redisReply **)malloc(sizeof(redisReply *) * (unsigned int)num);
  i = 0;
  while (i < num) {
    {
      void *__va_args_30[1] = {(void *)0};
      redisAppendCommand(c,"PING",(void * const *)(__va_args_30));
    }
    i ++;
  }
  t1 = usec();
  i = 0;
  while (i < num) {
    {
      int tmp_5;
      int tmp_6;
      tmp_5 = redisGetReply(c,(void **)(replies + i));
      __FC_assert((tmp_5 == 0) != 0,"test.c",817,
                  "redisGetReply(c, (void*)&replies[i]) == REDIS_OK");
      if (*(replies + i) != (redisReply *)0) 
        if ((*(replies + i))->type == 5) tmp_6 = 1; else tmp_6 = 0;
      else tmp_6 = 0;
      __FC_assert(tmp_6 != 0,"test.c",818,
                  "replies[i] != NULL && replies[i]->type == REDIS_REPLY_STATUS");
    }
    i ++;
  }
  t2 = usec();
  i = 0;
  while (i < num) {
    freeReplyObject((void *)*(replies + i));
    i ++;
  }
  free((void *)replies);
  printf("\t(%dx PING (pipelined): %.3fs)\n",num,
         (double)(t2 - t1) / 1000000.0); /* printf_va_274 */
  replies = (redisReply **)malloc(sizeof(redisReply *) * (unsigned int)num);
  i = 0;
  while (i < num) {
    {
      void *__va_args_32[1] = {(void *)0};
      redisAppendCommand(c,"LRANGE mylist 0 499",
                         (void * const *)(__va_args_32));
    }
    i ++;
  }
  t1 = usec();
  i = 0;
  while (i < num) {
    {
      int tmp_7;
      int tmp_8;
      int tmp_9;
      tmp_7 = redisGetReply(c,(void **)(replies + i));
      __FC_assert((tmp_7 == 0) != 0,"test.c",830,
                  "redisGetReply(c, (void*)&replies[i]) == REDIS_OK");
      if (*(replies + i) != (redisReply *)0) 
        if ((*(replies + i))->type == 2) tmp_8 = 1; else tmp_8 = 0;
      else tmp_8 = 0;
      __FC_assert(tmp_8 != 0,"test.c",831,
                  "replies[i] != NULL && replies[i]->type == REDIS_REPLY_ARRAY");
      if (*(replies + i) != (redisReply *)0) 
        if ((*(replies + i))->elements == (size_t)500) tmp_9 = 1;
        else tmp_9 = 0;
      else tmp_9 = 0;
      __FC_assert(tmp_9 != 0,"test.c",832,
                  "replies[i] != NULL && replies[i]->elements == 500");
    }
    i ++;
  }
  t2 = usec();
  i = 0;
  while (i < num) {
    freeReplyObject((void *)*(replies + i));
    i ++;
  }
  free((void *)replies);
  printf("\t(%dx LRANGE with 500 elements (pipelined): %.3fs)\n",num,
         (double)(t2 - t1) / 1000000.0); /* printf_va_275 */
  replies = (redisReply **)malloc(sizeof(redisReply *) * (unsigned int)num);
  i = 0;
  while (i < num) {
    {
      int __va_arg0_34 = 1000000;
      void *__va_args_36[1] = {& __va_arg0_34};
      redisAppendCommand(c,"INCRBY incrkey %d",
                         (void * const *)(__va_args_36));
    }
    i ++;
  }
  t1 = usec();
  i = 0;
  while (i < num) {
    {
      int tmp_10;
      int tmp_11;
      tmp_10 = redisGetReply(c,(void **)(replies + i));
      __FC_assert((tmp_10 == 0) != 0,"test.c",844,
                  "redisGetReply(c, (void*)&replies[i]) == REDIS_OK");
      if (*(replies + i) != (redisReply *)0) 
        if ((*(replies + i))->type == 3) tmp_11 = 1; else tmp_11 = 0;
      else tmp_11 = 0;
      __FC_assert(tmp_11 != 0,"test.c",845,
                  "replies[i] != NULL && replies[i]->type == REDIS_REPLY_INTEGER");
    }
    i ++;
  }
  t2 = usec();
  i = 0;
  while (i < num) {
    freeReplyObject((void *)*(replies + i));
    i ++;
  }
  free((void *)replies);
  printf("\t(%dx INCRBY (pipelined): %.3fs)\n",num,
         (double)(t2 - t1) / 1000000.0); /* printf_va_276 */
  disconnect(c,0);
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_2(FILE * restrict stream, char const * restrict format,
                 char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_277(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_278(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_279(char const * restrict format, int param0);

int main(int argc, char **argv)
{
  int __retres;
  int test_unix_socket;
  int tmp_5;
  struct config cfg =
    {.type = 0,
     .tcp = {.host = "127.0.0.1",
             .port = 6379,
             .timeout = {.tv_sec = 0L, .tv_usec = 0}},
     .unix_sock = {.path = "/tmp/redis.sock"},
     .ssl = {.host = (char const *)0,
             .port = 0,
             .ca_cert = (char const *)0,
             .cert = (char const *)0,
             .key = (char const *)0}};
  int throughput = 1;
  int test_inherit_fd = 1;
  int skips_as_fails = 0;
  argv ++;
  argc --;
  while (argc) {
    if (argc >= 2) {
      int tmp_4;
      tmp_4 = strcmp((char const *)*(argv + 0),"-h");
      if (tmp_4) goto _LAND_4;
      else {
        argv ++;
        argc --;
        cfg.tcp.host = (char const *)*(argv + 0);
      }
    }
    else {
      _LAND_4: ;
      if (argc >= 2) {
        int tmp_3;
        tmp_3 = strcmp((char const *)*(argv + 0),"-p");
        if (tmp_3) goto _LAND_3;
        else {
          argv ++;
          argc --;
          cfg.tcp.port = atoi((char const *)*(argv + 0));
        }
      }
      else {
        _LAND_3: ;
        if (argc >= 2) {
          int tmp_2;
          tmp_2 = strcmp((char const *)*(argv + 0),"-s");
          if (tmp_2) goto _LAND_2;
          else {
            argv ++;
            argc --;
            cfg.unix_sock.path = (char const *)*(argv + 0);
          }
        }
        else {
          _LAND_2: ;
          if (argc >= 1) {
            int tmp_1;
            tmp_1 = strcmp((char const *)*(argv + 0),"--skip-throughput");
            if (tmp_1) goto _LAND_1; else throughput = 0;
          }
          else {
            _LAND_1: ;
            if (argc >= 1) {
              int tmp_0;
              tmp_0 = strcmp((char const *)*(argv + 0),"--skip-inherit-fd");
              if (tmp_0) goto _LAND_0; else test_inherit_fd = 0;
            }
            else {
              _LAND_0: ;
              if (argc >= 1) {
                int tmp;
                tmp = strcmp((char const *)*(argv + 0),"--skips-as-fails");
                if (tmp) goto _LAND; else skips_as_fails = 1;
              }
              else {
                _LAND:
                {
                  fprintf(__fc_stderr,"Invalid argument: %s\n",*(argv + 0)); /* fprintf_va_2 */
                  exit(1);
                }
              }
            }
          }
        }
      }
    }
    argv ++;
    argc --;
  }
  signal(13,SIG_IGN);
  tmp_5 = access(cfg.unix_sock.path,0);
  test_unix_socket = tmp_5 == 0;
  test_format_commands();
  if (fails) goto _LOR;
  else 
    if (skips_as_fails) 
      if (skips) {
        _LOR:
        {
          printf("*** %d TESTS FAILED ***\n",fails); /* printf_va_277 */
          if (skips) printf("*** %d TESTS SKIPPED ***\n",skips); /* printf_va_278 */
          __retres = 1;
          goto return_label;
        }
      }
  printf("ALL TESTS PASSED (%d skipped)\n",skips); /* printf_va_279 */
  __retres = 0;
  return_label: return __retres;
}

int eva_main(void)
{
  char argv0[256];
  char argv1[256];
  char argv2[256];
  char argv3[256];
  char argv4[256];
  int tmp_0;
  int argc = Frama_C_interval(0,5);
  char *argv[6] = {argv0, argv1, argv2, argv3, argv4, (char *)0};
  {
    int i = 0;
    /*@ loop unroll 5; */
    while (i < 5) {
      Frama_C_make_unknown(argv[i],(size_t)255);
      *(argv[i] + 255) = (char)0;
      i ++;
    }
  }
  tmp_0 = main(argc,argv);
  return tmp_0;
}


