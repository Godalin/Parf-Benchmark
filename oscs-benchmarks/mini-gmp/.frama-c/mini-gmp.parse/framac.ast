/* Generated by Frama-C */
#include "__fc_builtin.h"
#include "assert.h"
#include "ctype.h"
#include "errno.h"
#include "signal.h"
#include "stdarg.h"
#include "stddef.h"
#include "stdint.h"
#include "stdio.c"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "strings.h"
#include "sys/types.h"
#include "time.h"
#include "unistd.h"
typedef unsigned long mp_limb_t;
typedef long mp_size_t;
typedef unsigned long mp_bitcnt_t;
typedef mp_limb_t *mp_ptr;
typedef mp_limb_t const *mp_srcptr;
struct __anonstruct___mpz_struct_1 {
   int _mp_alloc ;
   int _mp_size ;
   mp_limb_t *_mp_d ;
};
typedef struct __anonstruct___mpz_struct_1 __mpz_struct;
typedef __mpz_struct mpz_t[1];
typedef __mpz_struct *mpz_ptr;
typedef __mpz_struct const *mpz_srcptr;
enum hex_random_op {
    OP_ADD = 0,
    OP_SUB = 1,
    OP_MUL = 2,
    OP_SQR = 3,
    OP_CDIV = 4,
    OP_FDIV = 5,
    OP_TDIV = 6,
    OP_CDIV_Q_2 = 7,
    OP_CDIV_R_2 = 8,
    OP_FDIV_Q_2 = 9,
    OP_FDIV_R_2 = 10,
    OP_TDIV_Q_2 = 11,
    OP_TDIV_R_2 = 12,
    OP_GCD = 13,
    OP_LCM = 14,
    OP_POWM = 15,
    OP_AND = 16,
    OP_IOR = 17,
    OP_XOR = 18,
    OP_SETBIT = 19,
    OP_CLRBIT = 20,
    OP_COMBIT = 21,
    OP_SCAN0 = 22,
    OP_SCAN1 = 23
};
struct gmp_div_inverse {
   unsigned int shift ;
   mp_limb_t d1 ;
   mp_limb_t d0 ;
   mp_limb_t di ;
};
struct mpn_base_info {
   unsigned int exp ;
   mp_limb_t bb ;
};
enum mpz_div_round_mode {
    GMP_DIV_FLOOR = 0,
    GMP_DIV_CEIL = 1,
    GMP_DIV_TRUNC = 2
};
enum __anonenum_gmp_randalg_t_4 {
    GMP_RAND_ALG_DEFAULT = 0,
    GMP_RAND_ALG_LC = GMP_RAND_ALG_DEFAULT
};
typedef enum __anonenum_gmp_randalg_t_4 gmp_randalg_t;
union __anonunion__mp_algdata_6 {
   void *_mp_lc ;
};
struct __anonstruct___gmp_randstate_struct_5 {
   mpz_t _mp_seed ;
   gmp_randalg_t _mp_alg ;
   union __anonunion__mp_algdata_6 _mp_algdata ;
};
typedef struct __anonstruct___gmp_randstate_struct_5 __gmp_randstate_struct;
typedef __gmp_randstate_struct gmp_randstate_t[1];
void mp_set_memory_functions(void *(*alloc_func)(size_t ),
                             void *(*realloc_func)(void *, size_t , size_t ),
                             void (*free_func)(void *, size_t ));

void mp_get_memory_functions(void *(**alloc_func)(size_t ),
                             void *(**realloc_func)(void *, size_t , size_t ),
                             void (**free_func)(void *, size_t ));

int const mp_bits_per_limb;

void mpn_copyi(mp_ptr d, mp_srcptr s, mp_size_t n);

void mpn_copyd(mp_ptr d, mp_srcptr s, mp_size_t n);

void mpn_zero(mp_ptr rp, mp_size_t n);

int mpn_cmp(mp_srcptr ap, mp_srcptr bp, mp_size_t n);

int mpn_zero_p(mp_srcptr rp, mp_size_t n);

mp_limb_t mpn_add_1(mp_ptr rp, mp_srcptr ap, mp_size_t n, mp_limb_t b);

mp_limb_t mpn_add_n(mp_ptr rp, mp_srcptr ap, mp_srcptr bp, mp_size_t n);

mp_limb_t mpn_add(mp_ptr rp, mp_srcptr ap, mp_size_t an, mp_srcptr bp,
                  mp_size_t bn);

mp_limb_t mpn_sub_1(mp_ptr rp, mp_srcptr ap, mp_size_t n, mp_limb_t b);

mp_limb_t mpn_sub_n(mp_ptr rp, mp_srcptr ap, mp_srcptr bp, mp_size_t n);

mp_limb_t mpn_sub(mp_ptr rp, mp_srcptr ap, mp_size_t an, mp_srcptr bp,
                  mp_size_t bn);

mp_limb_t mpn_mul_1(mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl);

mp_limb_t mpn_addmul_1(mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl);

mp_limb_t mpn_submul_1(mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl);

mp_limb_t mpn_mul(mp_ptr rp, mp_srcptr up, mp_size_t un, mp_srcptr vp,
                  mp_size_t vn);

void mpn_mul_n(mp_ptr rp, mp_srcptr ap, mp_srcptr bp, mp_size_t n);

void mpn_sqr(mp_ptr rp, mp_srcptr ap, mp_size_t n);

int mpn_perfect_square_p(mp_srcptr p, mp_size_t n);

mp_size_t mpn_sqrtrem(mp_ptr sp, mp_ptr rp, mp_srcptr p, mp_size_t n);

mp_limb_t mpn_lshift(mp_ptr rp, mp_srcptr up, mp_size_t n, unsigned int cnt);

mp_limb_t mpn_rshift(mp_ptr rp, mp_srcptr up, mp_size_t n, unsigned int cnt);

mp_bitcnt_t mpn_scan0(mp_srcptr ptr, mp_bitcnt_t bit);

mp_bitcnt_t mpn_scan1(mp_srcptr ptr, mp_bitcnt_t bit);

mp_bitcnt_t mpn_popcount(mp_srcptr p, mp_size_t n);

mp_limb_t mpn_invert_3by2(mp_limb_t u1, mp_limb_t u0);

size_t mpn_get_str(unsigned char *sp, int base, mp_ptr up, mp_size_t un);

mp_size_t mpn_set_str(mp_ptr rp, unsigned char const *sp, size_t sn, int base);

void mpz_init(__mpz_struct r[1]);

void mpz_init2(__mpz_struct r[1], mp_bitcnt_t bits);

void mpz_clear(__mpz_struct r[1]);

int mpz_sgn(__mpz_struct const u[1]);

int mpz_cmp_si(__mpz_struct const u[1], long v);

int mpz_cmp_ui(__mpz_struct const u[1], unsigned long v);

int mpz_cmp(__mpz_struct const a[1], __mpz_struct const b[1]);

int mpz_cmpabs_ui(__mpz_struct const u[1], unsigned long v);

int mpz_cmpabs(__mpz_struct const u[1], __mpz_struct const v[1]);

int mpz_cmp_d(__mpz_struct const x[1], double d);

int mpz_cmpabs_d(__mpz_struct const x[1], double d);

void mpz_abs(__mpz_struct r[1], __mpz_struct const u[1]);

void mpz_neg(__mpz_struct r[1], __mpz_struct const u[1]);

void mpz_swap(__mpz_struct u[1], __mpz_struct v[1]);

void mpz_add_ui(__mpz_struct r[1], __mpz_struct const a[1], unsigned long b);

void mpz_add(__mpz_struct r[1], __mpz_struct const a[1],
             __mpz_struct const b[1]);

void mpz_sub_ui(__mpz_struct r[1], __mpz_struct const a[1], unsigned long b);

void mpz_ui_sub(__mpz_struct r[1], unsigned long a, __mpz_struct const b[1]);

void mpz_sub(__mpz_struct r[1], __mpz_struct const a[1],
             __mpz_struct const b[1]);

void mpz_mul_si(__mpz_struct r[1], __mpz_struct const u[1], long v);

void mpz_mul_ui(__mpz_struct r[1], __mpz_struct const u[1], unsigned long v);

void mpz_mul(__mpz_struct r[1], __mpz_struct const u[1],
             __mpz_struct const v[1]);

void mpz_mul_2exp(__mpz_struct r[1], __mpz_struct const u[1],
                  mp_bitcnt_t bits);

void mpz_addmul_ui(__mpz_struct r[1], __mpz_struct const u[1],
                   unsigned long v);

void mpz_addmul(__mpz_struct r[1], __mpz_struct const u[1],
                __mpz_struct const v[1]);

void mpz_submul_ui(__mpz_struct r[1], __mpz_struct const u[1],
                   unsigned long v);

void mpz_submul(__mpz_struct r[1], __mpz_struct const u[1],
                __mpz_struct const v[1]);

void mpz_cdiv_qr(__mpz_struct q[1], __mpz_struct r[1],
                 __mpz_struct const n[1], __mpz_struct const d[1]);

void mpz_fdiv_qr(__mpz_struct q[1], __mpz_struct r[1],
                 __mpz_struct const n[1], __mpz_struct const d[1]);

void mpz_tdiv_qr(__mpz_struct q[1], __mpz_struct r[1],
                 __mpz_struct const n[1], __mpz_struct const d[1]);

void mpz_cdiv_q(__mpz_struct q[1], __mpz_struct const n[1],
                __mpz_struct const d[1]);

void mpz_fdiv_q(__mpz_struct q[1], __mpz_struct const n[1],
                __mpz_struct const d[1]);

void mpz_tdiv_q(__mpz_struct q[1], __mpz_struct const n[1],
                __mpz_struct const d[1]);

void mpz_cdiv_r(__mpz_struct r[1], __mpz_struct const n[1],
                __mpz_struct const d[1]);

void mpz_fdiv_r(__mpz_struct r[1], __mpz_struct const n[1],
                __mpz_struct const d[1]);

void mpz_tdiv_r(__mpz_struct r[1], __mpz_struct const n[1],
                __mpz_struct const d[1]);

void mpz_cdiv_q_2exp(__mpz_struct r[1], __mpz_struct const u[1],
                     mp_bitcnt_t cnt);

void mpz_fdiv_q_2exp(__mpz_struct r[1], __mpz_struct const u[1],
                     mp_bitcnt_t cnt);

void mpz_tdiv_q_2exp(__mpz_struct r[1], __mpz_struct const u[1],
                     mp_bitcnt_t cnt);

void mpz_cdiv_r_2exp(__mpz_struct r[1], __mpz_struct const u[1],
                     mp_bitcnt_t cnt);

void mpz_fdiv_r_2exp(__mpz_struct r[1], __mpz_struct const u[1],
                     mp_bitcnt_t cnt);

void mpz_tdiv_r_2exp(__mpz_struct r[1], __mpz_struct const u[1],
                     mp_bitcnt_t cnt);

void mpz_mod(__mpz_struct r[1], __mpz_struct const n[1],
             __mpz_struct const d[1]);

void mpz_divexact(__mpz_struct q[1], __mpz_struct const n[1],
                  __mpz_struct const d[1]);

int mpz_divisible_p(__mpz_struct const n[1], __mpz_struct const d[1]);

int mpz_congruent_p(__mpz_struct const a[1], __mpz_struct const b[1],
                    __mpz_struct const m[1]);

unsigned long mpz_cdiv_qr_ui(__mpz_struct q[1], __mpz_struct r[1],
                             __mpz_struct const n[1], unsigned long d);

unsigned long mpz_fdiv_qr_ui(__mpz_struct q[1], __mpz_struct r[1],
                             __mpz_struct const n[1], unsigned long d);

unsigned long mpz_tdiv_qr_ui(__mpz_struct q[1], __mpz_struct r[1],
                             __mpz_struct const n[1], unsigned long d);

unsigned long mpz_cdiv_q_ui(__mpz_struct q[1], __mpz_struct const n[1],
                            unsigned long d);

unsigned long mpz_fdiv_q_ui(__mpz_struct q[1], __mpz_struct const n[1],
                            unsigned long d);

unsigned long mpz_tdiv_q_ui(__mpz_struct q[1], __mpz_struct const n[1],
                            unsigned long d);

unsigned long mpz_cdiv_r_ui(__mpz_struct r[1], __mpz_struct const n[1],
                            unsigned long d);

unsigned long mpz_fdiv_r_ui(__mpz_struct r[1], __mpz_struct const n[1],
                            unsigned long d);

unsigned long mpz_tdiv_r_ui(__mpz_struct r[1], __mpz_struct const n[1],
                            unsigned long d);

unsigned long mpz_cdiv_ui(__mpz_struct const n[1], unsigned long d);

unsigned long mpz_fdiv_ui(__mpz_struct const n[1], unsigned long d);

unsigned long mpz_tdiv_ui(__mpz_struct const n[1], unsigned long d);

unsigned long mpz_mod_ui(__mpz_struct r[1], __mpz_struct const n[1],
                         unsigned long d);

void mpz_divexact_ui(__mpz_struct q[1], __mpz_struct const n[1],
                     unsigned long d);

int mpz_divisible_ui_p(__mpz_struct const n[1], unsigned long d);

unsigned long mpz_gcd_ui(__mpz_struct g[1], __mpz_struct const u[1],
                         unsigned long v);

void mpz_gcd(__mpz_struct g[1], __mpz_struct const u[1],
             __mpz_struct const v[1]);

void mpz_gcdext(__mpz_struct g[1], __mpz_struct s[1], __mpz_struct t[1],
                __mpz_struct const u[1], __mpz_struct const v[1]);

void mpz_lcm_ui(__mpz_struct r[1], __mpz_struct const u[1], unsigned long v);

void mpz_lcm(__mpz_struct r[1], __mpz_struct const u[1],
             __mpz_struct const v[1]);

int mpz_invert(__mpz_struct r[1], __mpz_struct const u[1],
               __mpz_struct const m[1]);

void mpz_sqrtrem(__mpz_struct s[1], __mpz_struct r[1],
                 __mpz_struct const u[1]);

void mpz_sqrt(__mpz_struct s[1], __mpz_struct const u[1]);

int mpz_perfect_square_p(__mpz_struct const u[1]);

void mpz_pow_ui(__mpz_struct r[1], __mpz_struct const b[1], unsigned long e);

void mpz_ui_pow_ui(__mpz_struct r[1], unsigned long blimb, unsigned long e);

void mpz_powm(__mpz_struct r[1], __mpz_struct const b[1],
              __mpz_struct const e[1], __mpz_struct const m[1]);

void mpz_powm_ui(__mpz_struct r[1], __mpz_struct const b[1],
                 unsigned long elimb, __mpz_struct const m[1]);

void mpz_rootrem(__mpz_struct x[1], __mpz_struct r[1],
                 __mpz_struct const y[1], unsigned long z);

int mpz_root(__mpz_struct x[1], __mpz_struct const y[1], unsigned long z);

void mpz_fac_ui(__mpz_struct x[1], unsigned long n);

void mpz_bin_uiui(__mpz_struct r[1], unsigned long n, unsigned long k);

int mpz_probab_prime_p(__mpz_struct const n[1], int reps);

int mpz_tstbit(__mpz_struct const d[1], mp_bitcnt_t bit_index);

void mpz_setbit(__mpz_struct d[1], mp_bitcnt_t bit_index);

void mpz_clrbit(__mpz_struct d[1], mp_bitcnt_t bit_index);

void mpz_combit(__mpz_struct d[1], mp_bitcnt_t bit_index);

void mpz_com(__mpz_struct r[1], __mpz_struct const u[1]);

void mpz_and(__mpz_struct r[1], __mpz_struct const u[1],
             __mpz_struct const v[1]);

void mpz_ior(__mpz_struct r[1], __mpz_struct const u[1],
             __mpz_struct const v[1]);

void mpz_xor(__mpz_struct r[1], __mpz_struct const u[1],
             __mpz_struct const v[1]);

mp_bitcnt_t mpz_popcount(__mpz_struct const u[1]);

mp_bitcnt_t mpz_hamdist(__mpz_struct const u[1], __mpz_struct const v[1]);

mp_bitcnt_t mpz_scan0(__mpz_struct const u[1], mp_bitcnt_t starting_bit);

mp_bitcnt_t mpz_scan1(__mpz_struct const u[1], mp_bitcnt_t starting_bit);

int mpz_fits_slong_p(__mpz_struct const u[1]);

int mpz_fits_ulong_p(__mpz_struct const u[1]);

long mpz_get_si(__mpz_struct const u[1]);

unsigned long mpz_get_ui(__mpz_struct const u[1]);

double mpz_get_d(__mpz_struct const u[1]);

size_t mpz_size(__mpz_struct const u[1]);

mp_limb_t mpz_getlimbn(__mpz_struct const u[1], mp_size_t n);

void mpz_realloc2(__mpz_struct x[1], mp_bitcnt_t n);

mp_srcptr mpz_limbs_read(mpz_srcptr x);

mp_ptr mpz_limbs_modify(__mpz_struct x[1], mp_size_t n);

mp_ptr mpz_limbs_write(__mpz_struct x[1], mp_size_t n);

void mpz_limbs_finish(__mpz_struct x[1], mp_size_t xs);

mpz_srcptr mpz_roinit_n(__mpz_struct x[1], mp_srcptr xp, mp_size_t xs);

void mpz_set_si(__mpz_struct r[1], long x);

void mpz_set_ui(__mpz_struct r[1], unsigned long x);

void mpz_set(__mpz_struct r[1], __mpz_struct const x[1]);

void mpz_set_d(__mpz_struct r[1], double x);

void mpz_init_set_si(__mpz_struct r[1], long x);

void mpz_init_set_ui(__mpz_struct r[1], unsigned long x);

void mpz_init_set(__mpz_struct r[1], __mpz_struct const x[1]);

void mpz_init_set_d(__mpz_struct r[1], double x);

size_t mpz_sizeinbase(__mpz_struct const u[1], int base);

char *mpz_get_str(char *sp, int base, __mpz_struct const u[1]);

int mpz_set_str(__mpz_struct r[1], char const *sp, int base);

int mpz_init_set_str(__mpz_struct r[1], char const *sp, int base);

void mpz_import(__mpz_struct r[1], size_t count, int order, size_t size,
                int endian, size_t nails, void const *src);

void *mpz_export(void *r, size_t *countp, int order, size_t size, int endian,
                 size_t nails, __mpz_struct const u[1]);

void hex_random_init(void);

char *hex_urandomb(unsigned long bits);

char *hex_rrandomb(unsigned long bits);

char *hex_rrandomb_export(void *dst, size_t *countp, int order, size_t size,
                          int endian, unsigned long bits);

void hex_random_op2(enum hex_random_op op, unsigned long maxbits, char **ap,
                    char **rp);

void hex_random_op3(enum hex_random_op op, unsigned long maxbits, char **ap,
                    char **bp, char **rp);

void hex_random_op4(enum hex_random_op op, unsigned long maxbits, char **ap,
                    char **bp, char **cp, char **dp);

void hex_random_bit_op(enum hex_random_op op, unsigned long maxbits,
                       char **ap, unsigned long *b, char **rp);

void hex_random_scan_op(enum hex_random_op op, unsigned long maxbits,
                        char **ap, unsigned long *b, unsigned long *r);

void hex_random_str_op(unsigned long maxbits, int base, char **ap, char **rp);

void mini_urandomb(__mpz_struct r[1], unsigned long bits);

void mini_rrandomb(__mpz_struct r[1], unsigned long bits);

void mini_rrandomb_export(__mpz_struct r[1], void *dst, size_t *countp,
                          int order, size_t size, int endian,
                          unsigned long bits);

void mini_random_op2(enum hex_random_op op, unsigned long maxbits,
                     __mpz_struct a[1], __mpz_struct r[1]);

void mini_random_op3(enum hex_random_op op, unsigned long maxbits,
                     __mpz_struct a[1], __mpz_struct b[1], __mpz_struct r[1]);

void mini_random_op4(enum hex_random_op op, unsigned long maxbits,
                     __mpz_struct a[1], __mpz_struct b[1], __mpz_struct c[1],
                     __mpz_struct d[1]);

void mini_random_scan_op(enum hex_random_op op, unsigned long maxbits,
                         __mpz_struct a[1], mp_bitcnt_t *b, mp_bitcnt_t *r);

void mini_random_bit_op(enum hex_random_op op, unsigned long maxbits,
                        __mpz_struct a[1], mp_bitcnt_t *b, __mpz_struct r[1]);

void testmain(int argc, char **argv);

void testhalves(int count, void (*tested_fun)(int ));

void testfree(void *p);

void dump(char const *label, __mpz_struct const x[1]);

void mpz_set_str_or_abort(mpz_ptr z, char const *str, int base);

int const mp_bits_per_limb = (int)(sizeof(mp_limb_t) * (unsigned int)8);
/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_1(FILE * restrict stream, char const * restrict format,
                 char *param0);

static void gmp_die(char const *msg)
{
  fprintf(__fc_stderr,"%s\n",(char *)msg); /* fprintf_va_1 */
  abort();
  return;
}

static void *gmp_default_alloc(size_t size)
{
  void *p;
  __FC_assert((size > (size_t)0) != 0,"mini-gmp.c",255,"size > 0");
  p = malloc(size);
  if (! p) gmp_die("gmp_default_alloc: Virtual memory exhausted.");
  return p;
}

static void *gmp_default_realloc(void *old, size_t old_size, size_t new_size)
{
  void *p;
  p = realloc(old,new_size);
  if (! p) gmp_die("gmp_default_realloc: Virtual memory exhausted.");
  return p;
}

static void gmp_default_free(void *p, size_t size)
{
  free(p);
  return;
}

static void *(*gmp_allocate_func)(size_t ) = & gmp_default_alloc;
static void *(*gmp_reallocate_func)(void *, size_t , size_t ) =
  & gmp_default_realloc;
static void (*gmp_free_func)(void *, size_t ) = & gmp_default_free;
void mp_get_memory_functions(void *(**alloc_func)(size_t ),
                             void *(**realloc_func)(void *, size_t , size_t ),
                             void (**free_func)(void *, size_t ))
{
  if (alloc_func) *alloc_func = gmp_allocate_func;
  if (realloc_func) *realloc_func = gmp_reallocate_func;
  if (free_func) *free_func = gmp_free_func;
  return;
}

void mp_set_memory_functions(void *(*alloc_func)(size_t ),
                             void *(*realloc_func)(void *, size_t , size_t ),
                             void (*free_func)(void *, size_t ))
{
  if (! alloc_func) alloc_func = & gmp_default_alloc;
  if (! realloc_func) realloc_func = & gmp_default_realloc;
  if (! free_func) free_func = & gmp_default_free;
  gmp_allocate_func = alloc_func;
  gmp_reallocate_func = realloc_func;
  gmp_free_func = free_func;
  return;
}

static mp_ptr gmp_xalloc_limbs(mp_size_t size)
{
  mp_ptr tmp;
  tmp = (mp_ptr)(*gmp_allocate_func)((size_t)((unsigned long)size * (unsigned long)sizeof(mp_limb_t)));
  return tmp;
}

static mp_ptr gmp_xrealloc_limbs(mp_ptr old, mp_size_t size)
{
  mp_ptr tmp;
  __FC_assert((size > (mp_size_t)0) != 0,"mini-gmp.c",331,"size > 0");
  tmp = (mp_ptr)(*gmp_reallocate_func)((void *)old,(size_t)0,
                                       (size_t)((unsigned long)size * (unsigned long)sizeof(mp_limb_t)));
  return tmp;
}

void mpn_copyi(mp_ptr d, mp_srcptr s, mp_size_t n)
{
  mp_size_t i;
  i = (mp_size_t)0;
  while (i < n) {
    *(d + i) = *(s + i);
    i ++;
  }
  return;
}

void mpn_copyd(mp_ptr d, mp_srcptr s, mp_size_t n)
{
  while (1) {
    n --;
    if (! (n >= (mp_size_t)0)) break;
    *(d + n) = *(s + n);
  }
  return;
}

int mpn_cmp(mp_srcptr ap, mp_srcptr bp, mp_size_t n)
{
  int __retres;
  while (1) {
    n --;
    if (! (n >= (mp_size_t)0)) break;
    if (*(ap + n) != *(bp + n)) {
      int tmp;
      if (*(ap + n) > *(bp + n)) tmp = 1; else tmp = -1;
      __retres = tmp;
      goto return_label;
    }
  }
  __retres = 0;
  return_label: return __retres;
}

static int mpn_cmp4(mp_srcptr ap, mp_size_t an, mp_srcptr bp, mp_size_t bn)
{
  int __retres;
  if (an != bn) {
    int tmp;
    if (an < bn) tmp = -1; else tmp = 1;
    __retres = tmp;
    goto return_label;
  }
  else {
    int tmp_0;
    tmp_0 = mpn_cmp(ap,bp,an);
    __retres = tmp_0;
    goto return_label;
  }
  return_label: return __retres;
}

static mp_size_t mpn_normalized_size(mp_srcptr xp, mp_size_t n)
{
  while (1) {
    if (n > (mp_size_t)0) {
      if (! (*(xp + (n - (mp_size_t)1)) == (mp_limb_t)0)) break;
    }
    else break;
    n --;
  }
  return n;
}

int mpn_zero_p(mp_srcptr rp, mp_size_t n)
{
  int __retres;
  mp_size_t tmp;
  tmp = mpn_normalized_size(rp,n);
  __retres = tmp == (mp_size_t)0;
  return __retres;
}

void mpn_zero(mp_ptr rp, mp_size_t n)
{
  while (1) {
    n --;
    if (! (n >= (mp_size_t)0)) break;
    *(rp + n) = (mp_limb_t)0;
  }
  return;
}

mp_limb_t mpn_add_1(mp_ptr rp, mp_srcptr ap, mp_size_t n, mp_limb_t b)
{
  mp_size_t i;
  __FC_assert((n > (mp_size_t)0) != 0,"mini-gmp.c",399,"n > 0");
  i = (mp_size_t)0;
  while (1) {
    {
      mp_limb_t r = *(ap + i) + b;
      b = (mp_limb_t)(r < b);
      *(rp + i) = r;
    }
    i ++;
    ;
    if (! (i < n)) break;
  }
  return b;
}

mp_limb_t mpn_add_n(mp_ptr rp, mp_srcptr ap, mp_srcptr bp, mp_size_t n)
{
  mp_size_t i;
  mp_limb_t cy;
  i = (mp_size_t)0;
  cy = (mp_limb_t)0;
  while (i < n) {
    {
      mp_limb_t a;
      mp_limb_t b;
      mp_limb_t r;
      a = *(ap + i);
      b = *(bp + i);
      r = a + cy;
      cy = (mp_limb_t)(r < cy);
      r += b;
      cy += (mp_limb_t)(r < b);
      *(rp + i) = r;
    }
    i ++;
  }
  return cy;
}

mp_limb_t mpn_add(mp_ptr rp, mp_srcptr ap, mp_size_t an, mp_srcptr bp,
                  mp_size_t bn)
{
  mp_limb_t cy;
  __FC_assert((an >= bn) != 0,"mini-gmp.c",437,"an >= bn");
  cy = mpn_add_n(rp,ap,bp,bn);
  if (an > bn) cy = mpn_add_1(rp + bn,ap + bn,an - bn,cy);
  return cy;
}

mp_limb_t mpn_sub_1(mp_ptr rp, mp_srcptr ap, mp_size_t n, mp_limb_t b)
{
  mp_size_t i;
  __FC_assert((n > (mp_size_t)0) != 0,"mini-gmp.c",450,"n > 0");
  i = (mp_size_t)0;
  while (1) {
    {
      mp_limb_t a = *(ap + i);
      mp_limb_t cy = (mp_limb_t)(a < b);
      *(rp + i) = a - b;
      b = cy;
    }
    i ++;
    ;
    if (! (i < n)) break;
  }
  return b;
}

mp_limb_t mpn_sub_n(mp_ptr rp, mp_srcptr ap, mp_srcptr bp, mp_size_t n)
{
  mp_size_t i;
  mp_limb_t cy;
  i = (mp_size_t)0;
  cy = (mp_limb_t)0;
  while (i < n) {
    {
      mp_limb_t a;
      mp_limb_t b;
      a = *(ap + i);
      b = *(bp + i);
      b += cy;
      cy = (mp_limb_t)(b < cy);
      cy += (mp_limb_t)(a < b);
      *(rp + i) = a - b;
    }
    i ++;
  }
  return cy;
}

mp_limb_t mpn_sub(mp_ptr rp, mp_srcptr ap, mp_size_t an, mp_srcptr bp,
                  mp_size_t bn)
{
  mp_limb_t cy;
  __FC_assert((an >= bn) != 0,"mini-gmp.c",489,"an >= bn");
  cy = mpn_sub_n(rp,ap,bp,bn);
  if (an > bn) cy = mpn_sub_1(rp + bn,ap + bn,an - bn,cy);
  return cy;
}

mp_limb_t mpn_mul_1(mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl)
{
  mp_limb_t ul;
  mp_limb_t cl;
  mp_limb_t hpl;
  mp_limb_t lpl;
  __FC_assert((n >= (mp_size_t)1) != 0,"mini-gmp.c",502,"n >= 1");
  cl = (mp_limb_t)0;
  while (1) {
    {
      mp_srcptr tmp;
      mp_ptr tmp_0;
      tmp = up;
      up ++;
      ul = *tmp;
      {
        mp_limb_t __x0;
        mp_limb_t __x1;
        mp_limb_t __x2;
        mp_limb_t __x3;
        unsigned int __ul;
        unsigned int __vl;
        unsigned int __uh;
        unsigned int __vh;
        mp_limb_t __u = ul;
        mp_limb_t __v = vl;
        __ul = (unsigned int)(__u & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
        __uh = (unsigned int)(__u >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
        __vl = (unsigned int)(__v & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
        __vh = (unsigned int)(__v >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
        __x0 = (mp_limb_t)__ul * (mp_limb_t)__vl;
        __x1 = (mp_limb_t)__ul * (mp_limb_t)__vh;
        __x2 = (mp_limb_t)__uh * (mp_limb_t)__vl;
        __x3 = (mp_limb_t)__uh * (mp_limb_t)__vh;
        __x1 += __x0 >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2;
        __x1 += __x2;
        if (__x1 < __x2) __x3 += (mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2;
        hpl = __x3 + (__x1 >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
        lpl = (__x1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) + (
              __x0 & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
      }
      lpl += cl;
      cl = (mp_limb_t)(lpl < cl) + hpl;
      tmp_0 = rp;
      rp ++;
      *tmp_0 = lpl;
    }
    n --;
    if (! (n != (mp_size_t)0)) break;
  }
  return cl;
}

mp_limb_t mpn_addmul_1(mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl)
{
  mp_limb_t ul;
  mp_limb_t cl;
  mp_limb_t hpl;
  mp_limb_t lpl;
  mp_limb_t rl;
  __FC_assert((n >= (mp_size_t)1) != 0,"mini-gmp.c",525,"n >= 1");
  cl = (mp_limb_t)0;
  while (1) {
    {
      mp_srcptr tmp;
      mp_ptr tmp_0;
      tmp = up;
      up ++;
      ul = *tmp;
      {
        mp_limb_t __x0;
        mp_limb_t __x1;
        mp_limb_t __x2;
        mp_limb_t __x3;
        unsigned int __ul;
        unsigned int __vl;
        unsigned int __uh;
        unsigned int __vh;
        mp_limb_t __u = ul;
        mp_limb_t __v = vl;
        __ul = (unsigned int)(__u & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
        __uh = (unsigned int)(__u >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
        __vl = (unsigned int)(__v & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
        __vh = (unsigned int)(__v >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
        __x0 = (mp_limb_t)__ul * (mp_limb_t)__vl;
        __x1 = (mp_limb_t)__ul * (mp_limb_t)__vh;
        __x2 = (mp_limb_t)__uh * (mp_limb_t)__vl;
        __x3 = (mp_limb_t)__uh * (mp_limb_t)__vh;
        __x1 += __x0 >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2;
        __x1 += __x2;
        if (__x1 < __x2) __x3 += (mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2;
        hpl = __x3 + (__x1 >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
        lpl = (__x1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) + (
              __x0 & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
      }
      lpl += cl;
      cl = (mp_limb_t)(lpl < cl) + hpl;
      rl = *rp;
      lpl = rl + lpl;
      cl += (mp_limb_t)(lpl < rl);
      tmp_0 = rp;
      rp ++;
      *tmp_0 = lpl;
    }
    n --;
    if (! (n != (mp_size_t)0)) break;
  }
  return cl;
}

mp_limb_t mpn_submul_1(mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl)
{
  mp_limb_t ul;
  mp_limb_t cl;
  mp_limb_t hpl;
  mp_limb_t lpl;
  mp_limb_t rl;
  __FC_assert((n >= (mp_size_t)1) != 0,"mini-gmp.c",551,"n >= 1");
  cl = (mp_limb_t)0;
  while (1) {
    {
      mp_srcptr tmp;
      mp_ptr tmp_0;
      tmp = up;
      up ++;
      ul = *tmp;
      {
        mp_limb_t __x0;
        mp_limb_t __x1;
        mp_limb_t __x2;
        mp_limb_t __x3;
        unsigned int __ul;
        unsigned int __vl;
        unsigned int __uh;
        unsigned int __vh;
        mp_limb_t __u = ul;
        mp_limb_t __v = vl;
        __ul = (unsigned int)(__u & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
        __uh = (unsigned int)(__u >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
        __vl = (unsigned int)(__v & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
        __vh = (unsigned int)(__v >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
        __x0 = (mp_limb_t)__ul * (mp_limb_t)__vl;
        __x1 = (mp_limb_t)__ul * (mp_limb_t)__vh;
        __x2 = (mp_limb_t)__uh * (mp_limb_t)__vl;
        __x3 = (mp_limb_t)__uh * (mp_limb_t)__vh;
        __x1 += __x0 >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2;
        __x1 += __x2;
        if (__x1 < __x2) __x3 += (mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2;
        hpl = __x3 + (__x1 >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
        lpl = (__x1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) + (
              __x0 & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
      }
      lpl += cl;
      cl = (mp_limb_t)(lpl < cl) + hpl;
      rl = *rp;
      lpl = rl - lpl;
      cl += (mp_limb_t)(lpl > rl);
      tmp_0 = rp;
      rp ++;
      *tmp_0 = lpl;
    }
    n --;
    if (! (n != (mp_size_t)0)) break;
  }
  return cl;
}

mp_limb_t mpn_mul(mp_ptr rp, mp_srcptr up, mp_size_t un, mp_srcptr vp,
                  mp_size_t vn)
{
  mp_limb_t __retres;
  __FC_assert((un >= vn) != 0,"mini-gmp.c",575,"un >= vn");
  __FC_assert((vn >= (mp_size_t)1) != 0,"mini-gmp.c",576,"vn >= 1");
  *(rp + un) = mpn_mul_1(rp,up,un,*(vp + 0));
  while (1) {
    vn --;
    if (! (vn >= (mp_size_t)1)) break;
    rp ++;
    vp ++;
    *(rp + un) = mpn_addmul_1(rp,up,un,*(vp + 0));
  }
  __retres = *(rp + un);
  return __retres;
}

void mpn_mul_n(mp_ptr rp, mp_srcptr ap, mp_srcptr bp, mp_size_t n)
{
  mpn_mul(rp,ap,n,bp,n);
  return;
}

void mpn_sqr(mp_ptr rp, mp_srcptr ap, mp_size_t n)
{
  mpn_mul(rp,ap,n,ap,n);
  return;
}

mp_limb_t mpn_lshift(mp_ptr rp, mp_srcptr up, mp_size_t n, unsigned int cnt)
{
  mp_limb_t high_limb;
  mp_limb_t low_limb;
  unsigned int tnc;
  mp_limb_t retval;
  __FC_assert((n >= (mp_size_t)1) != 0,"mini-gmp.c",614,"n >= 1");
  __FC_assert((cnt >= (unsigned int)1) != 0,"mini-gmp.c",615,"cnt >= 1");
  __FC_assert((cnt < sizeof(mp_limb_t) * (unsigned int)8) != 0,"mini-gmp.c",
              616,"cnt < GMP_LIMB_BITS");
  up += n;
  rp += n;
  tnc = sizeof(mp_limb_t) * (unsigned int)8 - cnt;
  up --;
  low_limb = *up;
  retval = low_limb >> tnc;
  high_limb = low_limb << cnt;
  while (1) {
    n --;
    if (! (n != (mp_size_t)0)) break;
    up --;
    low_limb = *up;
    rp --;
    *rp = high_limb | (low_limb >> tnc);
    high_limb = low_limb << cnt;
  }
  rp --;
  *rp = high_limb;
  return retval;
}

mp_limb_t mpn_rshift(mp_ptr rp, mp_srcptr up, mp_size_t n, unsigned int cnt)
{
  mp_limb_t high_limb;
  mp_limb_t low_limb;
  unsigned int tnc;
  mp_limb_t retval;
  mp_srcptr tmp;
  __FC_assert((n >= (mp_size_t)1) != 0,"mini-gmp.c",644,"n >= 1");
  __FC_assert((cnt >= (unsigned int)1) != 0,"mini-gmp.c",645,"cnt >= 1");
  __FC_assert((cnt < sizeof(mp_limb_t) * (unsigned int)8) != 0,"mini-gmp.c",
              646,"cnt < GMP_LIMB_BITS");
  tnc = sizeof(mp_limb_t) * (unsigned int)8 - cnt;
  tmp = up;
  up ++;
  high_limb = *tmp;
  retval = high_limb << tnc;
  low_limb = high_limb >> cnt;
  while (1) {
    n --;
    if (! (n != (mp_size_t)0)) break;
    {
      mp_srcptr tmp_0;
      mp_ptr tmp_1;
      tmp_0 = up;
      up ++;
      high_limb = *tmp_0;
      tmp_1 = rp;
      rp ++;
      *tmp_1 = low_limb | (high_limb << tnc);
      low_limb = high_limb >> cnt;
    }
  }
  *rp = low_limb;
  return retval;
}

static mp_bitcnt_t mpn_common_scan(mp_limb_t limb, mp_size_t i, mp_srcptr up,
                                   mp_size_t un, mp_limb_t ux)
{
  mp_bitcnt_t __retres;
  unsigned int cnt;
  int tmp;
  int tmp_0;
  if (ux == (mp_limb_t)0) tmp = 1;
  else 
    if (ux == ~ ((mp_limb_t)0)) tmp = 1; else tmp = 0;
  __FC_assert(tmp != 0,"mini-gmp.c",670,"ux == 0 || ux == GMP_LIMB_MAX");
  if ((mp_size_t)0 <= i) 
    if (i <= un) tmp_0 = 1; else tmp_0 = 0;
  else tmp_0 = 0;
  __FC_assert(tmp_0 != 0,"mini-gmp.c",671,"0 <= i && i <= un");
  while (limb == (mp_limb_t)0) {
    i ++;
    if (i == un) {
      mp_bitcnt_t tmp_1;
      if (ux == (mp_limb_t)0) tmp_1 = ~ ((mp_bitcnt_t)0);
      else tmp_1 = (unsigned long)un * (unsigned long)(sizeof(mp_limb_t) * (unsigned int)8);
      __retres = tmp_1;
      goto return_label;
    }
    limb = ux ^ *(up + i);
  }
  {
    mp_limb_t __ctz_x = limb;
    unsigned int __ctz_c = (unsigned int)0;
    {
      unsigned int __clz_c;
      mp_limb_t __clz_x = __ctz_x & - __ctz_x;
      __clz_c = (unsigned int)0;
      while ((__clz_x & ((mp_limb_t)0xff << (sizeof(mp_limb_t) * (unsigned int)8 - (unsigned int)8))) == (unsigned long)0) {
        __clz_x <<= 8;
        __clz_c += (unsigned int)8;
      }
      while ((__clz_x & ((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8 - (unsigned int)1))) == (unsigned long)0) {
        __clz_x <<= 1;
        __clz_c ++;
      }
      __ctz_c = __clz_c;
    }
    cnt = (sizeof(mp_limb_t) * (unsigned int)8 - (unsigned int)1) - __ctz_c;
  }
  __retres = (mp_bitcnt_t)i * (mp_bitcnt_t)(sizeof(mp_limb_t) * (unsigned int)8) + (mp_bitcnt_t)cnt;
  return_label: return __retres;
}

mp_bitcnt_t mpn_scan1(mp_srcptr ptr, mp_bitcnt_t bit)
{
  mp_size_t i;
  mp_bitcnt_t tmp;
  i = (mp_size_t)(bit / (mp_bitcnt_t)(sizeof(mp_limb_t) * (unsigned int)8));
  tmp = mpn_common_scan(*(ptr + i) & (~ ((mp_limb_t)0) << bit % (unsigned long)(
                                                          sizeof(mp_limb_t) * (unsigned int)8)),
                        i,ptr,i,(mp_limb_t)0);
  return tmp;
}

mp_bitcnt_t mpn_scan0(mp_srcptr ptr, mp_bitcnt_t bit)
{
  mp_size_t i;
  mp_bitcnt_t tmp;
  i = (mp_size_t)(bit / (mp_bitcnt_t)(sizeof(mp_limb_t) * (unsigned int)8));
  tmp = mpn_common_scan(~ *(ptr + i) & (~ ((mp_limb_t)0) << bit % (unsigned long)(
                                                            sizeof(mp_limb_t) * (unsigned int)8)),
                        i,ptr,i,~ ((mp_limb_t)0));
  return tmp;
}

mp_limb_t mpn_invert_3by2(mp_limb_t u1, mp_limb_t u0)
{
  mp_limb_t r;
  mp_limb_t p;
  mp_limb_t m;
  unsigned int ul;
  unsigned int uh;
  unsigned int ql;
  unsigned int qh;
  __FC_assert((u1 >= (mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8 - (unsigned int)1)) != 0,
              "mini-gmp.c",716,"u1 >= GMP_LIMB_HIGHBIT");
  ul = (unsigned int)(u1 & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
  uh = (unsigned int)(u1 >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
  qh = (unsigned int)(~ u1 / (mp_limb_t)uh);
  r = ((~ u1 - (mp_limb_t)qh * (mp_limb_t)uh) << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) | (
      ((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1);
  p = (mp_limb_t)qh * (mp_limb_t)ul;
  if (r < p) {
    qh --;
    r += u1;
    if (r >= u1) 
      if (r < p) {
        qh --;
        r += u1;
      }
  }
  r -= p;
  p = (r >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) * (mp_limb_t)qh + r;
  ql = (unsigned int)((p >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) + (mp_limb_t)1);
  r = ((r << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) + (
       ((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1)) - 
      (mp_limb_t)ql * u1;
  if (r >= p << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) {
    ql --;
    r += u1;
  }
  m = ((mp_limb_t)qh << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) + (mp_limb_t)ql;
  if (r >= u1) {
    m ++;
    r -= u1;
  }
  if (u0 > (mp_limb_t)0) {
    mp_limb_t th;
    mp_limb_t tl;
    r = ~ r;
    r += u0;
    if (r < u0) {
      m --;
      if (r >= u1) {
        m --;
        r -= u1;
      }
      r -= u1;
    }
    {
      mp_limb_t __x0;
      mp_limb_t __x1;
      mp_limb_t __x2;
      mp_limb_t __x3;
      unsigned int __ul;
      unsigned int __vl;
      unsigned int __uh;
      unsigned int __vh;
      mp_limb_t __u = u0;
      mp_limb_t __v = m;
      __ul = (unsigned int)(__u & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
      __uh = (unsigned int)(__u >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
      __vl = (unsigned int)(__v & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
      __vh = (unsigned int)(__v >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
      __x0 = (mp_limb_t)__ul * (mp_limb_t)__vl;
      __x1 = (mp_limb_t)__ul * (mp_limb_t)__vh;
      __x2 = (mp_limb_t)__uh * (mp_limb_t)__vl;
      __x3 = (mp_limb_t)__uh * (mp_limb_t)__vh;
      __x1 += __x0 >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2;
      __x1 += __x2;
      if (__x1 < __x2) __x3 += (mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2;
      th = __x3 + (__x1 >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
      tl = (__x1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) + (
           __x0 & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
    }
    r += th;
    if (r < th) {
      m --;
      m -= (mp_limb_t)((r > u1) | ((r == u1) & (tl > u0)));
    }
  }
  return m;
}

static void mpn_div_qr_1_invert(struct gmp_div_inverse *inv, mp_limb_t d)
{
  unsigned int shift;
  __FC_assert((d > (mp_limb_t)0) != 0,"mini-gmp.c",800,"d > 0");
  {
    unsigned int __clz_c;
    mp_limb_t __clz_x = d;
    __clz_c = (unsigned int)0;
    while ((__clz_x & ((mp_limb_t)0xff << (sizeof(mp_limb_t) * (unsigned int)8 - (unsigned int)8))) == (unsigned long)0) {
      __clz_x <<= 8;
      __clz_c += (unsigned int)8;
    }
    while ((__clz_x & ((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8 - (unsigned int)1))) == (unsigned long)0) {
      __clz_x <<= 1;
      __clz_c ++;
    }
    shift = __clz_c;
  }
  inv->shift = shift;
  inv->d1 = d << shift;
  inv->di = mpn_invert_3by2(inv->d1,(mp_limb_t)0);
  return;
}

static void mpn_div_qr_2_invert(struct gmp_div_inverse *inv, mp_limb_t d1,
                                mp_limb_t d0)
{
  unsigned int shift;
  __FC_assert((d1 > (mp_limb_t)0) != 0,"mini-gmp.c",813,"d1 > 0");
  {
    unsigned int __clz_c;
    mp_limb_t __clz_x = d1;
    __clz_c = (unsigned int)0;
    while ((__clz_x & ((mp_limb_t)0xff << (sizeof(mp_limb_t) * (unsigned int)8 - (unsigned int)8))) == (unsigned long)0) {
      __clz_x <<= 8;
      __clz_c += (unsigned int)8;
    }
    while ((__clz_x & ((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8 - (unsigned int)1))) == (unsigned long)0) {
      __clz_x <<= 1;
      __clz_c ++;
    }
    shift = __clz_c;
  }
  inv->shift = shift;
  if (shift > (unsigned int)0) {
    d1 = (d1 << shift) | (d0 >> (sizeof(mp_limb_t) * (unsigned int)8 - shift));
    d0 <<= shift;
  }
  inv->d1 = d1;
  inv->d0 = d0;
  inv->di = mpn_invert_3by2(d1,d0);
  return;
}

static void mpn_div_qr_invert(struct gmp_div_inverse *inv, mp_srcptr dp,
                              mp_size_t dn)
{
  __FC_assert((dn > (mp_size_t)0) != 0,"mini-gmp.c",830,"dn > 0");
  if (dn == (mp_size_t)1) mpn_div_qr_1_invert(inv,*(dp + 0));
  else 
    if (dn == (mp_size_t)2) mpn_div_qr_2_invert(inv,*(dp + 1),*(dp + 0));
    else {
      unsigned int shift;
      mp_limb_t d1;
      mp_limb_t d0;
      d1 = *(dp + (dn - (mp_size_t)1));
      d0 = *(dp + (dn - (mp_size_t)2));
      __FC_assert((d1 > (mp_limb_t)0) != 0,"mini-gmp.c",843,"d1 > 0");
      {
        unsigned int __clz_c;
        mp_limb_t __clz_x = d1;
        __clz_c = (unsigned int)0;
        while ((__clz_x & ((mp_limb_t)0xff << (sizeof(mp_limb_t) * (unsigned int)8 - (unsigned int)8))) == (unsigned long)0) {
          __clz_x <<= 8;
          __clz_c += (unsigned int)8;
        }
        while ((__clz_x & ((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8 - (unsigned int)1))) == (unsigned long)0) {
          __clz_x <<= 1;
          __clz_c ++;
        }
        shift = __clz_c;
      }
      inv->shift = shift;
      if (shift > (unsigned int)0) {
        d1 = (d1 << shift) | (d0 >> (sizeof(mp_limb_t) * (unsigned int)8 - shift));
        d0 = (d0 << shift) | (*(dp + (dn - (mp_size_t)3)) >> (sizeof(mp_limb_t) * (unsigned int)8 - shift));
      }
      inv->d1 = d1;
      inv->d0 = d0;
      inv->di = mpn_invert_3by2(d1,d0);
    }
  return;
}

static mp_limb_t mpn_div_qr_1_preinv(mp_ptr qp, mp_srcptr np, mp_size_t nn,
                                     struct gmp_div_inverse const *inv)
{
  mp_limb_t __retres;
  mp_limb_t d;
  mp_limb_t di;
  mp_limb_t r;
  mp_ptr tp = (mp_ptr)0;
  if (inv->shift > (unsigned int)0) {
    tp = gmp_xalloc_limbs(nn);
    r = mpn_lshift(tp,np,nn,inv->shift);
    np = (mp_srcptr)tp;
  }
  else r = (mp_limb_t)0;
  d = inv->d1;
  di = inv->di;
  while (1) {
    nn --;
    if (! (nn >= (mp_size_t)0)) break;
    {
      mp_limb_t q;
      {
        mp_limb_t _qh;
        mp_limb_t _ql;
        mp_limb_t _r;
        mp_limb_t _mask;
        {
          mp_limb_t __x0;
          mp_limb_t __x1;
          mp_limb_t __x2;
          mp_limb_t __x3;
          unsigned int __ul;
          unsigned int __vl;
          unsigned int __uh;
          unsigned int __vh;
          mp_limb_t __u = r;
          mp_limb_t __v = di;
          __ul = (unsigned int)(__u & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
          __uh = (unsigned int)(__u >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
          __vl = (unsigned int)(__v & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
          __vh = (unsigned int)(__v >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
          __x0 = (mp_limb_t)__ul * (mp_limb_t)__vl;
          __x1 = (mp_limb_t)__ul * (mp_limb_t)__vh;
          __x2 = (mp_limb_t)__uh * (mp_limb_t)__vl;
          __x3 = (mp_limb_t)__uh * (mp_limb_t)__vh;
          __x1 += __x0 >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2;
          __x1 += __x2;
          if (__x1 < __x2) __x3 += (mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2;
          _qh = __x3 + (__x1 >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
          _ql = (__x1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) + (
                __x0 & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
        }
        {
          mp_limb_t __x;
          __x = _ql + *(np + nn);
          _qh = (_qh + (r + (mp_limb_t)1)) + (mp_limb_t)(__x < _ql);
          _ql = __x;
        }
        _r = *(np + nn) - _qh * d;
        _mask = - ((mp_limb_t)(_r > _ql));
        _qh += _mask;
        _r += _mask & d;
        if (_r >= d) {
          _r -= d;
          _qh ++;
        }
        r = _r;
        q = _qh;
      }
      if (qp) *(qp + nn) = q;
    }
  }
  if (inv->shift > (unsigned int)0) (*gmp_free_func)((void *)tp,(size_t)0);
  __retres = r >> inv->shift;
  return __retres;
}

static mp_limb_t mpn_div_qr_1(mp_ptr qp, mp_srcptr np, mp_size_t nn,
                              mp_limb_t d)
{
  mp_limb_t __retres;
  __FC_assert((d > (mp_limb_t)0) != 0,"mini-gmp.c",895,"d > 0");
  if ((d & (d - (mp_limb_t)1)) == (unsigned long)0) {
    mp_limb_t r = *(np + 0) & (d - (mp_limb_t)1);
    if (qp) 
      if (d <= (mp_limb_t)1) mpn_copyi(qp,np,nn);
      else {
        unsigned int shift;
        {
          mp_limb_t __ctz_x = d;
          unsigned int __ctz_c = (unsigned int)0;
          {
            unsigned int __clz_c;
            mp_limb_t __clz_x = __ctz_x & - __ctz_x;
            __clz_c = (unsigned int)0;
            while ((__clz_x & ((mp_limb_t)0xff << (sizeof(mp_limb_t) * (unsigned int)8 - (unsigned int)8))) == (unsigned long)0) {
              __clz_x <<= 8;
              __clz_c += (unsigned int)8;
            }
            while ((__clz_x & ((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8 - (unsigned int)1))) == (unsigned long)0) {
              __clz_x <<= 1;
              __clz_c ++;
            }
            __ctz_c = __clz_c;
          }
          shift = (sizeof(mp_limb_t) * (unsigned int)8 - (unsigned int)1) - __ctz_c;
        }
        mpn_rshift(qp,np,nn,shift);
      }
    __retres = r;
    goto return_label;
  }
  else {
    struct gmp_div_inverse inv;
    mp_limb_t tmp;
    mpn_div_qr_1_invert(& inv,d);
    tmp = mpn_div_qr_1_preinv(qp,np,nn,
                              (struct gmp_div_inverse const *)(& inv));
    __retres = tmp;
    goto return_label;
  }
  return_label: return __retres;
}

static void mpn_div_qr_2_preinv(mp_ptr qp, mp_ptr rp, mp_srcptr np,
                                mp_size_t nn,
                                struct gmp_div_inverse const *inv)
{
  unsigned int shift;
  mp_size_t i;
  mp_limb_t d1;
  mp_limb_t d0;
  mp_limb_t di;
  mp_limb_t r1;
  mp_limb_t r0;
  mp_ptr tp;
  __FC_assert((nn >= (mp_size_t)2) != 0,"mini-gmp.c",931,"nn >= 2");
  shift = inv->shift;
  d1 = inv->d1;
  d0 = inv->d0;
  di = inv->di;
  if (shift > (unsigned int)0) {
    tp = gmp_xalloc_limbs(nn);
    r1 = mpn_lshift(tp,np,nn,shift);
    np = (mp_srcptr)tp;
  }
  else r1 = (mp_limb_t)0;
  r0 = *(np + (nn - (mp_size_t)1));
  i = nn - (mp_size_t)2;
  while (1) {
    {
      mp_limb_t n0;
      mp_limb_t q;
      n0 = *(np + i);
      {
        mp_limb_t _q0;
        mp_limb_t _t1;
        mp_limb_t _t0;
        mp_limb_t _mask;
        {
          mp_limb_t __x0;
          mp_limb_t __x1;
          mp_limb_t __x2;
          mp_limb_t __x3;
          unsigned int __ul;
          unsigned int __vl;
          unsigned int __uh;
          unsigned int __vh;
          mp_limb_t __u = r1;
          mp_limb_t __v = di;
          __ul = (unsigned int)(__u & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
          __uh = (unsigned int)(__u >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
          __vl = (unsigned int)(__v & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
          __vh = (unsigned int)(__v >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
          __x0 = (mp_limb_t)__ul * (mp_limb_t)__vl;
          __x1 = (mp_limb_t)__ul * (mp_limb_t)__vh;
          __x2 = (mp_limb_t)__uh * (mp_limb_t)__vl;
          __x3 = (mp_limb_t)__uh * (mp_limb_t)__vh;
          __x1 += __x0 >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2;
          __x1 += __x2;
          if (__x1 < __x2) __x3 += (mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2;
          q = __x3 + (__x1 >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
          _q0 = (__x1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) + (
                __x0 & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
        }
        {
          mp_limb_t __x;
          __x = _q0 + r0;
          q = (q + r1) + (mp_limb_t)(__x < _q0);
          _q0 = __x;
        }
        r1 = r0 - d1 * q;
        {
          mp_limb_t __x_0;
          __x_0 = n0 - d0;
          r1 = (r1 - d1) - (mp_limb_t)(n0 < d0);
          r0 = __x_0;
        }
        {
          mp_limb_t __x0_0;
          mp_limb_t __x1_0;
          mp_limb_t __x2_0;
          mp_limb_t __x3_0;
          unsigned int __ul_0;
          unsigned int __vl_0;
          unsigned int __uh_0;
          unsigned int __vh_0;
          mp_limb_t __u_0 = d0;
          mp_limb_t __v_0 = q;
          __ul_0 = (unsigned int)(__u_0 & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
          __uh_0 = (unsigned int)(__u_0 >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
          __vl_0 = (unsigned int)(__v_0 & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
          __vh_0 = (unsigned int)(__v_0 >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
          __x0_0 = (mp_limb_t)__ul_0 * (mp_limb_t)__vl_0;
          __x1_0 = (mp_limb_t)__ul_0 * (mp_limb_t)__vh_0;
          __x2_0 = (mp_limb_t)__uh_0 * (mp_limb_t)__vl_0;
          __x3_0 = (mp_limb_t)__uh_0 * (mp_limb_t)__vh_0;
          __x1_0 += __x0_0 >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2;
          __x1_0 += __x2_0;
          if (__x1_0 < __x2_0) __x3_0 += (mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2;
          _t1 = __x3_0 + (__x1_0 >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
          _t0 = (__x1_0 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) + (
                __x0_0 & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
        }
        {
          mp_limb_t __x_1;
          __x_1 = r0 - _t0;
          r1 = (r1 - _t1) - (mp_limb_t)(r0 < _t0);
          r0 = __x_1;
        }
        q ++;
        _mask = - ((mp_limb_t)(r1 >= _q0));
        q += _mask;
        {
          mp_limb_t __x_2;
          __x_2 = r0 + (_mask & d0);
          r1 = (r1 + (_mask & d1)) + (mp_limb_t)(__x_2 < r0);
          r0 = __x_2;
        }
        if (r1 >= d1) 
          if (r1 > d1) goto _LOR;
          else 
            if (r0 >= d0) {
              _LOR:
              {
                q ++;
                {
                  mp_limb_t __x_3;
                  __x_3 = r0 - d0;
                  r1 = (r1 - d1) - (mp_limb_t)(r0 < d0);
                  r0 = __x_3;
                }
              }
            }
      }
      if (qp) *(qp + i) = q;
    }
    i --;
    if (! (i >= (mp_size_t)0)) break;
  }
  if (shift > (unsigned int)0) {
    __FC_assert((r0 << (sizeof(mp_limb_t) * (unsigned int)8 - shift) == (mp_limb_t)0) != 0,
                "mini-gmp.c",962,"(r0 << (GMP_LIMB_BITS - shift)) == 0");
    r0 = (r0 >> shift) | (r1 << (sizeof(mp_limb_t) * (unsigned int)8 - shift));
    r1 >>= shift;
    (*gmp_free_func)((void *)tp,(size_t)0);
  }
  *(rp + 1) = r1;
  *(rp + 0) = r0;
  return;
}

static void mpn_div_qr_pi1(mp_ptr qp, mp_ptr np, mp_size_t nn, mp_limb_t n1,
                           mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
{
  mp_size_t i;
  mp_limb_t d1;
  mp_limb_t d0;
  mp_limb_t cy;
  mp_limb_t cy1;
  mp_limb_t q;
  __FC_assert((dn > (mp_size_t)2) != 0,"mini-gmp.c",998,"dn > 2");
  __FC_assert((nn >= dn) != 0,"mini-gmp.c",999,"nn >= dn");
  d1 = *(dp + (dn - (mp_size_t)1));
  d0 = *(dp + (dn - (mp_size_t)2));
  __FC_assert(((d1 & ((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8 - (unsigned int)1))) != (unsigned long)0) != 0,
              "mini-gmp.c",1004,"(d1 & GMP_LIMB_HIGHBIT) != 0");
  i = nn - dn;
  while (1) {
    {
      mp_limb_t n0 = *(np + ((dn - (mp_size_t)1) + i));
      if (n1 == d1) {
        if (n0 == d0) {
          q = ~ ((mp_limb_t)0);
          mpn_submul_1(np + i,dp,dn,q);
          n1 = *(np + ((dn - (mp_size_t)1) + i));
        }
        else goto _LAND;
      }
      else {
        _LAND:
        {
          {
            mp_limb_t _q0;
            mp_limb_t _t1;
            mp_limb_t _t0;
            mp_limb_t _mask;
            {
              mp_limb_t __x0;
              mp_limb_t __x1;
              mp_limb_t __x2;
              mp_limb_t __x3;
              unsigned int __ul;
              unsigned int __vl;
              unsigned int __uh;
              unsigned int __vh;
              mp_limb_t __u = n1;
              mp_limb_t __v = dinv;
              __ul = (unsigned int)(__u & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
              __uh = (unsigned int)(__u >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
              __vl = (unsigned int)(__v & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
              __vh = (unsigned int)(__v >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
              __x0 = (mp_limb_t)__ul * (mp_limb_t)__vl;
              __x1 = (mp_limb_t)__ul * (mp_limb_t)__vh;
              __x2 = (mp_limb_t)__uh * (mp_limb_t)__vl;
              __x3 = (mp_limb_t)__uh * (mp_limb_t)__vh;
              __x1 += __x0 >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2;
              __x1 += __x2;
              if (__x1 < __x2) __x3 += (mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2;
              q = __x3 + (__x1 >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
              _q0 = (__x1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) + (
                    __x0 & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
            }
            {
              mp_limb_t __x;
              __x = _q0 + n0;
              q = (q + n1) + (mp_limb_t)(__x < _q0);
              _q0 = __x;
            }
            n1 = n0 - d1 * q;
            {
              mp_limb_t __x_0;
              __x_0 = *(np + ((dn - (mp_size_t)2) + i)) - d0;
              n1 = (n1 - d1) - (mp_limb_t)(*(np + ((dn - (mp_size_t)2) + i)) < d0);
              n0 = __x_0;
            }
            {
              mp_limb_t __x0_0;
              mp_limb_t __x1_0;
              mp_limb_t __x2_0;
              mp_limb_t __x3_0;
              unsigned int __ul_0;
              unsigned int __vl_0;
              unsigned int __uh_0;
              unsigned int __vh_0;
              mp_limb_t __u_0 = d0;
              mp_limb_t __v_0 = q;
              __ul_0 = (unsigned int)(__u_0 & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
              __uh_0 = (unsigned int)(__u_0 >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
              __vl_0 = (unsigned int)(__v_0 & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
              __vh_0 = (unsigned int)(__v_0 >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
              __x0_0 = (mp_limb_t)__ul_0 * (mp_limb_t)__vl_0;
              __x1_0 = (mp_limb_t)__ul_0 * (mp_limb_t)__vh_0;
              __x2_0 = (mp_limb_t)__uh_0 * (mp_limb_t)__vl_0;
              __x3_0 = (mp_limb_t)__uh_0 * (mp_limb_t)__vh_0;
              __x1_0 += __x0_0 >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2;
              __x1_0 += __x2_0;
              if (__x1_0 < __x2_0) __x3_0 += (mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2;
              _t1 = __x3_0 + (__x1_0 >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
              _t0 = (__x1_0 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) + (
                    __x0_0 & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
            }
            {
              mp_limb_t __x_1;
              __x_1 = n0 - _t0;
              n1 = (n1 - _t1) - (mp_limb_t)(n0 < _t0);
              n0 = __x_1;
            }
            q ++;
            _mask = - ((mp_limb_t)(n1 >= _q0));
            q += _mask;
            {
              mp_limb_t __x_2;
              __x_2 = n0 + (_mask & d0);
              n1 = (n1 + (_mask & d1)) + (mp_limb_t)(__x_2 < n0);
              n0 = __x_2;
            }
            if (n1 >= d1) 
              if (n1 > d1) goto _LOR;
              else 
                if (n0 >= d0) {
                  _LOR:
                  {
                    q ++;
                    {
                      mp_limb_t __x_3;
                      __x_3 = n0 - d0;
                      n1 = (n1 - d1) - (mp_limb_t)(n0 < d0);
                      n0 = __x_3;
                    }
                  }
                }
          }
          cy = mpn_submul_1(np + i,dp,dn - (mp_size_t)2,q);
          cy1 = (mp_limb_t)(n0 < cy);
          n0 -= cy;
          cy = (mp_limb_t)(n1 < cy1);
          n1 -= cy1;
          *(np + ((dn - (mp_size_t)2) + i)) = n0;
          if (cy != (mp_limb_t)0) {
            mp_limb_t tmp;
            tmp = mpn_add_n(np + i,(mp_srcptr)(np + i),dp,dn - (mp_size_t)1);
            n1 += d1 + tmp;
            q --;
          }
        }
      }
      if (qp) *(qp + i) = q;
    }
    i --;
    if (! (i >= (mp_size_t)0)) break;
  }
  *(np + (dn - (mp_size_t)1)) = n1;
  return;
}

static void mpn_div_qr_preinv(mp_ptr qp, mp_ptr np, mp_size_t nn,
                              mp_srcptr dp, mp_size_t dn,
                              struct gmp_div_inverse const *inv)
{
  __FC_assert((dn > (mp_size_t)0) != 0,"mini-gmp.c",1054,"dn > 0");
  __FC_assert((nn >= dn) != 0,"mini-gmp.c",1055,"nn >= dn");
  if (dn == (mp_size_t)1) *(np + 0) = mpn_div_qr_1_preinv(qp,(mp_srcptr)np,
                                                          nn,inv);
  else 
    if (dn == (mp_size_t)2) mpn_div_qr_2_preinv(qp,np,(mp_srcptr)np,nn,inv);
    else {
      mp_limb_t nh;
      unsigned int shift;
      __FC_assert((inv->d1 == *(dp + (dn - (mp_size_t)1))) != 0,"mini-gmp.c",
                  1066,"inv->d1 == dp[dn-1]");
      __FC_assert((inv->d0 == *(dp + (dn - (mp_size_t)2))) != 0,"mini-gmp.c",
                  1067,"inv->d0 == dp[dn-2]");
      __FC_assert(((inv->d1 & ((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8 - (unsigned int)1))) != (unsigned long)0) != 0,
                  "mini-gmp.c",1068,"(inv->d1 & GMP_LIMB_HIGHBIT) != 0");
      shift = inv->shift;
      if (shift > (unsigned int)0) nh = mpn_lshift(np,(mp_srcptr)np,nn,shift);
      else nh = (mp_limb_t)0;
      mpn_div_qr_pi1(qp,np,nn,nh,dp,dn,inv->di);
      if (shift > (unsigned int)0) {
        mp_limb_t __cy = mpn_rshift(np,(mp_srcptr)np,dn,shift);
        __FC_assert((__cy == (mp_limb_t)0) != 0,"mini-gmp.c",1079,
                    "__cy == 0");
      }
    }
  return;
}

static void mpn_div_qr(mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp,
                       mp_size_t dn)
{
  struct gmp_div_inverse inv;
  mp_ptr tp = (mp_ptr)0;
  __FC_assert((dn > (mp_size_t)0) != 0,"mini-gmp.c",1089,"dn > 0");
  __FC_assert((nn >= dn) != 0,"mini-gmp.c",1090,"nn >= dn");
  mpn_div_qr_invert(& inv,dp,dn);
  if (dn > (mp_size_t)2) 
    if (inv.shift > (unsigned int)0) {
      tp = gmp_xalloc_limbs(dn);
      {
        mp_limb_t __cy = mpn_lshift(tp,dp,dn,inv.shift);
        __FC_assert((__cy == (mp_limb_t)0) != 0,"mini-gmp.c",1096,
                    "__cy == 0");
      }
      dp = (mp_srcptr)tp;
    }
  mpn_div_qr_preinv(qp,np,nn,dp,dn,(struct gmp_div_inverse const *)(& inv));
  if (tp) (*gmp_free_func)((void *)tp,(size_t)0);
  return;
}

static unsigned int mpn_base_power_of_two_p(unsigned int b)
{
  unsigned int __retres;
  switch (b) {
    case (unsigned int)2: __retres = (unsigned int)1;
    goto return_label;
    case (unsigned int)4: __retres = (unsigned int)2;
    goto return_label;
    case (unsigned int)8: __retres = (unsigned int)3;
    goto return_label;
    case (unsigned int)16: __retres = (unsigned int)4;
    goto return_label;
    case (unsigned int)32: __retres = (unsigned int)5;
    goto return_label;
    case (unsigned int)64: __retres = (unsigned int)6;
    goto return_label;
    case (unsigned int)128: __retres = (unsigned int)7;
    goto return_label;
    case (unsigned int)256: __retres = (unsigned int)8;
    goto return_label;
    default: __retres = (unsigned int)0;
    goto return_label;
  }
  return_label: return __retres;
}

static void mpn_get_base_info(struct mpn_base_info *info, mp_limb_t b)
{
  mp_limb_t m;
  mp_limb_t p;
  unsigned int exp;
  m = ~ ((mp_limb_t)0) / b;
  exp = (unsigned int)1;
  p = b;
  while (p <= m) {
    p *= b;
    exp ++;
  }
  info->exp = exp;
  info->bb = p;
  return;
}

static mp_bitcnt_t mpn_limb_size_in_base_2(mp_limb_t u)
{
  mp_bitcnt_t __retres;
  unsigned int shift;
  __FC_assert((u > (mp_limb_t)0) != 0,"mini-gmp.c",1151,"u > 0");
  {
    unsigned int __clz_c;
    mp_limb_t __clz_x = u;
    __clz_c = (unsigned int)0;
    while ((__clz_x & ((mp_limb_t)0xff << (sizeof(mp_limb_t) * (unsigned int)8 - (unsigned int)8))) == (unsigned long)0) {
      __clz_x <<= 8;
      __clz_c += (unsigned int)8;
    }
    while ((__clz_x & ((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8 - (unsigned int)1))) == (unsigned long)0) {
      __clz_x <<= 1;
      __clz_c ++;
    }
    shift = __clz_c;
  }
  __retres = (mp_bitcnt_t)(sizeof(mp_limb_t) * (unsigned int)8 - shift);
  return __retres;
}

static size_t mpn_get_str_bits(unsigned char *sp, unsigned int bits,
                               mp_srcptr up, mp_size_t un)
{
  unsigned char mask;
  size_t sn;
  size_t j;
  mp_size_t i;
  int shift;
  mp_bitcnt_t tmp;
  tmp = mpn_limb_size_in_base_2(*(up + (un - (mp_size_t)1)));
  sn = (size_t)(((((unsigned long)(un - (mp_size_t)1) * (unsigned long)(
                   sizeof(mp_limb_t) * (unsigned int)8) + tmp) + (unsigned long)bits) - (unsigned long)1) / (unsigned long)bits);
  mask = (unsigned char)((1U << bits) - (unsigned int)1);
  i = (mp_size_t)0;
  j = sn;
  shift = 0;
  while (1) {
    size_t tmp_0;
    tmp_0 = j;
    j --;
    ;
    if (! (tmp_0 > (size_t)0)) break;
    {
      unsigned char digit = (unsigned char)(*(up + i) >> shift);
      shift = (int)((unsigned int)shift + bits);
      if ((unsigned int)shift >= sizeof(mp_limb_t) * (unsigned int)8) {
        i ++;
        ;
        if (i < un) {
          shift = (int)((unsigned int)shift - sizeof(mp_limb_t) * (unsigned int)8);
          digit = (unsigned char)((unsigned long)digit | (*(up + i) << (
                                                          bits - (unsigned int)shift)));
        }
      }
      *(sp + j) = (unsigned char)((int)digit & (int)mask);
    }
  }
  return sn;
}

static size_t mpn_limb_get_str(unsigned char *sp, mp_limb_t w,
                               struct gmp_div_inverse const *binv)
{
  size_t __retres;
  mp_size_t i;
  i = (mp_size_t)0;
  while (w > (mp_limb_t)0) {
    {
      mp_limb_t h;
      mp_limb_t l;
      mp_limb_t r;
      h = w >> (sizeof(mp_limb_t) * (unsigned int)8 - binv->shift);
      l = w << binv->shift;
      {
        mp_limb_t _qh;
        mp_limb_t _ql;
        mp_limb_t _r;
        mp_limb_t _mask;
        {
          mp_limb_t __x0;
          mp_limb_t __x1;
          mp_limb_t __x2;
          mp_limb_t __x3;
          unsigned int __ul;
          unsigned int __vl;
          unsigned int __uh;
          unsigned int __vh;
          mp_limb_t __u = h;
          mp_limb_t __v = binv->di;
          __ul = (unsigned int)(__u & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
          __uh = (unsigned int)(__u >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
          __vl = (unsigned int)(__v & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
          __vh = (unsigned int)(__v >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
          __x0 = (mp_limb_t)__ul * (mp_limb_t)__vl;
          __x1 = (mp_limb_t)__ul * (mp_limb_t)__vh;
          __x2 = (mp_limb_t)__uh * (mp_limb_t)__vl;
          __x3 = (mp_limb_t)__uh * (mp_limb_t)__vh;
          __x1 += __x0 >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2;
          __x1 += __x2;
          if (__x1 < __x2) __x3 += (mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2;
          _qh = __x3 + (__x1 >> (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2);
          _ql = (__x1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) + (
                __x0 & (((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8) / (unsigned int)2) - (mp_limb_t)1));
        }
        {
          mp_limb_t __x;
          __x = _ql + l;
          _qh = (_qh + (h + (mp_limb_t)1)) + (mp_limb_t)(__x < _ql);
          _ql = __x;
        }
        _r = l - _qh * binv->d1;
        _mask = - ((mp_limb_t)(_r > _ql));
        _qh += _mask;
        _r += _mask & binv->d1;
        if (_r >= binv->d1) {
          _r -= binv->d1;
          _qh ++;
        }
        r = _r;
        w = _qh;
      }
      __FC_assert((r << (sizeof(mp_limb_t) * (unsigned int)8 - binv->shift) == (mp_limb_t)0) != 0,
                  "mini-gmp.c",1200,
                  "(r << (GMP_LIMB_BITS - binv->shift)) == 0");
      r >>= binv->shift;
      *(sp + i) = (unsigned char)r;
    }
    i ++;
  }
  __retres = (size_t)i;
  return __retres;
}

static size_t mpn_get_str_other(unsigned char *sp, int base,
                                struct mpn_base_info const *info, mp_ptr up,
                                mp_size_t un)
{
  struct gmp_div_inverse binv;
  size_t sn;
  size_t i;
  size_t tmp_0;
  mpn_div_qr_1_invert(& binv,(mp_limb_t)base);
  sn = (size_t)0;
  if (un > (mp_size_t)1) {
    struct gmp_div_inverse bbinv;
    mpn_div_qr_1_invert(& bbinv,info->bb);
    while (1) {
      {
        mp_limb_t w;
        size_t done;
        w = mpn_div_qr_1_preinv(up,(mp_srcptr)up,un,
                                (struct gmp_div_inverse const *)(& bbinv));
        un -= (mp_size_t)(*(up + (un - (mp_size_t)1)) == (mp_limb_t)0);
        done = mpn_limb_get_str(sp + sn,w,
                                (struct gmp_div_inverse const *)(& binv));
        sn += done;
        while (done < info->exp) {
          size_t tmp;
          tmp = sn;
          sn ++;
          *(sp + tmp) = (unsigned char)0;
          done ++;
        }
      }
      if (! (un > (mp_size_t)1)) break;
    }
  }
  tmp_0 = mpn_limb_get_str(sp + sn,*(up + 0),
                           (struct gmp_div_inverse const *)(& binv));
  sn += tmp_0;
  i = (size_t)0;
  while ((size_t)2 * i + (size_t)1 < sn) {
    {
      unsigned char t = *(sp + i);
      *(sp + i) = *(sp + ((sn - i) - (size_t)1));
      *(sp + ((sn - i) - (size_t)1)) = t;
    }
    i ++;
  }
  return sn;
}

size_t mpn_get_str(unsigned char *sp, int base, mp_ptr up, mp_size_t un)
{
  size_t __retres;
  unsigned int bits;
  __FC_assert((un > (mp_size_t)0) != 0,"mini-gmp.c",1257,"un > 0");
  __FC_assert((*(up + (un - (mp_size_t)1)) > (mp_limb_t)0) != 0,"mini-gmp.c",
              1258,"up[un-1] > 0");
  bits = mpn_base_power_of_two_p((unsigned int)base);
  if (bits) {
    size_t tmp;
    tmp = mpn_get_str_bits(sp,bits,(mp_srcptr)up,un);
    __retres = tmp;
    goto return_label;
  }
  else {
    struct mpn_base_info info;
    size_t tmp_0;
    mpn_get_base_info(& info,(mp_limb_t)base);
    tmp_0 = mpn_get_str_other(sp,base,(struct mpn_base_info const *)(& info),
                              up,un);
    __retres = tmp_0;
    goto return_label;
  }
  return_label: return __retres;
}

static mp_size_t mpn_set_str_bits(mp_ptr rp, unsigned char const *sp,
                                  size_t sn, unsigned int bits)
{
  mp_size_t rn;
  size_t j;
  unsigned int shift;
  j = sn;
  rn = (mp_size_t)0;
  shift = (unsigned int)0;
  while (1) {
    size_t tmp_1;
    tmp_1 = j;
    j --;
    ;
    if (! (tmp_1 > (size_t)0)) break;
    if (shift == (unsigned int)0) {
      mp_size_t tmp;
      tmp = rn;
      rn ++;
      *(rp + tmp) = (mp_limb_t)*(sp + j);
      shift += bits;
    }
    else {
      *(rp + (rn - (mp_size_t)1)) |= (mp_limb_t)*(sp + j) << shift;
      shift += bits;
      if (shift >= sizeof(mp_limb_t) * (unsigned int)8) {
        shift -= sizeof(mp_limb_t) * (unsigned int)8;
        if (shift > (unsigned int)0) {
          mp_size_t tmp_0;
          tmp_0 = rn;
          rn ++;
          *(rp + tmp_0) = (mp_limb_t)*(sp + j) >> (bits - shift);
        }
      }
    }
  }
  rn = mpn_normalized_size((mp_srcptr)rp,rn);
  return rn;
}

static mp_size_t mpn_set_str_other(mp_ptr rp, unsigned char const *sp,
                                   size_t sn, mp_limb_t b,
                                   struct mpn_base_info const *info)
{
  mp_size_t rn;
  mp_limb_t w;
  unsigned int k;
  size_t j;
  size_t tmp;
  k = (unsigned int)1 + (sn - (size_t)1) % info->exp;
  j = (size_t)0;
  tmp = j;
  j ++;
  w = (mp_limb_t)*(sp + tmp);
  while (1) {
    size_t tmp_0;
    k --;
    if (! (k != (unsigned int)0)) break;
    tmp_0 = j;
    j ++;
    w = w * b + (mp_limb_t)*(sp + tmp_0);
  }
  *(rp + 0) = w;
  rn = (mp_size_t)(w > (mp_limb_t)0);
  while (j < sn) {
    mp_limb_t cy;
    size_t tmp_1;
    mp_limb_t tmp_3;
    tmp_1 = j;
    j ++;
    w = (mp_limb_t)*(sp + tmp_1);
    k = (unsigned int)1;
    while (k < info->exp) {
      size_t tmp_2;
      tmp_2 = j;
      j ++;
      w = w * b + (mp_limb_t)*(sp + tmp_2);
      k ++;
    }
    cy = mpn_mul_1(rp,(mp_srcptr)rp,rn,info->bb);
    tmp_3 = mpn_add_1(rp,(mp_srcptr)rp,rn,w);
    cy += tmp_3;
    if (cy > (mp_limb_t)0) {
      mp_size_t tmp_4;
      tmp_4 = rn;
      rn ++;
      *(rp + tmp_4) = cy;
    }
  }
  __FC_assert((j == sn) != 0,"mini-gmp.c",1334,"j == sn");
  return rn;
}

mp_size_t mpn_set_str(mp_ptr rp, unsigned char const *sp, size_t sn, int base)
{
  mp_size_t __retres;
  unsigned int bits;
  if (sn == (size_t)0) {
    __retres = (mp_size_t)0;
    goto return_label;
  }
  bits = mpn_base_power_of_two_p((unsigned int)base);
  if (bits) {
    mp_size_t tmp;
    tmp = mpn_set_str_bits(rp,sp,sn,bits);
    __retres = tmp;
    goto return_label;
  }
  else {
    struct mpn_base_info info;
    mp_size_t tmp_0;
    mpn_get_base_info(& info,(mp_limb_t)base);
    tmp_0 = mpn_set_str_other(rp,sp,sn,(mp_limb_t)base,
                              (struct mpn_base_info const *)(& info));
    __retres = tmp_0;
    goto return_label;
  }
  return_label: return __retres;
}

void mpz_init(__mpz_struct r[1])
{
  r->_mp_alloc = 1;
  r->_mp_size = 0;
  r->_mp_d = gmp_xalloc_limbs((mp_size_t)1);
  return;
}

void mpz_init2(__mpz_struct r[1], mp_bitcnt_t bits)
{
  mp_size_t rn;
  bits -= (mp_bitcnt_t)(bits != (mp_bitcnt_t)0);
  rn = (mp_size_t)((mp_bitcnt_t)1 + bits / (mp_bitcnt_t)(sizeof(mp_limb_t) * (unsigned int)8));
  r->_mp_alloc = (int)rn;
  r->_mp_size = 0;
  r->_mp_d = gmp_xalloc_limbs(rn);
  return;
}

void mpz_clear(__mpz_struct r[1])
{
  (*gmp_free_func)((void *)r->_mp_d,(size_t)0);
  return;
}

static mp_ptr mpz_realloc(__mpz_struct r[1], mp_size_t size)
{
  mp_ptr __retres;
  int tmp;
  if (size > (mp_size_t)1) size = size; else size = (mp_size_t)1;
  r->_mp_d = gmp_xrealloc_limbs(r->_mp_d,size);
  r->_mp_alloc = (int)size;
  if (r->_mp_size >= 0) tmp = r->_mp_size; else tmp = - r->_mp_size;
  ;
  if ((mp_size_t)tmp > size) r->_mp_size = 0;
  __retres = r->_mp_d;
  return __retres;
}

void mpz_set_si(__mpz_struct r[1], long x)
{
  if (x >= (long)0) mpz_set_ui(r,(unsigned long)x);
  else {
    r->_mp_size = -1;
    *(r->_mp_d + 0) = - ((unsigned long)(x + (long)1) - (unsigned long)1);
  }
  return;
}

void mpz_set_ui(__mpz_struct r[1], unsigned long x)
{
  if (x > (unsigned long)0) {
    r->_mp_size = 1;
    *(r->_mp_d + 0) = x;
  }
  else r->_mp_size = 0;
  return;
}

void mpz_set(__mpz_struct r[1], __mpz_struct const x[1])
{
  if ((void *)r != (void *)x) {
    mp_size_t n;
    mp_ptr rp;
    if (x->_mp_size >= 0) n = (mp_size_t)x->_mp_size;
    else n = (mp_size_t)(- x->_mp_size);
    if (n > (mp_size_t)r->_mp_alloc) rp = mpz_realloc(r,n);
    else rp = r->_mp_d;
    mpn_copyi(rp,(mp_srcptr)x->_mp_d,n);
    r->_mp_size = x->_mp_size;
  }
  return;
}

void mpz_init_set_si(__mpz_struct r[1], long x)
{
  mpz_init(r);
  mpz_set_si(r,x);
  return;
}

void mpz_init_set_ui(__mpz_struct r[1], unsigned long x)
{
  mpz_init(r);
  mpz_set_ui(r,x);
  return;
}

void mpz_init_set(__mpz_struct r[1], __mpz_struct const x[1])
{
  mpz_init(r);
  mpz_set(r,x);
  return;
}

int mpz_fits_slong_p(__mpz_struct const u[1])
{
  int __retres;
  mp_size_t us = (mp_size_t)u->_mp_size;
  if (us == (mp_size_t)1) {
    __retres = *(u->_mp_d + 0) < (mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8 - (unsigned int)1);
    goto return_label;
  }
  else 
    if (us == (mp_size_t)(-1)) {
      __retres = *(u->_mp_d + 0) <= (mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8 - (unsigned int)1);
      goto return_label;
    }
    else {
      __retres = us == (mp_size_t)0;
      goto return_label;
    }
  return_label: return __retres;
}

int mpz_fits_ulong_p(__mpz_struct const u[1])
{
  int __retres;
  mp_size_t us = (mp_size_t)u->_mp_size;
  __retres = us == (mp_size_t)(us > (mp_size_t)0);
  return __retres;
}

long mpz_get_si(__mpz_struct const u[1])
{
  long __retres;
  mp_size_t us = (mp_size_t)u->_mp_size;
  if (us > (mp_size_t)0) {
    __retres = (long)(*(u->_mp_d + 0) & ~ ((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8 - (unsigned int)1)));
    goto return_label;
  }
  else 
    if (us < (mp_size_t)0) {
      __retres = (long)(- *(u->_mp_d + 0) | ((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8 - (unsigned int)1)));
      goto return_label;
    }
    else {
      __retres = (long)0;
      goto return_label;
    }
  return_label: return __retres;
}

unsigned long mpz_get_ui(__mpz_struct const u[1])
{
  mp_limb_t tmp;
  if (u->_mp_size == 0) tmp = (mp_limb_t)0; else tmp = *(u->_mp_d + 0);
  return tmp;
}

size_t mpz_size(__mpz_struct const u[1])
{
  size_t __retres;
  int tmp;
  if (u->_mp_size >= 0) tmp = u->_mp_size; else tmp = - u->_mp_size;
  __retres = (size_t)tmp;
  return __retres;
}

mp_limb_t mpz_getlimbn(__mpz_struct const u[1], mp_size_t n)
{
  mp_limb_t __retres;
  if (n >= (mp_size_t)0) {
    int tmp;
    if (u->_mp_size >= 0) tmp = u->_mp_size; else tmp = - u->_mp_size;
    ;
    if (n < (mp_size_t)tmp) {
      __retres = *(u->_mp_d + n);
      goto return_label;
    }
    else {
      __retres = (mp_limb_t)0;
      goto return_label;
    }
  }
  else {
    __retres = (mp_limb_t)0;
    goto return_label;
  }
  return_label: return __retres;
}

void mpz_realloc2(__mpz_struct x[1], mp_bitcnt_t n)
{
  mpz_realloc(x,
              (mp_size_t)((mp_bitcnt_t)1 + (n - (mp_bitcnt_t)(n != (mp_bitcnt_t)0)) / (mp_bitcnt_t)(
                                           sizeof(mp_limb_t) * (unsigned int)8)));
  return;
}

mp_srcptr mpz_limbs_read(mpz_srcptr x)
{
  mp_srcptr __retres;
  __retres = (mp_srcptr)x->_mp_d;
  goto return_label;
  return_label: return __retres;
}

mp_ptr mpz_limbs_modify(__mpz_struct x[1], mp_size_t n)
{
  mp_ptr tmp_0;
  __FC_assert((n > (mp_size_t)0) != 0,"mini-gmp.c",1542,"n > 0");
  if (n > (mp_size_t)x->_mp_alloc) tmp_0 = mpz_realloc(x,n);
  else tmp_0 = x->_mp_d;
  return tmp_0;
}

mp_ptr mpz_limbs_write(__mpz_struct x[1], mp_size_t n)
{
  mp_ptr tmp;
  tmp = mpz_limbs_modify(x,n);
  return tmp;
}

void mpz_limbs_finish(__mpz_struct x[1], mp_size_t xs)
{
  mp_size_t xn;
  mp_size_t tmp;
  if (xs >= (mp_size_t)0) tmp = xs; else tmp = - xs;
  ;
  xn = mpn_normalized_size((mp_srcptr)x->_mp_d,tmp);
  if (xs < (mp_size_t)0) x->_mp_size = (int)(- xn);
  else x->_mp_size = (int)xn;
  return;
}

mpz_srcptr mpz_roinit_n(__mpz_struct x[1], mp_srcptr xp, mp_size_t xs)
{
  mpz_srcptr __retres;
  x->_mp_alloc = 0;
  x->_mp_d = (mp_ptr)xp;
  mpz_limbs_finish(x,xs);
  __retres = (mpz_srcptr)x;
  return __retres;
}

void mpz_set_d(__mpz_struct r[1], double x)
{
  int sign;
  mp_ptr rp;
  mp_size_t rn;
  mp_size_t i;
  double B;
  double Bi;
  mp_limb_t f;
  if (x != x) goto _LOR;
  else 
    if (x == x * 0.5) {
      _LOR: {
              r->_mp_size = 0;
              goto return_label;
            }
    }
  sign = x < 0.0;
  if (sign) x = - x;
  if (x < 1.0) {
    r->_mp_size = 0;
    goto return_label;
  }
  B = 2.0 * (double)((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8 - (unsigned int)1));
  Bi = 1.0 / B;
  rn = (mp_size_t)1;
  while (x >= B) {
    x *= Bi;
    rn ++;
  }
  if (rn > (mp_size_t)r->_mp_alloc) rp = mpz_realloc(r,rn);
  else rp = r->_mp_d;
  f = (mp_limb_t)x;
  x -= (double)f;
  __FC_assert((x < 1.0) != 0,"mini-gmp.c",1607,"x < 1.0");
  i = rn - (mp_size_t)1;
  *(rp + i) = f;
  while (1) {
    i --;
    if (! (i >= (mp_size_t)0)) break;
    x = B * x;
    f = (mp_limb_t)x;
    x -= (double)f;
    __FC_assert((x < 1.0) != 0,"mini-gmp.c",1615,"x < 1.0");
    *(rp + i) = f;
  }
  if (sign) r->_mp_size = (int)(- rn); else r->_mp_size = (int)rn;
  return_label: return;
}

void mpz_init_set_d(__mpz_struct r[1], double x)
{
  mpz_init(r);
  mpz_set_d(r,x);
  return;
}

double mpz_get_d(__mpz_struct const u[1])
{
  double __retres;
  mp_size_t un;
  double x;
  double B =
    2.0 * (double)((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8 - (unsigned int)1));
  if (u->_mp_size >= 0) un = (mp_size_t)u->_mp_size;
  else un = (mp_size_t)(- u->_mp_size);
  if (un == (mp_size_t)0) {
    __retres = 0.0;
    goto return_label;
  }
  un --;
  x = (double)*(u->_mp_d + un);
  while (un > (mp_size_t)0) {
    un --;
    x = B * x + (double)*(u->_mp_d + un);
  }
  if (u->_mp_size < 0) x = - x;
  __retres = x;
  return_label: return __retres;
}

int mpz_cmpabs_d(__mpz_struct const x[1], double d)
{
  int __retres;
  mp_size_t xn;
  double B;
  double Bi;
  mp_size_t i;
  xn = (mp_size_t)x->_mp_size;
  if (d >= (double)0) d = d; else d = - d;
  if (xn != (mp_size_t)0) {
    if (xn >= (mp_size_t)0) xn = xn; else xn = - xn;
    B = 2.0 * (double)((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8 - (unsigned int)1));
    Bi = 1.0 / B;
    i = (mp_size_t)1;
    while (i < xn) {
      d *= Bi;
      i ++;
    }
    if (d >= B) {
      __retres = -1;
      goto return_label;
    }
    i = xn;
    while (1) {
      mp_size_t tmp;
      tmp = i;
      i --;
      ;
      if (! (tmp > (mp_size_t)0)) break;
      {
        mp_limb_t f;
        mp_limb_t xl;
        f = (mp_limb_t)d;
        xl = *(x->_mp_d + i);
        if (xl > f) {
          __retres = 1;
          goto return_label;
        }
        else 
          if (xl < f) {
            __retres = -1;
            goto return_label;
          }
        d = B * (d - (double)f);
      }
    }
  }
  __retres = - (d > 0.0);
  return_label: return __retres;
}

int mpz_cmp_d(__mpz_struct const x[1], double d)
{
  int __retres;
  if (x->_mp_size < 0) 
    if (d >= 0.0) {
      __retres = -1;
      goto return_label;
    }
    else {
      int tmp;
      tmp = mpz_cmpabs_d(x,d);
      __retres = - tmp;
      goto return_label;
    }
  else 
    if (d < 0.0) {
      __retres = 1;
      goto return_label;
    }
    else {
      int tmp_0;
      tmp_0 = mpz_cmpabs_d(x,d);
      __retres = tmp_0;
      goto return_label;
    }
  return_label: return __retres;
}

int mpz_sgn(__mpz_struct const u[1])
{
  int __retres;
  mp_size_t usize = (mp_size_t)u->_mp_size;
  __retres = (usize > (mp_size_t)0) - (usize < (mp_size_t)0);
  return __retres;
}

int mpz_cmp_si(__mpz_struct const u[1], long v)
{
  int __retres;
  mp_size_t usize = (mp_size_t)u->_mp_size;
  if (usize < (mp_size_t)(-1)) {
    __retres = -1;
    goto return_label;
  }
  else 
    if (v >= (long)0) {
      int tmp;
      tmp = mpz_cmp_ui(u,(unsigned long)v);
      __retres = tmp;
      goto return_label;
    }
    else 
      if (usize >= (mp_size_t)0) {
        __retres = 1;
        goto return_label;
      }
      else {
        mp_limb_t ul = *(u->_mp_d + 0);
        if (- ((unsigned long)(v + (long)1) - (unsigned long)1) < ul) {
          __retres = -1;
          goto return_label;
        }
        else {
          __retres = - ((unsigned long)(v + (long)1) - (unsigned long)1) > ul;
          goto return_label;
        }
      }
  return_label: return __retres;
}

int mpz_cmp_ui(__mpz_struct const u[1], unsigned long v)
{
  int __retres;
  mp_size_t usize = (mp_size_t)u->_mp_size;
  if (usize > (mp_size_t)1) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (usize < (mp_size_t)0) {
      __retres = -1;
      goto return_label;
    }
    else {
      mp_limb_t tmp;
      if (usize > (mp_size_t)0) tmp = *(u->_mp_d + 0);
      else tmp = (mp_limb_t)0;
      mp_limb_t ul = tmp;
      __retres = (ul > v) - (ul < v);
      goto return_label;
    }
  return_label: return __retres;
}

int mpz_cmp(__mpz_struct const a[1], __mpz_struct const b[1])
{
  int __retres;
  mp_size_t asize = (mp_size_t)a->_mp_size;
  mp_size_t bsize = (mp_size_t)b->_mp_size;
  if (asize != bsize) {
    int tmp;
    if (asize < bsize) tmp = -1; else tmp = 1;
    __retres = tmp;
    goto return_label;
  }
  else 
    if (asize >= (mp_size_t)0) {
      int tmp_0;
      tmp_0 = mpn_cmp((mp_srcptr)a->_mp_d,(mp_srcptr)b->_mp_d,asize);
      __retres = tmp_0;
      goto return_label;
    }
    else {
      int tmp_1;
      tmp_1 = mpn_cmp((mp_srcptr)b->_mp_d,(mp_srcptr)a->_mp_d,- asize);
      __retres = tmp_1;
      goto return_label;
    }
  return_label: return __retres;
}

int mpz_cmpabs_ui(__mpz_struct const u[1], unsigned long v)
{
  int __retres;
  int tmp;
  mp_limb_t ul;
  if (u->_mp_size >= 0) tmp = u->_mp_size; else tmp = - u->_mp_size;
  mp_size_t un = (mp_size_t)tmp;
  if (un > (mp_size_t)1) {
    __retres = 1;
    goto return_label;
  }
  if (un == (mp_size_t)1) ul = *(u->_mp_d + 0); else ul = (mp_limb_t)0;
  __retres = (ul > v) - (ul < v);
  return_label: return __retres;
}

int mpz_cmpabs(__mpz_struct const u[1], __mpz_struct const v[1])
{
  int tmp_1;
  int tmp;
  int tmp_0;
  if (v->_mp_size >= 0) tmp = v->_mp_size; else tmp = - v->_mp_size;
  ;
  if (u->_mp_size >= 0) tmp_0 = u->_mp_size; else tmp_0 = - u->_mp_size;
  ;
  tmp_1 = mpn_cmp4((mp_srcptr)u->_mp_d,(mp_size_t)tmp_0,(mp_srcptr)v->_mp_d,
                   (mp_size_t)tmp);
  return tmp_1;
}

void mpz_abs(__mpz_struct r[1], __mpz_struct const u[1])
{
  mpz_set(r,u);
  if (r->_mp_size >= 0) r->_mp_size = r->_mp_size;
  else r->_mp_size = - r->_mp_size;
  return;
}

void mpz_neg(__mpz_struct r[1], __mpz_struct const u[1])
{
  mpz_set(r,u);
  r->_mp_size = - r->_mp_size;
  return;
}

void mpz_swap(__mpz_struct u[1], __mpz_struct v[1])
{
  {
    mp_size_t __mp_size_t_swap__tmp = (mp_size_t)u->_mp_size;
    u->_mp_size = v->_mp_size;
    v->_mp_size = (int)__mp_size_t_swap__tmp;
  }
  {
    mp_size_t __mp_size_t_swap__tmp_0 = (mp_size_t)u->_mp_alloc;
    u->_mp_alloc = v->_mp_alloc;
    v->_mp_alloc = (int)__mp_size_t_swap__tmp_0;
  }
  {
    mp_ptr __mp_ptr_swap__tmp = u->_mp_d;
    u->_mp_d = v->_mp_d;
    v->_mp_d = __mp_ptr_swap__tmp;
  }
  return;
}

static mp_size_t mpz_abs_add_ui(__mpz_struct r[1], __mpz_struct const a[1],
                                unsigned long b)
{
  mp_size_t __retres;
  mp_size_t an;
  mp_ptr rp;
  mp_limb_t cy;
  if (a->_mp_size >= 0) an = (mp_size_t)a->_mp_size;
  else an = (mp_size_t)(- a->_mp_size);
  if (an == (mp_size_t)0) {
    *(r->_mp_d + 0) = b;
    __retres = (mp_size_t)(b > (unsigned long)0);
    goto return_label;
  }
  if (an + (mp_size_t)1 > (mp_size_t)r->_mp_alloc) rp = mpz_realloc(r,
                                                                    an + (mp_size_t)1);
  else rp = r->_mp_d;
  cy = mpn_add_1(rp,(mp_srcptr)a->_mp_d,an,b);
  *(rp + an) = cy;
  an = (mp_size_t)((mp_limb_t)an + cy);
  __retres = an;
  return_label: return __retres;
}

static mp_size_t mpz_abs_sub_ui(__mpz_struct r[1], __mpz_struct const a[1],
                                unsigned long b)
{
  mp_size_t __retres;
  int tmp;
  mp_ptr tmp_1;
  if (a->_mp_size >= 0) tmp = a->_mp_size; else tmp = - a->_mp_size;
  mp_size_t an = (mp_size_t)tmp;
  if (an > (mp_size_t)r->_mp_alloc) tmp_1 = mpz_realloc(r,an);
  else tmp_1 = r->_mp_d;
  mp_ptr rp = tmp_1;
  if (an == (mp_size_t)0) {
    *(rp + 0) = b;
    __retres = (mp_size_t)(- (b > (unsigned long)0));
    goto return_label;
  }
  else 
    if (an == (mp_size_t)1) {
      if (*(a->_mp_d + 0) < b) {
        *(rp + 0) = b - *(a->_mp_d + 0);
        __retres = (mp_size_t)(-1);
        goto return_label;
      }
      else goto _LAND;
    }
    else {
      _LAND:
      {
        mp_size_t tmp_3;
        {
          mp_limb_t __cy = mpn_sub_1(rp,(mp_srcptr)a->_mp_d,an,b);
          __FC_assert((__cy == (mp_limb_t)0) != 0,"mini-gmp.c",1862,
                      "__cy == 0");
        }
        tmp_3 = mpn_normalized_size((mp_srcptr)rp,an);
        __retres = tmp_3;
        goto return_label;
      }
    }
  return_label: return __retres;
}

void mpz_add_ui(__mpz_struct r[1], __mpz_struct const a[1], unsigned long b)
{
  if (a->_mp_size >= 0) r->_mp_size = (int)mpz_abs_add_ui(r,a,b);
  else {
    mp_size_t tmp;
    tmp = mpz_abs_sub_ui(r,a,b);
    r->_mp_size = (int)(- tmp);
  }
  return;
}

void mpz_sub_ui(__mpz_struct r[1], __mpz_struct const a[1], unsigned long b)
{
  if (a->_mp_size < 0) {
    mp_size_t tmp;
    tmp = mpz_abs_add_ui(r,a,b);
    r->_mp_size = (int)(- tmp);
  }
  else r->_mp_size = (int)mpz_abs_sub_ui(r,a,b);
  return;
}

void mpz_ui_sub(__mpz_struct r[1], unsigned long a, __mpz_struct const b[1])
{
  if (b->_mp_size < 0) r->_mp_size = (int)mpz_abs_add_ui(r,b,a);
  else {
    mp_size_t tmp;
    tmp = mpz_abs_sub_ui(r,b,a);
    r->_mp_size = (int)(- tmp);
  }
  return;
}

static mp_size_t mpz_abs_add(__mpz_struct r[1], __mpz_struct const a[1],
                             __mpz_struct const b[1])
{
  mp_size_t __retres;
  int tmp;
  int tmp_0;
  mp_ptr rp;
  mp_limb_t cy;
  if (a->_mp_size >= 0) tmp = a->_mp_size; else tmp = - a->_mp_size;
  mp_size_t an = (mp_size_t)tmp;
  if (b->_mp_size >= 0) tmp_0 = b->_mp_size; else tmp_0 = - b->_mp_size;
  mp_size_t bn = (mp_size_t)tmp_0;
  if (an < bn) {
    {
      mpz_srcptr __mpz_srcptr_swap__tmp = a;
      a = b;
      b = __mpz_srcptr_swap__tmp;
    }
    {
      mp_size_t __mp_size_t_swap__tmp = an;
      an = bn;
      bn = __mp_size_t_swap__tmp;
    }
  }
  if (an + (mp_size_t)1 > (mp_size_t)r->_mp_alloc) rp = mpz_realloc(r,
                                                                    an + (mp_size_t)1);
  else rp = r->_mp_d;
  cy = mpn_add(rp,(mp_srcptr)a->_mp_d,an,(mp_srcptr)b->_mp_d,bn);
  *(rp + an) = cy;
  __retres = (mp_size_t)((mp_limb_t)an + cy);
  return __retres;
}

static mp_size_t mpz_abs_sub(__mpz_struct r[1], __mpz_struct const a[1],
                             __mpz_struct const b[1])
{
  mp_size_t __retres;
  int tmp;
  int tmp_0;
  int cmp;
  mp_ptr rp;
  if (a->_mp_size >= 0) tmp = a->_mp_size; else tmp = - a->_mp_size;
  mp_size_t an = (mp_size_t)tmp;
  if (b->_mp_size >= 0) tmp_0 = b->_mp_size; else tmp_0 = - b->_mp_size;
  mp_size_t bn = (mp_size_t)tmp_0;
  cmp = mpn_cmp4((mp_srcptr)a->_mp_d,an,(mp_srcptr)b->_mp_d,bn);
  if (cmp > 0) {
    mp_size_t tmp_3;
    if (an > (mp_size_t)r->_mp_alloc) rp = mpz_realloc(r,an);
    else rp = r->_mp_d;
    {
      mp_limb_t __cy =
        mpn_sub(rp,(mp_srcptr)a->_mp_d,an,(mp_srcptr)b->_mp_d,bn);
      __FC_assert((__cy == (mp_limb_t)0) != 0,"mini-gmp.c",1928,"__cy == 0");
    }
    tmp_3 = mpn_normalized_size((mp_srcptr)rp,an);
    __retres = tmp_3;
    goto return_label;
  }
  else 
    if (cmp < 0) {
      mp_size_t tmp_6;
      if (bn > (mp_size_t)r->_mp_alloc) rp = mpz_realloc(r,bn);
      else rp = r->_mp_d;
      {
        mp_limb_t __cy_0 =
          mpn_sub(rp,(mp_srcptr)b->_mp_d,bn,(mp_srcptr)a->_mp_d,an);
        __FC_assert((__cy_0 == (mp_limb_t)0) != 0,"mini-gmp.c",1934,
                    "__cy == 0");
      }
      tmp_6 = mpn_normalized_size((mp_srcptr)rp,bn);
      __retres = - tmp_6;
      goto return_label;
    }
    else {
      __retres = (mp_size_t)0;
      goto return_label;
    }
  return_label: return __retres;
}

void mpz_add(__mpz_struct r[1], __mpz_struct const a[1],
             __mpz_struct const b[1])
{
  mp_size_t rn;
  if ((a->_mp_size ^ b->_mp_size) >= 0) rn = mpz_abs_add(r,a,b);
  else rn = mpz_abs_sub(r,a,b);
  if (a->_mp_size >= 0) r->_mp_size = (int)rn;
  else r->_mp_size = (int)(- rn);
  return;
}

void mpz_sub(__mpz_struct r[1], __mpz_struct const a[1],
             __mpz_struct const b[1])
{
  mp_size_t rn;
  if ((a->_mp_size ^ b->_mp_size) >= 0) rn = mpz_abs_sub(r,a,b);
  else rn = mpz_abs_add(r,a,b);
  if (a->_mp_size >= 0) r->_mp_size = (int)rn;
  else r->_mp_size = (int)(- rn);
  return;
}

void mpz_mul_si(__mpz_struct r[1], __mpz_struct const u[1], long v)
{
  if (v < (long)0) {
    mpz_mul_ui(r,u,- ((unsigned long)(v + (long)1) - (unsigned long)1));
    mpz_neg(r,(__mpz_struct const *)r);
  }
  else mpz_mul_ui(r,u,(unsigned long)v);
  return;
}

void mpz_mul_ui(__mpz_struct r[1], __mpz_struct const u[1], unsigned long v)
{
  mp_size_t un;
  mp_size_t us;
  mp_ptr tp;
  mp_limb_t cy;
  us = (mp_size_t)u->_mp_size;
  if (us == (mp_size_t)0) goto _LOR;
  else 
    if (v == (unsigned long)0) {
      _LOR: {
              r->_mp_size = 0;
              goto return_label;
            }
    }
  if (us >= (mp_size_t)0) un = us; else un = - us;
  if (un + (mp_size_t)1 > (mp_size_t)r->_mp_alloc) tp = mpz_realloc(r,
                                                                    un + (mp_size_t)1);
  else tp = r->_mp_d;
  cy = mpn_mul_1(tp,(mp_srcptr)u->_mp_d,un,v);
  *(tp + un) = cy;
  un += (mp_size_t)(cy > (mp_limb_t)0);
  if (us < (mp_size_t)0) r->_mp_size = (int)(- un);
  else r->_mp_size = (int)un;
  return_label: return;
}

void mpz_mul(__mpz_struct r[1], __mpz_struct const u[1],
             __mpz_struct const v[1])
{
  int sign;
  mp_size_t un;
  mp_size_t vn;
  mp_size_t rn;
  mpz_t t;
  mp_ptr tp;
  un = (mp_size_t)u->_mp_size;
  vn = (mp_size_t)v->_mp_size;
  if (un == (mp_size_t)0) goto _LOR;
  else 
    if (vn == (mp_size_t)0) {
      _LOR: {
              r->_mp_size = 0;
              goto return_label;
            }
    }
  sign = (un ^ vn) < (long)0;
  if (un >= (mp_size_t)0) un = un; else un = - un;
  if (vn >= (mp_size_t)0) vn = vn; else vn = - vn;
  mpz_init2(t,
            (unsigned long)(un + vn) * (unsigned long)(sizeof(mp_limb_t) * (unsigned int)8));
  tp = t[0]._mp_d;
  if (un >= vn) mpn_mul(tp,(mp_srcptr)u->_mp_d,un,(mp_srcptr)v->_mp_d,vn);
  else mpn_mul(tp,(mp_srcptr)v->_mp_d,vn,(mp_srcptr)u->_mp_d,un);
  rn = un + vn;
  rn -= (mp_size_t)(*(tp + (rn - (mp_size_t)1)) == (mp_limb_t)0);
  if (sign) t[0]._mp_size = (int)(- rn); else t[0]._mp_size = (int)rn;
  mpz_swap(r,t);
  mpz_clear(t);
  return_label: return;
}

void mpz_mul_2exp(__mpz_struct r[1], __mpz_struct const u[1],
                  mp_bitcnt_t bits)
{
  mp_size_t un;
  mp_size_t rn;
  mp_size_t limbs;
  unsigned int shift;
  mp_ptr rp;
  if (u->_mp_size >= 0) un = (mp_size_t)u->_mp_size;
  else un = (mp_size_t)(- u->_mp_size);
  if (un == (mp_size_t)0) {
    r->_mp_size = 0;
    goto return_label;
  }
  limbs = (mp_size_t)(bits / (mp_bitcnt_t)(sizeof(mp_limb_t) * (unsigned int)8));
  shift = (unsigned int)(bits % (unsigned long)(sizeof(mp_limb_t) * (unsigned int)8));
  rn = (un + limbs) + (mp_size_t)(shift > (unsigned int)0);
  if (rn > (mp_size_t)r->_mp_alloc) rp = mpz_realloc(r,rn);
  else rp = r->_mp_d;
  if (shift > (unsigned int)0) {
    mp_limb_t cy = mpn_lshift(rp + limbs,(mp_srcptr)u->_mp_d,un,shift);
    *(rp + (rn - (mp_size_t)1)) = cy;
    rn -= (mp_size_t)(cy == (mp_limb_t)0);
  }
  else mpn_copyd(rp + limbs,(mp_srcptr)u->_mp_d,un);
  mpn_zero(rp,limbs);
  if (u->_mp_size < 0) r->_mp_size = (int)(- rn); else r->_mp_size = (int)rn;
  return_label: return;
}

void mpz_addmul_ui(__mpz_struct r[1], __mpz_struct const u[1],
                   unsigned long v)
{
  mpz_t t;
  mpz_init(t);
  mpz_mul_ui(t,u,v);
  mpz_add(r,(__mpz_struct const *)r,(__mpz_struct const *)(t));
  mpz_clear(t);
  return;
}

void mpz_submul_ui(__mpz_struct r[1], __mpz_struct const u[1],
                   unsigned long v)
{
  mpz_t t;
  mpz_init(t);
  mpz_mul_ui(t,u,v);
  mpz_sub(r,(__mpz_struct const *)r,(__mpz_struct const *)(t));
  mpz_clear(t);
  return;
}

void mpz_addmul(__mpz_struct r[1], __mpz_struct const u[1],
                __mpz_struct const v[1])
{
  mpz_t t;
  mpz_init(t);
  mpz_mul(t,u,v);
  mpz_add(r,(__mpz_struct const *)r,(__mpz_struct const *)(t));
  mpz_clear(t);
  return;
}

void mpz_submul(__mpz_struct r[1], __mpz_struct const u[1],
                __mpz_struct const v[1])
{
  mpz_t t;
  mpz_init(t);
  mpz_mul(t,u,v);
  mpz_sub(r,(__mpz_struct const *)r,(__mpz_struct const *)(t));
  mpz_clear(t);
  return;
}

static int mpz_div_qr(__mpz_struct q[1], __mpz_struct r[1],
                      __mpz_struct const n[1], __mpz_struct const d[1],
                      enum mpz_div_round_mode mode)
{
  int __retres;
  mp_size_t ns;
  mp_size_t ds;
  mp_size_t nn;
  mp_size_t dn;
  mp_size_t qs;
  ns = (mp_size_t)n->_mp_size;
  ds = (mp_size_t)d->_mp_size;
  if (ds == (mp_size_t)0) gmp_die("mpz_div_qr: Divide by zero.");
  if (ns == (mp_size_t)0) {
    if (q) q->_mp_size = 0;
    if (r) r->_mp_size = 0;
    __retres = 0;
    goto return_label;
  }
  if (ns >= (mp_size_t)0) nn = ns; else nn = - ns;
  if (ds >= (mp_size_t)0) dn = ds; else dn = - ds;
  qs = ds ^ ns;
  if (nn < dn) {
    if (mode == (unsigned int)GMP_DIV_CEIL) {
      if (qs >= (mp_size_t)0) {
        if (r) mpz_sub(r,n,d);
        if (q) mpz_set_ui(q,(unsigned long)1);
      }
      else goto _LAND_0;
    }
    else {
      _LAND_0: ;
      if (mode == (unsigned int)GMP_DIV_FLOOR) {
        if (qs < (mp_size_t)0) {
          if (r) mpz_add(r,n,d);
          if (q) mpz_set_si(q,(long)(-1));
        }
        else goto _LAND;
      }
      else {
        _LAND: {
                 if (r) mpz_set(r,n);
                 if (q) q->_mp_size = 0;
               }
      }
    }
    __retres = 1;
    goto return_label;
  }
  else {
    mp_ptr np;
    mp_ptr qp;
    mp_size_t qn;
    mp_size_t rn;
    mpz_t tq;
    mpz_t tr;
    mpz_init_set(tr,n);
    np = tr[0]._mp_d;
    qn = (nn - dn) + (mp_size_t)1;
    if (q) {
      mpz_init2(tq,
                (unsigned long)qn * (unsigned long)(sizeof(mp_limb_t) * (unsigned int)8));
      qp = tq[0]._mp_d;
    }
    else qp = (mp_ptr)0;
    mpn_div_qr(qp,np,nn,(mp_srcptr)d->_mp_d,dn);
    if (qp) {
      qn -= (mp_size_t)(*(qp + (qn - (mp_size_t)1)) == (mp_limb_t)0);
      if (qs < (mp_size_t)0) tq[0]._mp_size = (int)(- qn);
      else tq[0]._mp_size = (int)qn;
    }
    rn = mpn_normalized_size((mp_srcptr)np,dn);
    if (ns < (mp_size_t)0) tr[0]._mp_size = (int)(- rn);
    else tr[0]._mp_size = (int)rn;
    if (mode == (unsigned int)GMP_DIV_FLOOR) {
      if (qs < (mp_size_t)0) {
        if (rn != (mp_size_t)0) {
          if (q) mpz_sub_ui(tq,(__mpz_struct const *)(tq),(unsigned long)1);
          if (r) mpz_add(tr,(__mpz_struct const *)(tr),d);
        }
        else goto _LAND_2;
      }
      else goto _LAND_2;
    }
    else {
      _LAND_2: ;
      if (mode == (unsigned int)GMP_DIV_CEIL) 
        if (qs >= (mp_size_t)0) 
          if (rn != (mp_size_t)0) {
            if (q) mpz_add_ui(tq,(__mpz_struct const *)(tq),(unsigned long)1);
            if (r) mpz_sub(tr,(__mpz_struct const *)(tr),d);
          }
    }
    if (q) {
      mpz_swap(tq,q);
      mpz_clear(tq);
    }
    if (r) mpz_swap(tr,r);
    mpz_clear(tr);
    __retres = rn != (mp_size_t)0;
    goto return_label;
  }
  return_label: return __retres;
}

void mpz_cdiv_qr(__mpz_struct q[1], __mpz_struct r[1],
                 __mpz_struct const n[1], __mpz_struct const d[1])
{
  mpz_div_qr(q,r,n,d,GMP_DIV_CEIL);
  return;
}

void mpz_fdiv_qr(__mpz_struct q[1], __mpz_struct r[1],
                 __mpz_struct const n[1], __mpz_struct const d[1])
{
  mpz_div_qr(q,r,n,d,GMP_DIV_FLOOR);
  return;
}

void mpz_tdiv_qr(__mpz_struct q[1], __mpz_struct r[1],
                 __mpz_struct const n[1], __mpz_struct const d[1])
{
  mpz_div_qr(q,r,n,d,GMP_DIV_TRUNC);
  return;
}

void mpz_cdiv_q(__mpz_struct q[1], __mpz_struct const n[1],
                __mpz_struct const d[1])
{
  mpz_div_qr(q,(__mpz_struct *)0,n,d,GMP_DIV_CEIL);
  return;
}

void mpz_fdiv_q(__mpz_struct q[1], __mpz_struct const n[1],
                __mpz_struct const d[1])
{
  mpz_div_qr(q,(__mpz_struct *)0,n,d,GMP_DIV_FLOOR);
  return;
}

void mpz_tdiv_q(__mpz_struct q[1], __mpz_struct const n[1],
                __mpz_struct const d[1])
{
  mpz_div_qr(q,(__mpz_struct *)0,n,d,GMP_DIV_TRUNC);
  return;
}

void mpz_cdiv_r(__mpz_struct r[1], __mpz_struct const n[1],
                __mpz_struct const d[1])
{
  mpz_div_qr((__mpz_struct *)0,r,n,d,GMP_DIV_CEIL);
  return;
}

void mpz_fdiv_r(__mpz_struct r[1], __mpz_struct const n[1],
                __mpz_struct const d[1])
{
  mpz_div_qr((__mpz_struct *)0,r,n,d,GMP_DIV_FLOOR);
  return;
}

void mpz_tdiv_r(__mpz_struct r[1], __mpz_struct const n[1],
                __mpz_struct const d[1])
{
  mpz_div_qr((__mpz_struct *)0,r,n,d,GMP_DIV_TRUNC);
  return;
}

void mpz_mod(__mpz_struct r[1], __mpz_struct const n[1],
             __mpz_struct const d[1])
{
  int tmp;
  if (d->_mp_size >= 0) tmp = GMP_DIV_FLOOR; else tmp = GMP_DIV_CEIL;
  ;
  ;
  ;
  mpz_div_qr((__mpz_struct *)0,r,n,d,(enum mpz_div_round_mode)tmp);
  return;
}

static void mpz_div_q_2exp(__mpz_struct q[1], __mpz_struct const u[1],
                           mp_bitcnt_t bit_index,
                           enum mpz_div_round_mode mode)
{
  mp_size_t un;
  mp_size_t qn;
  mp_size_t limb_cnt;
  mp_ptr qp;
  int adjust;
  mp_size_t tmp;
  int tmp_2;
  un = (mp_size_t)u->_mp_size;
  if (un == (mp_size_t)0) {
    q->_mp_size = 0;
    goto return_label;
  }
  limb_cnt = (mp_size_t)(bit_index / (mp_bitcnt_t)(sizeof(mp_limb_t) * (unsigned int)8));
  if (un >= (mp_size_t)0) tmp = un; else tmp = - un;
  qn = tmp - limb_cnt;
  bit_index %= (unsigned long)(sizeof(mp_limb_t) * (unsigned int)8);
  if (un > (mp_size_t)0) tmp_2 = GMP_DIV_CEIL; else tmp_2 = GMP_DIV_FLOOR;
  ;
  if (mode == (unsigned int)tmp_2) {
    int tmp_1;
    if (qn <= (mp_size_t)0) tmp_1 = 1;
    else {
      int tmp_0;
      tmp_0 = mpn_zero_p((mp_srcptr)u->_mp_d,limb_cnt);
      if (tmp_0) 
        if (*(u->_mp_d + limb_cnt) & (((mp_limb_t)1 << bit_index) - (mp_limb_t)1)) 
          tmp_1 = 1;
        else tmp_1 = 0;
      else tmp_1 = 1;
    }
    adjust = tmp_1;
  }
  else adjust = 0;
  if (qn <= (mp_size_t)0) qn = (mp_size_t)0;
  else {
    if (qn > (mp_size_t)q->_mp_alloc) qp = mpz_realloc(q,qn);
    else qp = q->_mp_d;
    if (bit_index != (mp_bitcnt_t)0) {
      mpn_rshift(qp,(mp_srcptr)(u->_mp_d + limb_cnt),qn,
                 (unsigned int)bit_index);
      qn -= (mp_size_t)(*(qp + (qn - (mp_size_t)1)) == (mp_limb_t)0);
    }
    else mpn_copyi(qp,(mp_srcptr)(u->_mp_d + limb_cnt),qn);
  }
  q->_mp_size = (int)qn;
  if (adjust) mpz_add_ui(q,(__mpz_struct const *)q,(unsigned long)1);
  if (un < (mp_size_t)0) mpz_neg(q,(__mpz_struct const *)q);
  return_label: return;
}

static void mpz_div_r_2exp(__mpz_struct r[1], __mpz_struct const u[1],
                           mp_bitcnt_t bit_index,
                           enum mpz_div_round_mode mode)
{
  mp_size_t us;
  mp_size_t un;
  mp_size_t rn;
  mp_ptr rp;
  mp_limb_t mask;
  us = (mp_size_t)u->_mp_size;
  if (us == (mp_size_t)0) goto _LOR;
  else 
    if (bit_index == (mp_bitcnt_t)0) {
      _LOR: {
              r->_mp_size = 0;
              goto return_label;
            }
    }
  rn = (mp_size_t)(((bit_index + (mp_bitcnt_t)(sizeof(mp_limb_t) * (unsigned int)8)) - (mp_bitcnt_t)1) / (mp_bitcnt_t)(
                   sizeof(mp_limb_t) * (unsigned int)8));
  __FC_assert((rn > (mp_size_t)0) != 0,"mini-gmp.c",2365,"rn > 0");
  if (rn > (mp_size_t)r->_mp_alloc) rp = mpz_realloc(r,rn);
  else rp = r->_mp_d;
  if (us >= (mp_size_t)0) un = us; else un = - us;
  mask = ~ ((mp_limb_t)0) >> ((unsigned long)rn * (unsigned long)(sizeof(mp_limb_t) * (unsigned int)8) - bit_index);
  if (rn > un) {
    int tmp_0;
    if (us > (mp_size_t)0) tmp_0 = GMP_DIV_CEIL; else tmp_0 = GMP_DIV_FLOOR;
    ;
    if (mode == (unsigned int)tmp_0) {
      mp_size_t i;
      mp_limb_t cy;
      cy = (mp_limb_t)1;
      i = (mp_size_t)0;
      while (i < un) {
        {
          mp_limb_t s = ~ *(u->_mp_d + i) + cy;
          cy = (mp_limb_t)(s < cy);
          *(rp + i) = s;
        }
        i ++;
      }
      __FC_assert((cy == (mp_limb_t)0) != 0,"mini-gmp.c",2388,"cy == 0");
      while (i < rn - (mp_size_t)1) {
        *(rp + i) = ~ ((mp_limb_t)0);
        i ++;
      }
      *(rp + (rn - (mp_size_t)1)) = mask;
      us = - us;
    }
    else {
      if ((void *)r != (void *)u) mpn_copyi(rp,(mp_srcptr)u->_mp_d,un);
      rn = un;
    }
  }
  else {
    int tmp_1;
    if ((void *)r != (void *)u) mpn_copyi(rp,(mp_srcptr)u->_mp_d,
                                          rn - (mp_size_t)1);
    *(rp + (rn - (mp_size_t)1)) = *(u->_mp_d + (rn - (mp_size_t)1)) & mask;
    if (us > (mp_size_t)0) tmp_1 = GMP_DIV_CEIL; else tmp_1 = GMP_DIV_FLOOR;
    ;
    if (mode == (unsigned int)tmp_1) {
      mp_size_t i_0;
      i_0 = (mp_size_t)0;
      while (1) {
        if (i_0 < rn) {
          if (! (*(rp + i_0) == (mp_limb_t)0)) break;
        }
        else break;
        i_0 ++;
      }
      if (i_0 < rn) {
        *(rp + i_0) = ~ *(rp + i_0) + (mp_limb_t)1;
        while (1) {
          i_0 ++;
          ;
          if (! (i_0 < rn)) break;
          *(rp + i_0) = ~ *(rp + i_0);
        }
        *(rp + (rn - (mp_size_t)1)) &= mask;
        us = - us;
      }
    }
  }
  rn = mpn_normalized_size((mp_srcptr)rp,rn);
  if (us < (mp_size_t)0) r->_mp_size = (int)(- rn);
  else r->_mp_size = (int)rn;
  return_label: return;
}

void mpz_cdiv_q_2exp(__mpz_struct r[1], __mpz_struct const u[1],
                     mp_bitcnt_t cnt)
{
  mpz_div_q_2exp(r,u,cnt,GMP_DIV_CEIL);
  return;
}

void mpz_fdiv_q_2exp(__mpz_struct r[1], __mpz_struct const u[1],
                     mp_bitcnt_t cnt)
{
  mpz_div_q_2exp(r,u,cnt,GMP_DIV_FLOOR);
  return;
}

void mpz_tdiv_q_2exp(__mpz_struct r[1], __mpz_struct const u[1],
                     mp_bitcnt_t cnt)
{
  mpz_div_q_2exp(r,u,cnt,GMP_DIV_TRUNC);
  return;
}

void mpz_cdiv_r_2exp(__mpz_struct r[1], __mpz_struct const u[1],
                     mp_bitcnt_t cnt)
{
  mpz_div_r_2exp(r,u,cnt,GMP_DIV_CEIL);
  return;
}

void mpz_fdiv_r_2exp(__mpz_struct r[1], __mpz_struct const u[1],
                     mp_bitcnt_t cnt)
{
  mpz_div_r_2exp(r,u,cnt,GMP_DIV_FLOOR);
  return;
}

void mpz_tdiv_r_2exp(__mpz_struct r[1], __mpz_struct const u[1],
                     mp_bitcnt_t cnt)
{
  mpz_div_r_2exp(r,u,cnt,GMP_DIV_TRUNC);
  return;
}

void mpz_divexact(__mpz_struct q[1], __mpz_struct const n[1],
                  __mpz_struct const d[1])
{
  int tmp;
  tmp = mpz_div_qr(q,(__mpz_struct *)0,n,d,GMP_DIV_TRUNC);
  mp_limb_t __cy = (mp_limb_t)tmp;
  __FC_assert((__cy == (mp_limb_t)0) != 0,"mini-gmp.c",2476,"__cy == 0");
  return;
}

int mpz_divisible_p(__mpz_struct const n[1], __mpz_struct const d[1])
{
  int __retres;
  int tmp;
  tmp = mpz_div_qr((__mpz_struct *)0,(__mpz_struct *)0,n,d,GMP_DIV_TRUNC);
  __retres = tmp == 0;
  return __retres;
}

int mpz_congruent_p(__mpz_struct const a[1], __mpz_struct const b[1],
                    __mpz_struct const m[1])
{
  int __retres;
  mpz_t t;
  int res;
  int tmp_0;
  tmp_0 = mpz_sgn(m);
  if (tmp_0 == 0) {
    int tmp;
    tmp = mpz_cmp(a,b);
    __retres = tmp == 0;
    goto return_label;
  }
  mpz_init(t);
  mpz_sub(t,a,b);
  res = mpz_divisible_p((__mpz_struct const *)(t),m);
  mpz_clear(t);
  __retres = res;
  return_label: return __retres;
}

static unsigned long mpz_div_qr_ui(__mpz_struct q[1], __mpz_struct r[1],
                                   __mpz_struct const n[1], unsigned long d,
                                   enum mpz_div_round_mode mode)
{
  unsigned long __retres;
  mp_size_t ns;
  mp_size_t qn;
  mp_ptr qp;
  mp_limb_t rl;
  mp_size_t rs;
  ns = (mp_size_t)n->_mp_size;
  if (ns == (mp_size_t)0) {
    if (q) q->_mp_size = 0;
    if (r) r->_mp_size = 0;
    __retres = (unsigned long)0;
    goto return_label;
  }
  if (ns >= (mp_size_t)0) qn = ns; else qn = - ns;
  if (q) 
    if (qn > (mp_size_t)q->_mp_alloc) qp = mpz_realloc(q,qn);
    else qp = q->_mp_d;
  else qp = (mp_ptr)0;
  rl = mpn_div_qr_1(qp,(mp_srcptr)n->_mp_d,qn,d);
  __FC_assert((rl < d) != 0,"mini-gmp.c",2529,"rl < d");
  rs = (mp_size_t)(rl > (mp_limb_t)0);
  if (ns < (mp_size_t)0) rs = - rs; else rs = rs;
  if (rl > (mp_limb_t)0) 
    if (mode == (unsigned int)GMP_DIV_FLOOR) {
      if (ns < (mp_size_t)0) goto _LOR; else goto _LAND;
    }
    else {
      _LAND: ;
      if (mode == (unsigned int)GMP_DIV_CEIL) 
        if (ns >= (mp_size_t)0) {
          _LOR:
          {
            if (q) {
              mp_limb_t __cy = mpn_add_1(qp,(mp_srcptr)qp,qn,(mp_limb_t)1);
              __FC_assert((__cy == (mp_limb_t)0) != 0,"mini-gmp.c",2538,
                          "__cy == 0");
            }
            rl = d - rl;
            rs = - rs;
          }
        }
    }
  if (r) {
    *(r->_mp_d + 0) = rl;
    r->_mp_size = (int)rs;
  }
  if (q) {
    int tmp_1;
    qn -= (mp_size_t)(*(qp + (qn - (mp_size_t)1)) == (mp_limb_t)0);
    if (qn == (mp_size_t)0) tmp_1 = 1;
    else 
      if (*(qp + (qn - (mp_size_t)1)) > (mp_limb_t)0) tmp_1 = 1;
      else tmp_1 = 0;
    __FC_assert(tmp_1 != 0,"mini-gmp.c",2551,"qn == 0 || qp[qn-1] > 0");
    if (ns < (mp_size_t)0) q->_mp_size = (int)(- qn);
    else q->_mp_size = (int)qn;
  }
  __retres = rl;
  return_label: return __retres;
}

unsigned long mpz_cdiv_qr_ui(__mpz_struct q[1], __mpz_struct r[1],
                             __mpz_struct const n[1], unsigned long d)
{
  unsigned long tmp;
  tmp = mpz_div_qr_ui(q,r,n,d,GMP_DIV_CEIL);
  return tmp;
}

unsigned long mpz_fdiv_qr_ui(__mpz_struct q[1], __mpz_struct r[1],
                             __mpz_struct const n[1], unsigned long d)
{
  unsigned long tmp;
  tmp = mpz_div_qr_ui(q,r,n,d,GMP_DIV_FLOOR);
  return tmp;
}

unsigned long mpz_tdiv_qr_ui(__mpz_struct q[1], __mpz_struct r[1],
                             __mpz_struct const n[1], unsigned long d)
{
  unsigned long tmp;
  tmp = mpz_div_qr_ui(q,r,n,d,GMP_DIV_TRUNC);
  return tmp;
}

unsigned long mpz_cdiv_q_ui(__mpz_struct q[1], __mpz_struct const n[1],
                            unsigned long d)
{
  unsigned long tmp;
  tmp = mpz_div_qr_ui(q,(__mpz_struct *)0,n,d,GMP_DIV_CEIL);
  return tmp;
}

unsigned long mpz_fdiv_q_ui(__mpz_struct q[1], __mpz_struct const n[1],
                            unsigned long d)
{
  unsigned long tmp;
  tmp = mpz_div_qr_ui(q,(__mpz_struct *)0,n,d,GMP_DIV_FLOOR);
  return tmp;
}

unsigned long mpz_tdiv_q_ui(__mpz_struct q[1], __mpz_struct const n[1],
                            unsigned long d)
{
  unsigned long tmp;
  tmp = mpz_div_qr_ui(q,(__mpz_struct *)0,n,d,GMP_DIV_TRUNC);
  return tmp;
}

unsigned long mpz_cdiv_r_ui(__mpz_struct r[1], __mpz_struct const n[1],
                            unsigned long d)
{
  unsigned long tmp;
  tmp = mpz_div_qr_ui((__mpz_struct *)0,r,n,d,GMP_DIV_CEIL);
  return tmp;
}

unsigned long mpz_fdiv_r_ui(__mpz_struct r[1], __mpz_struct const n[1],
                            unsigned long d)
{
  unsigned long tmp;
  tmp = mpz_div_qr_ui((__mpz_struct *)0,r,n,d,GMP_DIV_FLOOR);
  return tmp;
}

unsigned long mpz_tdiv_r_ui(__mpz_struct r[1], __mpz_struct const n[1],
                            unsigned long d)
{
  unsigned long tmp;
  tmp = mpz_div_qr_ui((__mpz_struct *)0,r,n,d,GMP_DIV_TRUNC);
  return tmp;
}

unsigned long mpz_cdiv_ui(__mpz_struct const n[1], unsigned long d)
{
  unsigned long tmp;
  tmp = mpz_div_qr_ui((__mpz_struct *)0,(__mpz_struct *)0,n,d,GMP_DIV_CEIL);
  return tmp;
}

unsigned long mpz_fdiv_ui(__mpz_struct const n[1], unsigned long d)
{
  unsigned long tmp;
  tmp = mpz_div_qr_ui((__mpz_struct *)0,(__mpz_struct *)0,n,d,GMP_DIV_FLOOR);
  return tmp;
}

unsigned long mpz_tdiv_ui(__mpz_struct const n[1], unsigned long d)
{
  unsigned long tmp;
  tmp = mpz_div_qr_ui((__mpz_struct *)0,(__mpz_struct *)0,n,d,GMP_DIV_TRUNC);
  return tmp;
}

unsigned long mpz_mod_ui(__mpz_struct r[1], __mpz_struct const n[1],
                         unsigned long d)
{
  unsigned long tmp;
  tmp = mpz_div_qr_ui((__mpz_struct *)0,r,n,d,GMP_DIV_FLOOR);
  return tmp;
}

void mpz_divexact_ui(__mpz_struct q[1], __mpz_struct const n[1],
                     unsigned long d)
{
  mp_limb_t __cy = mpz_div_qr_ui(q,(__mpz_struct *)0,n,d,GMP_DIV_TRUNC);
  __FC_assert((__cy == (mp_limb_t)0) != 0,"mini-gmp.c",2638,"__cy == 0");
  return;
}

int mpz_divisible_ui_p(__mpz_struct const n[1], unsigned long d)
{
  int __retres;
  unsigned long tmp;
  tmp = mpz_div_qr_ui((__mpz_struct *)0,(__mpz_struct *)0,n,d,GMP_DIV_TRUNC);
  __retres = tmp == (unsigned long)0;
  return __retres;
}

static mp_limb_t mpn_gcd_11(mp_limb_t u, mp_limb_t v)
{
  mp_limb_t __retres;
  unsigned int shift;
  __FC_assert(((u | v) > (unsigned long)0) != 0,"mini-gmp.c",2654,
              "(u | v) > 0");
  if (u == (mp_limb_t)0) {
    __retres = v;
    goto return_label;
  }
  else 
    if (v == (mp_limb_t)0) {
      __retres = u;
      goto return_label;
    }
  {
    mp_limb_t __ctz_x = u | v;
    unsigned int __ctz_c = (unsigned int)0;
    {
      unsigned int __clz_c;
      mp_limb_t __clz_x = __ctz_x & - __ctz_x;
      __clz_c = (unsigned int)0;
      while ((__clz_x & ((mp_limb_t)0xff << (sizeof(mp_limb_t) * (unsigned int)8 - (unsigned int)8))) == (unsigned long)0) {
        __clz_x <<= 8;
        __clz_c += (unsigned int)8;
      }
      while ((__clz_x & ((mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8 - (unsigned int)1))) == (unsigned long)0) {
        __clz_x <<= 1;
        __clz_c ++;
      }
      __ctz_c = __clz_c;
    }
    shift = (sizeof(mp_limb_t) * (unsigned int)8 - (unsigned int)1) - __ctz_c;
  }
  u >>= shift;
  v >>= shift;
  if ((u & (unsigned long)1) == (unsigned long)0) {
    mp_limb_t __mp_limb_t_swap__tmp = u;
    u = v;
    v = __mp_limb_t_swap__tmp;
  }
  while ((v & (unsigned long)1) == (unsigned long)0) v >>= 1;
  while (u != v) 
    if (u > v) {
      u -= v;
      while (1) {
        u >>= 1;
        if (! ((u & (unsigned long)1) == (unsigned long)0)) break;
      }
    }
    else {
      v -= u;
      while (1) {
        v >>= 1;
        if (! ((v & (unsigned long)1) == (unsigned long)0)) break;
      }
    }
  __retres = u << shift;
  return_label: return __retres;
}

unsigned long mpz_gcd_ui(__mpz_struct g[1], __mpz_struct const u[1],
                         unsigned long v)
{
  mp_size_t un;
  if (v == (unsigned long)0) {
    if (g) mpz_abs(g,u);
  }
  else {
    if (u->_mp_size >= 0) un = (mp_size_t)u->_mp_size;
    else un = (mp_size_t)(- u->_mp_size);
    if (un != (mp_size_t)0) {
      mp_limb_t tmp;
      tmp = mpn_div_qr_1((mp_ptr)0,(mp_srcptr)u->_mp_d,un,v);
      v = mpn_gcd_11(tmp,v);
    }
    if (g) mpz_set_ui(g,v);
  }
  return v;
}

static mp_bitcnt_t mpz_make_odd(__mpz_struct r[1])
{
  mp_bitcnt_t shift;
  __FC_assert((r->_mp_size > 0) != 0,"mini-gmp.c",2720,"r->_mp_size > 0");
  shift = mpn_common_scan(*(r->_mp_d + 0),(mp_size_t)0,(mp_srcptr)r->_mp_d,
                          (mp_size_t)0,(mp_limb_t)0);
  mpz_tdiv_q_2exp(r,(__mpz_struct const *)r,shift);
  return shift;
}

void mpz_gcd(__mpz_struct g[1], __mpz_struct const u[1],
             __mpz_struct const v[1])
{
  mpz_t tu;
  mpz_t tv;
  mp_bitcnt_t uz;
  mp_bitcnt_t vz;
  mp_bitcnt_t gz;
  if (u->_mp_size == 0) {
    mpz_abs(g,v);
    goto return_label;
  }
  if (v->_mp_size == 0) {
    mpz_abs(g,u);
    goto return_label;
  }
  mpz_init(tu);
  mpz_init(tv);
  mpz_abs(tu,u);
  uz = mpz_make_odd(tu);
  mpz_abs(tv,v);
  vz = mpz_make_odd(tv);
  if (uz < vz) gz = uz; else gz = vz;
  if (tu[0]._mp_size < tv[0]._mp_size) mpz_swap(tu,tv);
  mpz_tdiv_r(tu,(__mpz_struct const *)(tu),(__mpz_struct const *)(tv));
  if (tu[0]._mp_size == 0) mpz_swap(g,tv);
  else 
    while (1) {
      int c;
      mpz_make_odd(tu);
      c = mpz_cmp((__mpz_struct const *)(tu),(__mpz_struct const *)(tv));
      if (c == 0) {
        mpz_swap(g,tu);
        break;
      }
      if (c < 0) mpz_swap(tu,tv);
      if (tv[0]._mp_size == 1) {
        mp_limb_t tmp_0;
        mp_limb_t vl = *(tv[0]._mp_d + 0);
        mp_limb_t ul = mpz_tdiv_ui((__mpz_struct const *)(tu),vl);
        tmp_0 = mpn_gcd_11(ul,vl);
        ;
        mpz_set_ui(g,tmp_0);
        break;
      }
      mpz_sub(tu,(__mpz_struct const *)(tu),(__mpz_struct const *)(tv));
    }
  mpz_clear(tu);
  mpz_clear(tv);
  mpz_mul_2exp(g,(__mpz_struct const *)g,gz);
  return_label: return;
}

void mpz_gcdext(__mpz_struct g[1], __mpz_struct s[1], __mpz_struct t[1],
                __mpz_struct const u[1], __mpz_struct const v[1])
{
  mpz_t tu;
  mpz_t tv;
  mpz_t s0;
  mpz_t s1;
  mpz_t t0;
  mpz_t t1;
  mp_bitcnt_t uz;
  mp_bitcnt_t vz;
  mp_bitcnt_t gz;
  mp_bitcnt_t power;
  int tmp_2;
  if (u->_mp_size == 0) {
    long sign = mpz_sgn(v);
    mpz_abs(g,v);
    if (s) mpz_set_ui(s,(unsigned long)0);
    if (t) mpz_set_si(t,sign);
    goto return_label;
  }
  if (v->_mp_size == 0) {
    long sign_0 = mpz_sgn(u);
    mpz_abs(g,u);
    if (s) mpz_set_si(s,sign_0);
    if (t) mpz_set_ui(t,(unsigned long)0);
    goto return_label;
  }
  mpz_init(tu);
  mpz_init(tv);
  mpz_init(s0);
  mpz_init(s1);
  mpz_init(t0);
  mpz_init(t1);
  mpz_abs(tu,u);
  uz = mpz_make_odd(tu);
  mpz_abs(tv,v);
  vz = mpz_make_odd(tv);
  if (uz < vz) gz = uz; else gz = vz;
  uz -= gz;
  vz -= gz;
  if (tu[0]._mp_size < tv[0]._mp_size) {
    mpz_swap(tu,tv);
    {
      mpz_srcptr __mpz_srcptr_swap__tmp = u;
      u = v;
      v = __mpz_srcptr_swap__tmp;
    }
    {
      mpz_ptr __mpz_ptr_swap__tmp = s;
      s = t;
      t = __mpz_ptr_swap__tmp;
    }
    {
      mp_bitcnt_t __mp_bitcnt_t_swap__tmp = uz;
      uz = vz;
      vz = __mp_bitcnt_t_swap__tmp;
    }
  }
  mpz_setbit(t0,uz);
  mpz_tdiv_qr(t1,tu,(__mpz_struct const *)(tu),(__mpz_struct const *)(tv));
  mpz_mul_2exp(t1,(__mpz_struct const *)(t1),uz);
  mpz_setbit(s1,vz);
  power = uz + vz;
  if (tu[0]._mp_size > 0) {
    mp_bitcnt_t shift;
    shift = mpz_make_odd(tu);
    mpz_mul_2exp(t0,(__mpz_struct const *)(t0),shift);
    mpz_mul_2exp(s0,(__mpz_struct const *)(s0),shift);
    power += shift;
    while (1) {
      int c;
      c = mpz_cmp((__mpz_struct const *)(tu),(__mpz_struct const *)(tv));
      if (c == 0) break;
      if (c < 0) {
        mpz_sub(tv,(__mpz_struct const *)(tv),(__mpz_struct const *)(tu));
        mpz_add(t0,(__mpz_struct const *)(t0),(__mpz_struct const *)(t1));
        mpz_add(s0,(__mpz_struct const *)(s0),(__mpz_struct const *)(s1));
        shift = mpz_make_odd(tv);
        mpz_mul_2exp(t1,(__mpz_struct const *)(t1),shift);
        mpz_mul_2exp(s1,(__mpz_struct const *)(s1),shift);
      }
      else {
        mpz_sub(tu,(__mpz_struct const *)(tu),(__mpz_struct const *)(tv));
        mpz_add(t1,(__mpz_struct const *)(t0),(__mpz_struct const *)(t1));
        mpz_add(s1,(__mpz_struct const *)(s0),(__mpz_struct const *)(s1));
        shift = mpz_make_odd(tu);
        mpz_mul_2exp(t0,(__mpz_struct const *)(t0),shift);
        mpz_mul_2exp(s0,(__mpz_struct const *)(s0),shift);
      }
      power += shift;
    }
  }
  mpz_mul_2exp(tv,(__mpz_struct const *)(tv),gz);
  mpz_neg(s0,(__mpz_struct const *)(s0));
  mpz_divexact(s1,v,(__mpz_struct const *)(tv));
  mpz_abs(s1,(__mpz_struct const *)(s1));
  mpz_divexact(t1,u,(__mpz_struct const *)(tv));
  mpz_abs(t1,(__mpz_struct const *)(t1));
  while (1) {
    mp_bitcnt_t tmp_1;
    tmp_1 = power;
    power --;
    ;
    if (! (tmp_1 > (mp_bitcnt_t)0)) break;
    if ((s0[0]._mp_size != 0) & (int)*(s0[0]._mp_d + 0)) goto _LOR;
    else 
      if ((t0[0]._mp_size != 0) & (int)*(t0[0]._mp_d + 0)) {
        _LOR:
        {
          mpz_sub(s0,(__mpz_struct const *)(s0),(__mpz_struct const *)(s1));
          mpz_add(t0,(__mpz_struct const *)(t0),(__mpz_struct const *)(t1));
        }
      }
    mpz_divexact_ui(s0,(__mpz_struct const *)(s0),(unsigned long)2);
    mpz_divexact_ui(t0,(__mpz_struct const *)(t0),(unsigned long)2);
  }
  mpz_add(s1,(__mpz_struct const *)(s0),(__mpz_struct const *)(s1));
  tmp_2 = mpz_cmpabs((__mpz_struct const *)(s0),(__mpz_struct const *)(s1));
  if (tmp_2 > 0) {
    mpz_swap(s0,s1);
    mpz_sub(t0,(__mpz_struct const *)(t0),(__mpz_struct const *)(t1));
  }
  if (u->_mp_size < 0) mpz_neg(s0,(__mpz_struct const *)(s0));
  if (v->_mp_size < 0) mpz_neg(t0,(__mpz_struct const *)(t0));
  mpz_swap(g,tv);
  if (s) mpz_swap(s,s0);
  if (t) mpz_swap(t,t0);
  mpz_clear(tu);
  mpz_clear(tv);
  mpz_clear(s0);
  mpz_clear(s1);
  mpz_clear(t0);
  mpz_clear(t1);
  return_label: return;
}

void mpz_lcm(__mpz_struct r[1], __mpz_struct const u[1],
             __mpz_struct const v[1])
{
  mpz_t g;
  if (u->_mp_size == 0) goto _LOR;
  else 
    if (v->_mp_size == 0) {
      _LOR: {
              r->_mp_size = 0;
              goto return_label;
            }
    }
  mpz_init(g);
  mpz_gcd(g,u,v);
  mpz_divexact(g,u,(__mpz_struct const *)(g));
  mpz_mul(r,(__mpz_struct const *)(g),v);
  mpz_clear(g);
  mpz_abs(r,(__mpz_struct const *)r);
  return_label: return;
}

void mpz_lcm_ui(__mpz_struct r[1], __mpz_struct const u[1], unsigned long v)
{
  unsigned long tmp;
  if (v == (unsigned long)0) goto _LOR;
  else 
    if (u->_mp_size == 0) {
      _LOR: {
              r->_mp_size = 0;
              goto return_label;
            }
    }
  tmp = mpz_gcd_ui((__mpz_struct *)0,u,v);
  v /= tmp;
  mpz_mul_ui(r,u,v);
  mpz_abs(r,(__mpz_struct const *)r);
  return_label: return;
}

int mpz_invert(__mpz_struct r[1], __mpz_struct const u[1],
               __mpz_struct const m[1])
{
  int __retres;
  mpz_t g;
  mpz_t tr;
  int invertible;
  int tmp_0;
  if (u->_mp_size == 0) {
    __retres = 0;
    goto return_label;
  }
  else {
    int tmp;
    tmp = mpz_cmpabs_ui(m,(unsigned long)1);
    if (tmp <= 0) {
      __retres = 0;
      goto return_label;
    }
  }
  mpz_init(g);
  mpz_init(tr);
  mpz_gcdext(g,tr,(__mpz_struct *)0,u,m);
  tmp_0 = mpz_cmp_ui((__mpz_struct const *)(g),(unsigned long)1);
  invertible = tmp_0 == 0;
  if (invertible) {
    if (tr[0]._mp_size < 0) 
      if (m->_mp_size >= 0) mpz_add(tr,(__mpz_struct const *)(tr),m);
      else mpz_sub(tr,(__mpz_struct const *)(tr),m);
    mpz_swap(r,tr);
  }
  mpz_clear(g);
  mpz_clear(tr);
  __retres = invertible;
  return_label: return __retres;
}

void mpz_pow_ui(__mpz_struct r[1], __mpz_struct const b[1], unsigned long e)
{
  unsigned long bit;
  mpz_t tr;
  mpz_init_set_ui(tr,(unsigned long)1);
  bit = (unsigned long)1 << (sizeof(unsigned long) * (unsigned int)8 - (unsigned int)1);
  while (1) {
    mpz_mul(tr,(__mpz_struct const *)(tr),(__mpz_struct const *)(tr));
    if (e & bit) mpz_mul(tr,(__mpz_struct const *)(tr),b);
    bit >>= 1;
    if (! (bit > (unsigned long)0)) break;
  }
  mpz_swap(r,tr);
  mpz_clear(tr);
  return;
}

void mpz_ui_pow_ui(__mpz_struct r[1], unsigned long blimb, unsigned long e)
{
  mpz_t b;
  mpz_srcptr tmp;
  ;
  tmp = mpz_roinit_n(b,(mp_srcptr)(& blimb),(mp_size_t)1);
  ;
  mpz_pow_ui(r,tmp,e);
  return;
}

void mpz_powm(__mpz_struct r[1], __mpz_struct const b[1],
              __mpz_struct const e[1], __mpz_struct const m[1])
{
  mpz_t tr;
  mpz_t base;
  mp_size_t en;
  mp_size_t mn;
  mp_srcptr mp;
  struct gmp_div_inverse minv;
  unsigned int shift;
  mp_ptr tp = (mp_ptr)0;
  if (e->_mp_size >= 0) en = (mp_size_t)e->_mp_size;
  else en = (mp_size_t)(- e->_mp_size);
  if (m->_mp_size >= 0) mn = (mp_size_t)m->_mp_size;
  else mn = (mp_size_t)(- m->_mp_size);
  if (mn == (mp_size_t)0) gmp_die("mpz_powm: Zero modulo.");
  if (en == (mp_size_t)0) {
    mpz_set_ui(r,(unsigned long)1);
    goto return_label;
  }
  mp = (mp_srcptr)m->_mp_d;
  mpn_div_qr_invert(& minv,mp,mn);
  shift = minv.shift;
  if (shift > (unsigned int)0) {
    minv.shift = (unsigned int)0;
    tp = gmp_xalloc_limbs(mn);
    {
      mp_limb_t __cy = mpn_lshift(tp,mp,mn,shift);
      __FC_assert((__cy == (mp_limb_t)0) != 0,"mini-gmp.c",3105,"__cy == 0");
    }
    mp = (mp_srcptr)tp;
  }
  mpz_init(base);
  if (e->_mp_size < 0) {
    int tmp_0;
    tmp_0 = mpz_invert(base,b,m);
    if (! tmp_0) gmp_die("mpz_powm: Negative exponent and non-invertible base.");
  }
  else {
    mp_size_t bn;
    mpz_abs(base,b);
    bn = (mp_size_t)base[0]._mp_size;
    if (bn >= mn) {
      mpn_div_qr_preinv((mp_ptr)0,base[0]._mp_d,(mp_size_t)base[0]._mp_size,
                        mp,mn,(struct gmp_div_inverse const *)(& minv));
      bn = mn;
    }
    if (b->_mp_size < 0) {
      mp_ptr tmp_2;
      if (mn > (mp_size_t)base[0]._mp_alloc) tmp_2 = mpz_realloc(base,mn);
      else tmp_2 = base[0]._mp_d;
      mp_ptr bp = tmp_2;
      {
        mp_limb_t __cy_0 = mpn_sub(bp,mp,mn,(mp_srcptr)bp,bn);
        __FC_assert((__cy_0 == (mp_limb_t)0) != 0,"mini-gmp.c",3134,
                    "__cy == 0");
      }
      bn = mn;
    }
    base[0]._mp_size = (int)mpn_normalized_size((mp_srcptr)base[0]._mp_d,bn);
  }
  mpz_init_set_ui(tr,(unsigned long)1);
  while (1) {
    en --;
    if (! (en >= (mp_size_t)0)) break;
    {
      mp_limb_t bit;
      mp_limb_t w = *(e->_mp_d + en);
      bit = (mp_limb_t)1 << (sizeof(mp_limb_t) * (unsigned int)8 - (unsigned int)1);
      while (1) {
        mpz_mul(tr,(__mpz_struct const *)(tr),(__mpz_struct const *)(tr));
        if (w & bit) mpz_mul(tr,(__mpz_struct const *)(tr),
                             (__mpz_struct const *)(base));
        if ((mp_size_t)tr[0]._mp_size > mn) {
          mpn_div_qr_preinv((mp_ptr)0,tr[0]._mp_d,(mp_size_t)tr[0]._mp_size,
                            mp,mn,(struct gmp_div_inverse const *)(& minv));
          tr[0]._mp_size = (int)mpn_normalized_size((mp_srcptr)tr[0]._mp_d,
                                                    mn);
        }
        bit >>= 1;
        if (! (bit > (mp_limb_t)0)) break;
      }
    }
  }
  if ((mp_size_t)tr[0]._mp_size >= mn) {
    minv.shift = shift;
    mpn_div_qr_preinv((mp_ptr)0,tr[0]._mp_d,(mp_size_t)tr[0]._mp_size,mp,mn,
                      (struct gmp_div_inverse const *)(& minv));
    tr[0]._mp_size = (int)mpn_normalized_size((mp_srcptr)tr[0]._mp_d,mn);
  }
  if (tp) (*gmp_free_func)((void *)tp,(size_t)0);
  mpz_swap(r,tr);
  mpz_clear(tr);
  mpz_clear(base);
  return_label: return;
}

void mpz_powm_ui(__mpz_struct r[1], __mpz_struct const b[1],
                 unsigned long elimb, __mpz_struct const m[1])
{
  mpz_t e;
  mpz_srcptr tmp;
  ;
  tmp = mpz_roinit_n(e,(mp_srcptr)(& elimb),(mp_size_t)1);
  ;
  ;
  mpz_powm(r,b,tmp,m);
  return;
}

void mpz_rootrem(__mpz_struct x[1], __mpz_struct r[1],
                 __mpz_struct const y[1], unsigned long z)
{
  int sgn;
  mpz_t t;
  mpz_t u;
  int tmp;
  sgn = y->_mp_size < 0;
  if ((~ z & (unsigned long)sgn) != (unsigned long)0) gmp_die("mpz_rootrem: Negative argument, with even root.");
  if (z == (unsigned long)0) gmp_die("mpz_rootrem: Zeroth root.");
  tmp = mpz_cmpabs_ui(y,(unsigned long)1);
  if (tmp <= 0) {
    if (x) mpz_set(x,y);
    if (r) r->_mp_size = 0;
    goto return_label;
  }
  mpz_init(u);
  {
    mp_bitcnt_t tb;
    size_t tmp_0;
    tmp_0 = mpz_sizeinbase(y,2);
    tb = (unsigned long)tmp_0 / z + (unsigned long)1;
    mpz_init2(t,tb + (mp_bitcnt_t)1);
    mpz_setbit(t,tb);
  }
  if (z == (unsigned long)2) 
    while (1) {
      int tmp_1;
      mpz_swap(u,t);
      mpz_tdiv_q(t,y,(__mpz_struct const *)(u));
      mpz_add(t,(__mpz_struct const *)(t),(__mpz_struct const *)(u));
      mpz_tdiv_q_2exp(t,(__mpz_struct const *)(t),(mp_bitcnt_t)1);
      tmp_1 = mpz_cmpabs((__mpz_struct const *)(t),(__mpz_struct const *)(u));
      if (! (tmp_1 < 0)) break;
    }
  else {
    mpz_t v;
    mpz_init(v);
    if (sgn) mpz_neg(t,(__mpz_struct const *)(t));
    while (1) {
      int tmp_2;
      mpz_swap(u,t);
      mpz_pow_ui(t,(__mpz_struct const *)(u),z - (unsigned long)1);
      mpz_tdiv_q(t,y,(__mpz_struct const *)(t));
      mpz_mul_ui(v,(__mpz_struct const *)(u),z - (unsigned long)1);
      mpz_add(t,(__mpz_struct const *)(t),(__mpz_struct const *)(v));
      mpz_tdiv_q_ui(t,(__mpz_struct const *)(t),z);
      tmp_2 = mpz_cmpabs((__mpz_struct const *)(t),(__mpz_struct const *)(u));
      if (! (tmp_2 < 0)) break;
    }
    mpz_clear(v);
  }
  if (r) {
    mpz_pow_ui(t,(__mpz_struct const *)(u),z);
    mpz_sub(r,y,(__mpz_struct const *)(t));
  }
  if (x) mpz_swap(x,u);
  mpz_clear(u);
  mpz_clear(t);
  return_label: return;
}

int mpz_root(__mpz_struct x[1], __mpz_struct const y[1], unsigned long z)
{
  int res;
  mpz_t r;
  mpz_init(r);
  mpz_rootrem(x,r,y,z);
  res = r[0]._mp_size == 0;
  mpz_clear(r);
  return res;
}

void mpz_sqrtrem(__mpz_struct s[1], __mpz_struct r[1],
                 __mpz_struct const u[1])
{
  mpz_rootrem(s,r,u,(unsigned long)2);
  return;
}

void mpz_sqrt(__mpz_struct s[1], __mpz_struct const u[1])
{
  mpz_rootrem(s,(__mpz_struct *)0,u,(unsigned long)2);
  return;
}

int mpz_perfect_square_p(__mpz_struct const u[1])
{
  int __retres;
  if (u->_mp_size <= 0) {
    __retres = u->_mp_size == 0;
    goto return_label;
  }
  else {
    int tmp;
    tmp = mpz_root((__mpz_struct *)0,u,(unsigned long)2);
    __retres = tmp;
    goto return_label;
  }
  return_label: return __retres;
}

int mpn_perfect_square_p(mp_srcptr p, mp_size_t n)
{
  mpz_t t;
  int tmp_0;
  mpz_srcptr tmp;
  __FC_assert((n > (mp_size_t)0) != 0,"mini-gmp.c",3290,"n > 0");
  __FC_assert((*(p + (n - (mp_size_t)1)) != (mp_limb_t)0) != 0,"mini-gmp.c",
              3291,"p [n-1] != 0");
  tmp = mpz_roinit_n(t,p,n);
  tmp_0 = mpz_root((__mpz_struct *)0,tmp,(unsigned long)2);
  return tmp_0;
}

mp_size_t mpn_sqrtrem(mp_ptr sp, mp_ptr rp, mp_srcptr p, mp_size_t n)
{
  mpz_t s;
  mpz_t r;
  mpz_t u;
  mp_size_t res;
  mpz_srcptr tmp;
  __FC_assert((n > (mp_size_t)0) != 0,"mini-gmp.c",3301,"n > 0");
  __FC_assert((*(p + (n - (mp_size_t)1)) != (mp_limb_t)0) != 0,"mini-gmp.c",
              3302,"p [n-1] != 0");
  mpz_init(r);
  mpz_init(s);
  tmp = mpz_roinit_n(u,p,n);
  mpz_rootrem(s,r,tmp,(unsigned long)2);
  __FC_assert(((mp_size_t)s[0]._mp_size == (n + (mp_size_t)1) / (mp_size_t)2) != 0,
              "mini-gmp.c",3308,"s->_mp_size == (n+1)/2");
  mpn_copyd(sp,(mp_srcptr)s[0]._mp_d,(mp_size_t)s[0]._mp_size);
  mpz_clear(s);
  res = (mp_size_t)r[0]._mp_size;
  if (rp) mpn_copyd(rp,(mp_srcptr)r[0]._mp_d,res);
  mpz_clear(r);
  return res;
}

void mpz_fac_ui(__mpz_struct x[1], unsigned long n)
{
  mpz_set_ui(x,n + (unsigned long)(n == (unsigned long)0));
  while (n > (unsigned long)2) {
    n --;
    ;
    ;
    mpz_mul_ui(x,(__mpz_struct const *)x,n);
  }
  return;
}

void mpz_bin_uiui(__mpz_struct r[1], unsigned long n, unsigned long k)
{
  mpz_t t;
  mpz_set_ui(r,(unsigned long)(k <= n));
  if (k > n >> 1) 
    if (k <= n) k = n - k; else k = (unsigned long)0;
  mpz_init(t);
  mpz_fac_ui(t,k);
  while (k > (unsigned long)0) {
    unsigned long tmp;
    tmp = n;
    n --;
    ;
    ;
    ;
    mpz_mul_ui(r,(__mpz_struct const *)r,tmp);
    k --;
  }
  mpz_divexact(r,(__mpz_struct const *)r,(__mpz_struct const *)(t));
  mpz_clear(t);
  return;
}

static int gmp_millerrabin(__mpz_struct const n[1],
                           __mpz_struct const nm1[1], __mpz_struct y[1],
                           __mpz_struct const q[1], mp_bitcnt_t k)
{
  int __retres;
  int tmp;
  __FC_assert((k > (mp_bitcnt_t)0) != 0,"mini-gmp.c",3354,"k > 0");
  mpz_powm(y,(__mpz_struct const *)y,q,n);
  tmp = mpz_cmp_ui((__mpz_struct const *)y,(unsigned long)1);
  if (tmp == 0) {
    __retres = 1;
    goto return_label;
  }
  else {
    int tmp_0;
    tmp_0 = mpz_cmp((__mpz_struct const *)y,nm1);
    if (tmp_0 == 0) {
      __retres = 1;
      goto return_label;
    }
  }
  while (1) {
    k --;
    if (! (k > (mp_bitcnt_t)0)) break;
    {
      int tmp_1;
      int tmp_2;
      mpz_powm_ui(y,(__mpz_struct const *)y,(unsigned long)2,n);
      tmp_1 = mpz_cmp((__mpz_struct const *)y,nm1);
      if (tmp_1 == 0) {
        __retres = 1;
        goto return_label;
      }
      tmp_2 = mpz_cmp_ui((__mpz_struct const *)y,(unsigned long)1);
      if (tmp_2 <= 0) {
        __retres = 0;
        goto return_label;
      }
    }
  }
  __retres = 0;
  return_label: return __retres;
}

int mpz_probab_prime_p(__mpz_struct const n[1], int reps)
{
  int __retres;
  mpz_t nm1;
  mpz_t q;
  mpz_t y;
  mp_bitcnt_t k;
  int is_prime;
  int j;
  int tmp_1;
  unsigned long tmp_2;
  int tmp_3;
  if (! ((n->_mp_size != 0) & (int)*(n->_mp_d + 0))) {
    int tmp_0;
    int tmp;
    tmp = mpz_cmpabs_ui(n,(unsigned long)2);
    if (tmp == 0) tmp_0 = 2; else tmp_0 = 0;
    __retres = tmp_0;
    goto return_label;
  }
  __FC_assert((n->_mp_size != 0) != 0,"mini-gmp.c",3399,"n->_mp_size != 0");
  tmp_1 = mpz_cmpabs_ui(n,(unsigned long)64);
  if (tmp_1 < 0) {
    __retres = (int)((0xc96996dcUL >> (*(n->_mp_d + 0) >> 1)) & (unsigned long)2);
    goto return_label;
  }
  tmp_2 = mpz_gcd_ui((__mpz_struct *)0,n,
                     (((((((3UL * 5UL) * 7UL) * 11UL) * 13UL) * 17UL) * 19UL) * 23UL) * 29UL);
  if (tmp_2 != (unsigned long)1) {
    __retres = 0;
    goto return_label;
  }
  tmp_3 = mpz_cmpabs_ui(n,(unsigned long)(31 * 31));
  if (tmp_3 < 0) {
    __retres = 2;
    goto return_label;
  }
  mpz_init(nm1);
  mpz_init(q);
  mpz_init(y);
  nm1[0]._mp_size = (int)mpz_abs_sub_ui(nm1,n,(unsigned long)1);
  k = mpz_scan1((__mpz_struct const *)(nm1),(mp_bitcnt_t)0);
  mpz_tdiv_q_2exp(q,(__mpz_struct const *)(nm1),k);
  j = 0;
  is_prime = 1;
  while (1) {
    if (is_prime) {
      if (! (j < reps)) break;
    }
    else break;
    {
      int tmp_4;
      mpz_set_ui(y,
                 ((unsigned long)j * (unsigned long)j + (unsigned long)j) + (unsigned long)41);
      tmp_4 = mpz_cmp((__mpz_struct const *)(y),(__mpz_struct const *)(nm1));
      if (tmp_4 >= 0) {
        __FC_assert((j >= 30) != 0,"mini-gmp.c",3432,"j >= 30");
        break;
      }
      is_prime = gmp_millerrabin(n,(__mpz_struct const *)(nm1),y,
                                 (__mpz_struct const *)(q),k);
    }
    j ++;
  }
  mpz_clear(nm1);
  mpz_clear(q);
  mpz_clear(y);
  __retres = is_prime;
  return_label: return __retres;
}

int mpz_tstbit(__mpz_struct const d[1], mp_bitcnt_t bit_index)
{
  int __retres;
  mp_size_t limb_index;
  unsigned int shift;
  mp_size_t ds;
  mp_size_t dn;
  mp_limb_t w;
  int bit;
  ds = (mp_size_t)d->_mp_size;
  if (ds >= (mp_size_t)0) dn = ds; else dn = - ds;
  limb_index = (mp_size_t)(bit_index / (mp_bitcnt_t)(sizeof(mp_limb_t) * (unsigned int)8));
  if (limb_index >= dn) {
    __retres = ds < (mp_size_t)0;
    goto return_label;
  }
  shift = (unsigned int)(bit_index % (unsigned long)(sizeof(mp_limb_t) * (unsigned int)8));
  w = *(d->_mp_d + limb_index);
  bit = (int)((w >> shift) & (unsigned long)1);
  if (ds < (mp_size_t)0) {
    if (shift > (unsigned int)0) 
      if (w << (sizeof(mp_limb_t) * (unsigned int)8 - shift) > (mp_limb_t)0) {
        __retres = bit ^ 1;
        goto return_label;
      }
    while (1) {
      limb_index --;
      if (! (limb_index >= (mp_size_t)0)) break;
      if (*(d->_mp_d + limb_index) > (mp_limb_t)0) {
        __retres = bit ^ 1;
        goto return_label;
      }
    }
  }
  __retres = bit;
  return_label: return __retres;
}

static void mpz_abs_add_bit(__mpz_struct d[1], mp_bitcnt_t bit_index)
{
  mp_size_t dn;
  mp_size_t limb_index;
  mp_limb_t bit;
  mp_ptr dp;
  if (d->_mp_size >= 0) dn = (mp_size_t)d->_mp_size;
  else dn = (mp_size_t)(- d->_mp_size);
  limb_index = (mp_size_t)(bit_index / (mp_bitcnt_t)(sizeof(mp_limb_t) * (unsigned int)8));
  bit = (mp_limb_t)1 << bit_index % (unsigned long)(sizeof(mp_limb_t) * (unsigned int)8);
  if (limb_index >= dn) {
    mp_size_t i;
    if (limb_index + (mp_size_t)1 > (mp_size_t)d->_mp_alloc) dp = mpz_realloc
                                                             (d,
                                                              limb_index + (mp_size_t)1);
    else dp = d->_mp_d;
    *(dp + limb_index) = bit;
    i = dn;
    while (i < limb_index) {
      *(dp + i) = (mp_limb_t)0;
      i ++;
    }
    dn = limb_index + (mp_size_t)1;
  }
  else {
    mp_limb_t cy;
    dp = d->_mp_d;
    cy = mpn_add_1(dp + limb_index,(mp_srcptr)(dp + limb_index),
                   dn - limb_index,bit);
    if (cy > (mp_limb_t)0) {
      mp_size_t tmp_1;
      if (dn + (mp_size_t)1 > (mp_size_t)d->_mp_alloc) dp = mpz_realloc
                                                       (d,dn + (mp_size_t)1);
      else dp = d->_mp_d;
      tmp_1 = dn;
      dn ++;
      *(dp + tmp_1) = cy;
    }
  }
  if (d->_mp_size < 0) d->_mp_size = (int)(- dn); else d->_mp_size = (int)dn;
  return;
}

static void mpz_abs_sub_bit(__mpz_struct d[1], mp_bitcnt_t bit_index)
{
  mp_size_t dn;
  mp_size_t limb_index;
  mp_ptr dp;
  mp_limb_t bit;
  if (d->_mp_size >= 0) dn = (mp_size_t)d->_mp_size;
  else dn = (mp_size_t)(- d->_mp_size);
  dp = d->_mp_d;
  limb_index = (mp_size_t)(bit_index / (mp_bitcnt_t)(sizeof(mp_limb_t) * (unsigned int)8));
  bit = (mp_limb_t)1 << bit_index % (unsigned long)(sizeof(mp_limb_t) * (unsigned int)8);
  __FC_assert((limb_index < dn) != 0,"mini-gmp.c",3556,"limb_index < dn");
  {
    mp_limb_t __cy =
      mpn_sub_1(dp + limb_index,(mp_srcptr)(dp + limb_index),dn - limb_index,
                bit);
    __FC_assert((__cy == (mp_limb_t)0) != 0,"mini-gmp.c",3558,"__cy == 0");
  }
  dn = mpn_normalized_size((mp_srcptr)dp,dn);
  if (d->_mp_size < 0) d->_mp_size = (int)(- dn); else d->_mp_size = (int)dn;
  return;
}

void mpz_setbit(__mpz_struct d[1], mp_bitcnt_t bit_index)
{
  int tmp;
  tmp = mpz_tstbit((__mpz_struct const *)d,bit_index);
  if (! tmp) 
    if (d->_mp_size >= 0) mpz_abs_add_bit(d,bit_index);
    else mpz_abs_sub_bit(d,bit_index);
  return;
}

void mpz_clrbit(__mpz_struct d[1], mp_bitcnt_t bit_index)
{
  int tmp;
  tmp = mpz_tstbit((__mpz_struct const *)d,bit_index);
  if (tmp) 
    if (d->_mp_size >= 0) mpz_abs_sub_bit(d,bit_index);
    else mpz_abs_add_bit(d,bit_index);
  return;
}

void mpz_combit(__mpz_struct d[1], mp_bitcnt_t bit_index)
{
  int tmp;
  tmp = mpz_tstbit((__mpz_struct const *)d,bit_index);
  ;
  if (tmp ^ (d->_mp_size < 0)) mpz_abs_sub_bit(d,bit_index);
  else mpz_abs_add_bit(d,bit_index);
  return;
}

void mpz_com(__mpz_struct r[1], __mpz_struct const u[1])
{
  mpz_neg(r,u);
  mpz_sub_ui(r,(__mpz_struct const *)r,(unsigned long)1);
  return;
}

void mpz_and(__mpz_struct r[1], __mpz_struct const u[1],
             __mpz_struct const v[1])
{
  mp_size_t un;
  mp_size_t vn;
  mp_size_t rn;
  mp_size_t i;
  mp_ptr up;
  mp_ptr vp;
  mp_ptr rp;
  mp_limb_t ux;
  mp_limb_t vx;
  mp_limb_t rx;
  mp_limb_t uc;
  mp_limb_t vc;
  mp_limb_t rc;
  mp_limb_t ul;
  mp_limb_t vl;
  mp_limb_t rl;
  if (u->_mp_size >= 0) un = (mp_size_t)u->_mp_size;
  else un = (mp_size_t)(- u->_mp_size);
  if (v->_mp_size >= 0) vn = (mp_size_t)v->_mp_size;
  else vn = (mp_size_t)(- v->_mp_size);
  if (un < vn) {
    {
      mpz_srcptr __mpz_srcptr_swap__tmp = u;
      u = v;
      v = __mpz_srcptr_swap__tmp;
    }
    {
      mp_size_t __mp_size_t_swap__tmp = un;
      un = vn;
      vn = __mp_size_t_swap__tmp;
    }
  }
  if (vn == (mp_size_t)0) {
    r->_mp_size = 0;
    goto return_label;
  }
  uc = (mp_limb_t)(u->_mp_size < 0);
  vc = (mp_limb_t)(v->_mp_size < 0);
  rc = uc & vc;
  ux = - uc;
  vx = - vc;
  rx = - rc;
  if (vx) rn = un; else rn = vn;
  if ((mp_limb_t)rn + rc > (mp_limb_t)r->_mp_alloc) rp = mpz_realloc(r,
                                                                    (mp_size_t)(
                                                                    (mp_limb_t)rn + rc));
  else rp = r->_mp_d;
  up = u->_mp_d;
  vp = v->_mp_d;
  i = (mp_size_t)0;
  while (1) {
    ul = (*(up + i) ^ ux) + uc;
    uc = (mp_limb_t)(ul < uc);
    vl = (*(vp + i) ^ vx) + vc;
    vc = (mp_limb_t)(vl < vc);
    rl = ((ul & vl) ^ rx) + rc;
    rc = (mp_limb_t)(rl < rc);
    *(rp + i) = rl;
    i ++;
    ;
    if (! (i < vn)) break;
  }
  __FC_assert((vc == (mp_limb_t)0) != 0,"mini-gmp.c",3657,"vc == 0");
  while (i < rn) {
    ul = (*(up + i) ^ ux) + uc;
    uc = (mp_limb_t)(ul < uc);
    rl = ((ul & vx) ^ rx) + rc;
    rc = (mp_limb_t)(rl < rc);
    *(rp + i) = rl;
    i ++;
  }
  if (rc) {
    mp_size_t tmp_0;
    tmp_0 = rn;
    rn ++;
    *(rp + tmp_0) = rc;
  }
  else rn = mpn_normalized_size((mp_srcptr)rp,rn);
  if (rx) r->_mp_size = (int)(- rn); else r->_mp_size = (int)rn;
  return_label: return;
}

void mpz_ior(__mpz_struct r[1], __mpz_struct const u[1],
             __mpz_struct const v[1])
{
  mp_size_t un;
  mp_size_t vn;
  mp_size_t rn;
  mp_size_t i;
  mp_ptr up;
  mp_ptr vp;
  mp_ptr rp;
  mp_limb_t ux;
  mp_limb_t vx;
  mp_limb_t rx;
  mp_limb_t uc;
  mp_limb_t vc;
  mp_limb_t rc;
  mp_limb_t ul;
  mp_limb_t vl;
  mp_limb_t rl;
  if (u->_mp_size >= 0) un = (mp_size_t)u->_mp_size;
  else un = (mp_size_t)(- u->_mp_size);
  if (v->_mp_size >= 0) vn = (mp_size_t)v->_mp_size;
  else vn = (mp_size_t)(- v->_mp_size);
  if (un < vn) {
    {
      mpz_srcptr __mpz_srcptr_swap__tmp = u;
      u = v;
      v = __mpz_srcptr_swap__tmp;
    }
    {
      mp_size_t __mp_size_t_swap__tmp = un;
      un = vn;
      vn = __mp_size_t_swap__tmp;
    }
  }
  if (vn == (mp_size_t)0) {
    mpz_set(r,u);
    goto return_label;
  }
  uc = (mp_limb_t)(u->_mp_size < 0);
  vc = (mp_limb_t)(v->_mp_size < 0);
  rc = uc | vc;
  ux = - uc;
  vx = - vc;
  rx = - rc;
  if (vx) rn = vn; else rn = un;
  if ((mp_limb_t)rn + rc > (mp_limb_t)r->_mp_alloc) rp = mpz_realloc(r,
                                                                    (mp_size_t)(
                                                                    (mp_limb_t)rn + rc));
  else rp = r->_mp_d;
  up = u->_mp_d;
  vp = v->_mp_d;
  i = (mp_size_t)0;
  while (1) {
    ul = (*(up + i) ^ ux) + uc;
    uc = (mp_limb_t)(ul < uc);
    vl = (*(vp + i) ^ vx) + vc;
    vc = (mp_limb_t)(vl < vc);
    rl = ((ul | vl) ^ rx) + rc;
    rc = (mp_limb_t)(rl < rc);
    *(rp + i) = rl;
    i ++;
    ;
    if (! (i < vn)) break;
  }
  __FC_assert((vc == (mp_limb_t)0) != 0,"mini-gmp.c",3730,"vc == 0");
  while (i < rn) {
    ul = (*(up + i) ^ ux) + uc;
    uc = (mp_limb_t)(ul < uc);
    rl = ((ul | vx) ^ rx) + rc;
    rc = (mp_limb_t)(rl < rc);
    *(rp + i) = rl;
    i ++;
  }
  if (rc) {
    mp_size_t tmp_0;
    tmp_0 = rn;
    rn ++;
    *(rp + tmp_0) = rc;
  }
  else rn = mpn_normalized_size((mp_srcptr)rp,rn);
  if (rx) r->_mp_size = (int)(- rn); else r->_mp_size = (int)rn;
  return_label: return;
}

void mpz_xor(__mpz_struct r[1], __mpz_struct const u[1],
             __mpz_struct const v[1])
{
  mp_size_t un;
  mp_size_t vn;
  mp_size_t i;
  mp_ptr up;
  mp_ptr vp;
  mp_ptr rp;
  mp_limb_t ux;
  mp_limb_t vx;
  mp_limb_t rx;
  mp_limb_t uc;
  mp_limb_t vc;
  mp_limb_t rc;
  mp_limb_t ul;
  mp_limb_t vl;
  mp_limb_t rl;
  if (u->_mp_size >= 0) un = (mp_size_t)u->_mp_size;
  else un = (mp_size_t)(- u->_mp_size);
  if (v->_mp_size >= 0) vn = (mp_size_t)v->_mp_size;
  else vn = (mp_size_t)(- v->_mp_size);
  if (un < vn) {
    {
      mpz_srcptr __mpz_srcptr_swap__tmp = u;
      u = v;
      v = __mpz_srcptr_swap__tmp;
    }
    {
      mp_size_t __mp_size_t_swap__tmp = un;
      un = vn;
      vn = __mp_size_t_swap__tmp;
    }
  }
  if (vn == (mp_size_t)0) {
    mpz_set(r,u);
    goto return_label;
  }
  uc = (mp_limb_t)(u->_mp_size < 0);
  vc = (mp_limb_t)(v->_mp_size < 0);
  rc = uc ^ vc;
  ux = - uc;
  vx = - vc;
  rx = - rc;
  if ((mp_limb_t)un + rc > (mp_limb_t)r->_mp_alloc) rp = mpz_realloc(r,
                                                                    (mp_size_t)(
                                                                    (mp_limb_t)un + rc));
  else rp = r->_mp_d;
  up = u->_mp_d;
  vp = v->_mp_d;
  i = (mp_size_t)0;
  while (1) {
    ul = (*(up + i) ^ ux) + uc;
    uc = (mp_limb_t)(ul < uc);
    vl = (*(vp + i) ^ vx) + vc;
    vc = (mp_limb_t)(vl < vc);
    rl = ((ul ^ vl) ^ rx) + rc;
    rc = (mp_limb_t)(rl < rc);
    *(rp + i) = rl;
    i ++;
    ;
    if (! (i < vn)) break;
  }
  __FC_assert((vc == (mp_limb_t)0) != 0,"mini-gmp.c",3799,"vc == 0");
  while (i < un) {
    ul = (*(up + i) ^ ux) + uc;
    uc = (mp_limb_t)(ul < uc);
    rl = (ul ^ ux) + rc;
    rc = (mp_limb_t)(rl < rc);
    *(rp + i) = rl;
    i ++;
  }
  if (rc) {
    mp_size_t tmp_0;
    tmp_0 = un;
    un ++;
    *(rp + tmp_0) = rc;
  }
  else un = mpn_normalized_size((mp_srcptr)rp,un);
  if (rx) r->_mp_size = (int)(- un); else r->_mp_size = (int)un;
  return_label: return;
}

static unsigned int gmp_popcount_limb(mp_limb_t x)
{
  unsigned int c;
  c = (unsigned int)0;
  while (x > (mp_limb_t)0) {
    {
      unsigned int w =
        (unsigned int)(((x >> 1) & (unsigned long)0x5555) + (x & (unsigned long)0x5555));
      w = ((w >> 2) & (unsigned int)0x3333) + (w & (unsigned int)0x3333);
      w = ((w >> 4) & (unsigned int)0x0f0f) + (w & (unsigned int)0x0f0f);
      w = (w >> 8) + (w & (unsigned int)0x00ff);
      c += w;
    }
    x >>= 16;
  }
  return c;
}

mp_bitcnt_t mpn_popcount(mp_srcptr p, mp_size_t n)
{
  mp_size_t i;
  mp_bitcnt_t c;
  c = (mp_bitcnt_t)0;
  i = (mp_size_t)0;
  while (i < n) {
    unsigned int tmp;
    tmp = gmp_popcount_limb(*(p + i));
    c += (mp_bitcnt_t)tmp;
    i ++;
  }
  return c;
}

mp_bitcnt_t mpz_popcount(__mpz_struct const u[1])
{
  mp_bitcnt_t __retres;
  mp_size_t un;
  mp_bitcnt_t tmp;
  un = (mp_size_t)u->_mp_size;
  if (un < (mp_size_t)0) {
    __retres = ~ ((mp_bitcnt_t)0);
    goto return_label;
  }
  tmp = mpn_popcount((mp_srcptr)u->_mp_d,un);
  __retres = tmp;
  return_label: return __retres;
}

mp_bitcnt_t mpz_hamdist(__mpz_struct const u[1], __mpz_struct const v[1])
{
  mp_bitcnt_t __retres;
  mp_size_t un;
  mp_size_t vn;
  mp_size_t i;
  mp_limb_t uc;
  mp_limb_t vc;
  mp_limb_t ul;
  mp_limb_t vl;
  mp_limb_t comp;
  mp_srcptr up;
  mp_srcptr vp;
  mp_bitcnt_t c;
  un = (mp_size_t)u->_mp_size;
  vn = (mp_size_t)v->_mp_size;
  if ((un ^ vn) < (long)0) {
    __retres = ~ ((mp_bitcnt_t)0);
    goto return_label;
  }
  vc = (mp_limb_t)(un < (mp_size_t)0);
  uc = vc;
  comp = - uc;
  if (uc) {
    __FC_assert((vn < (mp_size_t)0) != 0,"mini-gmp.c",3877,"vn < 0");
    un = - un;
    vn = - vn;
  }
  up = (mp_srcptr)u->_mp_d;
  vp = (mp_srcptr)v->_mp_d;
  if (un < vn) {
    {
      mp_srcptr __mp_srcptr_swap__tmp = up;
      up = vp;
      vp = __mp_srcptr_swap__tmp;
    }
    {
      mp_size_t __mp_size_t_swap__tmp = un;
      un = vn;
      vn = __mp_size_t_swap__tmp;
    }
  }
  i = (mp_size_t)0;
  c = (mp_bitcnt_t)0;
  while (i < vn) {
    {
      unsigned int tmp;
      ul = (*(up + i) ^ comp) + uc;
      uc = (mp_limb_t)(ul < uc);
      vl = (*(vp + i) ^ comp) + vc;
      vc = (mp_limb_t)(vl < vc);
      tmp = gmp_popcount_limb(ul ^ vl);
      c += (mp_bitcnt_t)tmp;
    }
    i ++;
  }
  __FC_assert((vc == (mp_limb_t)0) != 0,"mini-gmp.c",3898,"vc == 0");
  while (i < un) {
    {
      unsigned int tmp_0;
      ul = (*(up + i) ^ comp) + uc;
      uc = (mp_limb_t)(ul < uc);
      tmp_0 = gmp_popcount_limb(ul ^ comp);
      c += (mp_bitcnt_t)tmp_0;
    }
    i ++;
  }
  __retres = c;
  return_label: return __retres;
}

mp_bitcnt_t mpz_scan1(__mpz_struct const u[1], mp_bitcnt_t starting_bit)
{
  mp_bitcnt_t __retres;
  mp_ptr up;
  mp_size_t us;
  mp_size_t un;
  mp_size_t i;
  mp_limb_t limb;
  mp_limb_t ux;
  mp_bitcnt_t tmp_1;
  us = (mp_size_t)u->_mp_size;
  if (us >= (mp_size_t)0) un = us; else un = - us;
  i = (mp_size_t)(starting_bit / (mp_bitcnt_t)(sizeof(mp_limb_t) * (unsigned int)8));
  if (i >= un) {
    mp_bitcnt_t tmp;
    if (us >= (mp_size_t)0) tmp = ~ ((mp_bitcnt_t)0);
    else tmp = starting_bit;
    __retres = tmp;
    goto return_label;
  }
  up = u->_mp_d;
  ux = (mp_limb_t)0;
  limb = *(up + i);
  if (starting_bit != (mp_bitcnt_t)0) {
    if (us < (mp_size_t)0) {
      int tmp_0;
      tmp_0 = mpn_zero_p((mp_srcptr)up,i);
      ux = (mp_limb_t)tmp_0;
      limb = ~ limb + ux;
      ux = - ((mp_limb_t)(limb >= ux));
    }
    limb &= ~ ((mp_limb_t)0) << starting_bit % (unsigned long)(sizeof(mp_limb_t) * (unsigned int)8);
  }
  tmp_1 = mpn_common_scan(limb,i,(mp_srcptr)up,un,ux);
  __retres = tmp_1;
  return_label: return __retres;
}

mp_bitcnt_t mpz_scan0(__mpz_struct const u[1], mp_bitcnt_t starting_bit)
{
  mp_bitcnt_t __retres;
  mp_ptr up;
  mp_size_t us;
  mp_size_t un;
  mp_size_t i;
  mp_limb_t limb;
  mp_limb_t ux;
  mp_bitcnt_t tmp_1;
  us = (mp_size_t)u->_mp_size;
  ux = - ((mp_limb_t)(us >= (mp_size_t)0));
  if (us >= (mp_size_t)0) un = us; else un = - us;
  i = (mp_size_t)(starting_bit / (mp_bitcnt_t)(sizeof(mp_limb_t) * (unsigned int)8));
  if (i >= un) {
    mp_bitcnt_t tmp;
    if (ux) tmp = starting_bit; else tmp = ~ ((mp_bitcnt_t)0);
    __retres = tmp;
    goto return_label;
  }
  up = u->_mp_d;
  limb = *(up + i) ^ ux;
  if (ux == (mp_limb_t)0) {
    int tmp_0;
    tmp_0 = mpn_zero_p((mp_srcptr)up,i);
    limb -= (mp_limb_t)tmp_0;
  }
  limb &= ~ ((mp_limb_t)0) << starting_bit % (unsigned long)(sizeof(mp_limb_t) * (unsigned int)8);
  tmp_1 = mpn_common_scan(limb,i,(mp_srcptr)up,un,ux);
  __retres = tmp_1;
  return_label: return __retres;
}

size_t mpz_sizeinbase(__mpz_struct const u[1], int base)
{
  size_t __retres;
  mp_size_t un;
  mp_srcptr up;
  mp_ptr tp;
  mp_bitcnt_t bits;
  struct gmp_div_inverse bi;
  size_t ndigits;
  mp_bitcnt_t tmp;
  __FC_assert((base >= 2) != 0,"mini-gmp.c",3989,"base >= 2");
  __FC_assert((base <= 36) != 0,"mini-gmp.c",3990,"base <= 36");
  if (u->_mp_size >= 0) un = (mp_size_t)u->_mp_size;
  else un = (mp_size_t)(- u->_mp_size);
  if (un == (mp_size_t)0) {
    __retres = (size_t)1;
    goto return_label;
  }
  up = (mp_srcptr)u->_mp_d;
  tmp = mpn_limb_size_in_base_2(*(up + (un - (mp_size_t)1)));
  bits = (unsigned long)(un - (mp_size_t)1) * (unsigned long)(sizeof(mp_limb_t) * (unsigned int)8) + tmp;
  switch (base) {
    case 2: ;
    __retres = (size_t)bits;
    goto return_label;
    case 4: ;
    __retres = (size_t)((bits + (mp_bitcnt_t)1) / (mp_bitcnt_t)2);
    goto return_label;
    case 8: ;
    __retres = (size_t)((bits + (mp_bitcnt_t)2) / (mp_bitcnt_t)3);
    goto return_label;
    case 16: ;
    __retres = (size_t)((bits + (mp_bitcnt_t)3) / (mp_bitcnt_t)4);
    goto return_label;
    case 32: ;
    __retres = (size_t)((bits + (mp_bitcnt_t)4) / (mp_bitcnt_t)5);
    goto return_label;
  }
  tp = gmp_xalloc_limbs(un);
  mpn_copyi(tp,up,un);
  mpn_div_qr_1_invert(& bi,(mp_limb_t)base);
  ndigits = (size_t)0;
  while (1) {
    ndigits ++;
    mpn_div_qr_1_preinv(tp,(mp_srcptr)tp,un,
                        (struct gmp_div_inverse const *)(& bi));
    un -= (mp_size_t)(*(tp + (un - (mp_size_t)1)) == (mp_limb_t)0);
    if (! (un > (mp_size_t)0)) break;
  }
  (*gmp_free_func)((void *)tp,(size_t)0);
  __retres = ndigits;
  return_label: return __retres;
}

char *mpz_get_str(char *sp, int base, __mpz_struct const u[1])
{
  char *__retres;
  unsigned int bits;
  char const *digits;
  mp_size_t un;
  size_t i;
  size_t sn;
  size_t tmp;
  if (base >= 0) digits = "0123456789abcdefghijklmnopqrstuvwxyz";
  else {
    base = - base;
    digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  }
  if (base <= 1) base = 10;
  if (base > 36) {
    __retres = (char *)0;
    goto return_label;
  }
  tmp = mpz_sizeinbase(u,base);
  sn = (size_t)1 + tmp;
  if (! sp) sp = (char *)(*gmp_allocate_func)((size_t)1 + sn);
  if (u->_mp_size >= 0) un = (mp_size_t)u->_mp_size;
  else un = (mp_size_t)(- u->_mp_size);
  if (un == (mp_size_t)0) {
    *(sp + 0) = (char)'0';
    *(sp + 1) = (char)'\000';
    __retres = sp;
    goto return_label;
  }
  i = (size_t)0;
  if (u->_mp_size < 0) {
    size_t tmp_1;
    tmp_1 = i;
    i ++;
    *(sp + tmp_1) = (char)'-';
  }
  bits = mpn_base_power_of_two_p((unsigned int)base);
  if (bits) {
    size_t tmp_2;
    tmp_2 = mpn_get_str_bits((unsigned char *)sp + i,bits,
                             (mp_srcptr)u->_mp_d,un);
    sn = i + tmp_2;
  }
  else {
    struct mpn_base_info info;
    mp_ptr tp;
    size_t tmp_3;
    mpn_get_base_info(& info,(mp_limb_t)base);
    tp = gmp_xalloc_limbs(un);
    mpn_copyi(tp,(mp_srcptr)u->_mp_d,un);
    tmp_3 = mpn_get_str_other((unsigned char *)sp + i,base,
                              (struct mpn_base_info const *)(& info),tp,un);
    sn = i + tmp_3;
    (*gmp_free_func)((void *)tp,(size_t)0);
  }
  while (i < sn) {
    *(sp + i) = *(digits + (unsigned char)*(sp + i));
    i ++;
  }
  *(sp + sn) = (char)'\000';
  __retres = sp;
  return_label: return __retres;
}

int mpz_set_str(__mpz_struct r[1], char const *sp, int base)
{
  int __retres;
  unsigned int bits;
  mp_size_t rn;
  mp_size_t alloc;
  mp_ptr rp;
  size_t sn;
  int sign;
  unsigned char *dp;
  int tmp;
  if (base == 0) tmp = 1;
  else 
    if (base >= 2) 
      if (base <= 36) tmp = 1; else tmp = 0;
    else tmp = 0;
  __FC_assert(tmp != 0,"mini-gmp.c",4107,
              "base == 0 || (base >= 2 && base <= 36)");
  while (1) {
    int tmp_0;
    tmp_0 = isspace((int)((unsigned char)*sp));
    if (! tmp_0) break;
    sp ++;
  }
  sign = (int)*sp == '-';
  sp += sign;
  if (base == 0) 
    if ((int)*sp == '0') {
      sp ++;
      if ((int)*sp == 'x') goto _LOR_0;
      else 
        if ((int)*sp == 'X') {
          _LOR_0: {
                    base = 16;
                    sp ++;
                  }
        }
        else 
          if ((int)*sp == 'b') goto _LOR;
          else 
            if ((int)*sp == 'B') {
              _LOR: {
                      base = 2;
                      sp ++;
                    }
            }
            else base = 8;
    }
    else base = 10;
  sn = strlen(sp);
  dp = (unsigned char *)(*gmp_allocate_func)(sn + (size_t)(sn == (size_t)0));
  sn = (size_t)0;
  while (*sp) {
    {
      unsigned int digit;
      int tmp_2;
      size_t tmp_3;
      tmp_2 = isspace((int)((unsigned char)*sp));
      if (tmp_2) goto __Cont;
      if ((int)*sp >= '0') {
        if ((int)*sp <= '9') digit = (unsigned int)((int)*sp - '0');
        else goto _LAND_0;
      }
      else {
        _LAND_0: ;
        if ((int)*sp >= 'a') {
          if ((int)*sp <= 'z') digit = (unsigned int)(((int)*sp - 'a') + 10);
          else goto _LAND;
        }
        else {
          _LAND: ;
          if ((int)*sp >= 'A') 
            if ((int)*sp <= 'Z') digit = (unsigned int)(((int)*sp - 'A') + 10);
            else digit = (unsigned int)base;
          else digit = (unsigned int)base;
        }
      }
      if (digit >= (unsigned int)base) {
        (*gmp_free_func)((void *)dp,(size_t)0);
        r->_mp_size = 0;
        __retres = -1;
        goto return_label;
      }
      tmp_3 = sn;
      sn ++;
      *(dp + tmp_3) = (unsigned char)digit;
    }
    __Cont: sp ++;
  }
  bits = mpn_base_power_of_two_p((unsigned int)base);
  if (bits > (unsigned int)0) {
    alloc = (mp_size_t)(((sn * bits + sizeof(mp_limb_t) * (unsigned int)8) - (size_t)1) / (
                        sizeof(mp_limb_t) * (unsigned int)8));
    if (alloc > (mp_size_t)r->_mp_alloc) rp = mpz_realloc(r,alloc);
    else rp = r->_mp_d;
    rn = mpn_set_str_bits(rp,(unsigned char const *)dp,sn,bits);
  }
  else {
    struct mpn_base_info info;
    mpn_get_base_info(& info,(mp_limb_t)base);
    alloc = (mp_size_t)(((sn + info.exp) - (size_t)1) / info.exp);
    if (alloc > (mp_size_t)r->_mp_alloc) rp = mpz_realloc(r,alloc);
    else rp = r->_mp_d;
    rn = mpn_set_str_other(rp,(unsigned char const *)dp,sn,(mp_limb_t)base,
                           (struct mpn_base_info const *)(& info));
  }
  __FC_assert((rn <= alloc) != 0,"mini-gmp.c",4181,"rn <= alloc");
  (*gmp_free_func)((void *)dp,(size_t)0);
  if (sign) r->_mp_size = (int)(- rn); else r->_mp_size = (int)rn;
  __retres = 0;
  return_label: return __retres;
}

int mpz_init_set_str(__mpz_struct r[1], char const *sp, int base)
{
  int tmp;
  mpz_init(r);
  tmp = mpz_set_str(r,sp,base);
  return tmp;
}

size_t mpz_out_str(FILE *stream, int base, __mpz_struct const x[1])
{
  char *str;
  size_t len;
  str = mpz_get_str((char *)0,base,x);
  len = strlen((char const *)str);
  len = fwrite((void const *)str,(size_t)1,len,stream);
  (*gmp_free_func)((void *)str,(size_t)0);
  return len;
}

static int gmp_detect_endian(void);

static int const gmp_detect_endian_i = 2;
static int gmp_detect_endian(void)
{
  int __retres;
  unsigned char const *p = (unsigned char const *)(& gmp_detect_endian_i);
  __retres = 1 - (int)*p;
  return __retres;
}

void mpz_import(__mpz_struct r[1], size_t count, int order, size_t size,
                int endian, size_t nails, void const *src)
{
  unsigned char const *p;
  ptrdiff_t word_step;
  mp_ptr rp;
  mp_size_t rn;
  mp_limb_t limb;
  size_t bytes;
  mp_size_t i;
  int tmp;
  int tmp_0;
  if (nails != (size_t)0) gmp_die("mpz_import: Nails not supported.");
  if (order == 1) tmp = 1;
  else 
    if (order == -1) tmp = 1; else tmp = 0;
  __FC_assert(tmp != 0,"mini-gmp.c",4239,"order == 1 || order == -1");
  if (endian >= -1) 
    if (endian <= 1) tmp_0 = 1; else tmp_0 = 0;
  else tmp_0 = 0;
  __FC_assert(tmp_0 != 0,"mini-gmp.c",4240,"endian >= -1 && endian <= 1");
  if (endian == 0) endian = gmp_detect_endian();
  p = (unsigned char const *)src;
  if (order != endian) word_step = (ptrdiff_t)((size_t)2 * size);
  else word_step = 0;
  if (order == 1) {
    p += size * (count - (size_t)1);
    word_step = - word_step;
  }
  if (endian == 1) p += size - (size_t)1;
  rn = (mp_size_t)(((size * count + sizeof(mp_limb_t)) - (size_t)1) / sizeof(mp_limb_t));
  if (rn > (mp_size_t)r->_mp_alloc) rp = mpz_realloc(r,rn);
  else rp = r->_mp_d;
  limb = (mp_limb_t)0;
  bytes = (size_t)0;
  i = (mp_size_t)0;
  while (count > (size_t)0) {
    {
      size_t j;
      j = (size_t)0;
      while (j < size) {
        {
          size_t tmp_2;
          tmp_2 = bytes;
          bytes ++;
          limb |= (mp_limb_t)*p << tmp_2 * (size_t)8;
          if (bytes == sizeof(mp_limb_t)) {
            mp_size_t tmp_3;
            tmp_3 = i;
            i ++;
            *(rp + tmp_3) = limb;
            bytes = (size_t)0;
            limb = (mp_limb_t)0;
          }
        }
        j ++;
        p -= endian;
      }
    }
    count --;
    p += word_step;
  }
  __FC_assert((i + (mp_size_t)(bytes > (size_t)0) == rn) != 0,"mini-gmp.c",
              4278,"i + (bytes > 0) == rn");
  if (limb != (mp_limb_t)0) {
    mp_size_t tmp_4;
    tmp_4 = i;
    i ++;
    *(rp + tmp_4) = limb;
  }
  else i = mpn_normalized_size((mp_srcptr)rp,i);
  r->_mp_size = (int)i;
  return;
}

void *mpz_export(void *r, size_t *countp, int order, size_t size, int endian,
                 size_t nails, __mpz_struct const u[1])
{
  size_t count;
  mp_size_t un;
  int tmp;
  int tmp_0;
  int tmp_1;
  if (nails != (size_t)0) gmp_die("mpz_import: Nails not supported.");
  if (order == 1) tmp = 1;
  else 
    if (order == -1) tmp = 1; else tmp = 0;
  __FC_assert(tmp != 0,"mini-gmp.c",4297,"order == 1 || order == -1");
  if (endian >= -1) 
    if (endian <= 1) tmp_0 = 1; else tmp_0 = 0;
  else tmp_0 = 0;
  __FC_assert(tmp_0 != 0,"mini-gmp.c",4298,"endian >= -1 && endian <= 1");
  if (size > (size_t)0) tmp_1 = 1;
  else 
    if (u->_mp_size == 0) tmp_1 = 1; else tmp_1 = 0;
  __FC_assert(tmp_1 != 0,"mini-gmp.c",4299,"size > 0 || u->_mp_size == 0");
  un = (mp_size_t)u->_mp_size;
  count = (size_t)0;
  if (un != (mp_size_t)0) {
    size_t k;
    unsigned char *p;
    ptrdiff_t word_step;
    mp_limb_t limb;
    size_t bytes;
    mp_size_t i;
    if (un >= (mp_size_t)0) un = un; else un = - un;
    limb = *(u->_mp_d + (un - (mp_size_t)1));
    __FC_assert((limb != (mp_limb_t)0) != 0,"mini-gmp.c",4319,"limb != 0");
    k = (size_t)0;
    while (1) {
      k ++;
      limb >>= 8;
      if (! (limb != (mp_limb_t)0)) break;
    }
    count = (size_t)(((((unsigned long)k + (unsigned long)(un - (mp_size_t)1) * (unsigned long)sizeof(mp_limb_t)) + (unsigned long)size) - (unsigned long)1) / (unsigned long)size);
    if (! r) r = (*gmp_allocate_func)(count * size);
    if (endian == 0) endian = gmp_detect_endian();
    p = (unsigned char *)r;
    if (order != endian) word_step = (ptrdiff_t)((size_t)2 * size);
    else word_step = 0;
    if (order == 1) {
      p += size * (count - (size_t)1);
      word_step = - word_step;
    }
    if (endian == 1) p += size - (size_t)1;
    bytes = (size_t)0;
    i = (mp_size_t)0;
    k = (size_t)0;
    while (k < count) {
      {
        size_t j;
        j = (size_t)0;
        while (j < size) {
          if (bytes == (size_t)0) {
            if (i < un) {
              mp_size_t tmp_2;
              tmp_2 = i;
              i ++;
              limb = *(u->_mp_d + tmp_2);
            }
            bytes = sizeof(mp_limb_t);
          }
          *p = (unsigned char)limb;
          limb >>= 8;
          bytes --;
          j ++;
          p -= endian;
        }
      }
      k ++;
      p += word_step;
    }
    __FC_assert((i == un) != 0,"mini-gmp.c",4366,"i == un");
    __FC_assert((k == count) != 0,"mini-gmp.c",4367,"k == count");
  }
  if (countp) *countp = count;
  return r;
}

static size_t total_alloc = (size_t)0;
static char block_end[8] =
  {(char)0x7c,
   (char)0x37,
   (char)0xd6,
   (char)0x12,
   (char)0xa8,
   (char)0x6c,
   (char)0x01,
   (char)0xd1};
static void *block_init(size_t *block, size_t size)
{
  void *__retres;
  char *p;
  size_t *tmp;
  tmp = block;
  block ++;
  *tmp = size;
  p = (char *)block;
  memcpy((void *)(p + size),(void const *)(block_end),sizeof(block_end));
  total_alloc += size;
  __retres = (void *)p;
  return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_2(FILE * restrict stream, char const * restrict format);

static size_t *block_check(void *p)
{
  int tmp;
  size_t *block = (size_t *)p - 1;
  size_t size = *(block + 0);
  tmp = memcmp((void const *)((char *)p + size),(void const *)(block_end),
               sizeof(block_end));
  if (tmp != 0) {
    fprintf(__fc_stderr,"red zone overwritten.\n"); /* fprintf_va_2 */
    abort();
  }
  total_alloc -= size;
  return block;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_3(FILE * restrict stream, char const * restrict format);

static void *tu_alloc(size_t size)
{
  void *tmp_0;
  size_t *block = malloc((sizeof(size_t) + size) + sizeof(block_end));
  if (! block) {
    fprintf(__fc_stderr,"Virtual memory exhausted.\n"); /* fprintf_va_3 */
    abort();
  }
  tmp_0 = block_init(block,size);
  return tmp_0;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_4(FILE * restrict stream, char const * restrict format);

static void *tu_realloc(void *p, size_t old_size, size_t new_size)
{
  void *tmp_1;
  size_t *block = block_check(p);
  block = (size_t *)realloc((void *)block,
                            (sizeof(size_t) + new_size) + sizeof(block_end));
  if (! block) {
    fprintf(__fc_stderr,"Virtual memory exhausted.\n"); /* fprintf_va_4 */
    abort();
  }
  tmp_1 = block_init(block,new_size);
  return tmp_1;
}

static void tu_free(void *p, size_t old_size)
{
  size_t *tmp;
  tmp = block_check(p);
  free((void *)tmp);
  return;
}

void testfree(void *p)
{
  void (*freefunc)(void *, size_t );
  mp_get_memory_functions((void *(**)(size_t ))0,
                          (void *(**)(void *, size_t , size_t ))0,& freefunc);
  (*freefunc)(p,(size_t)0);
  return;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param0;
 */
int fprintf_va_5(FILE * restrict stream, char const * restrict format,
                 unsigned long param0);

int main(int argc, char **argv)
{
  int __retres;
  hex_random_init();
  mp_set_memory_functions(& tu_alloc,& tu_realloc,& tu_free);
  testmain(argc,argv);
  if (total_alloc != (size_t)0) {
    fprintf(__fc_stderr,"Memory leaked: %lu bytes.\n",
            (unsigned long)total_alloc); /* fprintf_va_5 */
    abort();
  }
  __retres = 0;
  return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param0;
 */
int fprintf_va_6(FILE * restrict stream, char const * restrict format,
                 unsigned long param0);

void testhalves(int count, void (*tested_fun)(int ))
{
  void (*freefunc)(void *, size_t );
  void *(*reallocfunc)(void *, size_t , size_t );
  void *(*allocfunc)(size_t );
  size_t initial_alloc;
  mp_get_memory_functions(& allocfunc,& reallocfunc,& freefunc);
  initial_alloc = total_alloc;
  (*tested_fun)(count / 2);
  if (initial_alloc != total_alloc) {
    fprintf(__fc_stderr,"First half, memory leaked: %lu bytes.\n",
            (unsigned long)total_alloc - (unsigned long)initial_alloc); /* fprintf_va_6 */
    abort();
  }
  mp_set_memory_functions((void *(*)(size_t ))0,
                          (void *(*)(void *, size_t , size_t ))0,
                          (void (*)(void *, size_t ))0);
  (*tested_fun)(count / 2);
  mp_set_memory_functions(allocfunc,reallocfunc,freefunc);
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_7(FILE * restrict stream, char const * restrict format,
                 char *param0, char *param1);

void dump(char const *label, __mpz_struct const x[1])
{
  char *buf = mpz_get_str((char *)0,16,x);
  fprintf(__fc_stderr,"%s: %s\n",(char *)label,buf); /* fprintf_va_7 */
  testfree((void *)buf);
  return;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_8(FILE * restrict stream, char const * restrict format);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_9(FILE * restrict stream, char const * restrict format,
                 char *param0);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param0;
 */
int fprintf_va_10(FILE * restrict stream, char const * restrict format,
                  int param0);

void mpz_set_str_or_abort(mpz_ptr z, char const *str, int base)
{
  int tmp;
  tmp = mpz_set_str(z,str,base);
  if (tmp != 0) {
    fprintf(__fc_stderr,"ERROR: mpz_set_str failed\n"); /* fprintf_va_8 */
    fprintf(__fc_stderr,"   str  = \"%s\"\n",(char *)str); /* fprintf_va_9 */
    fprintf(__fc_stderr,"   base = %d\n",base); /* fprintf_va_10 */
    abort();
  }
  return;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_11(FILE * restrict stream, char const * restrict format);

void testmain(int argc, char **argv)
{
  unsigned int i;
  mpz_t a;
  mpz_t b;
  mpz_t res;
  mpz_t ref;
  mpz_init(a);
  mpz_init(b);
  mpz_init(res);
  mpz_init(ref);
  i = (unsigned int)0;
  while (i < (unsigned int)10000) {
    {
      int tmp;
      mini_random_op3(OP_ADD,(unsigned long)400,a,b,ref);
      mpz_add(res,(__mpz_struct const *)(a),(__mpz_struct const *)(b));
      tmp = mpz_cmp((__mpz_struct const *)(res),(__mpz_struct const *)(ref));
      if (tmp) {
        fprintf(__fc_stderr,"mpz_add failed:\n"); /* fprintf_va_11 */
        dump("a",(__mpz_struct const *)(a));
        dump("b",(__mpz_struct const *)(b));
        dump("r",(__mpz_struct const *)(res));
        dump("ref",(__mpz_struct const *)(ref));
        abort();
      }
    }
    i ++;
  }
  mpz_clear(a);
  mpz_clear(b);
  mpz_clear(res);
  mpz_clear(ref);
  return;
}

void __gmp_randinit_default(__gmp_randstate_struct [1]);

void __gmp_randseed_ui(__gmp_randstate_struct [1], unsigned long);

/*@ assigns \result, *a, __fc_random_counter;
    assigns \result \from __fc_random_counter;
    assigns *a \from __fc_random_counter;
    assigns __fc_random_counter \from __fc_random_counter;
 */
unsigned long __gmp_urandomb_ui(__gmp_randstate_struct a[1], unsigned long b);

/*@ requires \valid(res);
    ensures \initialized(\old(res));
    assigns *res;
    assigns *res \from a, b;
 */
void __gmpz_add(mpz_ptr res, mpz_srcptr a, mpz_srcptr b);

/*@ assigns *res;
    assigns *res \from a, b; */
void __gmpz_and(mpz_ptr res, mpz_srcptr a, mpz_srcptr b);

void __gmpz_cdiv_q_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t);

void __gmpz_cdiv_qr(mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);

void __gmpz_cdiv_r_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t);

/*@ assigns *a, __fc_random_counter;
    assigns *a \from __fc_random_counter;
    assigns __fc_random_counter \from __fc_random_counter;
 */
void __gmpz_clear(mpz_ptr a);

void __gmpz_clrbit(mpz_ptr, mp_bitcnt_t);

int __gmpz_cmp_ui(mpz_srcptr, unsigned long) __attribute__((__pure__));

void __gmpz_combit(mpz_ptr, mp_bitcnt_t);

void __gmpz_divexact(mpz_ptr, mpz_srcptr, mpz_srcptr);

void *__gmpz_export(void *, size_t *, int, size_t, int, size_t, mpz_srcptr);

void __gmpz_fdiv_q_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t);

void __gmpz_fdiv_qr(mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);

void __gmpz_fdiv_r_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t);

/*@ assigns *res;
    assigns *res \from a, b; */
void __gmpz_gcd(mpz_ptr res, mpz_srcptr a, mpz_srcptr b);

char *__gmpz_get_str(char *, int, mpz_srcptr);

/*@ assigns *a, __fc_random_counter;
    assigns *a \from __fc_random_counter;
    assigns __fc_random_counter \from __fc_random_counter;
 */
void __gmpz_init(mpz_ptr a);

/*@ assigns *res;
    assigns *res \from a, b; */
void __gmpz_ior(mpz_ptr res, mpz_srcptr a, mpz_srcptr b);

/*@ assigns *res;
    assigns *res \from a, b; */
void __gmpz_lcm(mpz_ptr res, mpz_srcptr a, mpz_srcptr b);

/*@ assigns *res;
    assigns *res \from a, b; */
void __gmpz_mul(mpz_ptr res, mpz_srcptr a, mpz_srcptr b);

/*@ assigns *res;
    assigns *res \from a; */
void __gmpz_neg(mpz_ptr res, mpz_srcptr a);

void __gmpz_powm(mpz_ptr, mpz_srcptr, mpz_srcptr, mpz_srcptr);

/*@ assigns *a, *b, __fc_random_counter;
    assigns *a \from __fc_random_counter;
    assigns *b \from __fc_random_counter;
    assigns __fc_random_counter \from __fc_random_counter;
 */
void __gmpz_rrandomb(mpz_ptr a, __gmp_randstate_struct b[1], mp_bitcnt_t c);

mp_bitcnt_t __gmpz_scan0(mpz_srcptr, mp_bitcnt_t) __attribute__((__pure__));

mp_bitcnt_t __gmpz_scan1(mpz_srcptr, mp_bitcnt_t) __attribute__((__pure__));

void __gmpz_set(mpz_ptr, mpz_srcptr);

void __gmpz_set_ui(mpz_ptr, unsigned long);

void __gmpz_setbit(mpz_ptr, mp_bitcnt_t);

/*@ assigns *res;
    assigns *res \from a, b; */
void __gmpz_sub(mpz_ptr res, mpz_srcptr a, mpz_srcptr b);

void __gmpz_tdiv_q_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t);

void __gmpz_tdiv_qr(mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);

void __gmpz_tdiv_r_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t);

void __gmpz_urandomb(mpz_ptr, __gmp_randstate_struct [1], mp_bitcnt_t);

/*@ assigns *res;
    assigns *res \from a, b; */
void __gmpz_xor(mpz_ptr res, mpz_srcptr a, mpz_srcptr b);

static gmp_randstate_t state;
/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_1(char const * restrict format, unsigned long param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_2(char const * restrict format, unsigned long param0);

void hex_random_init(void)
{
  unsigned long seed;
  char *env_seed;
  env_seed = getenv("GMP_CHECK_RANDOMIZE");
  if (env_seed) 
    if (*(env_seed + 0)) {
      seed = strtoul((char const *)env_seed,(char **)0,0);
      if (seed) printf("Re-seeding with GMP_CHECK_RANDOMIZE=%lu\n",seed); /* printf_va_1 */
      else {
        time_t tmp;
        pid_t tmp_0;
        tmp = time((time_t *)0);
        tmp_0 = getpid();
        seed = (unsigned long)(tmp + (time_t)tmp_0);
        printf("Seed GMP_CHECK_RANDOMIZE=%lu (include this in bug reports)\n",
               seed); /* printf_va_2 */
      }
    }
    else seed = (unsigned long)4711;
  else seed = (unsigned long)4711;
  __gmp_randinit_default(state);
  __gmp_randseed_ui(state,seed);
  return;
}

char *hex_urandomb(unsigned long bits)
{
  char *res;
  mpz_t x;
  __gmpz_init(x);
  __gmpz_urandomb(x,state,bits);
  {
    __mpz_struct *__va_arg0 = x;
    void *__va_args[1] = {& __va_arg0};
    asprintf(& res,"%Zx",(void * const *)(__va_args));
  }
  __gmpz_clear(x);
  return res;
}

char *hex_rrandomb(unsigned long bits)
{
  char *res;
  mpz_t x;
  __gmpz_init(x);
  __gmpz_rrandomb(x,state,bits);
  {
    __mpz_struct *__va_arg0 = x;
    void *__va_args[1] = {& __va_arg0};
    asprintf(& res,"%Zx",(void * const *)(__va_args));
  }
  __gmpz_clear(x);
  return res;
}

char *hex_rrandomb_export(void *dst, size_t *countp, int order, size_t size,
                          int endian, unsigned long bits)
{
  char *res;
  mpz_t x;
  __gmpz_init(x);
  __gmpz_rrandomb(x,state,bits);
  {
    __mpz_struct *__va_arg0 = x;
    void *__va_args[1] = {& __va_arg0};
    asprintf(& res,"%Zx",(void * const *)(__va_args));
  }
  __gmpz_export(dst,countp,order,size,endian,(size_t)0,(mpz_srcptr)(x));
  __gmpz_clear(x);
  return res;
}

void hex_random_op2(enum hex_random_op op, unsigned long maxbits, char **ap,
                    char **rp)
{
  mpz_t a;
  mpz_t r;
  unsigned long abits;
  unsigned int signs;
  unsigned long tmp;
  __gmpz_init(a);
  __gmpz_init(r);
  tmp = __gmp_urandomb_ui(state,(unsigned long)32);
  abits = tmp % maxbits;
  __gmpz_rrandomb(a,state,abits);
  signs = (unsigned int)__gmp_urandomb_ui(state,(unsigned long)1);
  if (signs & (unsigned int)1) __gmpz_neg(a,(mpz_srcptr)(a));
  switch (op) {
    default: abort();
    case OP_SQR: __gmpz_mul(r,(mpz_srcptr)(a),(mpz_srcptr)(a));
    break;
  }
  {
    __mpz_struct *__va_arg0 = a;
    void *__va_args[1] = {& __va_arg0};
    asprintf(ap,"%Zx",(void * const *)(__va_args));
  }
  {
    __mpz_struct *__va_arg0_13 = r;
    void *__va_args_15[1] = {& __va_arg0_13};
    asprintf(rp,"%Zx",(void * const *)(__va_args_15));
  }
  __gmpz_clear(a);
  __gmpz_clear(r);
  return;
}

void hex_random_op3(enum hex_random_op op, unsigned long maxbits, char **ap,
                    char **bp, char **rp)
{
  mpz_t a;
  mpz_t b;
  mpz_t r;
  unsigned long abits;
  unsigned long bbits;
  unsigned int signs;
  unsigned long tmp;
  unsigned long tmp_0;
  __gmpz_init(a);
  __gmpz_init(b);
  __gmpz_init(r);
  tmp = __gmp_urandomb_ui(state,(unsigned long)32);
  abits = tmp % maxbits;
  tmp_0 = __gmp_urandomb_ui(state,(unsigned long)32);
  bbits = tmp_0 % maxbits;
  __gmpz_rrandomb(a,state,abits);
  __gmpz_rrandomb(b,state,bbits);
  signs = (unsigned int)__gmp_urandomb_ui(state,(unsigned long)3);
  if (signs & (unsigned int)1) __gmpz_neg(a,(mpz_srcptr)(a));
  if (signs & (unsigned int)2) __gmpz_neg(b,(mpz_srcptr)(b));
  switch (op) {
    default: abort();
    case OP_ADD: __gmpz_add(r,(mpz_srcptr)(a),(mpz_srcptr)(b));
    break;
    case OP_SUB: __gmpz_sub(r,(mpz_srcptr)(a),(mpz_srcptr)(b));
    break;
    case OP_MUL: __gmpz_mul(r,(mpz_srcptr)(a),(mpz_srcptr)(b));
    break;
    case OP_GCD: ;
    if (signs & (unsigned int)4) {
      unsigned long tmp_1;
      tmp_1 = __gmp_urandomb_ui(state,(unsigned long)32);
      unsigned long gbits = tmp_1 % maxbits;
      __gmpz_rrandomb(r,state,gbits);
      __gmpz_mul(a,(mpz_srcptr)(a),(mpz_srcptr)(r));
      __gmpz_mul(b,(mpz_srcptr)(b),(mpz_srcptr)(r));
    }
    __gmpz_gcd(r,(mpz_srcptr)(a),(mpz_srcptr)(b));
    break;
    case OP_LCM: ;
    if (signs & (unsigned int)4) {
      unsigned long tmp_2;
      tmp_2 = __gmp_urandomb_ui(state,(unsigned long)32);
      unsigned long gbits_0 = tmp_2 % maxbits;
      __gmpz_rrandomb(r,state,gbits_0);
      __gmpz_mul(a,(mpz_srcptr)(a),(mpz_srcptr)(r));
      __gmpz_mul(b,(mpz_srcptr)(b),(mpz_srcptr)(r));
    }
    __gmpz_lcm(r,(mpz_srcptr)(a),(mpz_srcptr)(b));
    break;
    case OP_AND: __gmpz_and(r,(mpz_srcptr)(a),(mpz_srcptr)(b));
    break;
    case OP_IOR: __gmpz_ior(r,(mpz_srcptr)(a),(mpz_srcptr)(b));
    break;
    case OP_XOR: __gmpz_xor(r,(mpz_srcptr)(a),(mpz_srcptr)(b));
    break;
  }
  {
    __mpz_struct *__va_arg0 = a;
    void *__va_args[1] = {& __va_arg0};
    asprintf(ap,"%Zx",(void * const *)(__va_args));
  }
  {
    __mpz_struct *__va_arg0_21 = b;
    void *__va_args_23[1] = {& __va_arg0_21};
    asprintf(bp,"%Zx",(void * const *)(__va_args_23));
  }
  {
    __mpz_struct *__va_arg0_25 = r;
    void *__va_args_27[1] = {& __va_arg0_25};
    asprintf(rp,"%Zx",(void * const *)(__va_args_27));
  }
  __gmpz_clear(a);
  __gmpz_clear(b);
  __gmpz_clear(r);
  return;
}

void hex_random_op4(enum hex_random_op op, unsigned long maxbits, char **ap,
                    char **bp, char **cp, char **dp)
{
  mpz_t a;
  mpz_t b;
  mpz_t c;
  mpz_t d;
  unsigned long abits;
  unsigned long bbits;
  unsigned int signs;
  __gmpz_init(a);
  __gmpz_init(b);
  __gmpz_init(c);
  __gmpz_init(d);
  if (op == (unsigned int)OP_POWM) {
    unsigned long cbits;
    unsigned long tmp;
    unsigned long tmp_0;
    unsigned long tmp_1;
    tmp = __gmp_urandomb_ui(state,(unsigned long)32);
    abits = tmp % maxbits;
    tmp_0 = __gmp_urandomb_ui(state,(unsigned long)32);
    bbits = (unsigned long)1 + tmp_0 % maxbits;
    tmp_1 = __gmp_urandomb_ui(state,(unsigned long)32);
    cbits = (unsigned long)2 + tmp_1 % maxbits;
    __gmpz_rrandomb(a,state,abits);
    __gmpz_rrandomb(b,state,bbits);
    __gmpz_rrandomb(c,state,cbits);
    signs = (unsigned int)__gmp_urandomb_ui(state,(unsigned long)3);
    if (signs & (unsigned int)1) __gmpz_neg(a,(mpz_srcptr)(a));
    if (signs & (unsigned int)2) {
      mpz_t g;
      int tmp_5;
      if (a[0]._mp_size < 0) tmp_5 = -1; else tmp_5 = a[0]._mp_size > 0;
      if (tmp_5 == 0) __gmpz_set_ui(a,(unsigned long)1);
      else {
        __gmpz_init(g);
        while (1) {
          int tmp_4;
          __gmpz_gcd(g,(mpz_srcptr)(a),(mpz_srcptr)(c));
          if (1 == 0) {
            int tmp_2;
            if (g[0]._mp_size < 0) tmp_2 = -1;
            else tmp_2 = g[0]._mp_size > 0;
            tmp_4 = tmp_2;
          }
          else tmp_4 = __gmpz_cmp_ui((mpz_srcptr)(g),(unsigned long)1);
          if (tmp_4 == 0) break;
          __gmpz_divexact(a,(mpz_srcptr)(a),(mpz_srcptr)(g));
        }
        __gmpz_clear(g);
      }
      __gmpz_neg(b,(mpz_srcptr)(b));
    }
    if (signs & (unsigned int)4) __gmpz_neg(c,(mpz_srcptr)(c));
    __gmpz_powm(d,(mpz_srcptr)(a),(mpz_srcptr)(b),(mpz_srcptr)(c));
  }
  else {
    unsigned long qbits;
    unsigned long tmp_6;
    unsigned long tmp_7;
    tmp_6 = __gmp_urandomb_ui(state,(unsigned long)32);
    bbits = (unsigned long)1 + tmp_6 % maxbits;
    tmp_7 = __gmp_urandomb_ui(state,(unsigned long)32);
    qbits = tmp_7 % maxbits;
    abits = bbits + qbits;
    if (abits > (unsigned long)30) abits -= (unsigned long)30;
    else abits = (unsigned long)0;
    __gmpz_rrandomb(a,state,abits);
    __gmpz_rrandomb(b,state,bbits);
    signs = (unsigned int)__gmp_urandomb_ui(state,(unsigned long)2);
    if (signs & (unsigned int)1) __gmpz_neg(a,(mpz_srcptr)(a));
    if (signs & (unsigned int)2) __gmpz_neg(b,(mpz_srcptr)(b));
    switch (op) {
      default: abort();
      case OP_CDIV: __gmpz_cdiv_qr(c,d,(mpz_srcptr)(a),(mpz_srcptr)(b));
      break;
      case OP_FDIV: __gmpz_fdiv_qr(c,d,(mpz_srcptr)(a),(mpz_srcptr)(b));
      break;
      case OP_TDIV: __gmpz_tdiv_qr(c,d,(mpz_srcptr)(a),(mpz_srcptr)(b));
      break;
    }
  }
  {
    __mpz_struct *__va_arg0 = a;
    void *__va_args[1] = {& __va_arg0};
    asprintf(ap,"%Zx",(void * const *)(__va_args));
  }
  {
    __mpz_struct *__va_arg0_29 = b;
    void *__va_args_31[1] = {& __va_arg0_29};
    asprintf(bp,"%Zx",(void * const *)(__va_args_31));
  }
  {
    __mpz_struct *__va_arg0_33 = c;
    void *__va_args_35[1] = {& __va_arg0_33};
    asprintf(cp,"%Zx",(void * const *)(__va_args_35));
  }
  {
    __mpz_struct *__va_arg0_37 = d;
    void *__va_args_39[1] = {& __va_arg0_37};
    asprintf(dp,"%Zx",(void * const *)(__va_args_39));
  }
  __gmpz_clear(a);
  __gmpz_clear(b);
  __gmpz_clear(c);
  __gmpz_clear(d);
  return;
}

void hex_random_bit_op(enum hex_random_op op, unsigned long maxbits,
                       char **ap, unsigned long *b, char **rp)
{
  mpz_t a;
  mpz_t r;
  unsigned long abits;
  unsigned long bbits;
  unsigned int signs;
  unsigned long tmp;
  unsigned long tmp_0;
  __gmpz_init(a);
  __gmpz_init(r);
  tmp = __gmp_urandomb_ui(state,(unsigned long)32);
  abits = tmp % maxbits;
  tmp_0 = __gmp_urandomb_ui(state,(unsigned long)32);
  bbits = tmp_0 % (maxbits + (unsigned long)100);
  __gmpz_rrandomb(a,state,abits);
  signs = (unsigned int)__gmp_urandomb_ui(state,(unsigned long)1);
  if (signs & (unsigned int)1) __gmpz_neg(a,(mpz_srcptr)(a));
  switch (op) {
    default: abort();
    case OP_SETBIT: __gmpz_set(r,(mpz_srcptr)(a));
    __gmpz_setbit(r,bbits);
    break;
    case OP_CLRBIT: __gmpz_set(r,(mpz_srcptr)(a));
    __gmpz_clrbit(r,bbits);
    break;
    case OP_COMBIT: __gmpz_set(r,(mpz_srcptr)(a));
    __gmpz_combit(r,bbits);
    break;
    case OP_CDIV_Q_2: __gmpz_cdiv_q_2exp(r,(mpz_srcptr)(a),bbits);
    break;
    case OP_CDIV_R_2: __gmpz_cdiv_r_2exp(r,(mpz_srcptr)(a),bbits);
    break;
    case OP_FDIV_Q_2: __gmpz_fdiv_q_2exp(r,(mpz_srcptr)(a),bbits);
    break;
    case OP_FDIV_R_2: __gmpz_fdiv_r_2exp(r,(mpz_srcptr)(a),bbits);
    break;
    case OP_TDIV_Q_2: __gmpz_tdiv_q_2exp(r,(mpz_srcptr)(a),bbits);
    break;
    case OP_TDIV_R_2: __gmpz_tdiv_r_2exp(r,(mpz_srcptr)(a),bbits);
    break;
  }
  {
    __mpz_struct *__va_arg0 = a;
    void *__va_args[1] = {& __va_arg0};
    asprintf(ap,"%Zx",(void * const *)(__va_args));
  }
  *b = bbits;
  {
    __mpz_struct *__va_arg0_16 = r;
    void *__va_args_18[1] = {& __va_arg0_16};
    asprintf(rp,"%Zx",(void * const *)(__va_args_18));
  }
  __gmpz_clear(a);
  __gmpz_clear(r);
  return;
}

void hex_random_scan_op(enum hex_random_op op, unsigned long maxbits,
                        char **ap, unsigned long *b, unsigned long *r)
{
  mpz_t a;
  unsigned long abits;
  unsigned long bbits;
  unsigned int signs;
  unsigned long tmp;
  unsigned long tmp_0;
  __gmpz_init(a);
  tmp = __gmp_urandomb_ui(state,(unsigned long)32);
  abits = tmp % maxbits;
  tmp_0 = __gmp_urandomb_ui(state,(unsigned long)32);
  bbits = tmp_0 % (maxbits + (unsigned long)100);
  __gmpz_rrandomb(a,state,abits);
  signs = (unsigned int)__gmp_urandomb_ui(state,(unsigned long)1);
  if (signs & (unsigned int)1) __gmpz_neg(a,(mpz_srcptr)(a));
  switch (op) {
    default: abort();
    case OP_SCAN0: *r = __gmpz_scan0((mpz_srcptr)(a),bbits);
    break;
    case OP_SCAN1: *r = __gmpz_scan1((mpz_srcptr)(a),bbits);
    break;
  }
  {
    __mpz_struct *__va_arg0 = a;
    void *__va_args[1] = {& __va_arg0};
    asprintf(ap,"%Zx",(void * const *)(__va_args));
  }
  *b = bbits;
  __gmpz_clear(a);
  return;
}

void hex_random_str_op(unsigned long maxbits, int base, char **ap, char **rp)
{
  mpz_t a;
  unsigned long abits;
  unsigned int signs;
  unsigned long tmp;
  __gmpz_init(a);
  tmp = __gmp_urandomb_ui(state,(unsigned long)32);
  abits = tmp % maxbits;
  __gmpz_rrandomb(a,state,abits);
  signs = (unsigned int)__gmp_urandomb_ui(state,(unsigned long)2);
  if (signs & (unsigned int)1) __gmpz_neg(a,(mpz_srcptr)(a));
  *ap = __gmpz_get_str((char *)0,16,(mpz_srcptr)(a));
  *rp = __gmpz_get_str((char *)0,base,(mpz_srcptr)(a));
  __gmpz_clear(a);
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_12(FILE * restrict stream, char const * restrict format,
                  char *param0);

static void set_str(__mpz_struct r[1], char const *s)
{
  int tmp;
  tmp = mpz_set_str(r,s,16);
  if (tmp != 0) {
    fprintf(__fc_stderr,"mpz_set_str failed on input %s\n",(char *)s); /* fprintf_va_12 */
    abort();
  }
  return;
}

void mini_urandomb(__mpz_struct r[1], unsigned long bits)
{
  char *s;
  s = hex_urandomb(bits);
  set_str(r,(char const *)s);
  free((void *)s);
  return;
}

void mini_rrandomb(__mpz_struct r[1], unsigned long bits)
{
  char *s;
  s = hex_rrandomb(bits);
  set_str(r,(char const *)s);
  free((void *)s);
  return;
}

void mini_rrandomb_export(__mpz_struct r[1], void *dst, size_t *countp,
                          int order, size_t size, int endian,
                          unsigned long bits)
{
  char *s;
  s = hex_rrandomb_export(dst,countp,order,size,endian,bits);
  set_str(r,(char const *)s);
  free((void *)s);
  return;
}

void mini_random_op2(enum hex_random_op op, unsigned long maxbits,
                     __mpz_struct a[1], __mpz_struct r[1])
{
  char *ap;
  char *rp;
  hex_random_op2(op,maxbits,& ap,& rp);
  set_str(a,(char const *)ap);
  set_str(r,(char const *)rp);
  free((void *)ap);
  free((void *)rp);
  return;
}

void mini_random_op3(enum hex_random_op op, unsigned long maxbits,
                     __mpz_struct a[1], __mpz_struct b[1], __mpz_struct r[1])
{
  char *ap;
  char *bp;
  char *rp;
  hex_random_op3(op,maxbits,& ap,& bp,& rp);
  set_str(a,(char const *)ap);
  set_str(b,(char const *)bp);
  set_str(r,(char const *)rp);
  free((void *)ap);
  free((void *)bp);
  free((void *)rp);
  return;
}

void mini_random_op4(enum hex_random_op op, unsigned long maxbits,
                     __mpz_struct a[1], __mpz_struct b[1], __mpz_struct c[1],
                     __mpz_struct d[1])
{
  char *ap;
  char *bp;
  char *cp;
  char *dp;
  hex_random_op4(op,maxbits,& ap,& bp,& cp,& dp);
  set_str(a,(char const *)ap);
  set_str(b,(char const *)bp);
  set_str(c,(char const *)cp);
  set_str(d,(char const *)dp);
  free((void *)ap);
  free((void *)bp);
  free((void *)cp);
  free((void *)dp);
  return;
}

void mini_random_bit_op(enum hex_random_op op, unsigned long maxbits,
                        __mpz_struct a[1], mp_bitcnt_t *b, __mpz_struct r[1])
{
  char *ap;
  char *rp;
  hex_random_bit_op(op,maxbits,& ap,b,& rp);
  set_str(a,(char const *)ap);
  set_str(r,(char const *)rp);
  free((void *)ap);
  free((void *)rp);
  return;
}

void mini_random_scan_op(enum hex_random_op op, unsigned long maxbits,
                         __mpz_struct a[1], mp_bitcnt_t *b, mp_bitcnt_t *r)
{
  char *ap;
  hex_random_scan_op(op,maxbits,& ap,b,r);
  set_str(a,(char const *)ap);
  free((void *)ap);
  return;
}


