/* Generated by Frama-C */
#include "__fc_builtin.h"
#include "ctype.h"
#include "errno.h"
#include "fcntl.h"
#include "signal.h"
#include "stdarg.h"
#include "stddef.h"
#include "stdint.h"
#include "stdio.c"
#include "stdio.h"
#include "stdlib.h"
#include "string.c"
#include "string.h"
#include "strings.h"
#include "stropts.h"
#include "sys/select.h"
#include "sys/time.h"
#include "sys/types.h"
#include "termios.h"
#include "time.h"
#include "unistd.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
struct editorSyntax {
   char **filematch ;
   char **keywords ;
   char singleline_comment_start[2] ;
   char multiline_comment_start[3] ;
   char multiline_comment_end[3] ;
   int flags ;
};
struct erow {
   int idx ;
   int size ;
   int rsize ;
   char *chars ;
   char *render ;
   unsigned char *hl ;
   int hl_oc ;
};
typedef struct erow erow;
struct editorConfig {
   int cx ;
   int cy ;
   int rowoff ;
   int coloff ;
   int screenrows ;
   int screencols ;
   int numrows ;
   int rawmode ;
   erow *row ;
   int dirty ;
   char *filename ;
   char statusmsg[80] ;
   time_t statusmsg_time ;
   struct editorSyntax *syntax ;
};
enum KEY_ACTION {
    KEY_NULL = 0,
    CTRL_C = 3,
    CTRL_D = 4,
    CTRL_F = 6,
    CTRL_H = 8,
    TAB = 9,
    CTRL_L = 12,
    ENTER = 13,
    CTRL_Q = 17,
    CTRL_S = 19,
    CTRL_U = 21,
    ESC = 27,
    BACKSPACE = 127,
    ARROW_LEFT = 1000,
    ARROW_RIGHT = 1001,
    ARROW_UP = 1002,
    ARROW_DOWN = 1003,
    DEL_KEY = 1004,
    HOME_KEY = 1005,
    END_KEY = 1006,
    PAGE_UP = 1007,
    PAGE_DOWN = 1008
};
struct abuf {
   char *b ;
   int len ;
};
static struct editorConfig E;
void editorSetStatusMessage(char const *fmt, void * const *__va_params);

char *C_HL_extensions[3] = {(char *)".c", (char *)".cpp", (char *)0};
char *C_HL_keywords[23] =
  {(char *)"switch",
   (char *)"if",
   (char *)"while",
   (char *)"for",
   (char *)"break",
   (char *)"continue",
   (char *)"return",
   (char *)"else",
   (char *)"struct",
   (char *)"union",
   (char *)"typedef",
   (char *)"static",
   (char *)"enum",
   (char *)"class",
   (char *)"int|",
   (char *)"long|",
   (char *)"double|",
   (char *)"float|",
   (char *)"char|",
   (char *)"unsigned|",
   (char *)"signed|",
   (char *)"void|",
   (char *)0};
struct editorSyntax HLDB[1] =
  {{.filematch = C_HL_extensions,
    .keywords = C_HL_keywords,
    .singleline_comment_start = {(char)'/', (char)'/'},
    .multiline_comment_start = {(char)'/', (char)'*', (char)'\000'},
    .multiline_comment_end = {(char)'*', (char)'/', (char)'\000'},
    .flags = (1 << 0) | (1 << 1)}};
static struct termios orig_termios;
void disableRawMode(int fd)
{
  if (E.rawmode) {
    tcsetattr(fd,2,& orig_termios);
    E.rawmode = 0;
  }
  return;
}

void editorAtExit(void)
{
  disableRawMode(0);
  return;
}

int enableRawMode(int fd)
{
  int __retres;
  struct termios raw;
  int tmp;
  int tmp_0;
  int tmp_1;
  if (E.rawmode) {
    __retres = 0;
    goto return_label;
  }
  tmp = isatty(0);
  if (! tmp) goto fatal;
  atexit(& editorAtExit);
  tmp_0 = tcgetattr(fd,& orig_termios);
  if (tmp_0 == -1) goto fatal;
  raw = orig_termios;
  raw.c_iflag &= (unsigned int)(~ ((((0000002 | 0000400) | 0000020) | 0000040) | 0002000));
  raw.c_oflag &= (unsigned int)(~ 0000001);
  raw.c_cflag |= (unsigned int)0000060;
  raw.c_lflag &= (unsigned int)(~ (((0000010 | 0000002) | 0001000) | 0000001));
  raw.c_cc[6] = (cc_t)0;
  raw.c_cc[5] = (cc_t)1;
  tmp_1 = tcsetattr(fd,2,& raw);
  if (tmp_1 < 0) goto fatal;
  E.rawmode = 1;
  __retres = 0;
  goto return_label;
  fatal: __fc_errno = 25;
  __retres = -1;
  return_label: return __retres;
}

int editorReadKey(int fd)
{
  int __retres;
  int nread;
  char c;
  char seq[3];
  while (1) {
    nread = read(fd,(void *)(& c),(size_t)1);
    if (! (nread == 0)) break;
  }
  if (nread == -1) exit(1);
  while (1) 
    switch ((int)c) {
      ssize_t tmp;
      ssize_t tmp_0;
      case ESC: tmp = read(fd,(void *)(seq),(size_t)1);
      if (tmp == 0) {
        __retres = ESC;
        goto return_label;
      }
      tmp_0 = read(fd,(void *)(& seq[1]),(size_t)1);
      if (tmp_0 == 0) {
        __retres = ESC;
        goto return_label;
      }
      if ((int)seq[0] == '[') 
        if ((int)seq[1] >= '0') {
          if ((int)seq[1] <= '9') {
            ssize_t tmp_1;
            tmp_1 = read(fd,(void *)(& seq[2]),(size_t)1);
            if (tmp_1 == 0) {
              __retres = ESC;
              goto return_label;
            }
            if ((int)seq[2] == '~') 
              switch ((int)seq[1]) {
                case '3': __retres = DEL_KEY;
                goto return_label;
                case '5': __retres = PAGE_UP;
                goto return_label;
                case '6': __retres = PAGE_DOWN;
                goto return_label;
              }
          }
          else goto _LAND;
        }
        else 
          _LAND:
          switch ((int)seq[1]) {
            case 'A': __retres = ARROW_UP;
            goto return_label;
            case 'B': __retres = ARROW_DOWN;
            goto return_label;
            case 'C': __retres = ARROW_RIGHT;
            goto return_label;
            case 'D': __retres = ARROW_LEFT;
            goto return_label;
            case 'H': __retres = HOME_KEY;
            goto return_label;
            case 'F': __retres = END_KEY;
            goto return_label;
          }
      else 
        if ((int)seq[0] == 'O') 
          switch ((int)seq[1]) {
            case 'H': __retres = HOME_KEY;
            goto return_label;
            case 'F': __retres = END_KEY;
            goto return_label;
          }
      break;
      default: ;
      __retres = (int)c;
      goto return_label;
    }
  return_label: return __retres;
}

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_1(char const * restrict s, char const * restrict format,
                int *param0, int *param1);

int getCursorPosition(int ifd, int ofd, int *rows, int *cols)
{
  int __retres;
  char buf[32];
  ssize_t tmp;
  int tmp_1;
  unsigned int i = (unsigned int)0;
  tmp = write(ofd,(void const *)"\033[6n",(size_t)4);
  if (tmp != 4) {
    __retres = -1;
    goto return_label;
  }
  while (i < sizeof(buf) - (unsigned int)1) {
    ssize_t tmp_0;
    tmp_0 = read(ifd,(void *)(& buf[i]),(size_t)1);
    if (tmp_0 != 1) break;
    if ((int)buf[i] == 'R') break;
    i ++;
  }
  buf[i] = (char)'\000';
  if ((int)buf[0] != ESC) {
    __retres = -1;
    goto return_label;
  }
  else 
    if ((int)buf[1] != '[') {
      __retres = -1;
      goto return_label;
    }
  tmp_1 = sscanf((char const *)(& buf[2]),"%d;%d",rows,cols); /* sscanf_va_1 */
  if (tmp_1 != 2) {
    __retres = -1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) âˆ¨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: param1), (indirect: param0);
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param1, param0;
 */
int snprintf_va_1(char * restrict s, size_t n, char const * restrict format,
                  int param0, int param1);

int getWindowSize(int ifd, int ofd, int *rows, int *cols)
{
  int __retres;
  struct winsize ws;
  int tmp_2;
  tmp_2 = ioctl(1,0x5413,(void *)(& ws)); /* __va_ioctl_ptr */
  if (tmp_2 == -1) goto _LOR;
  else 
    if ((int)ws.ws_col == 0) {
      _LOR:
      {
        int orig_row;
        int orig_col;
        int retval;
        ssize_t tmp;
        char seq[32];
        ssize_t tmp_1;
        size_t tmp_0;
        retval = getCursorPosition(ifd,ofd,& orig_row,& orig_col);
        if (retval == -1) goto failed;
        tmp = write(ofd,(void const *)"\033[999C\033[999B",(size_t)12);
        if (tmp != 12) goto failed;
        retval = getCursorPosition(ifd,ofd,rows,cols);
        if (retval == -1) goto failed;
        snprintf(seq,(size_t)32,"\033[%d;%dH",orig_row,orig_col); /* snprintf_va_1 */
        tmp_0 = strlen((char const *)(seq));
        ;
        tmp_1 = write(ofd,(void const *)(seq),tmp_0);
        if (tmp_1 == -1) ;
        __retres = 0;
        goto return_label;
      }
    }
    else {
      *cols = (int)ws.ws_col;
      *rows = (int)ws.ws_row;
      __retres = 0;
      goto return_label;
    }
  failed: __retres = -1;
  return_label: return __retres;
}

int is_separator(int c)
{
  int tmp_1;
  if (c == '\000') tmp_1 = 1;
  else {
    int tmp;
    tmp = isspace(c);
    if (tmp) tmp_1 = 1;
    else {
      char *tmp_0;
      tmp_0 = strchr(",.()+-/*=~%[];",c);
      if (tmp_0 != (char *)0) tmp_1 = 1; else tmp_1 = 0;
    }
  }
  return tmp_1;
}

int editorRowHasOpenComment(erow *row)
{
  int __retres;
  if (row->hl) 
    if (row->rsize) 
      if ((int)*(row->hl + (row->rsize - 1)) == 3) 
        if (row->rsize < 2) {
          __retres = 1;
          goto return_label;
        }
        else 
          if ((int)*(row->render + (row->rsize - 2)) != '*') {
            __retres = 1;
            goto return_label;
          }
          else 
            if ((int)*(row->render + (row->rsize - 1)) != '/') {
              __retres = 1;
              goto return_label;
            }
  __retres = 0;
  return_label: return __retres;
}

void editorUpdateSyntax(erow *row)
{
  int i;
  int prev_sep;
  int in_string;
  int in_comment;
  char *p;
  row->hl = (unsigned char *)realloc((void *)row->hl,(size_t)row->rsize);
  memset((void *)row->hl,0,(size_t)row->rsize);
  if (E.syntax == (struct editorSyntax *)0) goto return_label;
  char **keywords = (E.syntax)->keywords;
  char *scs = (E.syntax)->singleline_comment_start;
  char *mcs = (E.syntax)->multiline_comment_start;
  char *mce = (E.syntax)->multiline_comment_end;
  p = row->render;
  i = 0;
  while (1) {
    if (*p) {
      int tmp;
      tmp = isspace((int)*p);
      if (! tmp) break;
    }
    else break;
    p ++;
    i ++;
  }
  prev_sep = 1;
  in_string = 0;
  in_comment = 0;
  if (row->idx > 0) {
    int tmp_0;
    tmp_0 = editorRowHasOpenComment(E.row + (row->idx - 1));
    if (tmp_0) in_comment = 1;
  }
  while (*p) {
    int tmp_1;
    int tmp_2;
    if (prev_sep) 
      if ((int)*p == (int)*(scs + 0)) 
        if ((int)*(p + 1) == (int)*(scs + 1)) {
          memset((void *)(row->hl + i),2,(size_t)(row->size - i));
          goto return_label;
        }
    if (in_comment) {
      *(row->hl + i) = (unsigned char)3;
      if ((int)*p == (int)*(mce + 0)) {
        if ((int)*(p + 1) == (int)*(mce + 1)) {
          *(row->hl + (i + 1)) = (unsigned char)3;
          p += 2;
          i += 2;
          in_comment = 0;
          prev_sep = 1;
          continue;
        }
        else goto _LAND;
      }
      else {
        _LAND: {
                 prev_sep = 0;
                 p ++;
                 i ++;
                 continue;
               }
      }
    }
    else 
      if ((int)*p == (int)*(mcs + 0)) 
        if ((int)*(p + 1) == (int)*(mcs + 1)) {
          *(row->hl + i) = (unsigned char)3;
          *(row->hl + (i + 1)) = (unsigned char)3;
          p += 2;
          i += 2;
          in_comment = 1;
          prev_sep = 0;
          continue;
        }
    if (in_string) {
      *(row->hl + i) = (unsigned char)6;
      if ((int)*p == '\\') {
        *(row->hl + (i + 1)) = (unsigned char)6;
        p += 2;
        i += 2;
        prev_sep = 0;
        continue;
      }
      if ((int)*p == in_string) in_string = 0;
      p ++;
      i ++;
      continue;
    }
    else 
      if ((int)*p == '\"') goto _LOR;
      else 
        if ((int)*p == '\'') {
          _LOR:
          {
            in_string = (int)*p;
            *(row->hl + i) = (unsigned char)6;
            p ++;
            i ++;
            prev_sep = 0;
            continue;
          }
        }
    tmp_1 = isprint((int)*p);
    if (! tmp_1) {
      *(row->hl + i) = (unsigned char)1;
      p ++;
      i ++;
      prev_sep = 0;
      continue;
    }
    tmp_2 = isdigit((int)*p);
    if (tmp_2) {
      if (prev_sep) goto _LOR_0;
      else 
        if ((int)*(row->hl + (i - 1)) == 7) goto _LOR_0; else goto _LAND_0;
    }
    else {
      _LAND_0: ;
      if ((int)*p == '.') 
        if (i > 0) 
          if ((int)*(row->hl + (i - 1)) == 7) {
            _LOR_0:
            {
              *(row->hl + i) = (unsigned char)7;
              p ++;
              i ++;
              prev_sep = 0;
              continue;
            }
          }
    }
    if (prev_sep) {
      int j;
      j = 0;
      while (*(keywords + j)) {
        {
          size_t tmp_3;
          int tmp_5;
          tmp_3 = strlen((char const *)*(keywords + j));
          int klen = (int)tmp_3;
          int kw2 = (int)*(*(keywords + j) + (klen - 1)) == '|';
          if (kw2) klen --;
          tmp_5 = memcmp((void const *)p,(void const *)*(keywords + j),
                         (size_t)klen);
          if (! tmp_5) {
            int tmp_6;
            tmp_6 = is_separator((int)*(p + klen));
            if (tmp_6) {
              int tmp_4;
              ;
              if (kw2) tmp_4 = 5; else tmp_4 = 4;
              ;
              memset((void *)(row->hl + i),tmp_4,(size_t)klen);
              p += klen;
              i += klen;
              break;
            }
          }
        }
        j ++;
      }
      if (*(keywords + j) != (char *)0) {
        prev_sep = 0;
        continue;
      }
    }
    prev_sep = is_separator((int)*p);
    p ++;
    i ++;
  }
  int oc = editorRowHasOpenComment(row);
  row->hl_oc = oc;
  return_label: return;
}

int editorSyntaxToColor(int hl)
{
  int __retres;
  switch (hl) {
    case 2: case 3: __retres = 36;
    goto return_label;
    case 4: __retres = 33;
    goto return_label;
    case 5: __retres = 32;
    goto return_label;
    case 6: __retres = 35;
    goto return_label;
    case 7: __retres = 31;
    goto return_label;
    case 8: __retres = 34;
    goto return_label;
    default: __retres = 37;
    goto return_label;
  }
  return_label: return __retres;
}

void editorSelectSyntaxHighlight(char *filename)
{
  unsigned int j = (unsigned int)0;
  while (j < sizeof(HLDB) / sizeof(HLDB[0])) {
    {
      struct editorSyntax *s = & HLDB[j];
      unsigned int i = (unsigned int)0;
      while (*(s->filematch + i)) {
        char *p;
        size_t tmp;
        tmp = strlen((char const *)*(s->filematch + i));
        int patlen = (int)tmp;
        p = strstr((char const *)filename,(char const *)*(s->filematch + i));
        if (p != (char *)0) 
          if ((int)*(*(s->filematch + i) + 0) != '.') goto _LOR;
          else 
            if ((int)*(p + patlen) == '\000') {
              _LOR: {
                      E.syntax = s;
                      goto return_label;
                    }
            }
        i ++;
      }
    }
    j ++;
  }
  return_label: return;
}

void editorUpdateRow(erow *row)
{
  int j;
  int idx;
  int tabs = 0;
  int nonprint = 0;
  free((void *)row->render);
  j = 0;
  while (j < row->size) {
    if ((int)*(row->chars + j) == TAB) tabs ++;
    j ++;
  }
  row->render = (char *)malloc((size_t)(((row->size + tabs * 8) + nonprint * 9) + 1));
  idx = 0;
  j = 0;
  while (j < row->size) {
    if ((int)*(row->chars + j) == TAB) {
      int tmp;
      tmp = idx;
      idx ++;
      *(row->render + tmp) = (char)' ';
      while ((idx + 1) % 8 != 0) {
        int tmp_0;
        tmp_0 = idx;
        idx ++;
        *(row->render + tmp_0) = (char)' ';
      }
    }
    else {
      int tmp_1;
      tmp_1 = idx;
      idx ++;
      *(row->render + tmp_1) = *(row->chars + j);
    }
    j ++;
  }
  row->rsize = idx;
  *(row->render + idx) = (char)'\000';
  editorUpdateSyntax(row);
  return;
}

void editorInsertRow(int at, char *s, size_t len)
{
  if (at > E.numrows) goto return_label;
  E.row = (erow *)realloc((void *)E.row,
                          sizeof(erow) * (unsigned int)(E.numrows + 1));
  if (at != E.numrows) {
    memmove((void *)((E.row + at) + 1),(void const *)(E.row + at),
            sizeof(*(E.row + 0)) * (unsigned int)(E.numrows - at));
    {
      int j = at + 1;
      while (j <= E.numrows) {
        ((E.row + j)->idx) ++;
        j ++;
      }
    }
  }
  (E.row + at)->size = (int)len;
  (E.row + at)->chars = (char *)malloc(len + (size_t)1);
  memcpy((void *)(E.row + at)->chars,(void const *)s,len + (size_t)1);
  (E.row + at)->hl = (unsigned char *)0;
  (E.row + at)->hl_oc = 0;
  (E.row + at)->render = (char *)0;
  (E.row + at)->rsize = 0;
  (E.row + at)->idx = at;
  editorUpdateRow(E.row + at);
  (E.numrows) ++;
  (E.dirty) ++;
  return_label: return;
}

void editorFreeRow(erow *row)
{
  free((void *)row->render);
  free((void *)row->chars);
  free((void *)row->hl);
  return;
}

void editorDelRow(int at)
{
  erow *row;
  if (at >= E.numrows) goto return_label;
  row = E.row + at;
  editorFreeRow(row);
  memmove((void *)(E.row + at),(void const *)((E.row + at) + 1),
          sizeof(*(E.row + 0)) * (unsigned int)((E.numrows - at) - 1));
  {
    int j = at;
    while (j < E.numrows - 1) {
      ((E.row + j)->idx) ++;
      j ++;
    }
  }
  (E.numrows) --;
  (E.dirty) ++;
  return_label: return;
}

char *editorRowsToString(int *buflen)
{
  char *p;
  int j;
  char *buf = (char *)0;
  int totlen = 0;
  j = 0;
  while (j < E.numrows) {
    totlen += (E.row + j)->size + 1;
    j ++;
  }
  *buflen = totlen;
  totlen ++;
  buf = (char *)malloc((size_t)totlen);
  p = buf;
  j = 0;
  while (j < E.numrows) {
    memcpy((void *)p,(void const *)(E.row + j)->chars,
           (size_t)(E.row + j)->size);
    p += (E.row + j)->size;
    *p = (char)'\n';
    p ++;
    j ++;
  }
  *p = (char)'\000';
  return buf;
}

void editorRowInsertChar(erow *row, int at, int c)
{
  if (at > row->size) {
    int padlen = at - row->size;
    row->chars = (char *)realloc((void *)row->chars,
                                 (size_t)((row->size + padlen) + 2));
    memset((void *)(row->chars + row->size),' ',(size_t)padlen);
    *(row->chars + ((row->size + padlen) + 1)) = (char)'\000';
    row->size += padlen + 1;
  }
  else {
    row->chars = (char *)realloc((void *)row->chars,(size_t)(row->size + 2));
    memmove((void *)((row->chars + at) + 1),(void const *)(row->chars + at),
            (size_t)((row->size - at) + 1));
    (row->size) ++;
  }
  *(row->chars + at) = (char)c;
  editorUpdateRow(row);
  (E.dirty) ++;
  return;
}

void editorRowAppendString(erow *row, char *s, size_t len)
{
  row->chars = (char *)realloc((void *)row->chars,
                               ((size_t)row->size + len) + (size_t)1);
  memcpy((void *)(row->chars + row->size),(void const *)s,len);
  row->size = (int)((size_t)row->size + len);
  *(row->chars + row->size) = (char)'\000';
  editorUpdateRow(row);
  (E.dirty) ++;
  return;
}

void editorRowDelChar(erow *row, int at)
{
  if (row->size <= at) goto return_label;
  memmove((void *)(row->chars + at),(void const *)((row->chars + at) + 1),
          (size_t)(row->size - at));
  editorUpdateRow(row);
  (row->size) --;
  (E.dirty) ++;
  return_label: return;
}

void editorInsertChar(int c)
{
  erow *tmp;
  int filerow = E.rowoff + E.cy;
  int filecol = E.coloff + E.cx;
  if (filerow >= E.numrows) tmp = (erow *)0; else tmp = E.row + filerow;
  erow *row = tmp;
  if (! row) 
    while (E.numrows <= filerow) editorInsertRow(E.numrows,(char *)"",
                                                 (size_t)0);
  row = E.row + filerow;
  editorRowInsertChar(row,filecol,c);
  if (E.cx == E.screencols - 1) (E.coloff) ++; else (E.cx) ++;
  (E.dirty) ++;
  return;
}

void editorInsertNewline(void)
{
  erow *tmp;
  int filerow = E.rowoff + E.cy;
  int filecol = E.coloff + E.cx;
  if (filerow >= E.numrows) tmp = (erow *)0; else tmp = E.row + filerow;
  erow *row = tmp;
  if (! row) {
    if (filerow == E.numrows) {
      editorInsertRow(filerow,(char *)"",(size_t)0);
      goto fixcursor;
    }
    goto return_label;
  }
  if (filecol >= row->size) filecol = row->size;
  if (filecol == 0) editorInsertRow(filerow,(char *)"",(size_t)0);
  else {
    editorInsertRow(filerow + 1,row->chars + filecol,
                    (size_t)(row->size - filecol));
    row = E.row + filerow;
    *(row->chars + filecol) = (char)'\000';
    row->size = filecol;
    editorUpdateRow(row);
  }
  fixcursor: ;
  if (E.cy == E.screenrows - 1) (E.rowoff) ++; else (E.cy) ++;
  E.cx = 0;
  E.coloff = 0;
  return_label: return;
}

void editorDelChar(void)
{
  erow *tmp;
  int filerow = E.rowoff + E.cy;
  int filecol = E.coloff + E.cx;
  if (filerow >= E.numrows) tmp = (erow *)0; else tmp = E.row + filerow;
  erow *row = tmp;
  if (! row) goto return_label;
  else 
    if (filecol == 0) 
      if (filerow == 0) goto return_label;
  if (filecol == 0) {
    filecol = (E.row + (filerow - 1))->size;
    editorRowAppendString(E.row + (filerow - 1),row->chars,(size_t)row->size);
    editorDelRow(filerow);
    row = (erow *)0;
    if (E.cy == 0) (E.rowoff) --; else (E.cy) --;
    E.cx = filecol;
    if (E.cx >= E.screencols) {
      int shift = (E.screencols - E.cx) + 1;
      E.cx -= shift;
      E.coloff += shift;
    }
  }
  else {
    editorRowDelChar(row,filecol - 1);
    if (E.cx == 0) 
      if (E.coloff) (E.coloff) --; else (E.cx) --;
    else (E.cx) --;
  }
  if (row) editorUpdateRow(row);
  (E.dirty) ++;
  return_label: return;
}

int editorOpen(char *filename)
{
  int __retres;
  FILE *fp;
  ssize_t linelen;
  E.dirty = 0;
  free((void *)E.filename);
  E.filename = strdup((char const *)filename);
  fp = fopen((char const *)filename,"r");
  if (! fp) {
    if (__fc_errno != 2) {
      perror("Opening file");
      exit(1);
    }
    __retres = 1;
    goto return_label;
  }
  char *line = (char *)0;
  size_t linecap = (size_t)0;
  while (1) {
    linelen = getline(& line,& linecap,fp);
    if (! (linelen != -1)) break;
    if (linelen) 
      if ((int)*(line + (linelen - 1)) == '\n') goto _LOR;
      else 
        if ((int)*(line + (linelen - 1)) == '\r') {
          _LOR:
          { /* sequence */
            linelen --;
            *(line + linelen) = (char)'\000';
          }
        }
    editorInsertRow(E.numrows,line,(size_t)linelen);
  }
  free((void *)line);
  fclose(fp);
  E.dirty = 0;
  __retres = 0;
  return_label: return __retres;
}

int editorSave(void)
{
  int __retres;
  int len;
  int tmp_1;
  ssize_t tmp_2;
  char *tmp_3;
  char *buf = editorRowsToString(& len);
  int fd = __va_open_mode_t((char const *)E.filename,2 | 0x40,(mode_t)0644);
  if (fd == -1) goto writeerr;
  tmp_1 = ftruncate(fd,(off_t)len);
  if (tmp_1 == -1) goto writeerr;
  tmp_2 = write(fd,(void const *)buf,(size_t)len);
  ;
  if (tmp_2 != len) goto writeerr;
  close(fd);
  free((void *)buf);
  E.dirty = 0;
  {
    int __va_arg0 = len;
    void *__va_args[1] = {& __va_arg0};
    editorSetStatusMessage("%d bytes written on disk",
                           (void * const *)(__va_args));
  }
  __retres = 0;
  goto return_label;
  writeerr: free((void *)buf);
  if (fd != -1) close(fd);
  tmp_3 = strerror(__fc_errno);
  {
    char *__va_arg0_12 = tmp_3;
    void *__va_args_14[1] = {& __va_arg0_12};
    editorSetStatusMessage("Can\'t save! I/O error: %s",
                           (void * const *)(__va_args_14));
  }
  __retres = 1;
  return_label: return __retres;
}

void abAppend(struct abuf *ab, char const *s, int len)
{
  char *new = realloc((void *)ab->b,(size_t)(ab->len + len));
  if (new == (char *)0) goto return_label;
  memcpy((void *)(new + ab->len),(void const *)s,(size_t)len);
  ab->b = new;
  ab->len += len;
  return_label: return;
}

void abFree(struct abuf *ab)
{
  free((void *)ab->b);
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) âˆ¨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int snprintf_va_2(char * restrict s, size_t n, char const * restrict format,
                  char *param0);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) âˆ¨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))), (indirect: param0);
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param0;
 */
int snprintf_va_3(char * restrict s, size_t n, char const * restrict format,
                  int param0);

/*@ requires valid_read_nstring(param0, 20);
    requires valid_read_string(param2);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) âˆ¨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: *(param2 + (0 ..))), (indirect: param1),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))),
            *(param2 + (0 ..)), param1, *(param0 + (0 ..));
 */
int snprintf_va_4(char * restrict s, size_t n, char const * restrict format,
                  char *param0, int param1, char *param2);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) âˆ¨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: param1), (indirect: param0);
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param1, param0;
 */
int snprintf_va_5(char * restrict s, size_t n, char const * restrict format,
                  int param0, int param1);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) âˆ¨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: param1), (indirect: param0);
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param1, param0;
 */
int snprintf_va_6(char * restrict s, size_t n, char const * restrict format,
                  int param0, int param1);

void editorRefreshScreen(void)
{
  int y;
  erow *r;
  char buf[32];
  char status[80];
  char rstatus[80];
  int tmp_4;
  char const *tmp_3;
  size_t tmp_6;
  int j_0;
  erow *tmp_9;
  size_t tmp_10;
  struct abuf ab = {.b = (char *)0, .len = 0};
  abAppend(& ab,"\033[?25l",6);
  abAppend(& ab,"\033[H",3);
  y = 0;
  while (y < E.screenrows) {
    {
      int filerow = E.rowoff + y;
      if (filerow >= E.numrows) {
        if (E.numrows == 0) {
          if (y == E.screenrows / 3) {
            char welcome[80];
            int welcomelen =
              snprintf_va_2(welcome,sizeof(welcome),
                            "Kilo editor -- verison %s\033[0K\r\n",
                            (char *)"0.0.1");
            int padding = (E.screencols - welcomelen) / 2;
            if (padding) {
              abAppend(& ab,"~",1);
              padding --;
            }
            while (1) {
              int tmp_0;
              tmp_0 = padding;
              padding --;
              ;
              if (! tmp_0) break;
              abAppend(& ab," ",1);
            }
            abAppend(& ab,(char const *)(welcome),welcomelen);
          }
          else goto _LAND;
        }
        else _LAND: abAppend(& ab,"~\033[0K\r\n",7);
        goto __Cont;
      }
      r = E.row + filerow;
      int len = r->rsize - E.coloff;
      int current_color = -1;
      if (len > 0) {
        int j;
        if (len > E.screencols) len = E.screencols;
        char *c = r->render + E.coloff;
        unsigned char *hl = r->hl + E.coloff;
        j = 0;
        while (j < len) {
          if ((int)*(hl + j) == 1) {
            char sym;
            abAppend(& ab,"\033[7m",4);
            if ((int)*(c + j) <= 26) sym = (char)('@' + (int)*(c + j));
            else sym = (char)'?';
            abAppend(& ab,(char const *)(& sym),1);
            abAppend(& ab,"\033[0m",4);
          }
          else 
            if ((int)*(hl + j) == 0) {
              if (current_color != -1) {
                abAppend(& ab,"\033[39m",5);
                current_color = -1;
              }
              abAppend(& ab,(char const *)(c + j),1);
            }
            else {
              int color = editorSyntaxToColor((int)*(hl + j));
              if (color != current_color) {
                char buf_0[16];
                int clen =
                  snprintf_va_3(buf_0,sizeof(buf_0),"\033[%dm",color);
                current_color = color;
                abAppend(& ab,(char const *)(buf_0),clen);
              }
              abAppend(& ab,(char const *)(c + j),1);
            }
          j ++;
        }
      }
      abAppend(& ab,"\033[39m",5);
      abAppend(& ab,"\033[0K",4);
      abAppend(& ab,"\r\n",2);
    }
    __Cont: y ++;
  }
  abAppend(& ab,"\033[0K",4);
  abAppend(& ab,"\033[7m",4);
  if (E.dirty) tmp_3 = "(modified)"; else tmp_3 = "";
  ;
  ;
  tmp_4 = snprintf(status,sizeof(status),"%.20s - %d lines %s",E.filename,
                   E.numrows,(char *)tmp_3); /* snprintf_va_4 */
  int len_0 = tmp_4;
  int rlen =
    snprintf_va_5(rstatus,sizeof(rstatus),"%d/%d",(E.rowoff + E.cy) + 1,
                  E.numrows);
  if (len_0 > E.screencols) len_0 = E.screencols;
  abAppend(& ab,(char const *)(status),len_0);
  while (len_0 < E.screencols) 
    if (E.screencols - len_0 == rlen) {
      abAppend(& ab,(char const *)(rstatus),rlen);
      break;
    }
    else {
      abAppend(& ab," ",1);
      len_0 ++;
    }
  abAppend(& ab,"\033[0m\r\n",6);
  abAppend(& ab,"\033[0K",4);
  tmp_6 = strlen((char const *)(E.statusmsg));
  int msglen = (int)tmp_6;
  if (msglen) {
    time_t tmp_8;
    tmp_8 = time((time_t *)0);
    ;
    if (tmp_8 - E.statusmsg_time < (time_t)5) {
      int tmp_7;
      if (msglen <= E.screencols) tmp_7 = msglen; else tmp_7 = E.screencols;
      ;
      abAppend(& ab,(char const *)(E.statusmsg),tmp_7);
    }
  }
  int cx = 1;
  int filerow_0 = E.rowoff + E.cy;
  if (filerow_0 >= E.numrows) tmp_9 = (erow *)0;
  else tmp_9 = E.row + filerow_0;
  erow *row = tmp_9;
  if (row) {
    j_0 = E.coloff;
    while (j_0 < E.cx + E.coloff) {
      if (j_0 < row->size) 
        if ((int)*(row->chars + j_0) == TAB) cx += 7 - cx % 8;
      cx ++;
      j_0 ++;
    }
  }
  snprintf(buf,sizeof(buf),"\033[%d;%dH",E.cy + 1,cx); /* snprintf_va_6 */
  tmp_10 = strlen((char const *)(buf));
  abAppend(& ab,(char const *)(buf),(int)tmp_10);
  abAppend(& ab,"\033[?25h",6);
  write(1,(void const *)ab.b,(size_t)ab.len);
  abFree(& ab);
  return;
}

void editorSetStatusMessage(char const *fmt, void * const *__va_params)
{
  va_list ap;
  ap = __va_params;
  vsnprintf(E.statusmsg,sizeof(E.statusmsg),fmt,ap);
  E.statusmsg_time = time((time_t *)0);
  return;
}

void editorFind(int fd)
{
  char query[256 + 1] = {(char)0};
  int qlen = 0;
  int last_match = -1;
  int find_next = 0;
  int saved_hl_line = -1;
  char *saved_hl = (char *)0;
  int saved_cx = E.cx;
  int saved_cy = E.cy;
  int saved_coloff = E.coloff;
  int saved_rowoff = E.rowoff;
  while (1) {
    {
      {
        char *__va_arg0 = query;
        void *__va_args[1] = {& __va_arg0};
        editorSetStatusMessage("Search: %s (Use ESC/Arrows/Enter)",
                               (void * const *)(__va_args));
      }
      editorRefreshScreen();
      int c = editorReadKey(fd);
      if (c == DEL_KEY) goto _LOR_2;
      else 
        if (c == CTRL_H) goto _LOR_2;
        else 
          if (c == BACKSPACE) {
            _LOR_2:
            {
              if (qlen != 0) {
                qlen --;
                query[qlen] = (char)'\000';
              }
              last_match = -1;
            }
          }
          else 
            if (c == ESC) goto _LOR_1;
            else 
              if (c == ENTER) {
                _LOR_1:
                {
                  if (c == ESC) {
                    E.cx = saved_cx;
                    E.cy = saved_cy;
                    E.coloff = saved_coloff;
                    E.rowoff = saved_rowoff;
                  }
                  if (saved_hl) {
                    memcpy((void *)(E.row + saved_hl_line)->hl,
                           (void const *)saved_hl,
                           (size_t)(E.row + saved_hl_line)->rsize);
                    saved_hl = (char *)0;
                  }
                  {
                    void *__va_args_25[1] = {(void *)0};
                    editorSetStatusMessage("",(void * const *)(__va_args_25));
                  }
                  goto return_label;
                }
              }
              else 
                if (c == ARROW_RIGHT) goto _LOR_0;
                else 
                  if (c == ARROW_DOWN) _LOR_0: find_next = 1;
                  else 
                    if (c == ARROW_LEFT) goto _LOR;
                    else 
                      if (c == ARROW_UP) _LOR: find_next = -1;
                      else {
                        int tmp_1;
                        tmp_1 = isprint(c);
                        if (tmp_1) 
                          if (qlen < 256) {
                            int tmp_0;
                            tmp_0 = qlen;
                            qlen ++;
                            query[tmp_0] = (char)c;
                            query[qlen] = (char)'\000';
                            last_match = -1;
                          }
                      }
      if (last_match == -1) find_next = 1;
      if (find_next) {
        int i;
        char *match = (char *)0;
        int match_offset = 0;
        int current = last_match;
        i = 0;
        while (i < E.numrows) {
          current += find_next;
          if (current == -1) current = E.numrows - 1;
          else 
            if (current == E.numrows) current = 0;
          match = strstr((char const *)(E.row + current)->render,
                         (char const *)(query));
          if (match) {
            match_offset = match - (E.row + current)->render;
            break;
          }
          i ++;
        }
        find_next = 0;
        if (saved_hl) {
          memcpy((void *)(E.row + saved_hl_line)->hl,(void const *)saved_hl,
                 (size_t)(E.row + saved_hl_line)->rsize);
          saved_hl = (char *)0;
        }
        if (match) {
          erow *row = E.row + current;
          last_match = current;
          if (row->hl) {
            saved_hl_line = current;
            saved_hl = (char *)malloc((size_t)row->rsize);
            memcpy((void *)saved_hl,(void const *)row->hl,(size_t)row->rsize);
            memset((void *)(row->hl + match_offset),8,(size_t)qlen);
          }
          E.cy = 0;
          E.cx = match_offset;
          E.rowoff = current;
          E.coloff = 0;
          if (E.cx > E.screencols) {
            int diff = E.cx - E.screencols;
            E.cx -= diff;
            E.coloff += diff;
          }
        }
      }
    }
  }
  return_label: return;
}

void editorMoveCursor(int key)
{
  int rowlen;
  erow *tmp;
  int filerow = E.rowoff + E.cy;
  int filecol = E.coloff + E.cx;
  if (filerow >= E.numrows) tmp = (erow *)0; else tmp = E.row + filerow;
  erow *row = tmp;
  switch (key) {
    case ARROW_LEFT: ;
    if (E.cx == 0) {
      if (E.coloff) (E.coloff) --;
      else 
        if (filerow > 0) {
          (E.cy) --;
          E.cx = (E.row + (filerow - 1))->size;
          if (E.cx > E.screencols - 1) {
            E.coloff = (E.cx - E.screencols) + 1;
            E.cx = E.screencols - 1;
          }
        }
    }
    else (E.cx) --;
    break;
    case ARROW_RIGHT: ;
    if (row) {
      if (filecol < row->size) 
        if (E.cx == E.screencols - 1) (E.coloff) ++; else (E.cx) ++;
      else goto _LAND;
    }
    else {
      _LAND: ;
      if (row) 
        if (filecol == row->size) {
          E.cx = 0;
          E.coloff = 0;
          if (E.cy == E.screenrows - 1) (E.rowoff) ++; else (E.cy) ++;
        }
    }
    break;
    case ARROW_UP: ;
    if (E.cy == 0) {
      if (E.rowoff) (E.rowoff) --;
    }
    else (E.cy) --;
    break;
    case ARROW_DOWN: ;
    if (filerow < E.numrows) 
      if (E.cy == E.screenrows - 1) (E.rowoff) ++; else (E.cy) ++;
    break;
  }
  filerow = E.rowoff + E.cy;
  filecol = E.coloff + E.cx;
  if (filerow >= E.numrows) row = (erow *)0; else row = E.row + filerow;
  if (row) rowlen = row->size; else rowlen = 0;
  if (filecol > rowlen) {
    E.cx -= filecol - rowlen;
    if (E.cx < 0) {
      E.coloff += E.cx;
      E.cx = 0;
    }
  }
  return;
}

void editorProcessKeypress(int fd);

static int editorProcessKeypress_quit_times = 3;
void editorProcessKeypress(int fd)
{
  int c = editorReadKey(fd);
  switch (c) {
    case ENTER: editorInsertNewline();
    break;
    case CTRL_C: break;
    case CTRL_Q: ;
    if (E.dirty) 
      if (editorProcessKeypress_quit_times) {
        {
          int __va_arg0 = editorProcessKeypress_quit_times;
          void *__va_args[1] = {& __va_arg0};
          editorSetStatusMessage("WARNING!!! File has unsaved changes. Press Ctrl-Q %d more times to quit.",
                                 (void * const *)(__va_args));
        }
        editorProcessKeypress_quit_times --;
        goto return_label;
      }
    exit(0);
    break;
    case CTRL_S: editorSave();
    break;
    case CTRL_F: editorFind(fd);
    break;
    case BACKSPACE: case CTRL_H: case DEL_KEY: editorDelChar();
    break;
    case PAGE_UP: case PAGE_DOWN: ;
    if (c == PAGE_UP) {
      if (E.cy != 0) E.cy = 0; else goto _LAND;
    }
    else {
      _LAND: ;
      if (c == PAGE_DOWN) 
        if (E.cy != E.screenrows - 1) E.cy = E.screenrows - 1;
    }
    {
      int times = E.screenrows;
      while (1) {
        int tmp_1;
        int tmp_0;
        tmp_1 = times;
        times --;
        ;
        if (! tmp_1) break;
        if (c == PAGE_UP) tmp_0 = ARROW_UP; else tmp_0 = ARROW_DOWN;
        editorMoveCursor(tmp_0);
      }
    }
    break;
    case ARROW_UP: case ARROW_DOWN: case ARROW_LEFT: case ARROW_RIGHT:
    editorMoveCursor(c);
    break;
    case CTRL_L: break;
    case ESC: break;
    default: editorInsertChar(c);
    break;
  }
  editorProcessKeypress_quit_times = 3;
  return_label: return;
}

int editorFileWasModified(void)
{
  int __retres;
  __retres = E.dirty;
  return __retres;
}

void initEditor(void)
{
  int tmp;
  E.cx = 0;
  E.cy = 0;
  E.rowoff = 0;
  E.coloff = 0;
  E.numrows = 0;
  E.row = (erow *)0;
  E.dirty = 0;
  E.filename = (char *)0;
  E.syntax = (struct editorSyntax *)0;
  tmp = getWindowSize(0,1,& E.screenrows,& E.screencols);
  if (tmp == -1) {
    perror("Unable to query the screen for size (columns / rows)");
    exit(1);
  }
  E.screenrows -= 2;
  return;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_1(FILE * restrict stream, char const * restrict format);

int main(int argc, char **argv)
{
  int __retres;
  if (argc != 2) {
    fprintf(__fc_stderr,"Usage: kilo <filename>\n"); /* fprintf_va_1 */
    exit(1);
  }
  initEditor();
  editorSelectSyntaxHighlight(*(argv + 1));
  editorOpen(*(argv + 1));
  enableRawMode(0);
  {
    void *__va_args[1] = {(void *)0};
    editorSetStatusMessage("HELP: Ctrl-S = save | Ctrl-Q = quit | Ctrl-F = find",
                           (void * const *)(__va_args));
  }
  while (1) {
    editorRefreshScreen();
    editorProcessKeypress(0);
  }
  __retres = 0;
  return __retres;
}

ssize_t getdelim(char **lineptr, size_t *n, int delim, FILE *stream);

/*@ requires valid_n: \valid(n);
    requires valid_lineptr: \valid(lineptr);
    requires valid_stream: \valid_read(stream);
    requires representable: delim â‰¢ -1;
    requires
      lineptr â‰¡ \null âˆ¨
      (\valid(*lineptr + (0 .. *n - 1)) âˆ§ \freeable(*lineptr));
    ensures \result â‰¡ -1 âˆ¨ \result â‰¥ 0;
    assigns \result, *lineptr, *(*lineptr + (0 ..)), *n, *stream;
    assigns \result
      \from (indirect: lineptr), (indirect: n), (indirect: delim),
            (indirect: stream), (indirect: *lineptr), (indirect: *n),
            (indirect: *stream), (indirect: *(*lineptr + (0 ..)));
    assigns *lineptr
      \from (indirect: lineptr), (indirect: n), (indirect: delim),
            (indirect: stream), (indirect: *lineptr), (indirect: *n),
            (indirect: *stream), (indirect: *(*lineptr + (0 ..)));
    assigns *(*lineptr + (0 ..))
      \from (indirect: lineptr), (indirect: n), (indirect: delim),
            (indirect: stream), (indirect: *lineptr), (indirect: *n),
            (indirect: *stream), (indirect: *(*lineptr + (0 ..)));
    assigns *n
      \from (indirect: lineptr), (indirect: n), (indirect: delim),
            (indirect: stream), (indirect: *lineptr), (indirect: *n),
            (indirect: *stream), (indirect: *(*lineptr + (0 ..)));
    assigns *stream
      \from (indirect: lineptr), (indirect: n), (indirect: delim),
            (indirect: stream), (indirect: *lineptr), (indirect: *n),
            (indirect: *stream), (indirect: *(*lineptr + (0 ..)));
 */
ssize_t getdelim(char **lineptr, size_t *n, int delim, FILE *stream)
{
  ssize_t __retres;
  size_t i;
  char c;
  int tmp;
  size_t tmp_1;
  /*@ assert \valid(lineptr); */ ;
  /*@ assert \valid(n); */ ;
  /*@ assert (lineptr â‰¡ \null âˆ§ *n â‰¡ 0) âˆ¨ \freeable(lineptr); */ ;
  if (*lineptr == (char *)0) {
    *lineptr = (char *)malloc((size_t)128);
    if (! *lineptr) {
      __retres = -1;
      goto return_label;
    }
    *n = (size_t)128;
  }
  i = (size_t)0;
  tmp = getc(stream);
  c = (char)tmp;
  while ((int)c != -1) {
    int tmp_0;
    if (i == *n) {
      if (4294967295U - *n < (unsigned int)128) {
        __retres = -1;
        goto return_label;
      }
      *lineptr = (char *)realloc((void *)*lineptr,*n + (size_t)128);
      if (! *lineptr) {
        __retres = -1;
        goto return_label;
      }
      *n += (size_t)128;
    }
    *(*lineptr + i) = c;
    i ++;
    if ((int)c == delim) break;
    tmp_0 = getc(stream);
    c = (char)tmp_0;
  }
  if (i == *n) {
    (*n) ++;
    *lineptr = (char *)realloc((void *)*lineptr,*n);
    if (*lineptr == (char *)0) {
      __retres = -1;
      goto return_label;
    }
  }
  *(*lineptr + i) = (char)0;
  if ((int)c == -1) 
    if (i == (size_t)0) tmp_1 = (size_t)(-1); else tmp_1 = i;
  else tmp_1 = i;
  __retres = (ssize_t)tmp_1;
  return_label: return __retres;
}

int eva_main(void)
{
  char argv0[256];
  char argv1[256];
  char argv2[256];
  char argv3[256];
  char argv4[256];
  int tmp_0;
  int argc = Frama_C_interval(0,5);
  char *argv[6] = {argv0, argv1, argv2, argv3, argv4, (char *)0};
  {
    int i = 0;
    /*@ loop unroll 5; */
    while (i < 5) {
      Frama_C_make_unknown(argv[i],(size_t)255);
      *(argv[i] + 255) = (char)0;
      i ++;
    }
  }
  tmp_0 = main(argc,argv);
  return tmp_0;
}


