/* Generated by Frama-C */
#include "__fc_builtin.h"
#include "assert.h"
#include "ctype.h"
#include "errno.h"
#include "fcntl.h"
#include "glob.c"
#include "glob.h"
#include "grp.h"
#include "inttypes.h"
#include "math.h"
#include "netdb.c"
#include "netdb.h"
#include "netinet/in.h"
#include "pwd.h"
#include "resolv.h"
#include "signal.h"
#include "stdarg.h"
#include "stdint.h"
#include "stdio.c"
#include "stdio.h"
#include "stdlib.c"
#include "stdlib.h"
#include "string.c"
#include "string.h"
#include "strings.h"
#include "stropts.h"
#include "sys/resource.h"
#include "sys/select.h"
#include "sys/socket.h"
#include "sys/stat.h"
#include "sys/time.h"
#include "sys/types.h"
#include "sys/uio.h"
#include "sys/un.h"
#include "sys/wait.h"
#include "syslog.h"
#include "time.h"
#include "unistd.h"
enum __anonenum_LOG_Severity_1 {
    LOGS_INFO = 0,
    LOGS_WARN = 1,
    LOGS_ERR = 2,
    LOGS_FATAL = 3,
    LOGS_DEBUG = 4
};
typedef enum __anonenum_LOG_Severity_1 LOG_Severity;
typedef int LOG_FileID;
union __anonunion_addr_3 {
   uint32_t in4 ;
   uint8_t in6[16] ;
};
struct __anonstruct_IPAddr_2 {
   union __anonunion_addr_3 addr ;
   uint16_t family ;
   uint16_t _pad ;
};
typedef struct __anonstruct_IPAddr_2 IPAddr;
struct __anonstruct_NTP_Remote_Address_4 {
   IPAddr ip_addr ;
   unsigned short port ;
};
typedef struct __anonstruct_NTP_Remote_Address_4 NTP_Remote_Address;
struct __anonstruct_NTP_Local_Address_5 {
   IPAddr ip_addr ;
   int if_index ;
   int sock_fd ;
};
typedef struct __anonstruct_NTP_Local_Address_5 NTP_Local_Address;
struct __anonstruct_NTP_int64_6 {
   uint32_t hi ;
   uint32_t lo ;
};
typedef struct __anonstruct_NTP_int64_6 NTP_int64;
typedef uint32_t NTP_int32;
enum __anonenum_NTP_Leap_7 {
    LEAP_Normal = 0,
    LEAP_InsertSecond = 1,
    LEAP_DeleteSecond = 2,
    LEAP_Unsynchronised = 3
};
typedef enum __anonenum_NTP_Leap_7 NTP_Leap;
enum __anonenum_NTP_Mode_8 {
    MODE_UNDEFINED = 0,
    MODE_ACTIVE = 1,
    MODE_PASSIVE = 2,
    MODE_CLIENT = 3,
    MODE_SERVER = 4,
    MODE_BROADCAST = 5
};
typedef enum __anonenum_NTP_Mode_8 NTP_Mode;
struct __anonstruct_NTP_Packet_9 {
   uint8_t lvm ;
   uint8_t stratum ;
   int8_t poll ;
   int8_t precision ;
   NTP_int32 root_delay ;
   NTP_int32 root_dispersion ;
   NTP_int32 reference_id ;
   NTP_int64 reference_ts ;
   NTP_int64 originate_ts ;
   NTP_int64 receive_ts ;
   NTP_int64 transmit_ts ;
   NTP_int32 auth_keyid ;
   uint8_t auth_data[(4 + 64) - 4] ;
};
typedef struct __anonstruct_NTP_Packet_9 NTP_Packet;
struct __anonstruct_NTP_Receive_Buffer_10 {
   NTP_Packet ntp_pkt ;
   uint8_t extensions[1024] ;
};
typedef struct __anonstruct_NTP_Receive_Buffer_10 NTP_Receive_Buffer;
struct __anonstruct_NTP_Sample_11 {
   struct timespec time ;
   double offset ;
   double peer_delay ;
   double peer_dispersion ;
   double root_delay ;
   double root_dispersion ;
   int stratum ;
   NTP_Leap leap ;
};
typedef struct __anonstruct_NTP_Sample_11 NTP_Sample;
struct __anonstruct_Timespec_12 {
   uint32_t tv_sec_high ;
   uint32_t tv_sec_low ;
   uint32_t tv_nsec ;
};
typedef struct __anonstruct_Timespec_12 Timespec;
struct __anonstruct_Float_13 {
   int32_t f ;
};
typedef struct __anonstruct_Float_13 Float;
struct ADF_AuthTableInst;
typedef struct ADF_AuthTableInst *ADF_AuthTable;
enum __anonenum_ADF_Status_5 {
    ADF_SUCCESS = 0,
    ADF_BADSUBNET = 1
};
typedef enum __anonenum_ADF_Status_5 ADF_Status;
enum __anonenum_State_6 {
    DENY = 0,
    ALLOW = 1,
    AS_PARENT = 2
};
typedef enum __anonenum_State_6 State;
struct _TableNode {
   State state ;
   struct _TableNode *extended ;
};
typedef struct _TableNode TableNode;
struct ADF_AuthTableInst {
   TableNode base4 ;
   TableNode base6 ;
};
struct ARR_Instance_Record;
typedef struct ARR_Instance_Record *ARR_Instance;
struct ARR_Instance_Record {
   void *data ;
   unsigned int elem_size ;
   unsigned int used ;
   unsigned int allocated ;
};
enum __anonenum_mode_12 {
    RPT_NTP_CLIENT = 0,
    RPT_NTP_PEER = 1,
    RPT_LOCAL_REFERENCE = 2
};
enum __anonenum_state_13 {
    RPT_SYNC = 0,
    RPT_UNREACH = 1,
    RPT_FALSETICKER = 2,
    RPT_JITTERY = 3,
    RPT_CANDIDATE = 4,
    RPT_OUTLIER = 5
};
struct __anonstruct_RPT_SourceReport_11 {
   IPAddr ip_addr ;
   int stratum ;
   int poll ;
   enum __anonenum_mode_12 mode ;
   enum __anonenum_state_13 state ;
   int sel_options ;
   int reachability ;
   unsigned long latest_meas_ago ;
   double orig_latest_meas ;
   double latest_meas ;
   double latest_meas_err ;
};
typedef struct __anonstruct_RPT_SourceReport_11 RPT_SourceReport;
struct __anonstruct_RPT_TrackingReport_14 {
   uint32_t ref_id ;
   IPAddr ip_addr ;
   int stratum ;
   NTP_Leap leap_status ;
   struct timespec ref_time ;
   double current_correction ;
   double last_offset ;
   double rms_offset ;
   double freq_ppm ;
   double resid_freq_ppm ;
   double skew_ppm ;
   double root_delay ;
   double root_dispersion ;
   double last_update_interval ;
};
typedef struct __anonstruct_RPT_TrackingReport_14 RPT_TrackingReport;
struct __anonstruct_RPT_SourcestatsReport_15 {
   uint32_t ref_id ;
   IPAddr ip_addr ;
   unsigned long n_samples ;
   unsigned long n_runs ;
   unsigned long span_seconds ;
   double resid_freq_ppm ;
   double skew_ppm ;
   double sd ;
   double est_offset ;
   double est_offset_err ;
};
typedef struct __anonstruct_RPT_SourcestatsReport_15 RPT_SourcestatsReport;
struct __anonstruct_RPT_ClientAccessByIndex_Report_17 {
   IPAddr ip_addr ;
   uint32_t ntp_hits ;
   uint32_t cmd_hits ;
   uint16_t ntp_drops ;
   uint16_t cmd_drops ;
   int8_t ntp_interval ;
   int8_t cmd_interval ;
   int8_t ntp_timeout_interval ;
   uint32_t last_ntp_hit_ago ;
   uint32_t last_cmd_hit_ago ;
};
typedef struct __anonstruct_RPT_ClientAccessByIndex_Report_17 RPT_ClientAccessByIndex_Report;
struct __anonstruct_RPT_ServerStatsReport_18 {
   uint32_t ntp_hits ;
   uint32_t cmd_hits ;
   uint32_t ntp_drops ;
   uint32_t cmd_drops ;
   uint32_t log_drops ;
};
typedef struct __anonstruct_RPT_ServerStatsReport_18 RPT_ServerStatsReport;
struct __anonstruct_RPT_SmoothingReport_21 {
   int active ;
   int leap_only ;
   double offset ;
   double freq_ppm ;
   double wander_ppm ;
   double last_update_ago ;
   double remaining_time ;
};
typedef struct __anonstruct_RPT_SmoothingReport_21 RPT_SmoothingReport;
struct __anonstruct_RPT_NTPReport_22 {
   IPAddr remote_addr ;
   IPAddr local_addr ;
   uint16_t remote_port ;
   uint8_t leap ;
   uint8_t version ;
   uint8_t mode ;
   uint8_t stratum ;
   int8_t poll ;
   int8_t precision ;
   double root_delay ;
   double root_dispersion ;
   uint32_t ref_id ;
   struct timespec ref_time ;
   double offset ;
   double peer_delay ;
   double peer_dispersion ;
   double response_time ;
   double jitter_asymmetry ;
   uint16_t tests ;
   int interleaved ;
   int authenticated ;
   char tx_tss_char ;
   char rx_tss_char ;
   uint32_t total_tx_count ;
   uint32_t total_rx_count ;
   uint32_t total_valid_count ;
};
typedef struct __anonstruct_RPT_NTPReport_22 RPT_NTPReport;
enum __anonenum_REF_LeapMode_23 {
    REF_LeapModeSystem = 0,
    REF_LeapModeSlew = 1,
    REF_LeapModeStep = 2,
    REF_LeapModeIgnore = 3
};
typedef enum __anonenum_REF_LeapMode_23 REF_LeapMode;
enum __anonenum_REF_Mode_24 {
    REF_ModeNormal = 0,
    REF_ModeInitStepSlew = 1,
    REF_ModeUpdateOnce = 2,
    REF_ModePrintOnce = 3,
    REF_ModeIgnore = 4
};
typedef enum __anonenum_REF_Mode_24 REF_Mode;
enum __anonenum_CNF_HwTs_RxFilter_25 {
    CNF_HWTS_RXFILTER_ANY = 0,
    CNF_HWTS_RXFILTER_NONE = 1,
    CNF_HWTS_RXFILTER_NTP = 2,
    CNF_HWTS_RXFILTER_ALL = 3
};
typedef enum __anonenum_CNF_HwTs_RxFilter_25 CNF_HwTs_RxFilter;
struct __anonstruct_CNF_HwTsInterface_26 {
   char *name ;
   int minpoll ;
   int min_samples ;
   int max_samples ;
   int nocrossts ;
   CNF_HwTs_RxFilter rxfilter ;
   double precision ;
   double tx_comp ;
   double rx_comp ;
};
typedef struct __anonstruct_CNF_HwTsInterface_26 CNF_HwTsInterface;
struct __anonstruct_Record_80 {
   IPAddr ip_addr ;
   uint32_t last_ntp_hit ;
   uint32_t last_cmd_hit ;
   uint32_t ntp_hits ;
   uint32_t cmd_hits ;
   uint16_t ntp_drops ;
   uint16_t cmd_drops ;
   uint16_t ntp_tokens ;
   uint16_t cmd_tokens ;
   int8_t ntp_rate ;
   int8_t cmd_rate ;
   int8_t ntp_timeout_rate ;
   uint8_t flags ;
   NTP_int64 ntp_rx_ts ;
   NTP_int64 ntp_tx_ts ;
};
typedef struct __anonstruct_Record_80 Record;
typedef struct SST_Stats_Record *SST_Stats;
typedef struct SRC_Instance_Record *SRC_Instance;
enum __anonenum_SRC_Type_23 {
    SRC_NTP = 0,
    SRC_REFCLOCK = 1
};
typedef enum __anonenum_SRC_Type_23 SRC_Type;
enum __anonenum_SRC_Connectivity_24 {
    SRC_OFFLINE = 0,
    SRC_ONLINE = 1,
    SRC_MAYBE_ONLINE = 2
};
typedef enum __anonenum_SRC_Connectivity_24 SRC_Connectivity;
struct __anonstruct_SourceParameters_25 {
   int minpoll ;
   int maxpoll ;
   SRC_Connectivity connectivity ;
   int auto_offline ;
   int presend_minpoll ;
   int burst ;
   int iburst ;
   int min_stratum ;
   int poll_target ;
   int version ;
   int max_sources ;
   int min_samples ;
   int max_samples ;
   int filter_length ;
   int interleaved ;
   int sel_options ;
   uint32_t authkey ;
   double max_delay ;
   double max_delay_ratio ;
   double max_delay_dev_ratio ;
   double min_delay ;
   double asymmetry ;
   double offset ;
};
typedef struct __anonstruct_SourceParameters_25 SourceParameters;
struct __anonstruct_CPS_NTP_Source_26 {
   char *name ;
   unsigned short port ;
   SourceParameters params ;
};
typedef struct __anonstruct_CPS_NTP_Source_26 CPS_NTP_Source;
enum __anonenum_DNS_Status_27 {
    DNS_Success = 0,
    DNS_TryAgain = 1,
    DNS_Failure = 2
};
typedef enum __anonenum_DNS_Status_27 DNS_Status;
enum __anonenum_NTP_Source_Type_30 {
    NTP_SERVER = 0,
    NTP_PEER = 1
};
typedef enum __anonenum_NTP_Source_Type_30 NTP_Source_Type;
enum __anonenum_NTP_Timestamp_Source_31 {
    NTP_TS_DAEMON = 0,
    NTP_TS_KERNEL = 1,
    NTP_TS_HARDWARE = 2
};
typedef enum __anonenum_NTP_Timestamp_Source_31 NTP_Timestamp_Source;
struct __anonstruct_NTP_Local_Timestamp_32 {
   struct timespec ts ;
   double err ;
   NTP_Timestamp_Source source ;
};
typedef struct __anonstruct_NTP_Local_Timestamp_32 NTP_Local_Timestamp;
typedef struct NCR_Instance_Record *NCR_Instance;
enum __anonenum_NSR_Status_33 {
    NSR_Success = 0,
    NSR_NoSuchSource = 1,
    NSR_AlreadyInUse = 2,
    NSR_TooManySources = 3,
    NSR_InvalidAF = 4
};
typedef enum __anonenum_NSR_Status_33 NSR_Status;
struct __anonstruct_RefclockParameters_34 {
   char *driver_name ;
   char *driver_parameter ;
   int driver_poll ;
   int poll ;
   int filter_length ;
   int pps_forced ;
   int pps_rate ;
   int min_samples ;
   int max_samples ;
   int sel_options ;
   int max_lock_age ;
   int stratum ;
   int tai ;
   uint32_t ref_id ;
   uint32_t lock_ref_id ;
   double offset ;
   double delay ;
   double precision ;
   double max_dispersion ;
   double pulse_width ;
};
typedef struct __anonstruct_RefclockParameters_34 RefclockParameters;
struct __anonstruct_NTP_Source_91 {
   NTP_Source_Type type ;
   int pool ;
   CPS_NTP_Source params ;
};
typedef struct __anonstruct_NTP_Source_91 NTP_Source;
struct _AllowDeny {
   IPAddr ip ;
   int subnet_bits ;
   int all ;
   int allow ;
};
typedef struct _AllowDeny AllowDeny;
struct __anonstruct_NTP_Broadcast_Destination_92 {
   IPAddr addr ;
   unsigned short port ;
   int interval ;
};
typedef struct __anonstruct_NTP_Broadcast_Destination_92 NTP_Broadcast_Destination;
typedef uint32_t UINT4;
struct __anonstruct_MD5_CTX_63 {
   UINT4 i[2] ;
   UINT4 buf[4] ;
   unsigned char in[64] ;
   unsigned char digest[16] ;
};
typedef struct __anonstruct_MD5_CTX_63 MD5_CTX;
enum __anonenum_LCL_ChangeType_83 {
    LCL_ChangeAdjust = 0,
    LCL_ChangeStep = 1,
    LCL_ChangeUnknownStep = 2
};
typedef enum __anonenum_LCL_ChangeType_83 LCL_ChangeType;
struct __anonstruct_Key_85 {
   uint32_t id ;
   char *val ;
   int len ;
   int hash_id ;
   int auth_delay ;
};
typedef struct __anonstruct_Key_85 Key;
struct _ChangeListEntry {
   struct _ChangeListEntry *next ;
   struct _ChangeListEntry *prev ;
   void (*handler)(struct timespec *raw, struct timespec *cooked,
                   double dfreq, double doffset, LCL_ChangeType change_type,
                   void *anything) ;
   void *anything ;
};
typedef struct _ChangeListEntry ChangeListEntry;
struct _DispersionNotifyListEntry {
   struct _DispersionNotifyListEntry *next ;
   struct _DispersionNotifyListEntry *prev ;
   void (*handler)(double dispersion, void *anything) ;
   void *anything ;
};
typedef struct _DispersionNotifyListEntry DispersionNotifyListEntry;
typedef unsigned int SCH_TimeoutID;
enum __anonenum_SCH_TimeoutClass_30 {
    SCH_ReservedTimeoutValue = 0,
    SCH_NtpClientClass = 1,
    SCH_NtpPeerClass = 2,
    SCH_NtpBroadcastClass = 3,
    SCH_NumberOfClasses = 4
};
typedef enum __anonenum_SCH_TimeoutClass_30 SCH_TimeoutClass;
typedef void *SCH_ArbitraryArgument;
union sockaddr_in46 {
   struct sockaddr_in in4 ;
   struct sockaddr u ;
};
struct Message {
   union sockaddr_in46 name ;
   struct iovec iov ;
   NTP_Receive_Buffer buf ;
   struct cmsghdr cmsgbuf[(unsigned long)256 / sizeof(struct cmsghdr)] ;
};
struct MessageHeader {
   struct msghdr msg_hdr ;
   unsigned int msg_len ;
};
struct fb_drift {
   double freq ;
   double secs ;
};
struct __anonstruct_FileHandlerEntry_66 {
   void (*handler)(int fd, int event, SCH_ArbitraryArgument ) ;
   SCH_ArbitraryArgument arg ;
   int events ;
};
typedef struct __anonstruct_FileHandlerEntry_66 FileHandlerEntry;
struct _TimerQueueEntry {
   struct _TimerQueueEntry *next ;
   struct _TimerQueueEntry *prev ;
   struct timespec ts ;
   SCH_TimeoutID id ;
   SCH_TimeoutClass class ;
   void (*handler)(SCH_ArbitraryArgument ) ;
   SCH_ArbitraryArgument arg ;
};
typedef struct _TimerQueueEntry TimerQueueEntry;
struct stage {
   double wander ;
   double length ;
};
struct SelectInfo {
   NTP_Leap leap ;
   int stratum ;
   int select_ok ;
   double std_dev ;
   double root_distance ;
   double lo_limit ;
   double hi_limit ;
   double last_sample_ago ;
};
enum __anonenum_SRC_Status_90 {
    SRC_OK = 0,
    SRC_UNSELECTABLE = 1,
    SRC_BAD_STATS = 2,
    SRC_BAD_DISTANCE = 3,
    SRC_JITTERY = 4,
    SRC_WAITS_STATS = 5,
    SRC_STALE = 6,
    SRC_ORPHAN = 7,
    SRC_UNTRUSTED = 8,
    SRC_FALSETICKER = 9,
    SRC_WAITS_SOURCES = 10,
    SRC_NONPREFERRED = 11,
    SRC_WAITS_UPDATE = 12,
    SRC_DISTANT = 13,
    SRC_OUTLIER = 14,
    SRC_UNSELECTED = 15,
    SRC_SELECTED = 16
};
typedef enum __anonenum_SRC_Status_90 SRC_Status;
struct SRC_Instance_Record {
   SST_Stats stats ;
   int index ;
   uint32_t ref_id ;
   IPAddr *ip_addr ;
   int active ;
   int reachability ;
   int reachability_size ;
   int updates ;
   int distant ;
   SRC_Status status ;
   SRC_Type type ;
   int sel_options ;
   double sel_score ;
   struct SelectInfo sel_info ;
};
enum __anonenum_tag_91 {
    LOW = -1,
    HIGH = 1
};
struct Sort_Element {
   int index ;
   double offset ;
   enum __anonenum_tag_91 tag ;
};
struct SST_Stats_Record {
   uint32_t refid ;
   IPAddr *ip_addr ;
   int min_samples ;
   int max_samples ;
   double fixed_min_delay ;
   double fixed_asymmetry ;
   int n_samples ;
   int runs_samples ;
   int last_sample ;
   int regression_ok ;
   int best_single_sample ;
   int min_delay_sample ;
   double estimated_offset ;
   double estimated_offset_sd ;
   struct timespec offset_time ;
   int nruns ;
   int asymmetry_run ;
   double asymmetry ;
   double estimated_frequency ;
   double estimated_frequency_sd ;
   double skew ;
   double std_dev ;
   struct timespec sample_times[64 * 2] ;
   double offsets[64 * 2] ;
   double orig_offsets[64] ;
   double peer_delays[64 * 2] ;
   double peer_dispersions[64] ;
   double root_delays[64] ;
   double root_dispersions[64] ;
   int stratum ;
   NTP_Leap leap ;
};
struct DNS_Async_Instance {
   char const *name ;
   void (*handler)(DNS_Status status, int n_addrs, IPAddr *ip_addrs,
                   void *anything) ;
   void *arg ;
   int pipe[2] ;
};
struct SPF_Instance_Record;
typedef struct SPF_Instance_Record *SPF_Instance;
enum __anonenum_OperatingMode_90 {
    MD_OFFLINE = 0,
    MD_ONLINE = 1,
    MD_BURST_WAS_OFFLINE = 2,
    MD_BURST_WAS_ONLINE = 3
};
typedef enum __anonenum_OperatingMode_90 OperatingMode;
enum __anonenum_AuthenticationMode_91 {
    AUTH_NONE = 0,
    AUTH_SYMMETRIC = 1,
    AUTH_MSSNTP = 2,
    AUTH_MSSNTP_EXT = 3
};
typedef enum __anonenum_AuthenticationMode_91 AuthenticationMode;
struct NCR_Instance_Record {
   NTP_Remote_Address remote_addr ;
   NTP_Local_Address local_addr ;
   NTP_Mode mode ;
   int interleaved ;
   OperatingMode opmode ;
   SCH_TimeoutID rx_timeout_id ;
   SCH_TimeoutID tx_timeout_id ;
   int tx_suspended ;
   int auto_burst ;
   int auto_offline ;
   int local_poll ;
   int remote_poll ;
   int remote_stratum ;
   int presend_minpoll ;
   int presend_done ;
   int minpoll ;
   int maxpoll ;
   int min_stratum ;
   int poll_target ;
   int version ;
   double poll_score ;
   double max_delay ;
   double max_delay_ratio ;
   double max_delay_dev_ratio ;
   double offset_correction ;
   AuthenticationMode auth_mode ;
   uint32_t auth_key_id ;
   unsigned int tx_count ;
   int valid_rx ;
   int valid_timestamps ;
   NTP_int64 remote_ntp_rx ;
   NTP_int64 remote_ntp_tx ;
   NTP_int64 local_ntp_rx ;
   NTP_Local_Timestamp local_rx ;
   NTP_int64 local_ntp_tx ;
   NTP_Local_Timestamp local_tx ;
   NTP_Local_Timestamp prev_local_tx ;
   int prev_local_poll ;
   unsigned int prev_tx_count ;
   int updated_init_timestamps ;
   NTP_int64 init_remote_ntp_tx ;
   NTP_Local_Timestamp init_local_rx ;
   SRC_Instance source ;
   SPF_Instance filter ;
   int burst_good_samples_to_go ;
   int burst_total_samples_to_go ;
   RPT_NTPReport report ;
};
struct __anonstruct_BroadcastDestination_92 {
   NTP_Remote_Address addr ;
   NTP_Local_Address local_addr ;
   int interval ;
};
typedef struct __anonstruct_BroadcastDestination_92 BroadcastDestination;
extern void LOG_Initialise(void);

extern void LOG_Finalise(void);

extern void ( /* format attribute */ LOG_Message)(LOG_Severity severity,
                                                  char const *format,
                                                  void * const *__va_params);

extern void LOG_SetDebugLevel(int level);

extern void LOG_OpenFileLog(char const *log_file);

extern LOG_FileID LOG_FileOpen(char const *name, char const *banner);

extern void ( /* format attribute */ LOG_FileWrite)(LOG_FileID id,
                                                    char const *format,
                                                    void * const *__va_params);

void lcl_InvokeDispersionNotifyHandlers(double dispersion);

void lcl_RegisterSystemDrivers(double (*read_freq)(void),
                               double (*set_freq)(double freq_ppm),
                               void (*accrue_offset_0)(double offset,
                                                       double corr_rate),
                               int (*apply_step_offset_0)(double offset),
                               void (*offset_convert_0)(struct timespec *raw,
                                                        double *corr,
                                                        double *err),
                               void (*set_leap)(int leap, int tai_offset),
                               void (*set_sync_status)(int synchronised,
                                                       double est_error,
                                                       double max_error));

void test_unit(void);

void TST_Fail(int line);

void TST_SuspendLogging(void);

void TST_ResumeLogging(void);

double TST_GetRandomDouble(double min, double max);

void TST_GetRandomAddress(IPAddr *ip, int family, int bits);

void TST_SwapAddressBit(IPAddr *ip, unsigned int b);

void TST_RegisterDummyDrivers(void);

int HSH_GetHashId(char const *name);

unsigned int HSH_Hash(int id, unsigned char const *in1, unsigned int in1_len,
                      unsigned char const *in2, unsigned int in2_len,
                      unsigned char *out, unsigned int out_len);

void HSH_Finalise(void);

void UTI_ZeroTimespec(struct timespec *ts);

int UTI_IsZeroTimespec(struct timespec *ts);

void UTI_TimevalToTimespec(struct timeval *tv, struct timespec *ts);

void UTI_TimespecToTimeval(struct timespec *ts, struct timeval *tv);

double UTI_TimespecToDouble(struct timespec *ts);

void UTI_DoubleToTimespec(double d, struct timespec *ts);

void UTI_NormaliseTimespec(struct timespec *ts);

double UTI_TimevalToDouble(struct timeval *tv);

void UTI_DoubleToTimeval(double a, struct timeval *b);

void UTI_NormaliseTimeval(struct timeval *x);

int UTI_CompareTimespecs(struct timespec *a, struct timespec *b);

void UTI_DiffTimespecs(struct timespec *result, struct timespec *a,
                       struct timespec *b);

double UTI_DiffTimespecsToDouble(struct timespec *a, struct timespec *b);

void UTI_AddDoubleToTimespec(struct timespec *start, double increment,
                             struct timespec *end);

void UTI_AverageDiffTimespecs(struct timespec *earlier,
                              struct timespec *later,
                              struct timespec *average, double *diff);

void UTI_AddDiffToTimespec(struct timespec *a, struct timespec *b,
                           struct timespec *c, struct timespec *result);

char *UTI_TimespecToString(struct timespec *ts);

char *UTI_Ntp64ToString(NTP_int64 *ntp_ts);

char *UTI_RefidToString(uint32_t ref_id);

char *UTI_IPToString(IPAddr *addr);

int UTI_StringToIP(char const *addr, IPAddr *ip);

uint32_t UTI_IPToRefid(IPAddr *ip);

uint32_t UTI_IPToHash(IPAddr *ip);

void UTI_IPHostToNetwork(IPAddr *src, IPAddr *dest);

void UTI_IPNetworkToHost(IPAddr *src, IPAddr *dest);

int UTI_CompareIPs(IPAddr *a, IPAddr *b, IPAddr *mask);

void UTI_SockaddrToIPAndPort(struct sockaddr *sa, IPAddr *ip,
                             unsigned short *port);

int UTI_IPAndPortToSockaddr(IPAddr *ip, unsigned short port,
                            struct sockaddr *sa);

char *UTI_SockaddrToString(struct sockaddr *sa);

char const *UTI_SockaddrFamilyToString(int family);

char *UTI_TimeToLogForm(time_t t);

void UTI_AdjustTimespec(struct timespec *old_ts, struct timespec *when,
                        struct timespec *new_ts, double *delta_time,
                        double dfreq, double doffset);

void UTI_GetNtp64Fuzz(NTP_int64 *ts, int precision);

double UTI_Ntp32ToDouble(NTP_int32 x);

NTP_int32 UTI_DoubleToNtp32(double x);

void UTI_ZeroNtp64(NTP_int64 *ts);

int UTI_IsZeroNtp64(NTP_int64 *ts);

int UTI_CompareNtp64(NTP_int64 *a, NTP_int64 *b);

int UTI_IsEqualAnyNtp64(NTP_int64 *a, NTP_int64 *b1, NTP_int64 *b2,
                        NTP_int64 *b3);

void UTI_TimespecToNtp64(struct timespec *src, NTP_int64 *dest,
                         NTP_int64 *fuzz);

void UTI_Ntp64ToTimespec(NTP_int64 *src, struct timespec *dest);

int UTI_IsTimeOffsetSane(struct timespec *ts, double offset);

double UTI_Log2ToDouble(int l);

void UTI_TimespecNetworkToHost(Timespec *src, struct timespec *dest);

void UTI_TimespecHostToNetwork(struct timespec *src, Timespec *dest);

double UTI_FloatNetworkToHost(Float f);

Float UTI_FloatHostToNetwork(double x);

int UTI_FdSetCloexec(int fd);

void UTI_SetQuitSignalsHandler(void (*handler)(int ), int ignore_sigpipe);

char *UTI_PathToDir(char const *path);

int UTI_CreateDirAndParents(char const *path, mode_t mode_0, uid_t uid,
                            gid_t gid);

int UTI_CheckDirPermissions(char const *path, mode_t perm, uid_t uid,
                            gid_t gid);

void UTI_DropRoot(uid_t uid, gid_t gid);

void UTI_GetRandomBytesUrandom(void *buf, unsigned int len);

void UTI_GetRandomBytes(void *buf, unsigned int len);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_1(char const * restrict format, int param0);

void TST_Fail(int line)
{
  printf("FAIL (on line %d)\n",line); /* printf_va_1 */
  exit(1);
  return;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_1(FILE * restrict stream, char const * restrict format);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_2(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_3(char const * restrict format);

int main(int argc, char **argv)
{
  int __retres;
  char *test_name;
  char *s;
  int i;
  struct timeval tv;
  long tmp_1;
  int seed = 0;
  test_name = *(argv + 0);
  s = strrchr((char const *)test_name,'.');
  if (s) *s = (char)'\000';
  s = strrchr((char const *)test_name,'/');
  if (s) test_name = s + 1;
  i = 1;
  while (i < argc) {
    {
      int tmp_0;
      tmp_0 = strcmp((char const *)*(argv + i),"-d");
      if (tmp_0) {
        int tmp;
        tmp = strcmp((char const *)*(argv + i),"-s");
        if (tmp) {
          _LAND:
          {
            fprintf(__fc_stderr,"Unknown option\n"); /* fprintf_va_1 */
            exit(1);
          }
        }
        else 
          if (i + 1 < argc) {
            i ++;
            ;
            seed = atoi((char const *)*(argv + i));
          }
          else goto _LAND;
      }
      else LOG_SetDebugLevel(2);
    }
    i ++;
  }
  gettimeofday(& tv,(void *)0);
  if (seed) tmp_1 = (long)seed;
  else tmp_1 = tv.tv_sec ^ (long)(tv.tv_usec << 10);
  srandom((unsigned int)tmp_1);
  printf("Testing %-30s ",test_name); /* printf_va_2 */
  fflush(__fc_stdout);
  LOG_Initialise();
  test_unit();
  LOG_Finalise();
  printf("PASS\n"); /* printf_va_3 */
  __retres = 0;
  return __retres;
}

void TST_SuspendLogging(void)
{
  LOG_OpenFileLog("/dev/null");
  return;
}

void TST_ResumeLogging(void)
{
  LOG_OpenFileLog((char const *)0);
  return;
}

double TST_GetRandomDouble(double min, double max)
{
  double __retres;
  long tmp;
  tmp = random();
  ;
  __retres = min + ((double)tmp / (double)2147483647) * (max - min);
  return __retres;
}

void TST_GetRandomAddress(IPAddr *ip, int family, int bits)
{
  if (family != 1) 
    if (family != 2) {
      long tmp;
      tmp = random();
      if (tmp % (long)2) family = 1; else family = 2;
    }
  ip->family = (uint16_t)family;
  if (family == 1) {
    if (bits < 0) bits = 32;
    __FC_assert((bits <= 32) != 0,"test/unit/test.c",106,"bits <= 32");
    if (bits > 16) {
      long tmp_0;
      long tmp_1;
      tmp_0 = random();
      tmp_1 = random();
      ip->addr.in4 = ((uint32_t)tmp_0 % (1U << (bits - 16)) << 16) | 
                     (uint32_t)tmp_1 % (1U << 16);
    }
    else {
      long tmp_2;
      tmp_2 = random();
      ip->addr.in4 = (uint32_t)tmp_2 % (1U << bits);
    }
  }
  else {
    int i;
    int b;
    if (bits < 0) bits = 128;
    __FC_assert((bits <= 128) != 0,"test/unit/test.c",118,"bits <= 128");
    i = 0;
    b = 120;
    /*@ loop unroll 16; */
    while (i < 16) {
      if (b >= bits) ip->addr.in6[i] = (uint8_t)0;
      else {
        long tmp_3;
        int tmp_4;
        tmp_3 = random();
        if (bits - b < 8) tmp_4 = bits - b; else tmp_4 = 8;
        ip->addr.in6[i] = (uint8_t)(tmp_3 % (long)(1U << tmp_4));
      }
      i ++;
      b -= 8;
    }
  }
  return;
}

void TST_SwapAddressBit(IPAddr *ip, unsigned int b)
{
  if ((int)ip->family == 1) {
    __FC_assert((b < (unsigned int)32) != 0,"test/unit/test.c",135,"b < 32");
    ip->addr.in4 ^= 1U << ((unsigned int)31 - b);
  }
  else 
    if ((int)ip->family == 2) {
      __FC_assert((b < (unsigned int)128) != 0,"test/unit/test.c",138,
                  "b < 128");
      ip->addr.in6[b / (unsigned int)8] = (uint8_t)((unsigned int)ip->addr.in6[
                                                    b / (unsigned int)8] ^ (
                                                    1U << ((unsigned int)7 - 
                                                           b % (unsigned int)8)));
    }
    else __FC_assert(0 != 0,"test/unit/test.c",141,"0");
  return;
}

static double read_frequency(void)
{
  double __retres;
  __retres = 0.0;
  return __retres;
}

static double set_frequency(double freq_ppm)
{
  double __retres;
  __retres = 0.0;
  return __retres;
}

static void accrue_offset(double offset, double corr_rate)
{
  return;
}

static int apply_step_offset(double offset)
{
  int __retres;
  __retres = 0;
  return __retres;
}

static void offset_convert(struct timespec *raw, double *corr, double *err)
{
  *corr = 0.0;
  if (err) *err = 0.0;
  return;
}

void TST_RegisterDummyDrivers(void)
{
  lcl_RegisterSystemDrivers(& read_frequency,& set_frequency,& accrue_offset,
                            & apply_step_offset,& offset_convert,
                            (void (*)(int leap, int tai_offset))0,
                            (void (*)(int synchronised, double est_error,
                                      double max_error))0);
  return;
}

ADF_AuthTable ADF_CreateTable(void);

ADF_Status ADF_Allow(ADF_AuthTable table, IPAddr *ip, int subnet_bits);

ADF_Status ADF_AllowAll(ADF_AuthTable table, IPAddr *ip, int subnet_bits);

ADF_Status ADF_Deny(ADF_AuthTable table, IPAddr *ip, int subnet_bits);

ADF_Status ADF_DenyAll(ADF_AuthTable table, IPAddr *ip, int subnet_bits);

void ADF_DestroyTable(ADF_AuthTable table);

int ADF_IsAllowed(ADF_AuthTable table, IPAddr *ip_addr);

int ADF_IsAnyAllowed(ADF_AuthTable table, int family);

void *Malloc(size_t size);

void *Realloc(void *ptr, size_t size);

void *Malloc2(size_t nmemb, size_t size);

void *Realloc2(void *ptr, size_t nmemb, size_t size);

char *Strdup(char const *s);

static void split_ip6(IPAddr *ip, uint32_t *dst)
{
  int i;
  i = 0;
  /*@ loop unroll 4; */
  while (i < 4) {
    *(dst + i) = ((((uint32_t)ip->addr.in6[i * 4 + 0] << 24) | (unsigned int)(
                   (int)ip->addr.in6[i * 4 + 1] << 16)) | (unsigned int)(
                  (int)ip->addr.in6[i * 4 + 2] << 8)) | (unsigned int)ip->addr.in6[
                 i * 4 + 3];
    i ++;
  }
  return;
}

__inline static uint32_t get_subnet(uint32_t *addr, unsigned int where)
{
  uint32_t __retres;
  int off;
  off = (int)(where / (unsigned int)32);
  where %= (unsigned int)32;
  __retres = (uint32_t)((unsigned long)(*(addr + off) >> ((unsigned int)(
                                                          32 - 4) - where)) & (
                        (1UL << 4) - (unsigned long)1));
  return __retres;
}

ADF_AuthTable ADF_CreateTable(void)
{
  ADF_AuthTable result;
  result = (ADF_AuthTable)Malloc(sizeof(struct ADF_AuthTableInst));
  result->base4.state = DENY;
  result->base4.extended = (struct _TableNode *)0;
  result->base6.state = DENY;
  result->base6.extended = (struct _TableNode *)0;
  return result;
}

static void close_node(TableNode *node)
{
  int i;
  TableNode *child_node;
  if (node->extended != (struct _TableNode *)0) {
    i = 0;
    /*@ loop unroll 16; */
    while ((unsigned long)i < 1UL << 4) {
      child_node = node->extended + i;
      i ++;
    }
    free((void *)node->extended);
    node->extended = (struct _TableNode *)0;
  }
  return;
}

static void open_node(TableNode *node)
{
  int i;
  TableNode *child_node;
  if (node->extended == (struct _TableNode *)0) {
    node->extended = (struct _TableNode *)Malloc2(1UL << 4,
                                                  sizeof(struct _TableNode));
    i = 0;
    /*@ loop unroll 4; */
    while ((unsigned long)i < 1UL << 4) {
      child_node = node->extended + i;
      child_node->state = AS_PARENT;
      child_node->extended = (struct _TableNode *)0;
      i ++;
    }
  }
  return;
}

static ADF_Status set_subnet(TableNode *start_node, uint32_t *ip, int ip_len,
                             int subnet_bits, State new_state,
                             int delete_children)
{
  ADF_Status __retres;
  int bits_to_go;
  int bits_consumed;
  uint32_t subnet;
  TableNode *node;
  bits_consumed = 0;
  bits_to_go = subnet_bits;
  node = start_node;
  if (subnet_bits < 0) goto _LOR;
  else 
    if (subnet_bits > 32 * ip_len) {
      _LOR: {
              __retres = ADF_BADSUBNET;
              goto return_label;
            }
    }
    else {
      if ((bits_to_go & (4 - 1)) == 0) {
        /*@ loop unroll 128; */
        while (bits_to_go > 0) {
          subnet = get_subnet(ip,(unsigned int)bits_consumed);
          if (! node->extended) open_node(node);
          node = node->extended + subnet;
          bits_to_go -= 4;
          bits_consumed += 4;
        }
        if (delete_children) close_node(node);
        node->state = new_state;
      }
      else {
        int N;
        int i;
        int j;
        TableNode *this_node;
        uint32_t tmp;
        /*@ loop unroll 124; */
        while (bits_to_go >= 4) {
          subnet = get_subnet(ip,(unsigned int)bits_consumed);
          if (! node->extended) open_node(node);
          node = node->extended + subnet;
          bits_to_go -= 4;
          bits_consumed += 4;
        }
        N = 1 << (4 - bits_to_go);
        tmp = get_subnet(ip,(unsigned int)bits_consumed);
        subnet = tmp & (unsigned int)(~ (N - 1));
        __FC_assert(((unsigned long)(subnet + (uint32_t)N) <= 1UL << 4) != 0,
                    "addrfilt.c",210,"subnet + N <= TABLE_SIZE");
        if (! node->extended) open_node(node);
        i = (int)subnet;
        j = 0;
        /*@ loop unroll 16; */
        while (j < N) {
          this_node = node->extended + i;
          if (delete_children) close_node(this_node);
          this_node->state = new_state;
          i ++;
          j ++;
        }
      }
      __retres = ADF_SUCCESS;
      goto return_label;
    }
  return_label: return __retres;
}

static ADF_Status set_subnet_(ADF_AuthTable table, IPAddr *ip_addr,
                              int subnet_bits, State new_state,
                              int delete_children)
{
  ADF_Status __retres;
  uint32_t ip6[4];
  switch ((int)ip_addr->family) {
    ADF_Status tmp;
    ADF_Status tmp_0;
    ADF_Status tmp_1;
    case 1:
    tmp = set_subnet(& table->base4,& ip_addr->addr.in4,1,subnet_bits,
                     new_state,delete_children);
    __retres = tmp;
    goto return_label;
    case 2: split_ip6(ip_addr,ip6);
    tmp_0 = set_subnet(& table->base6,ip6,4,subnet_bits,new_state,
                       delete_children);
    __retres = tmp_0;
    goto return_label;
    case 0: ;
    if (subnet_bits != 0) {
      __retres = ADF_BADSUBNET;
      goto return_label;
    }
    memset((void *)(ip6),0,sizeof(ip6));
    tmp_1 = set_subnet(& table->base4,ip6,1,0,new_state,delete_children);
    if (tmp_1 == (unsigned int)ADF_SUCCESS) {
      ADF_Status tmp_2;
      tmp_2 = set_subnet(& table->base6,ip6,4,0,new_state,delete_children);
      if (tmp_2 == (unsigned int)ADF_SUCCESS) {
        __retres = ADF_SUCCESS;
        goto return_label;
      }
    }
    break;
  }
  __retres = ADF_BADSUBNET;
  return_label: return __retres;
}

ADF_Status ADF_Allow(ADF_AuthTable table, IPAddr *ip, int subnet_bits)
{
  ADF_Status tmp;
  tmp = set_subnet_(table,ip,subnet_bits,ALLOW,0);
  return tmp;
}

ADF_Status ADF_AllowAll(ADF_AuthTable table, IPAddr *ip, int subnet_bits)
{
  ADF_Status tmp;
  tmp = set_subnet_(table,ip,subnet_bits,ALLOW,1);
  return tmp;
}

ADF_Status ADF_Deny(ADF_AuthTable table, IPAddr *ip, int subnet_bits)
{
  ADF_Status tmp;
  tmp = set_subnet_(table,ip,subnet_bits,DENY,0);
  return tmp;
}

ADF_Status ADF_DenyAll(ADF_AuthTable table, IPAddr *ip, int subnet_bits)
{
  ADF_Status tmp;
  tmp = set_subnet_(table,ip,subnet_bits,DENY,1);
  return tmp;
}

void ADF_DestroyTable(ADF_AuthTable table)
{
  close_node(& table->base4);
  close_node(& table->base6);
  free((void *)table);
  return;
}

static int check_ip_in_node(TableNode *start_node, uint32_t *ip)
{
  uint32_t subnet;
  TableNode *node;
  int bits_consumed = 0;
  int result = 0;
  int finished = 0;
  State state = DENY;
  node = start_node;
  while (1) {
    if (node->state != (unsigned int)AS_PARENT) state = node->state;
    if (node->extended) {
      subnet = get_subnet(ip,(unsigned int)bits_consumed);
      node = node->extended + subnet;
      bits_consumed += 4;
    }
    else finished = 1;
    if (! (! finished)) break;
  }
  switch (state) {
    case ALLOW: result = 1;
    break;
    case DENY: result = 0;
    break;
    case AS_PARENT: __FC_assert(0 != 0,"addrfilt.c",347,"0");
    break;
  }
  return result;
}

int ADF_IsAllowed(ADF_AuthTable table, IPAddr *ip_addr)
{
  int __retres;
  uint32_t ip6[4];
  switch ((int)ip_addr->family) {
    int tmp;
    int tmp_0;
    case 1: tmp = check_ip_in_node(& table->base4,& ip_addr->addr.in4);
    __retres = tmp;
    goto return_label;
    case 2: split_ip6(ip_addr,ip6);
    tmp_0 = check_ip_in_node(& table->base6,ip6);
    __retres = tmp_0;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int volatile nondet;
static int is_any_allowed(TableNode *node, State parent)
{
  int __retres;
  State state;
  int i;
  if (node->state != (unsigned int)AS_PARENT) state = node->state;
  else state = parent;
  __FC_assert((state != (unsigned int)AS_PARENT) != 0,"addrfilt.c",387,
              "state != AS_PARENT");
  if (node->extended) {
    i = 0;
    /*@ loop unroll 16; */
    while ((unsigned long)i < 1UL << 4) {
      if (nondet) {
        __retres = 1;
        goto return_label;
      }
      i ++;
    }
  }
  else 
    if (state == (unsigned int)ALLOW) {
      __retres = 1;
      goto return_label;
    }
  __retres = 0;
  return_label: return __retres;
}

int ADF_IsAnyAllowed(ADF_AuthTable table, int family)
{
  int __retres;
  switch (family) {
    int tmp;
    int tmp_0;
    case 1: tmp = is_any_allowed(& table->base4,AS_PARENT);
    __retres = tmp;
    goto return_label;
    case 2: tmp_0 = is_any_allowed(& table->base6,AS_PARENT);
    __retres = tmp_0;
    goto return_label;
    default: __retres = 0;
    goto return_label;
  }
  return_label: return __retres;
}

ARR_Instance ARR_CreateInstance(unsigned int elem_size);

void ARR_DestroyInstance(ARR_Instance array);

void *ARR_GetNewElement(ARR_Instance array);

void *ARR_GetElement(ARR_Instance array, unsigned int index_0);

void *ARR_GetElements(ARR_Instance array);

void ARR_AppendElement(ARR_Instance array, void *element);

void ARR_SetSize(ARR_Instance array, unsigned int size);

unsigned int ARR_GetSize(ARR_Instance array);

ARR_Instance ARR_CreateInstance(unsigned int elem_size)
{
  ARR_Instance array;
  __FC_assert((elem_size > (unsigned int)0) != 0,"array.c",47,
              "elem_size > 0");
  array = (ARR_Instance)Malloc(sizeof(struct ARR_Instance_Record));
  array->data = (void *)0;
  array->elem_size = elem_size;
  array->used = (unsigned int)0;
  array->allocated = (unsigned int)0;
  return array;
}

void ARR_DestroyInstance(ARR_Instance array)
{
  free(array->data);
  free((void *)array);
  return;
}

static void realloc_array(ARR_Instance array, unsigned int min_size)
{
  __FC_assert((min_size <= (unsigned int)2 * min_size) != 0,"array.c",69,
              "min_size <= 2 * min_size");
  if (array->allocated >= min_size) 
    if (array->allocated <= (unsigned int)2 * min_size) goto return_label;
  if (array->allocated < min_size) 
    while (array->allocated < min_size) 
      if (array->allocated) array->allocated = (unsigned int)2 * array->allocated;
      else array->allocated = (unsigned int)1;
  else array->allocated = min_size;
  array->data = Realloc2(array->data,(size_t)array->allocated,
                         (size_t)array->elem_size);
  return_label: return;
}

void *ARR_GetNewElement(ARR_Instance array)
{
  void *tmp;
  (array->used) ++;
  realloc_array(array,array->used);
  tmp = ARR_GetElement(array,array->used - (unsigned int)1);
  return tmp;
}

void *ARR_GetElement(ARR_Instance array, unsigned int index_0)
{
  void *__retres;
  __FC_assert((index_0 < array->used) != 0,"array.c",94,
              "index < array->used");
  __retres = (void *)((char *)array->data + (size_t)index_0 * (size_t)array->elem_size);
  return __retres;
}

void *ARR_GetElements(ARR_Instance array)
{
  void *__retres;
  if (! array->data) {
    __FC_assert(! array->used != 0,"array.c",103,"!array->used");
    __retres = (void *)array;
    goto return_label;
  }
  __retres = array->data;
  return_label: return __retres;
}

void ARR_AppendElement(ARR_Instance array, void *element)
{
  void *e;
  e = ARR_GetNewElement(array);
  memcpy(e,(void const *)element,(size_t)array->elem_size);
  return;
}

void ARR_SetSize(ARR_Instance array, unsigned int size)
{
  realloc_array(array,size);
  array->used = size;
  return;
}

unsigned int ARR_GetSize(ARR_Instance array)
{
  unsigned int __retres;
  __retres = array->used;
  return __retres;
}

void CLG_Initialise(void);

void CLG_Finalise(void);

int CLG_GetClientIndex(IPAddr *client);

int CLG_LogNTPAccess(IPAddr *client, struct timespec *now);

int CLG_LogCommandAccess(IPAddr *client, struct timespec *now);

int CLG_LimitNTPResponseRate(int index_0);

int CLG_LimitCommandResponseRate(int index_0);

void CLG_GetNtpTimestamps(int index_0, NTP_int64 **rx_ts, NTP_int64 **tx_ts);

int CLG_GetNtpMinPoll(void);

int CLG_GetNumberOfIndices(void);

int CLG_GetClientAccessReportByIndex(int index_0,
                                     RPT_ClientAccessByIndex_Report *report,
                                     struct timespec *now);

void CLG_GetServerStatsReport(RPT_ServerStatsReport *report);

void REF_Initialise(void);

void REF_Finalise(void);

void REF_SetMode(REF_Mode new_mode);

REF_Mode REF_GetMode(void);

void REF_SetModeEndHandler(void (*handler)(int result));

REF_LeapMode REF_GetLeapMode(void);

void REF_GetReferenceParams(struct timespec *local_time,
                            int *is_synchronised, NTP_Leap *leap_status,
                            int *stratum, uint32_t *ref_id,
                            struct timespec *ref_time, double *root_delay,
                            double *root_dispersion);

void REF_SetReference(int stratum, NTP_Leap leap, int combined_sources,
                      uint32_t ref_id, IPAddr *ref_ip,
                      struct timespec *ref_time, double offset,
                      double offset_sd, double frequency,
                      double frequency_sd, double skew, double root_delay,
                      double root_dispersion);

void REF_SetManualReference(struct timespec *ref_time, double offset,
                            double frequency, double skew);

void REF_SetUnsynchronised(void);

int REF_GetOurStratum(void);

int REF_GetOrphanStratum(void);

double REF_GetSkew(void);

void REF_ModifyMaxupdateskew(double new_max_update_skew);

void REF_ModifyMakestep(int limit, double threshold);

void REF_EnableLocal(int stratum, double distance, int orphan);

void REF_DisableLocal(void);

int REF_IsLeapSecondClose(void);

int REF_GetTaiOffset(struct timespec *ts);

void REF_GetTrackingReport(RPT_TrackingReport *rep);

void CNF_Initialise(int r, int client_only);

void CNF_Finalise(void);

char *CNF_GetRtcDevice(void);

void CNF_ReadFile(char const *filename);

void CNF_ParseLine(char const *filename, int number, char *line);

void CNF_CreateDirs(uid_t uid, gid_t gid);

void CNF_AddInitSources(void);

void CNF_AddSources(void);

void CNF_AddBroadcasts(void);

void CNF_AddRefclocks(void);

int CNF_GetAcquisitionPort(void);

int CNF_GetNTPPort(void);

char *CNF_GetDriftFile(void);

char *CNF_GetLogDir(void);

char *CNF_GetDumpDir(void);

int CNF_GetLogBanner(void);

int CNF_GetLogMeasurements(int *raw);

int CNF_GetLogStatistics(void);

int CNF_GetLogTracking(void);

int CNF_GetLogRtc(void);

int CNF_GetLogRefclocks(void);

int CNF_GetLogTempComp(void);

char *CNF_GetKeysFile(void);

char *CNF_GetRtcFile(void);

int CNF_GetManualEnabled(void);

int CNF_GetCommandPort(void);

int CNF_GetRtcOnUtc(void);

int CNF_GetRtcSync(void);

void CNF_GetMakeStep(int *limit, double *threshold);

void CNF_GetMaxChange(int *delay, int *ignore, double *offset);

double CNF_GetLogChange(void);

void CNF_GetMailOnChange(int *enabled_0, double *threshold, char **user_0);

int CNF_GetNoClientLog(void);

unsigned long CNF_GetClientLogLimit(void);

void CNF_GetFallbackDrifts(int *min, int *max);

void CNF_GetBindAddress(int family, IPAddr *addr);

void CNF_GetBindAcquisitionAddress(int family, IPAddr *addr);

void CNF_GetBindCommandAddress(int family, IPAddr *addr);

char *CNF_GetBindCommandPath(void);

char *CNF_GetNtpSigndSocket(void);

char *CNF_GetPidFile(void);

REF_LeapMode CNF_GetLeapSecMode(void);

char *CNF_GetLeapSecTimezone(void);

double CNF_GetMaxUpdateSkew(void);

double CNF_GetMaxClockError(void);

double CNF_GetMaxDrift(void);

double CNF_GetCorrectionTimeRatio(void);

double CNF_GetMaxSlewRate(void);

double CNF_GetMaxDistance(void);

double CNF_GetMaxJitter(void);

double CNF_GetReselectDistance(void);

double CNF_GetStratumWeight(void);

double CNF_GetCombineLimit(void);

int CNF_AllowLocalReference(int *stratum, int *orphan, double *distance);

void CNF_SetupAccessRestrictions(void);

int CNF_GetSchedPriority(void);

int CNF_GetLockMemory(void);

int CNF_GetNTPRateLimit(int *interval, int *burst, int *leak);

int CNF_GetCommandRateLimit(int *interval, int *burst, int *leak);

void CNF_GetSmooth(double *max_freq_0, double *max_wander_0, int *leap_only);

void CNF_GetTempComp(char **file, double *interval, char **point_file,
                     double *T0, double *k0, double *k1, double *k2);

char *CNF_GetUser(void);

int CNF_GetMaxSamples(void);

int CNF_GetMinSamples(void);

int CNF_GetMinSources(void);

double CNF_GetRtcAutotrim(void);

char *CNF_GetHwclockFile(void);

int CNF_GetInitSources(void);

double CNF_GetInitStepThreshold(void);

int CNF_GetHwTsInterface(unsigned int index_0, CNF_HwTsInterface **iface);

static ARR_Instance records;
static unsigned int slots;
static unsigned int max_slots;
static uint32_t ts_offset;
static uint16_t max_ntp_tokens;
static uint16_t max_cmd_tokens;
static uint16_t ntp_tokens_per_packet;
static uint16_t cmd_tokens_per_packet;
static int ntp_token_shift;
static int cmd_token_shift;
static int ntp_leak_rate;
static int cmd_leak_rate;
static int ntp_limit_interval;
static int active;
static uint32_t total_ntp_hits;
static uint32_t total_cmd_hits;
static uint32_t total_ntp_drops;
static uint32_t total_cmd_drops;
static uint32_t total_record_drops;
static int expand_hashtable(void);

static int compare_ts(uint32_t x, uint32_t y)
{
  int __retres;
  int tmp;
  if (x == y) {
    __retres = 0;
    goto return_label;
  }
  if (y == (uint32_t)0) {
    __retres = 1;
    goto return_label;
  }
  if ((int32_t)(x - y) > 0) tmp = 1; else tmp = -1;
  __retres = tmp;
  return_label: return __retres;
}

static Record *get_record(IPAddr *ip)
{
  Record *__retres;
  unsigned int first;
  unsigned int i;
  time_t last_hit;
  Record *record;
  Record *oldest_record;
  uint32_t tmp_4;
  uint32_t tmp_5;
  uint16_t tmp_6;
  int8_t tmp_7;
  time_t oldest_hit = (time_t)0;
  if (! active) {
    __retres = (Record *)0;
    goto return_label;
  }
  else 
    if ((int)ip->family != 1) 
      if ((int)ip->family != 2) {
        __retres = (Record *)0;
        goto return_label;
      }
  while (1) {
    {
      uint32_t tmp;
      int tmp_3;
      tmp = UTI_IPToHash(ip);
      first = (tmp % slots) * (1U << 4);
      i = (unsigned int)0;
      oldest_record = (Record *)0;
      while (i < 1U << 4) {
        {
          int tmp_0;
          int tmp_1;
          record = (Record *)ARR_GetElement(records,first + i);
          tmp_0 = UTI_CompareIPs(ip,& record->ip_addr,(IPAddr *)0);
          if (! tmp_0) {
            __retres = record;
            goto return_label;
          }
          if ((int)record->ip_addr.family == 0) break;
          tmp_1 = compare_ts(record->last_ntp_hit,record->last_cmd_hit);
          if (tmp_1 > 0) last_hit = (time_t)record->last_ntp_hit;
          else last_hit = (time_t)record->last_cmd_hit;
          if (! oldest_record) goto _LOR;
          else {
            int tmp_2;
            tmp_2 = compare_ts((uint32_t)oldest_hit,(uint32_t)last_hit);
            if (tmp_2 > 0) goto _LOR;
            else 
              if (oldest_hit == last_hit) 
                if (record->ntp_hits + record->cmd_hits < oldest_record->ntp_hits + oldest_record->cmd_hits) {
                  _LOR: {
                          oldest_record = record;
                          oldest_hit = last_hit;
                        }
                }
          }
        }
        i ++;
      }
      if ((int)record->ip_addr.family == 0) break;
      tmp_3 = expand_hashtable();
      if (tmp_3) continue;
      record = oldest_record;
      total_record_drops ++;
      break;
    }
  }
  record->ip_addr = *ip;
  tmp_4 = (uint32_t)0;
  record->last_cmd_hit = tmp_4;
  record->last_ntp_hit = tmp_4;
  tmp_5 = (uint32_t)0;
  record->cmd_hits = tmp_5;
  record->ntp_hits = tmp_5;
  tmp_6 = (uint16_t)0;
  record->cmd_drops = tmp_6;
  record->ntp_drops = tmp_6;
  record->ntp_tokens = max_ntp_tokens;
  record->cmd_tokens = max_cmd_tokens;
  tmp_7 = (int8_t)(-128);
  record->cmd_rate = tmp_7;
  record->ntp_rate = tmp_7;
  record->ntp_timeout_rate = (int8_t)(-128);
  record->flags = (uint8_t)0;
  UTI_ZeroNtp64(& record->ntp_rx_ts);
  UTI_ZeroNtp64(& record->ntp_tx_ts);
  __retres = record;
  return_label: return __retres;
}

static int expand_hashtable(void)
{
  int __retres;
  ARR_Instance old_records;
  Record *old_record;
  Record *new_record;
  unsigned int i;
  old_records = records;
  if ((unsigned int)2 * slots > max_slots) {
    __retres = 0;
    goto return_label;
  }
  records = ARR_CreateInstance((unsigned int)sizeof(Record));
  if ((unsigned int)1 > (unsigned int)2 * slots) slots = (unsigned int)1;
  else slots = (unsigned int)2 * slots;
  __FC_assert((slots <= max_slots) != 0,"clientlog.c",245,
              "slots <= max_slots");
  ARR_SetSize(records,slots * (1U << 4));
  i = (unsigned int)0;
  while (i < slots * (1U << 4)) {
    new_record = (Record *)ARR_GetElement(records,i);
    new_record->ip_addr.family = (uint16_t)0;
    i ++;
  }
  if (! old_records) {
    __retres = 1;
    goto return_label;
  }
  i = (unsigned int)0;
  while (1) {
    unsigned int tmp;
    tmp = ARR_GetSize(old_records);
    ;
    if (! (i < tmp)) break;
    old_record = (Record *)ARR_GetElement(old_records,i);
    if ((int)old_record->ip_addr.family == 0) goto __Cont;
    new_record = get_record(& old_record->ip_addr);
    __FC_assert(new_record != (Record *)0,"clientlog.c",266,"new_record");
    *new_record = *old_record;
    __Cont: i ++;
  }
  ARR_DestroyInstance(old_records);
  __retres = 1;
  return_label: return __retres;
}

static void set_bucket_params(int interval, int burst, uint16_t *max_tokens,
                              uint16_t *tokens_per_packet, int *token_shift)
{
  int tmp;
  int tmp_1;
  if (interval < 12) tmp = interval; else tmp = 12;
  if (-15 - 4 > tmp) interval = -15 - 4;
  else {
    int tmp_0;
    if (interval < 12) tmp_0 = interval; else tmp_0 = 12;
    interval = tmp_0;
  }
  if (burst < 255) tmp_1 = burst; else tmp_1 = 255;
  if (1 > tmp_1) burst = 1;
  else {
    int tmp_2;
    if (burst < 255) tmp_2 = burst; else tmp_2 = 255;
    burst = tmp_2;
  }
  if (interval >= -4) {
    *token_shift = 0;
    while (*token_shift < interval + 4) {
      if ((unsigned int)(burst << ((4 + interval) - *token_shift)) < 1U << 16) 
        break;
      (*token_shift) ++;
    }
  }
  else {
    *token_shift = interval + 4;
    *tokens_per_packet = (uint16_t)1;
    if (1U << - *token_shift > (unsigned int)burst) burst = (int)(1U << - *token_shift);
    else burst = burst;
  }
  *tokens_per_packet = (uint16_t)(1U << ((4 + interval) - *token_shift));
  *max_tokens = (uint16_t)((int)*tokens_per_packet * burst);
  return;
}

void CLG_Initialise(void)
{
  int interval;
  int burst;
  int leak_rate;
  int tmp_3;
  int tmp_6;
  int tmp_8;
  int tmp_7;
  unsigned long tmp_9;
  unsigned int tmp_10;
  max_cmd_tokens = (uint16_t)0;
  max_ntp_tokens = max_cmd_tokens;
  cmd_tokens_per_packet = (uint16_t)0;
  ntp_tokens_per_packet = cmd_tokens_per_packet;
  cmd_token_shift = 0;
  ntp_token_shift = cmd_token_shift;
  cmd_leak_rate = 0;
  ntp_leak_rate = cmd_leak_rate;
  ntp_limit_interval = -15 - 4;
  tmp_3 = CNF_GetNTPRateLimit(& interval,& burst,& leak_rate);
  if (tmp_3) {
    int tmp;
    int tmp_1;
    set_bucket_params(interval,burst,& max_ntp_tokens,
                      & ntp_tokens_per_packet,& ntp_token_shift);
    if (leak_rate < 4) tmp = leak_rate; else tmp = 4;
    if (1 > tmp) ntp_leak_rate = 1;
    else {
      int tmp_0;
      if (leak_rate < 4) tmp_0 = leak_rate; else tmp_0 = 4;
      ntp_leak_rate = tmp_0;
    }
    if (interval < 12) tmp_1 = interval; else tmp_1 = 12;
    if (-15 - 4 > tmp_1) ntp_limit_interval = -15 - 4;
    else {
      int tmp_2;
      if (interval < 12) tmp_2 = interval; else tmp_2 = 12;
      ntp_limit_interval = tmp_2;
    }
  }
  tmp_6 = CNF_GetCommandRateLimit(& interval,& burst,& leak_rate);
  if (tmp_6) {
    int tmp_4;
    set_bucket_params(interval,burst,& max_cmd_tokens,
                      & cmd_tokens_per_packet,& cmd_token_shift);
    if (leak_rate < 4) tmp_4 = leak_rate; else tmp_4 = 4;
    if (1 > tmp_4) cmd_leak_rate = 1;
    else {
      int tmp_5;
      if (leak_rate < 4) tmp_5 = leak_rate; else tmp_5 = 4;
      cmd_leak_rate = tmp_5;
    }
  }
  tmp_7 = CNF_GetNoClientLog();
  if (tmp_7) tmp_8 = 0; else tmp_8 = 1;
  active = tmp_8;
  if (! active) {
    if (ntp_leak_rate) goto _LOR;
    else 
      if (cmd_leak_rate) {
        _LOR:
        {
          {
            void *__va_args[1] = {(void *)0};
            LOG_Message(LOGS_FATAL,
                        "ratelimit cannot be used with noclientlog",
                        (void * const *)(__va_args));
          }
          exit(1);
        }
      }
    goto return_label;
  }
  tmp_9 = CNF_GetClientLogLimit();
  max_slots = (unsigned int)(tmp_9 / (((sizeof(Record) * (unsigned long)(
                                        1U << 4)) * (unsigned long)3) / (unsigned long)2));
  if (max_slots < 1U << (24 - 4)) tmp_10 = max_slots;
  else tmp_10 = 1U << (24 - 4);
  if ((unsigned int)1 > tmp_10) max_slots = (unsigned int)1;
  else {
    unsigned int tmp_11;
    if (max_slots < 1U << (24 - 4)) tmp_11 = max_slots;
    else tmp_11 = 1U << (24 - 4);
    max_slots = tmp_11;
  }
  slots = (unsigned int)0;
  records = (ARR_Instance)0;
  expand_hashtable();
  UTI_GetRandomBytes((void *)(& ts_offset),(unsigned int)sizeof(ts_offset));
  ts_offset %= 1000000000U / (1U << 4);
  return_label: return;
}

void CLG_Finalise(void)
{
  if (! active) goto return_label;
  ARR_DestroyInstance(records);
  return_label: return;
}

static uint32_t get_ts_from_timespec(struct timespec *ts)
{
  uint32_t __retres;
  uint32_t sec = (uint32_t)ts->tv_sec;
  uint32_t nsec = (uint32_t)ts->tv_nsec;
  nsec += ts_offset;
  if (nsec >= 1000000000U) {
    nsec -= 1000000000U;
    sec ++;
  }
  __retres = (sec << 4) | (140740U * (nsec >> 15) >> (32 - 4));
  return __retres;
}

static void update_record(struct timespec *now, uint32_t *last_hit,
                          uint32_t *hits, uint16_t *tokens,
                          uint32_t max_tokens, int token_shift, int8_t *rate)
{
  uint32_t interval;
  uint32_t now_ts;
  uint32_t prev_hit;
  uint32_t new_tokens;
  int interval2;
  now_ts = get_ts_from_timespec(now);
  prev_hit = *last_hit;
  *last_hit = now_ts;
  (*hits) ++;
  interval = now_ts - prev_hit;
  if (prev_hit == (uint32_t)0) goto return_label;
  else 
    if ((int32_t)interval < 0) goto return_label;
  if (token_shift >= 0) new_tokens = (now_ts >> token_shift) - (prev_hit >> token_shift);
  else 
    if (now_ts - prev_hit > max_tokens) new_tokens = max_tokens;
    else new_tokens = (now_ts - prev_hit) << - token_shift;
  if ((uint32_t)*tokens + new_tokens < max_tokens) *tokens = (uint16_t)(
                                                   (uint32_t)*tokens + new_tokens);
  else *tokens = (uint16_t)max_tokens;
  if (interval) {
    interval += interval >> 1;
    interval2 = -4 * 4;
    while (interval2 < - (-14 * 4)) {
      if (interval <= (uint32_t)1) break;
      interval >>= 1;
      interval2 += 4;
    }
  }
  else interval2 = -4 * (4 + 1);
  if ((int)*rate == -128) *rate = (int8_t)(- interval2);
  else 
    if ((int)*rate < - interval2) *rate = (int8_t)((int)*rate + 1);
    else 
      if ((int)*rate > - interval2) 
        if ((int)*rate > (4 * 5) / 2 - interval2) *rate = (int8_t)((4 * 5) / 2 - interval2);
        else *rate = (int8_t)((((int)*rate - interval2) - 1) / 2);
  return_label: return;
}

static int get_index(Record *record)
{
  int __retres;
  void *tmp;
  tmp = ARR_GetElements(records);
  ;
  __retres = (int)(record - (Record *)tmp);
  return __retres;
}

int CLG_GetClientIndex(IPAddr *client)
{
  int __retres;
  Record *record;
  int tmp;
  record = get_record(client);
  if (record == (Record *)0) {
    __retres = -1;
    goto return_label;
  }
  tmp = get_index(record);
  __retres = tmp;
  return_label: return __retres;
}

int CLG_LogNTPAccess(IPAddr *client, struct timespec *now)
{
  int __retres;
  Record *record;
  int8_t *tmp;
  int tmp_0;
  total_ntp_hits ++;
  record = get_record(client);
  if (record == (Record *)0) {
    __retres = -1;
    goto return_label;
  }
  if ((int)record->flags & 0x1) tmp = & record->ntp_timeout_rate;
  else tmp = & record->ntp_rate;
  ;
  ;
  ;
  ;
  ;
  ;
  update_record(now,& record->last_ntp_hit,& record->ntp_hits,
                & record->ntp_tokens,(uint32_t)max_ntp_tokens,
                ntp_token_shift,tmp);
  tmp_0 = get_index(record);
  __retres = tmp_0;
  return_label: return __retres;
}

int CLG_LogCommandAccess(IPAddr *client, struct timespec *now)
{
  int __retres;
  Record *record;
  int tmp;
  total_cmd_hits ++;
  record = get_record(client);
  if (record == (Record *)0) {
    __retres = -1;
    goto return_label;
  }
  update_record(now,& record->last_cmd_hit,& record->cmd_hits,
                & record->cmd_tokens,(uint32_t)max_cmd_tokens,
                cmd_token_shift,& record->cmd_rate);
  tmp = get_index(record);
  __retres = tmp;
  return_label: return __retres;
}

static uint32_t limit_response_random_rnd;
static int limit_response_random(int leak_rate);

static int limit_response_random_bits_left = 0;
static int limit_response_random(int leak_rate)
{
  int r;
  if (limit_response_random_bits_left < leak_rate) {
    UTI_GetRandomBytes((void *)(& limit_response_random_rnd),
                       (unsigned int)sizeof(limit_response_random_rnd));
    limit_response_random_bits_left = (int)((unsigned long)8 * sizeof(limit_response_random_rnd));
  }
  if (limit_response_random_rnd % (1U << leak_rate)) r = 1; else r = 0;
  limit_response_random_rnd >>= leak_rate;
  limit_response_random_bits_left -= leak_rate;
  return r;
}

int CLG_LimitNTPResponseRate(int index_0)
{
  int __retres;
  Record *record;
  int drop;
  if (! ntp_tokens_per_packet) {
    __retres = 0;
    goto return_label;
  }
  record = (Record *)ARR_GetElement(records,(unsigned int)index_0);
  record->flags = (uint8_t)((int)record->flags & ~ 0x1);
  if ((int)record->ntp_tokens >= (int)ntp_tokens_per_packet) {
    record->ntp_tokens = (uint16_t)((int)record->ntp_tokens - (int)ntp_tokens_per_packet);
    __retres = 0;
    goto return_label;
  }
  drop = limit_response_random(ntp_leak_rate);
  if ((int)record->ntp_timeout_rate != -128) 
    if ((int)record->ntp_timeout_rate > (int)record->ntp_rate + 4) drop = ! drop;
  if (! drop) {
    record->ntp_tokens = (uint16_t)0;
    __retres = 0;
    goto return_label;
  }
  record->flags = (uint8_t)((int)record->flags | 0x1);
  record->ntp_drops = (uint16_t)((int)record->ntp_drops + 1);
  total_ntp_drops ++;
  __retres = 1;
  return_label: return __retres;
}

int CLG_LimitCommandResponseRate(int index_0)
{
  int __retres;
  Record *record;
  int tmp;
  if (! cmd_tokens_per_packet) {
    __retres = 0;
    goto return_label;
  }
  record = (Record *)ARR_GetElement(records,(unsigned int)index_0);
  if ((int)record->cmd_tokens >= (int)cmd_tokens_per_packet) {
    record->cmd_tokens = (uint16_t)((int)record->cmd_tokens - (int)cmd_tokens_per_packet);
    __retres = 0;
    goto return_label;
  }
  tmp = limit_response_random(cmd_leak_rate);
  if (! tmp) {
    record->cmd_tokens = (uint16_t)0;
    __retres = 0;
    goto return_label;
  }
  record->cmd_drops = (uint16_t)((int)record->cmd_drops + 1);
  total_cmd_drops ++;
  __retres = 1;
  return_label: return __retres;
}

void CLG_GetNtpTimestamps(int index_0, NTP_int64 **rx_ts, NTP_int64 **tx_ts)
{
  Record *record;
  record = (Record *)ARR_GetElement(records,(unsigned int)index_0);
  *rx_ts = & record->ntp_rx_ts;
  *tx_ts = & record->ntp_tx_ts;
  return;
}

int CLG_GetNtpMinPoll(void)
{
  return ntp_limit_interval;
}

int CLG_GetNumberOfIndices(void)
{
  int __retres;
  unsigned int tmp;
  if (! active) {
    __retres = -1;
    goto return_label;
  }
  tmp = ARR_GetSize(records);
  __retres = (int)tmp;
  return_label: return __retres;
}

static int get_interval(int rate)
{
  int __retres;
  int tmp;
  if (rate == -128) {
    __retres = 127;
    goto return_label;
  }
  if (rate > 0) tmp = 4 / 2; else tmp = -4 / 2;
  rate += tmp;
  __retres = rate / -4;
  return_label: return __retres;
}

static uint32_t get_last_ago(uint32_t x, uint32_t y)
{
  uint32_t __retres;
  if (y == (uint32_t)0) {
    __retres = (uint32_t)(-1);
    goto return_label;
  }
  else 
    if ((int32_t)(x - y) < 0) {
      __retres = (uint32_t)(-1);
      goto return_label;
    }
  __retres = (x - y) >> 4;
  return_label: return __retres;
}

int CLG_GetClientAccessReportByIndex(int index_0,
                                     RPT_ClientAccessByIndex_Report *report,
                                     struct timespec *now)
{
  int __retres;
  Record *record;
  uint32_t now_ts;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  if (! active) {
    __retres = 0;
    goto return_label;
  }
  else 
    if (index_0 < 0) {
      __retres = 0;
      goto return_label;
    }
    else {
      unsigned int tmp;
      tmp = ARR_GetSize(records);
      ;
      if ((unsigned int)index_0 >= tmp) {
        __retres = 0;
        goto return_label;
      }
    }
  record = (Record *)ARR_GetElement(records,(unsigned int)index_0);
  if ((int)record->ip_addr.family == 0) {
    __retres = 0;
    goto return_label;
  }
  now_ts = get_ts_from_timespec(now);
  report->ip_addr = record->ip_addr;
  report->ntp_hits = record->ntp_hits;
  report->cmd_hits = record->cmd_hits;
  report->ntp_drops = record->ntp_drops;
  report->cmd_drops = record->cmd_drops;
  tmp_0 = get_interval((int)record->ntp_rate);
  report->ntp_interval = (int8_t)tmp_0;
  tmp_1 = get_interval((int)record->cmd_rate);
  report->cmd_interval = (int8_t)tmp_1;
  tmp_2 = get_interval((int)record->ntp_timeout_rate);
  report->ntp_timeout_interval = (int8_t)tmp_2;
  report->last_ntp_hit_ago = get_last_ago(now_ts,record->last_ntp_hit);
  report->last_cmd_hit_ago = get_last_ago(now_ts,record->last_cmd_hit);
  __retres = 1;
  return_label: return __retres;
}

void CLG_GetServerStatsReport(RPT_ServerStatsReport *report)
{
  report->ntp_hits = total_ntp_hits;
  report->cmd_hits = total_cmd_hits;
  report->ntp_drops = total_ntp_drops;
  report->cmd_drops = total_cmd_drops;
  report->log_drops = total_record_drops;
  return;
}

void SST_Initialise(void);

void SST_Finalise(void);

SST_Stats SST_CreateInstance(uint32_t refid, IPAddr *addr, int min_samples_0,
                             int max_samples_0, double min_delay,
                             double asymmetry);

void SST_DeleteInstance(SST_Stats inst);

void SST_ResetInstance(SST_Stats inst);

void SST_SetRefid(SST_Stats inst, uint32_t refid, IPAddr *addr);

void SST_AccumulateSample(SST_Stats inst, NTP_Sample *sample);

void SST_DoNewRegression(SST_Stats inst);

void SST_GetFrequencyRange(SST_Stats inst, double *lo, double *hi);

void SST_GetSelectionData(SST_Stats inst, struct timespec *now, int *stratum,
                          NTP_Leap *leap, double *offset_lo_limit,
                          double *offset_hi_limit, double *root_distance,
                          double *std_dev, double *first_sample_ago,
                          double *last_sample_ago, int *select_ok);

void SST_GetTrackingData(SST_Stats inst, struct timespec *ref_time,
                         double *average_offset, double *offset_sd,
                         double *frequency, double *frequency_sd,
                         double *skew, double *root_delay,
                         double *root_dispersion);

void SST_SlewSamples(SST_Stats inst, struct timespec *when, double dfreq,
                     double doffset);

void SST_AddDispersion(SST_Stats inst, double dispersion);

double SST_PredictOffset(SST_Stats inst, struct timespec *when);

double SST_MinRoundTripDelay(SST_Stats inst);

int SST_GetDelayTestData(SST_Stats inst, struct timespec *sample_time,
                         double *last_sample_ago, double *predicted_offset,
                         double *min_delay, double *skew, double *std_dev);

void SST_SaveToFile(SST_Stats inst, FILE *out);

int SST_LoadFromFile(SST_Stats inst, FILE *in);

void SST_DoSourceReport(SST_Stats inst, RPT_SourceReport *report,
                        struct timespec *now);

void SST_DoSourcestatsReport(SST_Stats inst, RPT_SourcestatsReport *report,
                             struct timespec *now);

int SST_Samples(SST_Stats inst);

double SST_GetJitterAsymmetry(SST_Stats inst);

void SRC_Initialise(void);

void SRC_Finalise(void);

SRC_Instance SRC_CreateNewInstance(uint32_t ref_id, SRC_Type type,
                                   int sel_options, IPAddr *addr,
                                   int min_samples_0, int max_samples_0,
                                   double min_delay, double asymmetry);

void SRC_DestroyInstance(SRC_Instance instance);

void SRC_ResetInstance(SRC_Instance instance);

void SRC_SetRefid(SRC_Instance instance, uint32_t ref_id, IPAddr *addr);

SST_Stats SRC_GetSourcestats(SRC_Instance instance);

void SRC_AccumulateSample(SRC_Instance inst, NTP_Sample *sample);

void SRC_SetActive(SRC_Instance inst);

void SRC_UnsetActive(SRC_Instance inst);

void SRC_UpdateReachability(SRC_Instance inst, int reachable);

void SRC_ResetReachability(SRC_Instance inst);

void SRC_SelectSource(SRC_Instance updated_inst);

void SRC_ReselectSource(void);

void SRC_SetReselectDistance(double distance);

void SRC_DumpSources(void);

void SRC_ReloadSources(void);

void SRC_RemoveDumpFiles(void);

int SRC_IsSyncPeer(SRC_Instance inst);

int SRC_IsReachable(SRC_Instance inst);

int SRC_ReadNumberOfSources(void);

int SRC_ActiveSources(void);

int SRC_ReportSource(int index_0, RPT_SourceReport *report,
                     struct timespec *now);

int SRC_ReportSourcestats(int index_0, RPT_SourcestatsReport *report,
                          struct timespec *now);

SRC_Type SRC_GetType(int index_0);

int CPS_ParseNTPSourceAdd(char *line, CPS_NTP_Source *src);

int CPS_ParseLocal(char *line, int *stratum, int *orphan, double *distance);

void CPS_NormalizeLine(char *line);

char *CPS_SplitWord(char *line);

int CPS_ParseKey(char *line, uint32_t *id, char const **hash, char **key);

void DNS_SetAddressFamily(int family);

DNS_Status DNS_Name2IPAddress(char const *name, IPAddr *ip_addrs,
                              int max_addrs);

int DNS_IPAddress2Name(IPAddr *ip_addr, char *name, int len);

void DNS_Reload(void);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_1(char const * restrict s, char const * restrict format,
                int *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_2(char const * restrict s, char const * restrict format,
                int *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_3(char const * restrict s, char const * restrict format,
                int *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_4(char const * restrict s, char const * restrict format,
                unsigned short *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_5(char const * restrict s, char const * restrict format,
                double *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_6(char const * restrict s, char const * restrict format,
                int *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_7(char const * restrict s, char const * restrict format,
                int *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_8(char const * restrict s, char const * restrict format,
                int *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_9(char const * restrict s, char const * restrict format,
                double *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_10(char const * restrict s, char const * restrict format,
                 int *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_11(char const * restrict s, char const * restrict format,
                 int *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_12(char const * restrict s, char const * restrict format,
                 int *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_13(char const * restrict s, char const * restrict format,
                 double *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_14(char const * restrict s, char const * restrict format,
                 double *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_15(char const * restrict s, char const * restrict format,
                 double *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_16(char const * restrict s, char const * restrict format,
                 int *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_17(char const * restrict s, char const * restrict format,
                 double *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_18(char const * restrict s, char const * restrict format,
                 unsigned int *param0, int *param1);

int CPS_ParseNTPSourceAdd(char *line, CPS_NTP_Source *src)
{
  int __retres;
  char *hostname;
  char *cmd;
  int n;
  src->port = (unsigned short)123;
  src->params.minpoll = 6;
  src->params.maxpoll = 10;
  src->params.connectivity = SRC_ONLINE;
  src->params.auto_offline = 0;
  src->params.presend_minpoll = 100;
  src->params.burst = 0;
  src->params.iburst = 0;
  src->params.min_stratum = 0;
  src->params.poll_target = 8;
  src->params.version = 0;
  src->params.max_sources = 4;
  src->params.min_samples = -1;
  src->params.max_samples = -1;
  src->params.filter_length = 0;
  src->params.interleaved = 0;
  src->params.sel_options = 0;
  src->params.authkey = (uint32_t)0;
  src->params.max_delay = 3.0;
  src->params.max_delay_ratio = 0.0;
  src->params.max_delay_dev_ratio = 10.0;
  src->params.min_delay = 0.0;
  src->params.asymmetry = 1.0;
  src->params.offset = 0.0;
  hostname = line;
  line = CPS_SplitWord(line);
  if (! *hostname) {
    __retres = 0;
    goto return_label;
  }
  src->name = hostname;
  while (*line) {
    {
      int tmp_43;
      cmd = line;
      line = CPS_SplitWord(line);
      n = 0;
      tmp_43 = strcasecmp((char const *)cmd,"auto_offline");
      if (tmp_43) {
        int tmp_42;
        tmp_42 = strcasecmp((char const *)cmd,"burst");
        if (tmp_42) {
          int tmp_41;
          tmp_41 = strcasecmp((char const *)cmd,"iburst");
          if (tmp_41) {
            int tmp_40;
            tmp_40 = strcasecmp((char const *)cmd,"offline");
            if (tmp_40) {
              int tmp_39;
              tmp_39 = strcasecmp((char const *)cmd,"noselect");
              if (tmp_39) {
                int tmp_38;
                tmp_38 = strcasecmp((char const *)cmd,"prefer");
                if (tmp_38) {
                  int tmp_37;
                  tmp_37 = strcasecmp((char const *)cmd,"require");
                  if (tmp_37) {
                    int tmp_36;
                    tmp_36 = strcasecmp((char const *)cmd,"trust");
                    if (tmp_36) {
                      int tmp_35;
                      tmp_35 = strcasecmp((char const *)cmd,"key");
                      if (tmp_35) {
                        int tmp_34;
                        tmp_34 = strcasecmp((char const *)cmd,"asymmetry");
                        if (tmp_34) {
                          int tmp_33;
                          tmp_33 = strcasecmp((char const *)cmd,"filter");
                          if (tmp_33) {
                            int tmp_32;
                            tmp_32 = strcasecmp((char const *)cmd,"maxdelay");
                            if (tmp_32) {
                              int tmp_31;
                              tmp_31 = strcasecmp((char const *)cmd,
                                                  "maxdelayratio");
                              if (tmp_31) {
                                int tmp_30;
                                tmp_30 = strcasecmp((char const *)cmd,
                                                    "maxdelaydevratio");
                                if (tmp_30) {
                                  int tmp_29;
                                  tmp_29 = strcasecmp((char const *)cmd,
                                                      "maxpoll");
                                  if (tmp_29) {
                                    int tmp_28;
                                    tmp_28 = strcasecmp((char const *)cmd,
                                                        "maxsamples");
                                    if (tmp_28) {
                                      int tmp_27;
                                      tmp_27 = strcasecmp((char const *)cmd,
                                                          "maxsources");
                                      if (tmp_27) {
                                        int tmp_26;
                                        tmp_26 = strcasecmp((char const *)cmd,
                                                            "mindelay");
                                        if (tmp_26) {
                                          int tmp_25;
                                          tmp_25 = strcasecmp((char const *)cmd,
                                                              "minpoll");
                                          if (tmp_25) {
                                            int tmp_24;
                                            tmp_24 = strcasecmp((char const *)cmd,
                                                                "minsamples");
                                            if (tmp_24) {
                                              int tmp_23;
                                              tmp_23 = strcasecmp((char const *)cmd,
                                                                  "minstratum");
                                              if (tmp_23) {
                                                int tmp_22;
                                                tmp_22 = strcasecmp((char const *)cmd,
                                                                    "offset");
                                                if (tmp_22) {
                                                  int tmp_21;
                                                  tmp_21 = strcasecmp
                                                  ((char const *)cmd,"port");
                                                  if (tmp_21) {
                                                    int tmp_20;
                                                    tmp_20 = strcasecmp
                                                    ((char const *)cmd,
                                                     "polltarget");
                                                    if (tmp_20) {
                                                      int tmp_19;
                                                      tmp_19 = strcasecmp
                                                      ((char const *)cmd,
                                                       "presend");
                                                      if (tmp_19) {
                                                        int tmp_18;
                                                        tmp_18 = strcasecmp
                                                        ((char const *)cmd,
                                                         "version");
                                                        if (tmp_18) {
                                                          int tmp_17;
                                                          tmp_17 = strcasecmp
                                                          ((char const *)cmd,
                                                           "xleave");
                                                          if (tmp_17) {
                                                            __retres = 0;
                                                            goto return_label;
                                                          }
                                                          else src->params.interleaved = 1;
                                                        }
                                                        else {
                                                          int tmp_16;
                                                          tmp_16 = sscanf
                                                          ((char const *)line,
                                                           "%d%n",
                                                           & src->params.version,
                                                           & n); /* sscanf_va_1 */
                                                          if (tmp_16 != 1) {
                                                            __retres = 0;
                                                            goto return_label;
                                                          }
                                                        }
                                                      }
                                                      else {
                                                        int tmp_15;
                                                        tmp_15 = sscanf
                                                        ((char const *)line,
                                                         "%d%n",
                                                         & src->params.presend_minpoll,
                                                         & n); /* sscanf_va_2 */
                                                        if (tmp_15 != 1) {
                                                          __retres = 0;
                                                          goto return_label;
                                                        }
                                                      }
                                                    }
                                                    else {
                                                      int tmp_14;
                                                      tmp_14 = sscanf
                                                      ((char const *)line,
                                                       "%d%n",
                                                       & src->params.poll_target,
                                                       & n); /* sscanf_va_3 */
                                                      if (tmp_14 != 1) {
                                                        __retres = 0;
                                                        goto return_label;
                                                      }
                                                    }
                                                  }
                                                  else {
                                                    int tmp_13;
                                                    tmp_13 = sscanf((char const *)line,
                                                                    "%hu%n",
                                                                    & src->port,
                                                                    & n); /* sscanf_va_4 */
                                                    if (tmp_13 != 1) {
                                                      __retres = 0;
                                                      goto return_label;
                                                    }
                                                  }
                                                }
                                                else {
                                                  int tmp_12;
                                                  tmp_12 = sscanf((char const *)line,
                                                                  "%lf%n",
                                                                  & src->params.offset,
                                                                  & n); /* sscanf_va_5 */
                                                  if (tmp_12 != 1) {
                                                    __retres = 0;
                                                    goto return_label;
                                                  }
                                                }
                                              }
                                              else {
                                                int tmp_11;
                                                tmp_11 = sscanf((char const *)line,
                                                                "%d%n",
                                                                & src->params.min_stratum,
                                                                & n); /* sscanf_va_6 */
                                                if (tmp_11 != 1) {
                                                  __retres = 0;
                                                  goto return_label;
                                                }
                                              }
                                            }
                                            else {
                                              int tmp_10;
                                              tmp_10 = sscanf((char const *)line,
                                                              "%d%n",
                                                              & src->params.min_samples,
                                                              & n); /* sscanf_va_7 */
                                              if (tmp_10 != 1) {
                                                __retres = 0;
                                                goto return_label;
                                              }
                                            }
                                          }
                                          else {
                                            int tmp_9;
                                            tmp_9 = sscanf((char const *)line,
                                                           "%d%n",
                                                           & src->params.minpoll,
                                                           & n); /* sscanf_va_8 */
                                            if (tmp_9 != 1) {
                                              __retres = 0;
                                              goto return_label;
                                            }
                                          }
                                        }
                                        else {
                                          int tmp_8;
                                          tmp_8 = sscanf((char const *)line,
                                                         "%lf%n",
                                                         & src->params.min_delay,
                                                         & n); /* sscanf_va_9 */
                                          if (tmp_8 != 1) {
                                            __retres = 0;
                                            goto return_label;
                                          }
                                        }
                                      }
                                      else {
                                        int tmp_7;
                                        tmp_7 = sscanf((char const *)line,
                                                       "%d%n",
                                                       & src->params.max_sources,
                                                       & n); /* sscanf_va_10 */
                                        if (tmp_7 != 1) {
                                          __retres = 0;
                                          goto return_label;
                                        }
                                      }
                                    }
                                    else {
                                      int tmp_6;
                                      tmp_6 = sscanf((char const *)line,
                                                     "%d%n",
                                                     & src->params.max_samples,
                                                     & n); /* sscanf_va_11 */
                                      if (tmp_6 != 1) {
                                        __retres = 0;
                                        goto return_label;
                                      }
                                    }
                                  }
                                  else {
                                    int tmp_5;
                                    tmp_5 = sscanf((char const *)line,"%d%n",
                                                   & src->params.maxpoll,& n); /* sscanf_va_12 */
                                    if (tmp_5 != 1) {
                                      __retres = 0;
                                      goto return_label;
                                    }
                                  }
                                }
                                else {
                                  int tmp_4;
                                  tmp_4 = sscanf((char const *)line,"%lf%n",
                                                 & src->params.max_delay_dev_ratio,
                                                 & n); /* sscanf_va_13 */
                                  if (tmp_4 != 1) {
                                    __retres = 0;
                                    goto return_label;
                                  }
                                }
                              }
                              else {
                                int tmp_3;
                                tmp_3 = sscanf((char const *)line,"%lf%n",
                                               & src->params.max_delay_ratio,
                                               & n); /* sscanf_va_14 */
                                if (tmp_3 != 1) {
                                  __retres = 0;
                                  goto return_label;
                                }
                              }
                            }
                            else {
                              int tmp_2;
                              tmp_2 = sscanf((char const *)line,"%lf%n",
                                             & src->params.max_delay,& n); /* sscanf_va_15 */
                              if (tmp_2 != 1) {
                                __retres = 0;
                                goto return_label;
                              }
                            }
                          }
                          else {
                            int tmp_1;
                            tmp_1 = sscanf((char const *)line,"%d%n",
                                           & src->params.filter_length,& n); /* sscanf_va_16 */
                            if (tmp_1 != 1) {
                              __retres = 0;
                              goto return_label;
                            }
                          }
                        }
                        else {
                          int tmp_0;
                          tmp_0 = sscanf((char const *)line,"%lf%n",
                                         & src->params.asymmetry,& n); /* sscanf_va_17 */
                          if (tmp_0 != 1) {
                            __retres = 0;
                            goto return_label;
                          }
                        }
                      }
                      else {
                        int tmp;
                        tmp = sscanf((char const *)line,"%u%n",
                                     & src->params.authkey,& n); /* sscanf_va_18 */
                        if (tmp != 1) {
                          __retres = 0;
                          goto return_label;
                        }
                        else 
                          if (src->params.authkey == (uint32_t)0) {
                            __retres = 0;
                            goto return_label;
                          }
                      }
                    }
                    else src->params.sel_options |= 0x4;
                  }
                  else src->params.sel_options |= 0x8;
                }
                else src->params.sel_options |= 0x2;
              }
              else src->params.sel_options |= 0x1;
            }
            else src->params.connectivity = SRC_OFFLINE;
          }
          else src->params.iburst = 1;
        }
        else src->params.burst = 1;
      }
      else src->params.auto_offline = 1;
    }
    line += n;
  }
  __retres = 1;
  return_label: return __retres;
}

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_19(char const * restrict s, char const * restrict format,
                 double *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_20(char const * restrict s, char const * restrict format,
                 int *param0, int *param1);

int CPS_ParseLocal(char *line, int *stratum, int *orphan, double *distance)
{
  int __retres;
  int n;
  char *cmd;
  *stratum = 10;
  *distance = 1.0;
  *orphan = 0;
  while (*line) {
    int tmp_3;
    cmd = line;
    line = CPS_SplitWord(line);
    tmp_3 = strcasecmp((char const *)cmd,"stratum");
    if (tmp_3) {
      int tmp_2;
      tmp_2 = strcasecmp((char const *)cmd,"orphan");
      if (tmp_2) {
        int tmp_1;
        tmp_1 = strcasecmp((char const *)cmd,"distance");
        if (tmp_1) {
          __retres = 0;
          goto return_label;
        }
        else {
          int tmp_0;
          tmp_0 = sscanf((char const *)line,"%lf%n",distance,& n); /* sscanf_va_19 */
          if (tmp_0 != 1) {
            __retres = 0;
            goto return_label;
          }
        }
      }
      else {
        *orphan = 1;
        n = 0;
      }
    }
    else {
      int tmp;
      tmp = sscanf((char const *)line,"%d%n",stratum,& n); /* sscanf_va_20 */
      if (tmp != 1) {
        __retres = 0;
        goto return_label;
      }
      else 
        if (*stratum >= 16) {
          __retres = 0;
          goto return_label;
        }
        else 
          if (*stratum <= 0) {
            __retres = 0;
            goto return_label;
          }
    }
    line += n;
  }
  __retres = 1;
  return_label: return __retres;
}

void CPS_NormalizeLine(char *line)
{
  char *p;
  char *q;
  int space = 1;
  int first = 1;
  q = line;
  p = q;
  while (*p) {
    {
      int tmp_0;
      char *tmp_2;
      tmp_0 = isspace((int)((unsigned char)*p));
      if (tmp_0) {
        if (! space) {
          char *tmp;
          tmp = q;
          q ++;
          *tmp = (char)' ';
        }
        space = 1;
        goto __Cont;
      }
      if (first) {
        char *tmp_1;
        tmp_1 = strchr("!;#%",(int)*p);
        if (tmp_1) break;
      }
      tmp_2 = q;
      q ++;
      *tmp_2 = *p;
      first = 0;
      space = first;
    }
    __Cont: p ++;
  }
  if (q > line) 
    if ((int)*(q + -1) == ' ') q --;
  *q = (char)'\000';
  return;
}

char *CPS_SplitWord(char *line)
{
  char *p = line;
  char *q = line;
  while (1) {
    if (*q) {
      int tmp;
      tmp = isspace((int)((unsigned char)*q));
      if (! tmp) break;
    }
    else break;
    q ++;
  }
  while (1) {
    char *tmp_0;
    char *tmp_1;
    if (*q) {
      int tmp_2;
      tmp_2 = isspace((int)((unsigned char)*q));
      if (tmp_2) break;
    }
    else break;
    tmp_0 = p;
    p ++;
    tmp_1 = q;
    q ++;
    *tmp_0 = *tmp_1;
  }
  while (1) {
    if (*q) {
      int tmp_3;
      tmp_3 = isspace((int)((unsigned char)*q));
      if (! tmp_3) break;
    }
    else break;
    q ++;
  }
  *p = (char)'\000';
  return q;
}

/*@ requires \valid(param0);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    assigns \result, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_21(char const * restrict s, char const * restrict format,
                 unsigned int *param0);

int CPS_ParseKey(char *line, uint32_t *id, char const **hash, char **key)
{
  int __retres;
  char *s1;
  char *s2;
  char *s3;
  char *s4;
  int tmp;
  s1 = line;
  s2 = CPS_SplitWord(s1);
  s3 = CPS_SplitWord(s2);
  s4 = CPS_SplitWord(s3);
  if (! *s2) {
    __retres = 0;
    goto return_label;
  }
  else 
    if (*s4) {
      __retres = 0;
      goto return_label;
    }
  tmp = sscanf((char const *)s1,"%u",id); /* sscanf_va_21 */
  if (tmp != 1) {
    __retres = 0;
    goto return_label;
  }
  if (*s3) {
    *hash = (char const *)s2;
    *key = s3;
  }
  else {
    *hash = "MD5";
    *key = s2;
  }
  __retres = 1;
  return_label: return __retres;
}

void NCR_Initialise(void);

void NCR_Finalise(void);

NCR_Instance NCR_GetInstance(NTP_Remote_Address *remote_addr,
                             NTP_Source_Type type, SourceParameters *params);

void NCR_DestroyInstance(NCR_Instance instance);

void NCR_StartInstance(NCR_Instance instance);

void NCR_ResetInstance(NCR_Instance instance);

void NCR_ResetPoll(NCR_Instance instance);

void NCR_ChangeRemoteAddress(NCR_Instance inst,
                             NTP_Remote_Address *remote_addr);

int NCR_ProcessRxKnown(NCR_Instance inst, NTP_Local_Address *local_addr,
                       NTP_Local_Timestamp *rx_ts, NTP_Packet *message,
                       int length);

void NCR_ProcessRxUnknown(NTP_Remote_Address *remote_addr,
                          NTP_Local_Address *local_addr,
                          NTP_Local_Timestamp *rx_ts, NTP_Packet *message,
                          int length);

void NCR_ProcessTxKnown(NCR_Instance inst, NTP_Local_Address *local_addr,
                        NTP_Local_Timestamp *tx_ts, NTP_Packet *message,
                        int length);

void NCR_ProcessTxUnknown(NTP_Remote_Address *remote_addr,
                          NTP_Local_Address *local_addr,
                          NTP_Local_Timestamp *tx_ts, NTP_Packet *message,
                          int length);

void NCR_SlewTimes(NCR_Instance inst, struct timespec *when, double dfreq,
                   double doffset);

void NCR_SetConnectivity(NCR_Instance inst, SRC_Connectivity connectivity);

void NCR_ModifyMinpoll(NCR_Instance inst, int new_minpoll);

void NCR_ModifyMaxpoll(NCR_Instance inst, int new_maxpoll);

void NCR_ModifyMaxdelay(NCR_Instance inst, double new_max_delay);

void NCR_ModifyMaxdelayratio(NCR_Instance inst, double new_max_delay_ratio);

void NCR_ModifyMaxdelaydevratio(NCR_Instance inst,
                                double new_max_delay_dev_ratio);

void NCR_ModifyMinstratum(NCR_Instance inst, int new_min_stratum);

void NCR_ModifyPolltarget(NCR_Instance inst, int new_poll_target);

void NCR_InitiateSampleBurst(NCR_Instance inst, int n_good_samples,
                             int n_total_samples);

void NCR_ReportSource(NCR_Instance inst, RPT_SourceReport *report,
                      struct timespec *now);

void NCR_GetNTPReport(NCR_Instance inst, RPT_NTPReport *report);

int NCR_AddAccessRestriction(IPAddr *ip_addr, int subnet_bits, int allow,
                             int all);

int NCR_CheckAccessRestriction(IPAddr *ip_addr);

void NCR_IncrementActivityCounters(NCR_Instance inst, int *online,
                                   int *offline, int *burst_online,
                                   int *burst_offline);

NTP_Remote_Address *NCR_GetRemoteAddress(NCR_Instance inst);

uint32_t NCR_GetLocalRefid(NCR_Instance inst);

int NCR_IsSyncPeer(NCR_Instance inst);

void NCR_AddBroadcastDestination(IPAddr *addr, unsigned short port,
                                 int interval);

extern NSR_Status NSR_AddSource(NTP_Remote_Address *remote_addr,
                                NTP_Source_Type type,
                                SourceParameters *params);

extern void NSR_AddSourceByName(char *name, int port, int pool,
                                NTP_Source_Type type,
                                SourceParameters *params);

extern void NSR_HandleBadSource(IPAddr *address);

extern uint32_t NSR_GetLocalRefid(IPAddr *address);

extern void NSR_ProcessRx(NTP_Remote_Address *remote_addr,
                          NTP_Local_Address *local_addr,
                          NTP_Local_Timestamp *rx_ts, NTP_Packet *message,
                          int length);

extern int RCL_AddRefclock(RefclockParameters *params);

extern int CAM_AddAccessRestriction(IPAddr *ip_addr, int subnet_bits,
                                    int allow, int all);

static int parse_string(char *line, char **result);

static int parse_int(char *line, int *result);

static int parse_double(char *line, double *result);

static int parse_null(char *line);

static void parse_allow_deny(char *line, ARR_Instance restrictions, int allow);

static void parse_bindacqaddress(char *line);

static void parse_bindaddress(char *line);

static void parse_bindcmdaddress(char *line);

static void parse_broadcast(char *line);

static void parse_clientloglimit(char *line);

static void parse_fallbackdrift(char *line);

static void parse_hwtimestamp(char *line);

static void parse_include(char *line);

static void parse_initstepslew(char *line);

static void parse_leapsecmode(char *line);

static void parse_local(char *line);

static void parse_log(char *line);

static void parse_mailonchange(char *line);

static void parse_makestep(char *line);

static void parse_maxchange(char *line);

static void parse_ratelimit(char *line, int *enabled_0, int *interval,
                            int *burst, int *leak);

static void parse_refclock(char *line);

static void parse_smoothtime(char *line);

static void parse_source(char *line, NTP_Source_Type type, int pool);

static void parse_tempcomp(char *line);

static int restarted = 0;
static char *rtc_device;
static int acquisition_port = -1;
static int ntp_port = 123;
static char *keys_file = (char *)0;
static char *drift_file = (char *)0;
static char *rtc_file = (char *)0;
static double max_update_skew = 1000.0;
static double correction_time_ratio = 3.0;
static double max_clock_error = 1.0;
static double max_drift = 500000.0;
static double max_slew_rate = 1e6 / 12.0;
static double max_distance = 3.0;
static double max_jitter = 1.0;
static double reselect_distance = 1e-4;
static double stratum_weight = 1e-3;
static double combine_limit = 3.0;
static int cmd_port = 323;
static int raw_measurements = 0;
static int do_log_measurements = 0;
static int do_log_statistics = 0;
static int do_log_tracking = 0;
static int do_log_rtc = 0;
static int do_log_refclocks = 0;
static int do_log_tempcomp = 0;
static int log_banner = 32;
static char *logdir;
static char *dumpdir;
static int enable_local = 0;
static int local_stratum;
static int local_orphan;
static double local_distance;
static double init_slew_threshold;
static ARR_Instance init_sources;
static int enable_manual = 0;
static int rtc_on_utc = 0;
static char *hwclock_file;
static int rtc_sync = 0;
static int make_step_limit = 0;
static double make_step_threshold = 0.0;
static double rtc_autotrim_threshold = 0.0;
static int min_sources = 1;
static int max_offset_delay = -1;
static int max_offset_ignore;
static double max_offset;
static int max_samples = 0;
static int min_samples = 6;
static double log_change_threshold = 1.0;
static char *mail_user_on_change = (char *)0;
static double mail_change_threshold = 0.0;
static int no_client_log = 0;
static unsigned long client_log_limit = (unsigned long)524288;
static int fb_drift_min = 0;
static int fb_drift_max = 0;
static IPAddr bind_address4;
static IPAddr bind_address6;
static IPAddr bind_acq_address4;
static IPAddr bind_acq_address6;
static IPAddr bind_cmd_address4;
static IPAddr bind_cmd_address6;
static char *bind_cmd_path;
static char *ntp_signd_socket = (char *)0;
static char *pidfile;
static int ntp_ratelimit_enabled = 0;
static int ntp_ratelimit_interval = 3;
static int ntp_ratelimit_burst = 8;
static int ntp_ratelimit_leak = 2;
static int cmd_ratelimit_enabled = 0;
static int cmd_ratelimit_interval = -4;
static int cmd_ratelimit_burst = 8;
static int cmd_ratelimit_leak = 2;
static double smooth_max_freq = 0.0;
static double smooth_max_wander = 0.0;
static int smooth_leap_only = 0;
static char *tempcomp_sensor_file = (char *)0;
static char *tempcomp_point_file = (char *)0;
static double tempcomp_interval;
static double tempcomp_T0;
static double tempcomp_k0;
static double tempcomp_k1;
static double tempcomp_k2;
static int sched_priority = 0;
static int lock_memory = 0;
static REF_LeapMode leapsec_mode = REF_LeapModeSystem;
static char *leapsec_tz = (char *)0;
static char *user;
static ARR_Instance hwts_interfaces;
static ARR_Instance ntp_sources;
static ARR_Instance refclock_sources;
static ARR_Instance ntp_restrictions;
static ARR_Instance cmd_restrictions;
static ARR_Instance broadcasts;
static int line_number;
static char const *processed_file;
static char const *processed_command;
static void command_parse_error(void)
{
  char const *tmp;
  char const *tmp_0;
  if (processed_file) tmp = processed_file; else tmp = "";
  if (processed_file) tmp_0 = " in file "; else tmp_0 = "";
  ;
  ;
  {
    char const *__va_arg0 = processed_command;
    int __va_arg1 = line_number;
    char const *__va_arg2 = tmp_0;
    char const *__va_arg3 = tmp;
    void *__va_args[4] =
      {& __va_arg0, & __va_arg1, & __va_arg2, & __va_arg3};
    LOG_Message(LOGS_FATAL,"Could not parse %s directive at line %d%s%s",
                (void * const *)(__va_args));
  }
  exit(1);
  return;
}

static void other_parse_error(char const *message)
{
  char const *tmp;
  char const *tmp_0;
  if (processed_file) tmp = processed_file; else tmp = "";
  if (processed_file) tmp_0 = " in file "; else tmp_0 = "";
  ;
  ;
  {
    char const *__va_arg0 = message;
    int __va_arg1 = line_number;
    char const *__va_arg2 = tmp_0;
    char const *__va_arg3 = tmp;
    void *__va_args[4] =
      {& __va_arg0, & __va_arg1, & __va_arg2, & __va_arg3};
    LOG_Message(LOGS_FATAL,"%s at line %d%s%s",(void * const *)(__va_args));
  }
  exit(1);
  return;
}

static int get_number_of_args(char *line)
{
  int num = 0;
  if ((int)*line == ' ') line ++;
  if (*line) num ++;
  while (*line) {
    if ((int)*line == ' ') num ++;
    line ++;
  }
  return num;
}

static void check_number_of_args(char *line, int num)
{
  int tmp;
  tmp = get_number_of_args(line);
  num -= tmp;
  if (num) {
    char const *tmp_0;
    char const *tmp_1;
    char const *tmp_2;
    if (processed_file) tmp_0 = processed_file; else tmp_0 = "";
    if (processed_file) tmp_1 = " in file "; else tmp_1 = "";
    ;
    ;
    if (num > 0) tmp_2 = "Missing"; else tmp_2 = "Too many";
    {
      char const *__va_arg0 = tmp_2;
      char const *__va_arg1 = processed_command;
      int __va_arg2 = line_number;
      char const *__va_arg3 = tmp_1;
      char const *__va_arg4 = tmp_0;
      void *__va_args[5] =
        {& __va_arg0, & __va_arg1, & __va_arg2, & __va_arg3, & __va_arg4};
      LOG_Message(LOGS_FATAL,"%s arguments for %s directive at line %d%s%s",
                  (void * const *)(__va_args));
    }
    exit(1);
  }
  return;
}

void CNF_Initialise(int r, int client_only)
{
  restarted = r;
  hwts_interfaces = ARR_CreateInstance((unsigned int)sizeof(CNF_HwTsInterface));
  init_sources = ARR_CreateInstance((unsigned int)sizeof(IPAddr));
  ntp_sources = ARR_CreateInstance((unsigned int)sizeof(NTP_Source));
  refclock_sources = ARR_CreateInstance((unsigned int)sizeof(RefclockParameters));
  broadcasts = ARR_CreateInstance((unsigned int)sizeof(NTP_Broadcast_Destination));
  ntp_restrictions = ARR_CreateInstance((unsigned int)sizeof(AllowDeny));
  cmd_restrictions = ARR_CreateInstance((unsigned int)sizeof(AllowDeny));
  dumpdir = Strdup("");
  logdir = Strdup("");
  rtc_device = Strdup("/dev/rtc");
  hwclock_file = Strdup("");
  user = Strdup("root");
  if (client_only) {
    ntp_port = 0;
    cmd_port = ntp_port;
    bind_cmd_path = Strdup("");
    pidfile = Strdup("");
  }
  else {
    bind_cmd_path = Strdup("/var/run/chrony/chronyd.sock");
    pidfile = Strdup("/var/run/chrony/chronyd.pid");
  }
  return;
}

void CNF_Finalise(void)
{
  unsigned int i;
  i = (unsigned int)0;
  while (1) {
    unsigned int tmp_0;
    void *tmp;
    tmp_0 = ARR_GetSize(hwts_interfaces);
    ;
    if (! (i < tmp_0)) break;
    tmp = ARR_GetElement(hwts_interfaces,i);
    free((void *)((CNF_HwTsInterface *)tmp)->name);
    i ++;
  }
  ARR_DestroyInstance(hwts_interfaces);
  i = (unsigned int)0;
  while (1) {
    unsigned int tmp_2;
    void *tmp_1;
    tmp_2 = ARR_GetSize(ntp_sources);
    ;
    if (! (i < tmp_2)) break;
    tmp_1 = ARR_GetElement(ntp_sources,i);
    free((void *)((NTP_Source *)tmp_1)->params.name);
    i ++;
  }
  ARR_DestroyInstance(init_sources);
  ARR_DestroyInstance(ntp_sources);
  ARR_DestroyInstance(refclock_sources);
  ARR_DestroyInstance(broadcasts);
  ARR_DestroyInstance(ntp_restrictions);
  ARR_DestroyInstance(cmd_restrictions);
  free((void *)drift_file);
  free((void *)dumpdir);
  free((void *)hwclock_file);
  free((void *)keys_file);
  free((void *)leapsec_tz);
  free((void *)logdir);
  free((void *)bind_cmd_path);
  free((void *)ntp_signd_socket);
  free((void *)pidfile);
  free((void *)rtc_device);
  free((void *)rtc_file);
  free((void *)user);
  free((void *)mail_user_on_change);
  free((void *)tempcomp_sensor_file);
  free((void *)tempcomp_point_file);
  return;
}

void CNF_ReadFile(char const *filename)
{
  FILE *in;
  char line[2048];
  int i;
  in = fopen(filename,"r");
  if (! in) {
    {
      char *tmp;
      tmp = strerror(__fc_errno);
      ;
      {
        char const *__va_arg0 = filename;
        char *__va_arg1 = tmp;
        void *__va_args[2] = {& __va_arg0, & __va_arg1};
        LOG_Message(LOGS_FATAL,"Could not open configuration file %s : %s",
                    (void * const *)(__va_args));
      }
      exit(1);
    }
    goto return_label;
  }
  i = 1;
  while (1) {
    char *tmp_0;
    tmp_0 = fgets(line,(int)sizeof(line),in);
    if (! tmp_0) break;
    CNF_ParseLine(filename,i,line);
    i ++;
  }
  fclose(in);
  return_label: return;
}

void CNF_ParseLine(char const *filename, int number, char *line)
{
  char *p;
  char *command;
  int tmp_66;
  processed_file = filename;
  line_number = number;
  CPS_NormalizeLine(line);
  if (! *line) goto return_label;
  command = line;
  processed_command = (char const *)command;
  p = CPS_SplitWord(line);
  tmp_66 = strcasecmp((char const *)command,"acquisitionport");
  if (tmp_66) {
    int tmp_65;
    tmp_65 = strcasecmp((char const *)command,"allow");
    if (tmp_65) {
      int tmp_64;
      tmp_64 = strcasecmp((char const *)command,"bindacqaddress");
      if (tmp_64) {
        int tmp_63;
        tmp_63 = strcasecmp((char const *)command,"bindaddress");
        if (tmp_63) {
          int tmp_62;
          tmp_62 = strcasecmp((char const *)command,"bindcmdaddress");
          if (tmp_62) {
            int tmp_61;
            tmp_61 = strcasecmp((char const *)command,"broadcast");
            if (tmp_61) {
              int tmp_60;
              tmp_60 = strcasecmp((char const *)command,"clientloglimit");
              if (tmp_60) {
                int tmp_59;
                tmp_59 = strcasecmp((char const *)command,"cmdallow");
                if (tmp_59) {
                  int tmp_58;
                  tmp_58 = strcasecmp((char const *)command,"cmddeny");
                  if (tmp_58) {
                    int tmp_57;
                    tmp_57 = strcasecmp((char const *)command,"cmdport");
                    if (tmp_57) {
                      int tmp_56;
                      tmp_56 = strcasecmp((char const *)command,
                                          "cmdratelimit");
                      if (tmp_56) {
                        int tmp_55;
                        tmp_55 = strcasecmp((char const *)command,
                                            "combinelimit");
                        if (tmp_55) {
                          int tmp_54;
                          tmp_54 = strcasecmp((char const *)command,
                                              "corrtimeratio");
                          if (tmp_54) {
                            int tmp_53;
                            tmp_53 = strcasecmp((char const *)command,"deny");
                            if (tmp_53) {
                              int tmp_52;
                              tmp_52 = strcasecmp((char const *)command,
                                                  "driftfile");
                              if (tmp_52) {
                                int tmp_51;
                                tmp_51 = strcasecmp((char const *)command,
                                                    "dumpdir");
                                if (tmp_51) {
                                  int tmp_50;
                                  tmp_50 = strcasecmp((char const *)command,
                                                      "dumponexit");
                                  if (tmp_50) {
                                    int tmp_49;
                                    tmp_49 = strcasecmp((char const *)command,
                                                        "fallbackdrift");
                                    if (tmp_49) {
                                      int tmp_48;
                                      tmp_48 = strcasecmp((char const *)command,
                                                          "hwclockfile");
                                      if (tmp_48) {
                                        int tmp_47;
                                        tmp_47 = strcasecmp((char const *)command,
                                                            "hwtimestamp");
                                        if (tmp_47) {
                                          int tmp_46;
                                          tmp_46 = strcasecmp((char const *)command,
                                                              "include");
                                          if (tmp_46) {
                                            int tmp_45;
                                            tmp_45 = strcasecmp((char const *)command,
                                                                "initstepslew");
                                            if (tmp_45) {
                                              int tmp_44;
                                              tmp_44 = strcasecmp((char const *)command,
                                                                  "keyfile");
                                              if (tmp_44) {
                                                int tmp_43;
                                                tmp_43 = strcasecmp((char const *)command,
                                                                    "leapsecmode");
                                                if (tmp_43) {
                                                  int tmp_42;
                                                  tmp_42 = strcasecmp
                                                  ((char const *)command,
                                                   "leapsectz");
                                                  if (tmp_42) {
                                                    int tmp_41;
                                                    tmp_41 = strcasecmp
                                                    ((char const *)command,
                                                     "local");
                                                    if (tmp_41) {
                                                      int tmp_40;
                                                      tmp_40 = strcasecmp
                                                      ((char const *)command,
                                                       "lock_all");
                                                      if (tmp_40) {
                                                        int tmp_39;
                                                        tmp_39 = strcasecmp
                                                        ((char const *)command,
                                                         "log");
                                                        if (tmp_39) {
                                                          int tmp_38;
                                                          tmp_38 = strcasecmp
                                                          ((char const *)command,
                                                           "logbanner");
                                                          if (tmp_38) {
                                                            int tmp_37;
                                                            tmp_37 = strcasecmp
                                                            ((char const *)command,
                                                             "logchange");
                                                            if (tmp_37) {
                                                              int tmp_36;
                                                              tmp_36 = strcasecmp
                                                              ((char const *)command,
                                                               "logdir");
                                                              if (tmp_36) {
                                                                int tmp_35;
                                                                tmp_35 = strcasecmp
                                                                ((char const *)command,
                                                                 "mailonchange");
                                                                if (tmp_35) {
                                                                  int tmp_34;
                                                                  tmp_34 = strcasecmp
                                                                  ((char const *)command,
                                                                   "makestep");
                                                                  if (tmp_34) {
                                                                    int tmp_33;
                                                                    tmp_33 = strcasecmp
                                                                    ((char const *)command,
                                                                    "manual");
                                                                    if (tmp_33) {
                                                                    int tmp_32;
                                                                    tmp_32 = strcasecmp
                                                                    ((char const *)command,
                                                                    "maxchange");
                                                                    if (tmp_32) {
                                                                    int tmp_31;
                                                                    tmp_31 = strcasecmp
                                                                    ((char const *)command,
                                                                    "maxclockerror");
                                                                    if (tmp_31) {
                                                                    int tmp_30;
                                                                    tmp_30 = strcasecmp
                                                                    ((char const *)command,
                                                                    "maxdistance");
                                                                    if (tmp_30) {
                                                                    int tmp_29;
                                                                    tmp_29 = strcasecmp
                                                                    ((char const *)command,
                                                                    "maxdrift");
                                                                    if (tmp_29) {
                                                                    int tmp_28;
                                                                    tmp_28 = strcasecmp
                                                                    ((char const *)command,
                                                                    "maxjitter");
                                                                    if (tmp_28) {
                                                                    int tmp_27;
                                                                    tmp_27 = strcasecmp
                                                                    ((char const *)command,
                                                                    "maxsamples");
                                                                    if (tmp_27) {
                                                                    int tmp_26;
                                                                    tmp_26 = strcasecmp
                                                                    ((char const *)command,
                                                                    "maxslewrate");
                                                                    if (tmp_26) {
                                                                    int tmp_25;
                                                                    tmp_25 = strcasecmp
                                                                    ((char const *)command,
                                                                    "maxupdateskew");
                                                                    if (tmp_25) {
                                                                    int tmp_24;
                                                                    tmp_24 = strcasecmp
                                                                    ((char const *)command,
                                                                    "minsamples");
                                                                    if (tmp_24) {
                                                                    int tmp_23;
                                                                    tmp_23 = strcasecmp
                                                                    ((char const *)command,
                                                                    "minsources");
                                                                    if (tmp_23) {
                                                                    int tmp_22;
                                                                    tmp_22 = strcasecmp
                                                                    ((char const *)command,
                                                                    "noclientlog");
                                                                    if (tmp_22) {
                                                                    int tmp_21;
                                                                    tmp_21 = strcasecmp
                                                                    ((char const *)command,
                                                                    "ntpsigndsocket");
                                                                    if (tmp_21) {
                                                                    int tmp_20;
                                                                    tmp_20 = strcasecmp
                                                                    ((char const *)command,
                                                                    "peer");
                                                                    if (tmp_20) {
                                                                    int tmp_19;
                                                                    tmp_19 = strcasecmp
                                                                    ((char const *)command,
                                                                    "pidfile");
                                                                    if (tmp_19) {
                                                                    int tmp_18;
                                                                    tmp_18 = strcasecmp
                                                                    ((char const *)command,
                                                                    "pool");
                                                                    if (tmp_18) {
                                                                    int tmp_17;
                                                                    tmp_17 = strcasecmp
                                                                    ((char const *)command,
                                                                    "port");
                                                                    if (tmp_17) {
                                                                    int tmp_16;
                                                                    tmp_16 = strcasecmp
                                                                    ((char const *)command,
                                                                    "ratelimit");
                                                                    if (tmp_16) {
                                                                    int tmp_15;
                                                                    tmp_15 = strcasecmp
                                                                    ((char const *)command,
                                                                    "refclock");
                                                                    if (tmp_15) {
                                                                    int tmp_14;
                                                                    tmp_14 = strcasecmp
                                                                    ((char const *)command,
                                                                    "reselectdist");
                                                                    if (tmp_14) {
                                                                    int tmp_13;
                                                                    tmp_13 = strcasecmp
                                                                    ((char const *)command,
                                                                    "rtcautotrim");
                                                                    if (tmp_13) {
                                                                    int tmp_12;
                                                                    tmp_12 = strcasecmp
                                                                    ((char const *)command,
                                                                    "rtcdevice");
                                                                    if (tmp_12) {
                                                                    int tmp_11;
                                                                    tmp_11 = strcasecmp
                                                                    ((char const *)command,
                                                                    "rtcfile");
                                                                    if (tmp_11) {
                                                                    int tmp_10;
                                                                    tmp_10 = strcasecmp
                                                                    ((char const *)command,
                                                                    "rtconutc");
                                                                    if (tmp_10) {
                                                                    int tmp_9;
                                                                    tmp_9 = strcasecmp
                                                                    ((char const *)command,
                                                                    "rtcsync");
                                                                    if (tmp_9) {
                                                                    int tmp_8;
                                                                    tmp_8 = strcasecmp
                                                                    ((char const *)command,
                                                                    "sched_priority");
                                                                    if (tmp_8) {
                                                                    int tmp_7;
                                                                    tmp_7 = strcasecmp
                                                                    ((char const *)command,
                                                                    "server");
                                                                    if (tmp_7) {
                                                                    int tmp_6;
                                                                    tmp_6 = strcasecmp
                                                                    ((char const *)command,
                                                                    "smoothtime");
                                                                    if (tmp_6) {
                                                                    int tmp_5;
                                                                    tmp_5 = strcasecmp
                                                                    ((char const *)command,
                                                                    "stratumweight");
                                                                    if (tmp_5) {
                                                                    int tmp_4;
                                                                    tmp_4 = strcasecmp
                                                                    ((char const *)command,
                                                                    "tempcomp");
                                                                    if (tmp_4) {
                                                                    int tmp_3;
                                                                    tmp_3 = strcasecmp
                                                                    ((char const *)command,
                                                                    "user");
                                                                    if (tmp_3) {
                                                                    int tmp;
                                                                    tmp = strcasecmp
                                                                    ((char const *)command,
                                                                    "commandkey");
                                                                    if (tmp) {
                                                                    int tmp_0;
                                                                    tmp_0 = strcasecmp
                                                                    ((char const *)command,
                                                                    "generatecommandkey");
                                                                    if (tmp_0) {
                                                                    int tmp_1;
                                                                    tmp_1 = strcasecmp
                                                                    ((char const *)command,
                                                                    "linux_freq_scale");
                                                                    if (tmp_1) {
                                                                    int tmp_2;
                                                                    tmp_2 = strcasecmp
                                                                    ((char const *)command,
                                                                    "linux_hz");
                                                                    if (tmp_2) 
                                                                    other_parse_error
                                                                    ("Invalid command");
                                                                    else {
                                                                    _LOR:
                                                                    {
                                                                    char *__va_arg0 =
                                                                    command;
                                                                    void *__va_args[1] =
                                                                    {& __va_arg0};
                                                                    LOG_Message
                                                                    (LOGS_WARN,
                                                                    "%s directive is no longer supported",
                                                                    (void * const *)(__va_args));
                                                                    }
                                                                    }
                                                                    }
                                                                    else 
                                                                    goto _LOR;
                                                                    }
                                                                    else 
                                                                    goto _LOR;
                                                                    }
                                                                    else 
                                                                    goto _LOR;
                                                                    }
                                                                    else 
                                                                    parse_string
                                                                    (p,
                                                                    & user);
                                                                    }
                                                                    else 
                                                                    parse_tempcomp
                                                                    (p);
                                                                    }
                                                                    else 
                                                                    parse_double
                                                                    (p,
                                                                    & stratum_weight);
                                                                    }
                                                                    else 
                                                                    parse_smoothtime
                                                                    (p);
                                                                    }
                                                                    else 
                                                                    parse_source
                                                                    (p,
                                                                    NTP_SERVER,
                                                                    0);
                                                                    }
                                                                    else 
                                                                    parse_int
                                                                    (p,
                                                                    & sched_priority);
                                                                    }
                                                                    else 
                                                                    rtc_sync = parse_null
                                                                    (p);
                                                                    }
                                                                    else 
                                                                    rtc_on_utc = parse_null
                                                                    (p);
                                                                    }
                                                                    else 
                                                                    parse_string
                                                                    (p,
                                                                    & rtc_file);
                                                                    }
                                                                    else 
                                                                    parse_string
                                                                    (p,
                                                                    & rtc_device);
                                                                    }
                                                                    else 
                                                                    parse_double
                                                                    (p,
                                                                    & rtc_autotrim_threshold);
                                                                    }
                                                                    else 
                                                                    parse_double
                                                                    (p,
                                                                    & reselect_distance);
                                                                    }
                                                                    else 
                                                                    parse_refclock
                                                                    (p);
                                                                    }
                                                                    else 
                                                                    parse_ratelimit
                                                                    (p,
                                                                    & ntp_ratelimit_enabled,
                                                                    & ntp_ratelimit_interval,
                                                                    & ntp_ratelimit_burst,
                                                                    & ntp_ratelimit_leak);
                                                                    }
                                                                    else 
                                                                    parse_int
                                                                    (p,
                                                                    & ntp_port);
                                                                    }
                                                                    else 
                                                                    parse_source
                                                                    (p,
                                                                    NTP_SERVER,
                                                                    1);
                                                                    }
                                                                    else 
                                                                    parse_string
                                                                    (p,
                                                                    & pidfile);
                                                                    }
                                                                    else 
                                                                    parse_source
                                                                    (p,
                                                                    NTP_PEER,
                                                                    0);
                                                                    }
                                                                    else 
                                                                    parse_string
                                                                    (p,
                                                                    & ntp_signd_socket);
                                                                    }
                                                                    else 
                                                                    no_client_log = parse_null
                                                                    (p);
                                                                    }
                                                                    else 
                                                                    parse_int
                                                                    (p,
                                                                    & min_sources);
                                                                    }
                                                                    else 
                                                                    parse_int
                                                                    (p,
                                                                    & min_samples);
                                                                    }
                                                                    else 
                                                                    parse_double
                                                                    (p,
                                                                    & max_update_skew);
                                                                    }
                                                                    else 
                                                                    parse_double
                                                                    (p,
                                                                    & max_slew_rate);
                                                                    }
                                                                    else 
                                                                    parse_int
                                                                    (p,
                                                                    & max_samples);
                                                                    }
                                                                    else 
                                                                    parse_double
                                                                    (p,
                                                                    & max_jitter);
                                                                    }
                                                                    else 
                                                                    parse_double
                                                                    (p,
                                                                    & max_drift);
                                                                    }
                                                                    else 
                                                                    parse_double
                                                                    (p,
                                                                    & max_distance);
                                                                    }
                                                                    else 
                                                                    parse_double
                                                                    (p,
                                                                    & max_clock_error);
                                                                    }
                                                                    else 
                                                                    parse_maxchange
                                                                    (p);
                                                                    }
                                                                    else 
                                                                    enable_manual = parse_null
                                                                    (p);
                                                                  }
                                                                  else 
                                                                    parse_makestep
                                                                    (p);
                                                                }
                                                                else 
                                                                  parse_mailonchange
                                                                  (p);
                                                              }
                                                              else parse_string
                                                                   (p,
                                                                    & logdir);
                                                            }
                                                            else parse_double
                                                                 (p,
                                                                  & log_change_threshold);
                                                          }
                                                          else parse_int
                                                               (p,
                                                                & log_banner);
                                                        }
                                                        else parse_log(p);
                                                      }
                                                      else lock_memory = parse_null
                                                           (p);
                                                    }
                                                    else parse_local(p);
                                                  }
                                                  else parse_string(p,
                                                                    & leapsec_tz);
                                                }
                                                else parse_leapsecmode(p);
                                              }
                                              else parse_string(p,
                                                                & keys_file);
                                            }
                                            else parse_initstepslew(p);
                                          }
                                          else parse_include(p);
                                        }
                                        else parse_hwtimestamp(p);
                                      }
                                      else parse_string(p,& hwclock_file);
                                    }
                                    else parse_fallbackdrift(p);
                                  }
                                }
                                else parse_string(p,& dumpdir);
                              }
                              else parse_string(p,& drift_file);
                            }
                            else parse_allow_deny(p,ntp_restrictions,0);
                          }
                          else parse_double(p,& correction_time_ratio);
                        }
                        else parse_double(p,& combine_limit);
                      }
                      else parse_ratelimit(p,& cmd_ratelimit_enabled,
                                           & cmd_ratelimit_interval,
                                           & cmd_ratelimit_burst,
                                           & cmd_ratelimit_leak);
                    }
                    else parse_int(p,& cmd_port);
                  }
                  else parse_allow_deny(p,cmd_restrictions,0);
                }
                else parse_allow_deny(p,cmd_restrictions,1);
              }
              else parse_clientloglimit(p);
            }
            else parse_broadcast(p);
          }
          else parse_bindcmdaddress(p);
        }
        else parse_bindaddress(p);
      }
      else parse_bindacqaddress(p);
    }
    else parse_allow_deny(p,ntp_restrictions,1);
  }
  else parse_int(p,& acquisition_port);
  return_label: return;
}

static int parse_string(char *line, char **result)
{
  int __retres;
  check_number_of_args(line,1);
  free((void *)*result);
  *result = Strdup((char const *)line);
  __retres = 1;
  return __retres;
}

/*@ requires \valid(param0);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    assigns \result, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_22(char const * restrict s, char const * restrict format,
                 int *param0);

static int parse_int(char *line, int *result)
{
  int __retres;
  int tmp;
  check_number_of_args(line,1);
  tmp = sscanf((char const *)line,"%d",result); /* sscanf_va_22 */
  if (tmp != 1) {
    command_parse_error();
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

/*@ requires \valid(param0);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    assigns \result, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_23(char const * restrict s, char const * restrict format,
                 double *param0);

static int parse_double(char *line, double *result)
{
  int __retres;
  int tmp;
  check_number_of_args(line,1);
  tmp = sscanf((char const *)line,"%lf",result); /* sscanf_va_23 */
  if (tmp != 1) {
    command_parse_error();
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static int parse_null(char *line)
{
  int __retres;
  check_number_of_args(line,0);
  __retres = 1;
  return __retres;
}

static void parse_source(char *line, NTP_Source_Type type, int pool)
{
  NTP_Source source;
  int tmp;
  source.type = type;
  source.pool = pool;
  tmp = CPS_ParseNTPSourceAdd(line,& source.params);
  if (! tmp) {
    command_parse_error();
    goto return_label;
  }
  source.params.name = Strdup((char const *)source.params.name);
  ARR_AppendElement(ntp_sources,(void *)(& source));
  return_label: return;
}

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_24(char const * restrict s, char const * restrict format,
                 int *param0, int *param1);

static void parse_ratelimit(char *line, int *enabled_0, int *interval,
                            int *burst, int *leak)
{
  int n;
  int val;
  char *opt;
  *enabled_0 = 1;
  while (*line) {
    int tmp;
    int tmp_2;
    opt = line;
    line = CPS_SplitWord(line);
    tmp = sscanf((char const *)line,"%d%n",& val,& n); /* sscanf_va_24 */
    if (tmp != 1) {
      command_parse_error();
      goto return_label;
    }
    line += n;
    tmp_2 = strcasecmp((char const *)opt,"interval");
    if (tmp_2) {
      int tmp_1;
      tmp_1 = strcasecmp((char const *)opt,"burst");
      if (tmp_1) {
        int tmp_0;
        tmp_0 = strcasecmp((char const *)opt,"leak");
        if (tmp_0) command_parse_error(); else *leak = val;
      }
      else *burst = val;
    }
    else *interval = val;
  }
  return_label: return;
}

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_25(char const * restrict s, char const * restrict format,
                 double *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_26(char const * restrict s, char const * restrict format,
                 int *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_27(char const * restrict s, char const * restrict format,
                 double *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_28(char const * restrict s, char const * restrict format,
                 double *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_29(char const * restrict s, char const * restrict format,
                 double *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_30(char const * restrict s, char const * restrict format,
                 double *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_31(char const * restrict s, char const * restrict format,
                 int *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_32(char const * restrict s, char const * restrict format,
                 int *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_33(char const * restrict s, char const * restrict format,
                 int *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_34(char const * restrict s, char const * restrict format,
                 int *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_35(char const * restrict s, char const * restrict format,
                 int *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_36(char const * restrict s, char const * restrict format,
                 int *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_37(char const * restrict s, char const * restrict format,
                 int *param0, int *param1);

/*@ requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param1);
    assigns \result, *param1, *(param0 + (0 ..));
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *(param0 + (0 ..))
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_38(char const * restrict s, char const * restrict format,
                 char *param0, int *param1);

/*@ requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param1);
    assigns \result, *param1, *(param0 + (0 ..));
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *(param0 + (0 ..))
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_39(char const * restrict s, char const * restrict format,
                 char *param0, int *param1);

static void parse_refclock(char *line)
{
  int n;
  int poll;
  int dpoll;
  int filter_length;
  int pps_rate;
  int min_samples_0;
  int max_samples_0;
  int sel_options;
  int max_lock_age;
  int pps_forced;
  int stratum;
  int tai;
  uint32_t ref_id;
  uint32_t lock_ref_id;
  double offset;
  double delay;
  double precision;
  double max_dispersion;
  double pulse_width;
  char *p;
  char *cmd;
  char *name;
  char *param;
  unsigned char ref[5];
  RefclockParameters *refclock;
  poll = 4;
  dpoll = 0;
  filter_length = 64;
  pps_forced = 0;
  pps_rate = 0;
  min_samples_0 = -1;
  max_samples_0 = -1;
  sel_options = 0;
  offset = 0.0;
  delay = 1e-9;
  precision = 0.0;
  max_dispersion = 0.0;
  pulse_width = 0.0;
  ref_id = (uint32_t)0;
  max_lock_age = 2;
  lock_ref_id = (uint32_t)0;
  stratum = 0;
  tai = 0;
  if (! *line) {
    command_parse_error();
    goto return_label;
  }
  p = line;
  line = CPS_SplitWord(line);
  if (! *line) {
    command_parse_error();
    goto return_label;
  }
  name = Strdup((char const *)p);
  p = line;
  line = CPS_SplitWord(line);
  param = Strdup((char const *)p);
  cmd = line;
  while (*cmd) {
    {
      int tmp_34;
      line = CPS_SplitWord(line);
      tmp_34 = strcasecmp((char const *)cmd,"refid");
      if (tmp_34) {
        int tmp_33;
        tmp_33 = strcasecmp((char const *)cmd,"lock");
        if (tmp_33) {
          int tmp_32;
          tmp_32 = strcasecmp((char const *)cmd,"poll");
          if (tmp_32) {
            int tmp_31;
            tmp_31 = strcasecmp((char const *)cmd,"dpoll");
            if (tmp_31) {
              int tmp_30;
              tmp_30 = strcasecmp((char const *)cmd,"filter");
              if (tmp_30) {
                int tmp_29;
                tmp_29 = strcasecmp((char const *)cmd,"rate");
                if (tmp_29) {
                  int tmp_28;
                  tmp_28 = strcasecmp((char const *)cmd,"minsamples");
                  if (tmp_28) {
                    int tmp_27;
                    tmp_27 = strcasecmp((char const *)cmd,"maxlockage");
                    if (tmp_27) {
                      int tmp_26;
                      tmp_26 = strcasecmp((char const *)cmd,"maxsamples");
                      if (tmp_26) {
                        int tmp_25;
                        tmp_25 = strcasecmp((char const *)cmd,"offset");
                        if (tmp_25) {
                          int tmp_24;
                          tmp_24 = strcasecmp((char const *)cmd,"delay");
                          if (tmp_24) {
                            int tmp_23;
                            tmp_23 = strcasecmp((char const *)cmd,"pps");
                            if (tmp_23) {
                              int tmp_22;
                              tmp_22 = strcasecmp((char const *)cmd,
                                                  "precision");
                              if (tmp_22) {
                                int tmp_21;
                                tmp_21 = strcasecmp((char const *)cmd,
                                                    "maxdispersion");
                                if (tmp_21) {
                                  int tmp_20;
                                  tmp_20 = strcasecmp((char const *)cmd,
                                                      "stratum");
                                  if (tmp_20) {
                                    int tmp_19;
                                    tmp_19 = strcasecmp((char const *)cmd,
                                                        "tai");
                                    if (tmp_19) {
                                      int tmp_18;
                                      tmp_18 = strcasecmp((char const *)cmd,
                                                          "width");
                                      if (tmp_18) {
                                        int tmp_17;
                                        tmp_17 = strcasecmp((char const *)cmd,
                                                            "noselect");
                                        if (tmp_17) {
                                          int tmp_16;
                                          tmp_16 = strcasecmp((char const *)cmd,
                                                              "prefer");
                                          if (tmp_16) {
                                            int tmp_15;
                                            tmp_15 = strcasecmp((char const *)cmd,
                                                                "trust");
                                            if (tmp_15) {
                                              int tmp_14;
                                              tmp_14 = strcasecmp((char const *)cmd,
                                                                  "require");
                                              if (tmp_14) {
                                                other_parse_error("Invalid refclock option");
                                                goto return_label;
                                              }
                                              else {
                                                n = 0;
                                                sel_options |= 0x8;
                                              }
                                            }
                                            else {
                                              n = 0;
                                              sel_options |= 0x4;
                                            }
                                          }
                                          else {
                                            n = 0;
                                            sel_options |= 0x2;
                                          }
                                        }
                                        else {
                                          n = 0;
                                          sel_options |= 0x1;
                                        }
                                      }
                                      else {
                                        int tmp_13;
                                        tmp_13 = sscanf((char const *)line,
                                                        "%lf%n",
                                                        & pulse_width,& n); /* sscanf_va_25 */
                                        if (tmp_13 != 1) break;
                                      }
                                    }
                                    else {
                                      n = 0;
                                      tai = 1;
                                    }
                                  }
                                  else {
                                    int tmp_12;
                                    tmp_12 = sscanf((char const *)line,
                                                    "%d%n",& stratum,& n); /* sscanf_va_26 */
                                    if (tmp_12 != 1) break;
                                    else 
                                      if (stratum >= 16) break;
                                      else 
                                        if (stratum < 0) break;
                                  }
                                }
                                else {
                                  int tmp_11;
                                  tmp_11 = sscanf((char const *)line,"%lf%n",
                                                  & max_dispersion,& n); /* sscanf_va_27 */
                                  if (tmp_11 != 1) break;
                                }
                              }
                              else {
                                int tmp_10;
                                tmp_10 = sscanf((char const *)line,"%lf%n",
                                                & precision,& n); /* sscanf_va_28 */
                                if (tmp_10 != 1) break;
                              }
                            }
                            else {
                              n = 0;
                              pps_forced = 1;
                            }
                          }
                          else {
                            int tmp_9;
                            tmp_9 = sscanf((char const *)line,"%lf%n",
                                           & delay,& n); /* sscanf_va_29 */
                            if (tmp_9 != 1) break;
                          }
                        }
                        else {
                          int tmp_8;
                          tmp_8 = sscanf((char const *)line,"%lf%n",& offset,
                                         & n); /* sscanf_va_30 */
                          if (tmp_8 != 1) break;
                        }
                      }
                      else {
                        int tmp_7;
                        tmp_7 = sscanf((char const *)line,"%d%n",
                                       & max_samples_0,& n); /* sscanf_va_31 */
                        if (tmp_7 != 1) break;
                      }
                    }
                    else {
                      int tmp_6;
                      tmp_6 = sscanf((char const *)line,"%d%n",
                                     & max_lock_age,& n); /* sscanf_va_32 */
                      if (tmp_6 != 1) break;
                    }
                  }
                  else {
                    int tmp_5;
                    tmp_5 = sscanf((char const *)line,"%d%n",& min_samples_0,
                                   & n); /* sscanf_va_33 */
                    if (tmp_5 != 1) break;
                  }
                }
                else {
                  int tmp_4;
                  tmp_4 = sscanf((char const *)line,"%d%n",& pps_rate,& n); /* sscanf_va_34 */
                  if (tmp_4 != 1) break;
                }
              }
              else {
                int tmp_3;
                tmp_3 = sscanf((char const *)line,"%d%n",& filter_length,& n); /* sscanf_va_35 */
                if (tmp_3 != 1) break;
              }
            }
            else {
              int tmp_2;
              tmp_2 = sscanf((char const *)line,"%d%n",& dpoll,& n); /* sscanf_va_36 */
              if (tmp_2 != 1) break;
            }
          }
          else {
            int tmp_1;
            tmp_1 = sscanf((char const *)line,"%d%n",& poll,& n); /* sscanf_va_37 */
            if (tmp_1 != 1) break;
          }
        }
        else {
          int tmp_0;
          tmp_0 = sscanf((char const *)line,"%4s%n",(char *)(ref),& n); /* sscanf_va_38 */
          if (tmp_0 != 1) break;
          lock_ref_id = ((((uint32_t)ref[0] << 24) | (unsigned int)((int)ref[1] << 16)) | (unsigned int)(
                         (int)ref[2] << 8)) | (unsigned int)ref[3];
        }
      }
      else {
        int tmp;
        tmp = sscanf((char const *)line,"%4s%n",(char *)(ref),& n); /* sscanf_va_39 */
        if (tmp != 1) break;
        ref_id = ((((uint32_t)ref[0] << 24) | (unsigned int)((int)ref[1] << 16)) | (unsigned int)(
                  (int)ref[2] << 8)) | (unsigned int)ref[3];
      }
    }
    line += n;
    cmd = line;
  }
  if (*cmd) {
    command_parse_error();
    goto return_label;
  }
  refclock = (RefclockParameters *)ARR_GetNewElement(refclock_sources);
  refclock->driver_name = name;
  refclock->driver_parameter = param;
  refclock->driver_poll = dpoll;
  refclock->poll = poll;
  refclock->filter_length = filter_length;
  refclock->pps_forced = pps_forced;
  refclock->pps_rate = pps_rate;
  refclock->min_samples = min_samples_0;
  refclock->max_samples = max_samples_0;
  refclock->sel_options = sel_options;
  refclock->stratum = stratum;
  refclock->tai = tai;
  refclock->offset = offset;
  refclock->delay = delay;
  refclock->precision = precision;
  refclock->max_dispersion = max_dispersion;
  refclock->pulse_width = pulse_width;
  refclock->ref_id = ref_id;
  refclock->max_lock_age = max_lock_age;
  refclock->lock_ref_id = lock_ref_id;
  return_label: return;
}

static void parse_log(char *line)
{
  char *log_name;
  while (1) {
    log_name = line;
    line = CPS_SplitWord(line);
    if (*log_name) {
      int tmp_5;
      tmp_5 = strcmp((char const *)log_name,"rawmeasurements");
      if (tmp_5) {
        int tmp_4;
        tmp_4 = strcmp((char const *)log_name,"measurements");
        if (tmp_4) {
          int tmp_3;
          tmp_3 = strcmp((char const *)log_name,"statistics");
          if (tmp_3) {
            int tmp_2;
            tmp_2 = strcmp((char const *)log_name,"tracking");
            if (tmp_2) {
              int tmp_1;
              tmp_1 = strcmp((char const *)log_name,"rtc");
              if (tmp_1) {
                int tmp_0;
                tmp_0 = strcmp((char const *)log_name,"refclocks");
                if (tmp_0) {
                  int tmp;
                  tmp = strcmp((char const *)log_name,"tempcomp");
                  if (tmp) {
                    other_parse_error("Invalid log parameter");
                    break;
                  }
                  else do_log_tempcomp = 1;
                }
                else do_log_refclocks = 1;
              }
              else do_log_rtc = 1;
            }
            else do_log_tracking = 1;
          }
          else do_log_statistics = 1;
        }
        else do_log_measurements = 1;
      }
      else {
        do_log_measurements = 1;
        raw_measurements = 1;
      }
    }
    else break;
  }
  return;
}

static void parse_local(char *line)
{
  int tmp;
  tmp = CPS_ParseLocal(line,& local_stratum,& local_orphan,& local_distance);
  if (! tmp) command_parse_error();
  enable_local = 1;
  return;
}

/*@ requires \valid(param0);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    assigns \result, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_40(char const * restrict s, char const * restrict format,
                 double *param0);

static void parse_initstepslew(char *line)
{
  char *p;
  char *hostname;
  IPAddr ip_addr;
  int tmp;
  if (restarted) goto return_label;
  ARR_SetSize(init_sources,(unsigned int)0);
  p = CPS_SplitWord(line);
  tmp = sscanf((char const *)line,"%lf",& init_slew_threshold); /* sscanf_va_40 */
  if (tmp != 1) {
    command_parse_error();
    goto return_label;
  }
  while (*p) {
    hostname = p;
    p = CPS_SplitWord(p);
    if (*hostname) {
      DNS_Status tmp_0;
      tmp_0 = DNS_Name2IPAddress((char const *)hostname,& ip_addr,1);
      if (tmp_0 == (unsigned int)DNS_Success) ARR_AppendElement(init_sources,
                                                                (void *)(& ip_addr));
      else {
        {
          char *__va_arg0 = hostname;
          void *__va_args[1] = {& __va_arg0};
          LOG_Message(LOGS_WARN,
                      "Could not resolve address of initstepslew server %s",
                      (void * const *)(__va_args));
        }
      }
    }
  }
  return_label: return;
}

static void parse_leapsecmode(char *line)
{
  int tmp_2;
  tmp_2 = strcasecmp((char const *)line,"system");
  if (tmp_2) {
    int tmp_1;
    tmp_1 = strcasecmp((char const *)line,"slew");
    if (tmp_1) {
      int tmp_0;
      tmp_0 = strcasecmp((char const *)line,"step");
      if (tmp_0) {
        int tmp;
        tmp = strcasecmp((char const *)line,"ignore");
        if (tmp) command_parse_error();
        else leapsec_mode = REF_LeapModeIgnore;
      }
      else leapsec_mode = REF_LeapModeStep;
    }
    else leapsec_mode = REF_LeapModeSlew;
  }
  else leapsec_mode = REF_LeapModeSystem;
  return;
}

/*@ requires \valid(param0);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    assigns \result, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_41(char const * restrict s, char const * restrict format,
                 unsigned long *param0);

static void parse_clientloglimit(char *line)
{
  int tmp;
  check_number_of_args(line,1);
  tmp = sscanf((char const *)line,"%lu",& client_log_limit); /* sscanf_va_41 */
  if (tmp != 1) command_parse_error();
  return;
}

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_42(char const * restrict s, char const * restrict format,
                 int *param0, int *param1);

static void parse_fallbackdrift(char *line)
{
  int tmp;
  check_number_of_args(line,2);
  tmp = sscanf((char const *)line,"%d %d",& fb_drift_min,& fb_drift_max); /* sscanf_va_42 */
  if (tmp != 2) command_parse_error();
  return;
}

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_43(char const * restrict s, char const * restrict format,
                 double *param0, int *param1);

static void parse_makestep(char *line)
{
  int tmp;
  check_number_of_args(line,2);
  tmp = sscanf((char const *)line,"%lf %d",& make_step_threshold,
               & make_step_limit); /* sscanf_va_43 */
  if (tmp != 2) {
    make_step_limit = 0;
    command_parse_error();
  }
  if (restarted) 
    if (make_step_limit > 0) make_step_limit = 0;
  return;
}

/*@ requires \valid(param0);
    requires \valid(param1);
    requires \valid(param2);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    ensures \initialized(param2);
    assigns \result, *param2, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param2
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_44(char const * restrict s, char const * restrict format,
                 double *param0, int *param1, int *param2);

static void parse_maxchange(char *line)
{
  int tmp;
  check_number_of_args(line,3);
  tmp = sscanf((char const *)line,"%lf %d %d",& max_offset,
               & max_offset_delay,& max_offset_ignore); /* sscanf_va_44 */
  if (tmp != 3) {
    max_offset_delay = -1;
    command_parse_error();
  }
  return;
}

/*@ requires \valid(param0);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    assigns \result, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_45(char const * restrict s, char const * restrict format,
                 double *param0);

static void parse_mailonchange(char *line)
{
  char *address;
  int tmp;
  check_number_of_args(line,2);
  address = line;
  line = CPS_SplitWord(line);
  free((void *)mail_user_on_change);
  tmp = sscanf((char const *)line,"%lf",& mail_change_threshold); /* sscanf_va_45 */
  if (tmp == 1) mail_user_on_change = Strdup((char const *)address);
  else {
    mail_user_on_change = (char *)0;
    command_parse_error();
  }
  return;
}

/*@ requires \valid(param0);
    requires \valid(param1);
    requires \valid(param2);
    requires \valid(param3);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    ensures \initialized(param2);
    ensures \initialized(param3);
    assigns \result, *param3, *param2, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param3
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param2
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_46(char const * restrict s, char const * restrict format,
                 unsigned long *param0, unsigned long *param1,
                 unsigned long *param2, unsigned long *param3);

/*@ requires \valid(param0);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    assigns \result, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_47(char const * restrict s, char const * restrict format,
                 int *param0);

static void parse_allow_deny(char *line, ARR_Instance restrictions, int allow)
{
  char *p;
  unsigned long a;
  unsigned long b;
  unsigned long c;
  unsigned long d;
  unsigned long n;
  IPAddr ip_addr;
  int tmp;
  int all = 0;
  AllowDeny *new_node = (AllowDeny *)0;
  p = line;
  tmp = strncmp((char const *)p,"all",(size_t)3);
  if (! tmp) {
    all = 1;
    p = CPS_SplitWord(line);
  }
  if (! *p) {
    new_node = (AllowDeny *)ARR_GetNewElement(restrictions);
    new_node->allow = allow;
    new_node->all = all;
    new_node->ip.family = (uint16_t)0;
    new_node->subnet_bits = 0;
  }
  else {
    char *slashpos;
    int tmp_4;
    slashpos = strchr((char const *)p,'/');
    if (slashpos) *slashpos = (char)0;
    check_number_of_args(p,1);
    n = (unsigned long)0;
    tmp_4 = UTI_StringToIP((char const *)p,& ip_addr);
    if (tmp_4) goto _LOR;
    else {
      int tmp_5;
      tmp_5 = sscanf((char const *)p,"%lu.%lu.%lu.%lu",& a,& b,& c,& d); /* sscanf_va_46 */
      n = (unsigned long)tmp_5;
      if (n >= (unsigned long)1) {
        _LOR:
        {
          /*@ assert n  4; */ ;
          new_node = (AllowDeny *)ARR_GetNewElement(restrictions);
          new_node->allow = allow;
          new_node->all = all;
          if (n == (unsigned long)0) {
            new_node->ip = ip_addr;
            if ((int)ip_addr.family == 2) new_node->subnet_bits = 128;
            else new_node->subnet_bits = 32;
          }
          else {
            new_node->ip.family = (uint16_t)1;
            a &= (unsigned long)0xff;
            b &= (unsigned long)0xff;
            c &= (unsigned long)0xff;
            d &= (unsigned long)0xff;
            switch (n) {
              case (unsigned long)1:
              new_node->ip.addr.in4 = (uint32_t)(a << 24);
              new_node->subnet_bits = 8;
              break;
              case (unsigned long)2:
              new_node->ip.addr.in4 = (uint32_t)((a << 24) | (b << 16));
              new_node->subnet_bits = 16;
              break;
              case (unsigned long)3:
              new_node->ip.addr.in4 = (uint32_t)(((a << 24) | (b << 16)) | (
                                                 c << 8));
              new_node->subnet_bits = 24;
              break;
              case (unsigned long)4:
              new_node->ip.addr.in4 = (uint32_t)((((a << 24) | (b << 16)) | (
                                                  c << 8)) | d);
              new_node->subnet_bits = 32;
              break;
              default: __FC_assert(0 != 0,"conf.c",1073,"0");
            }
          }
          if (slashpos) {
            int specified_subnet_bits;
            int n_0;
            n_0 = sscanf((char const *)(slashpos + 1),"%d",
                         & specified_subnet_bits); /* sscanf_va_47 */
            if (n_0 == 1) new_node->subnet_bits = specified_subnet_bits;
            else command_parse_error();
          }
        }
      }
      else 
        if (! slashpos) {
          DNS_Status tmp_3;
          tmp_3 = DNS_Name2IPAddress((char const *)p,& ip_addr,1);
          if (tmp_3 == (unsigned int)DNS_Success) {
            new_node = (AllowDeny *)ARR_GetNewElement(restrictions);
            new_node->allow = allow;
            new_node->all = all;
            new_node->ip = ip_addr;
            if ((int)ip_addr.family == 2) new_node->subnet_bits = 128;
            else new_node->subnet_bits = 32;
          }
          else goto _LAND;
        }
        else _LAND: command_parse_error();
    }
  }
  return;
}

static void parse_bindacqaddress(char *line)
{
  IPAddr ip;
  int tmp;
  check_number_of_args(line,1);
  tmp = UTI_StringToIP((char const *)line,& ip);
  if (tmp) {
    if ((int)ip.family == 1) bind_acq_address4 = ip;
    else 
      if ((int)ip.family == 2) bind_acq_address6 = ip;
  }
  else command_parse_error();
  return;
}

static void parse_bindaddress(char *line)
{
  IPAddr ip;
  int tmp;
  check_number_of_args(line,1);
  tmp = UTI_StringToIP((char const *)line,& ip);
  if (tmp) {
    if ((int)ip.family == 1) bind_address4 = ip;
    else 
      if ((int)ip.family == 2) bind_address6 = ip;
  }
  else command_parse_error();
  return;
}

static void parse_bindcmdaddress(char *line)
{
  IPAddr ip;
  check_number_of_args(line,1);
  if ((int)*(line + 0) == '/') {
    int tmp;
    parse_string(line,& bind_cmd_path);
    tmp = strcmp((char const *)bind_cmd_path,"/");
    if (! tmp) *(bind_cmd_path + 0) = (char)'\000';
  }
  else {
    int tmp_0;
    tmp_0 = UTI_StringToIP((char const *)line,& ip);
    if (tmp_0) {
      if ((int)ip.family == 1) bind_cmd_address4 = ip;
      else 
        if ((int)ip.family == 2) bind_cmd_address6 = ip;
    }
    else command_parse_error();
  }
  return;
}

/*@ requires \valid(param0);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    assigns \result, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_48(char const * restrict s, char const * restrict format,
                 int *param0);

/*@ requires \valid(param0);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    assigns \result, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_49(char const * restrict s, char const * restrict format,
                 int *param0);

static void parse_broadcast(char *line)
{
  NTP_Broadcast_Destination *destination;
  int port;
  int interval;
  char *p;
  IPAddr ip;
  int tmp;
  int tmp_0;
  p = line;
  line = CPS_SplitWord(line);
  tmp = sscanf((char const *)p,"%d",& interval); /* sscanf_va_48 */
  if (tmp != 1) {
    command_parse_error();
    goto return_label;
  }
  p = line;
  line = CPS_SplitWord(line);
  tmp_0 = UTI_StringToIP((char const *)p,& ip);
  if (! tmp_0) {
    command_parse_error();
    goto return_label;
  }
  p = line;
  line = CPS_SplitWord(line);
  if (*p) {
    int tmp_1;
    tmp_1 = sscanf((char const *)p,"%d",& port); /* sscanf_va_49 */
    if (tmp_1 != 1) goto _LOR;
    else 
      if (*line) {
        _LOR: {
                command_parse_error();
                goto return_label;
              }
      }
  }
  else port = 123;
  destination = (NTP_Broadcast_Destination *)ARR_GetNewElement(broadcasts);
  destination->addr = ip;
  destination->port = (unsigned short)port;
  destination->interval = interval;
  return_label: return;
}

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_50(char const * restrict s, char const * restrict format,
                 double *param0, double *param1);

static void parse_smoothtime(char *line)
{
  int tmp;
  int tmp_0;
  char *tmp_1;
  tmp = get_number_of_args(line);
  if (tmp != 3) check_number_of_args(line,2);
  tmp_0 = sscanf((char const *)line,"%lf %lf",& smooth_max_freq,
                 & smooth_max_wander); /* sscanf_va_50 */
  if (tmp_0 != 2) {
    smooth_max_freq = 0.0;
    command_parse_error();
  }
  tmp_1 = CPS_SplitWord(line);
  line = CPS_SplitWord(tmp_1);
  smooth_leap_only = 0;
  if (*line) {
    int tmp_2;
    tmp_2 = strcasecmp((char const *)line,"leaponly");
    if (tmp_2) command_parse_error(); else smooth_leap_only = 1;
  }
  return;
}

/*@ requires \valid(param0);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    assigns \result, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_51(char const * restrict s, char const * restrict format,
                 double *param0);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires \valid(param2);
    requires \valid(param3);
    requires \valid(param4);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    ensures \initialized(param2);
    ensures \initialized(param3);
    ensures \initialized(param4);
    assigns \result, *param4, *param3, *param2, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param4
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param3
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param2
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_52(char const * restrict s, char const * restrict format,
                 double *param0, double *param1, double *param2,
                 double *param3, double *param4);

static void parse_tempcomp(char *line)
{
  char *p;
  int point_form;
  int tmp;
  tmp = get_number_of_args(line);
  point_form = tmp == 3;
  if (! point_form) check_number_of_args(line,6);
  p = line;
  line = CPS_SplitWord(line);
  if (! *p) {
    command_parse_error();
    goto return_label;
  }
  free((void *)tempcomp_point_file);
  if (point_form) {
    int tmp_0;
    char *tmp_1;
    tmp_0 = sscanf((char const *)line,"%lf",& tempcomp_interval); /* sscanf_va_51 */
    if (tmp_0 != 1) {
      command_parse_error();
      goto return_label;
    }
    tmp_1 = CPS_SplitWord(line);
    tempcomp_point_file = Strdup((char const *)tmp_1);
  }
  else {
    int tmp_2;
    tmp_2 = sscanf((char const *)line,"%lf %lf %lf %lf %lf",
                   & tempcomp_interval,& tempcomp_T0,& tempcomp_k0,
                   & tempcomp_k1,& tempcomp_k2); /* sscanf_va_52 */
    if (tmp_2 != 5) {
      command_parse_error();
      goto return_label;
    }
    tempcomp_point_file = (char *)0;
  }
  free((void *)tempcomp_sensor_file);
  tempcomp_sensor_file = Strdup((char const *)p);
  return_label: return;
}

/*@ requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param1);
    assigns \result, *param1, *(param0 + (0 ..));
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *(param0 + (0 ..))
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_53(char const * restrict s, char const * restrict format,
                 char *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_54(char const * restrict s, char const * restrict format,
                 double *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_55(char const * restrict s, char const * restrict format,
                 double *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_56(char const * restrict s, char const * restrict format,
                 double *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_57(char const * restrict s, char const * restrict format,
                 int *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_58(char const * restrict s, char const * restrict format,
                 int *param0, int *param1);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_59(char const * restrict s, char const * restrict format,
                 int *param0, int *param1);

static void parse_hwtimestamp(char *line)
{
  CNF_HwTsInterface *iface;
  char *p;
  char filter[5];
  int n;
  if (! *line) {
    command_parse_error();
    goto return_label;
  }
  p = line;
  line = CPS_SplitWord(line);
  iface = (CNF_HwTsInterface *)ARR_GetNewElement(hwts_interfaces);
  iface->name = Strdup((char const *)p);
  iface->minpoll = 0;
  iface->min_samples = 2;
  iface->max_samples = 16;
  iface->nocrossts = 0;
  iface->rxfilter = CNF_HWTS_RXFILTER_ANY;
  iface->precision = 100.0e-9;
  iface->tx_comp = 0.0;
  iface->rx_comp = 0.0;
  p = line;
  while (*p) {
    {
      int tmp_16;
      line = CPS_SplitWord(line);
      tmp_16 = strcasecmp((char const *)p,"maxsamples");
      if (tmp_16) {
        int tmp_15;
        tmp_15 = strcasecmp((char const *)p,"minpoll");
        if (tmp_15) {
          int tmp_14;
          tmp_14 = strcasecmp((char const *)p,"minsamples");
          if (tmp_14) {
            int tmp_13;
            tmp_13 = strcasecmp((char const *)p,"precision");
            if (tmp_13) {
              int tmp_12;
              tmp_12 = strcasecmp((char const *)p,"rxcomp");
              if (tmp_12) {
                int tmp_11;
                tmp_11 = strcasecmp((char const *)p,"txcomp");
                if (tmp_11) {
                  int tmp_10;
                  tmp_10 = strcasecmp((char const *)p,"rxfilter");
                  if (tmp_10) {
                    int tmp_9;
                    tmp_9 = strcasecmp((char const *)p,"nocrossts");
                    if (tmp_9) break;
                    else {
                      n = 0;
                      iface->nocrossts = 1;
                    }
                  }
                  else {
                    int tmp_5;
                    int tmp_8;
                    tmp_5 = sscanf((char const *)line,"%4s%n",filter,& n); /* sscanf_va_53 */
                    if (tmp_5 != 1) break;
                    tmp_8 = strcasecmp((char const *)(filter),"none");
                    if (tmp_8) {
                      int tmp_7;
                      tmp_7 = strcasecmp((char const *)(filter),"ntp");
                      if (tmp_7) {
                        int tmp_6;
                        tmp_6 = strcasecmp((char const *)(filter),"all");
                        if (tmp_6) break;
                        else iface->rxfilter = CNF_HWTS_RXFILTER_ALL;
                      }
                      else iface->rxfilter = CNF_HWTS_RXFILTER_NTP;
                    }
                    else iface->rxfilter = CNF_HWTS_RXFILTER_NONE;
                  }
                }
                else {
                  int tmp_4;
                  tmp_4 = sscanf((char const *)line,"%lf%n",& iface->tx_comp,
                                 & n); /* sscanf_va_54 */
                  if (tmp_4 != 1) break;
                }
              }
              else {
                int tmp_3;
                tmp_3 = sscanf((char const *)line,"%lf%n",& iface->rx_comp,
                               & n); /* sscanf_va_55 */
                if (tmp_3 != 1) break;
              }
            }
            else {
              int tmp_2;
              tmp_2 = sscanf((char const *)line,"%lf%n",& iface->precision,
                             & n); /* sscanf_va_56 */
              if (tmp_2 != 1) break;
            }
          }
          else {
            int tmp_1;
            tmp_1 = sscanf((char const *)line,"%d%n",& iface->min_samples,
                           & n); /* sscanf_va_57 */
            if (tmp_1 != 1) break;
          }
        }
        else {
          int tmp_0;
          tmp_0 = sscanf((char const *)line,"%d%n",& iface->minpoll,& n); /* sscanf_va_58 */
          if (tmp_0 != 1) break;
        }
      }
      else {
        int tmp;
        tmp = sscanf((char const *)line,"%d%n",& iface->max_samples,& n); /* sscanf_va_59 */
        if (tmp != 1) break;
      }
    }
    line += n;
    p = line;
  }
  if (*p) command_parse_error();
  return_label: return;
}

/*@ assigns \nothing; */
static void parse_include(char *line)
{
  glob_t gl;
  size_t i;
  int r;
  check_number_of_args(line,1);
  r = glob((char const *)line,1 << 0,
           (int (*)(char const *epath, int eerrno))0,& gl);
  if (r != 0) {
    if (r != 3) {
      {
        char *__va_arg0 = line;
        void *__va_args[1] = {& __va_arg0};
        LOG_Message(LOGS_FATAL,"Could not search for files matching %s",
                    (void * const *)(__va_args));
      }
      exit(1);
    }
    goto return_label;
  }
  i = (size_t)0;
  while (i < gl.gl_pathc) {
    CNF_ReadFile((char const *)*(gl.gl_pathv + i));
    i ++;
  }
  globfree(& gl);
  return_label: return;
}

void CNF_CreateDirs(uid_t uid, gid_t gid)
{
  char *dir;
  if (*(bind_cmd_path + 0)) {
    int tmp;
    dir = UTI_PathToDir((char const *)bind_cmd_path);
    UTI_CreateDirAndParents((char const *)dir,(mode_t)0770,uid,gid);
    tmp = UTI_CheckDirPermissions((char const *)dir,(mode_t)0770,uid,gid);
    if (! tmp) {
      {
        char *__va_arg0 = bind_cmd_path;
        void *__va_args[1] = {& __va_arg0};
        LOG_Message(LOGS_WARN,"Disabled command socket %s",
                    (void * const *)(__va_args));
      }
      *(bind_cmd_path + 0) = (char)'\000';
    }
    free((void *)dir);
  }
  if (*(logdir + 0)) UTI_CreateDirAndParents((char const *)logdir,
                                             (mode_t)0755,uid,gid);
  if (*(dumpdir + 0)) UTI_CreateDirAndParents((char const *)dumpdir,
                                              (mode_t)0755,uid,gid);
  return;
}

void CNF_AddInitSources(void)
{
  CPS_NTP_Source cps_source;
  NTP_Remote_Address ntp_addr;
  unsigned int i;
  char dummy_hostname[2] = {(char)'H', (char)'\000'};
  i = (unsigned int)0;
  while (1) {
    unsigned int tmp_0;
    tmp_0 = ARR_GetSize(init_sources);
    ;
    if (! (i < tmp_0)) break;
    {
      void *tmp;
      CPS_ParseNTPSourceAdd(dummy_hostname,& cps_source);
      tmp = ARR_GetElement(init_sources,i);
      ntp_addr.ip_addr = *((IPAddr *)tmp);
      ntp_addr.port = cps_source.port;
      cps_source.params.iburst = 1;
      cps_source.params.connectivity = SRC_OFFLINE;
      NSR_AddSource(& ntp_addr,NTP_SERVER,& cps_source.params);
    }
    i ++;
  }
  ARR_SetSize(init_sources,(unsigned int)0);
  return;
}

void CNF_AddSources(void)
{
  NTP_Source *source;
  unsigned int i;
  i = (unsigned int)0;
  while (1) {
    unsigned int tmp_0;
    tmp_0 = ARR_GetSize(ntp_sources);
    ;
    if (! (i < tmp_0)) break;
    source = (NTP_Source *)ARR_GetElement(ntp_sources,i);
    NSR_AddSourceByName(source->params.name,(int)source->params.port,
                        source->pool,source->type,& source->params.params);
    free((void *)source->params.name);
    i ++;
  }
  ARR_SetSize(ntp_sources,(unsigned int)0);
  return;
}

void CNF_AddRefclocks(void)
{
  unsigned int i;
  i = (unsigned int)0;
  while (1) {
    unsigned int tmp_0;
    tmp_0 = ARR_GetSize(refclock_sources);
    ;
    if (! (i < tmp_0)) break;
    {
      void *tmp;
      tmp = ARR_GetElement(refclock_sources,i);
      RCL_AddRefclock((RefclockParameters *)tmp);
    }
    i ++;
  }
  ARR_SetSize(refclock_sources,(unsigned int)0);
  return;
}

void CNF_AddBroadcasts(void)
{
  unsigned int i;
  NTP_Broadcast_Destination *destination;
  i = (unsigned int)0;
  while (1) {
    unsigned int tmp_0;
    tmp_0 = ARR_GetSize(broadcasts);
    ;
    if (! (i < tmp_0)) break;
    destination = (NTP_Broadcast_Destination *)ARR_GetElement(broadcasts,i);
    NCR_AddBroadcastDestination(& destination->addr,destination->port,
                                destination->interval);
    i ++;
  }
  ARR_SetSize(broadcasts,(unsigned int)0);
  return;
}

int CNF_GetNTPPort(void)
{
  return ntp_port;
}

int CNF_GetAcquisitionPort(void)
{
  return acquisition_port;
}

char *CNF_GetDriftFile(void)
{
  return drift_file;
}

int CNF_GetLogBanner(void)
{
  return log_banner;
}

char *CNF_GetLogDir(void)
{
  return logdir;
}

char *CNF_GetDumpDir(void)
{
  return dumpdir;
}

int CNF_GetLogMeasurements(int *raw)
{
  *raw = raw_measurements;
  return do_log_measurements;
}

int CNF_GetLogStatistics(void)
{
  return do_log_statistics;
}

int CNF_GetLogTracking(void)
{
  return do_log_tracking;
}

int CNF_GetLogRtc(void)
{
  return do_log_rtc;
}

int CNF_GetLogRefclocks(void)
{
  return do_log_refclocks;
}

int CNF_GetLogTempComp(void)
{
  return do_log_tempcomp;
}

char *CNF_GetKeysFile(void)
{
  return keys_file;
}

double CNF_GetRtcAutotrim(void)
{
  return rtc_autotrim_threshold;
}

char *CNF_GetRtcFile(void)
{
  return rtc_file;
}

char *CNF_GetRtcDevice(void)
{
  return rtc_device;
}

double CNF_GetMaxUpdateSkew(void)
{
  return max_update_skew;
}

double CNF_GetMaxDrift(void)
{
  return max_drift;
}

double CNF_GetMaxClockError(void)
{
  return max_clock_error;
}

double CNF_GetCorrectionTimeRatio(void)
{
  return correction_time_ratio;
}

double CNF_GetMaxSlewRate(void)
{
  return max_slew_rate;
}

double CNF_GetMaxDistance(void)
{
  return max_distance;
}

double CNF_GetMaxJitter(void)
{
  return max_jitter;
}

double CNF_GetReselectDistance(void)
{
  return reselect_distance;
}

double CNF_GetStratumWeight(void)
{
  return stratum_weight;
}

double CNF_GetCombineLimit(void)
{
  return combine_limit;
}

int CNF_GetManualEnabled(void)
{
  return enable_manual;
}

int CNF_GetCommandPort(void)
{
  return cmd_port;
}

int CNF_AllowLocalReference(int *stratum, int *orphan, double *distance)
{
  int __retres;
  if (enable_local) {
    *stratum = local_stratum;
    *orphan = local_orphan;
    *distance = local_distance;
    __retres = 1;
    goto return_label;
  }
  else {
    __retres = 0;
    goto return_label;
  }
  return_label: return __retres;
}

int CNF_GetRtcOnUtc(void)
{
  return rtc_on_utc;
}

int CNF_GetRtcSync(void)
{
  return rtc_sync;
}

void CNF_GetMakeStep(int *limit, double *threshold)
{
  *limit = make_step_limit;
  *threshold = make_step_threshold;
  return;
}

void CNF_GetMaxChange(int *delay, int *ignore, double *offset)
{
  *delay = max_offset_delay;
  *ignore = max_offset_ignore;
  *offset = max_offset;
  return;
}

double CNF_GetLogChange(void)
{
  return log_change_threshold;
}

void CNF_GetMailOnChange(int *enabled_0, double *threshold, char **user_0)
{
  if (mail_user_on_change) {
    *enabled_0 = 1;
    *threshold = mail_change_threshold;
    *user_0 = mail_user_on_change;
  }
  else {
    *enabled_0 = 0;
    *threshold = 0.0;
    *user_0 = (char *)0;
  }
  return;
}

void CNF_SetupAccessRestrictions(void)
{
  AllowDeny *node;
  int status;
  unsigned int i;
  i = (unsigned int)0;
  while (1) {
    unsigned int tmp_0;
    tmp_0 = ARR_GetSize(ntp_restrictions);
    ;
    if (! (i < tmp_0)) break;
    node = (AllowDeny *)ARR_GetElement(ntp_restrictions,i);
    status = NCR_AddAccessRestriction(& node->ip,node->subnet_bits,
                                      node->allow,node->all);
    if (! status) {
      char *tmp;
      ;
      tmp = UTI_IPToString(& node->ip);
      {
        char *__va_arg0 = tmp;
        int __va_arg1 = node->subnet_bits;
        void *__va_args[2] = {& __va_arg0, & __va_arg1};
        LOG_Message(LOGS_FATAL,"Bad subnet in %s/%d",
                    (void * const *)(__va_args));
      }
      exit(1);
    }
    i ++;
  }
  i = (unsigned int)0;
  while (1) {
    unsigned int tmp_2;
    tmp_2 = ARR_GetSize(cmd_restrictions);
    ;
    if (! (i < tmp_2)) break;
    node = (AllowDeny *)ARR_GetElement(cmd_restrictions,i);
    status = CAM_AddAccessRestriction(& node->ip,node->subnet_bits,
                                      node->allow,node->all);
    if (! status) {
      char *tmp_1;
      ;
      tmp_1 = UTI_IPToString(& node->ip);
      {
        char *__va_arg0_12 = tmp_1;
        int __va_arg1_14 = node->subnet_bits;
        void *__va_args_16[2] = {& __va_arg0_12, & __va_arg1_14};
        LOG_Message(LOGS_FATAL,"Bad subnet in %s/%d",
                    (void * const *)(__va_args_16));
      }
      exit(1);
    }
    i ++;
  }
  ARR_SetSize(ntp_restrictions,(unsigned int)0);
  ARR_SetSize(cmd_restrictions,(unsigned int)0);
  return;
}

int CNF_GetNoClientLog(void)
{
  return no_client_log;
}

unsigned long CNF_GetClientLogLimit(void)
{
  return client_log_limit;
}

void CNF_GetFallbackDrifts(int *min, int *max)
{
  *min = fb_drift_min;
  *max = fb_drift_max;
  return;
}

void CNF_GetBindAddress(int family, IPAddr *addr)
{
  if (family == 1) *addr = bind_address4;
  else 
    if (family == 2) *addr = bind_address6; else addr->family = (uint16_t)0;
  return;
}

void CNF_GetBindAcquisitionAddress(int family, IPAddr *addr)
{
  if (family == 1) *addr = bind_acq_address4;
  else 
    if (family == 2) *addr = bind_acq_address6;
    else addr->family = (uint16_t)0;
  return;
}

char *CNF_GetBindCommandPath(void)
{
  return bind_cmd_path;
}

void CNF_GetBindCommandAddress(int family, IPAddr *addr)
{
  if (family == 1) *addr = bind_cmd_address4;
  else 
    if (family == 2) *addr = bind_cmd_address6;
    else addr->family = (uint16_t)0;
  return;
}

char *CNF_GetNtpSigndSocket(void)
{
  return ntp_signd_socket;
}

char *CNF_GetPidFile(void)
{
  return pidfile;
}

REF_LeapMode CNF_GetLeapSecMode(void)
{
  return leapsec_mode;
}

char *CNF_GetLeapSecTimezone(void)
{
  return leapsec_tz;
}

int CNF_GetSchedPriority(void)
{
  return sched_priority;
}

int CNF_GetLockMemory(void)
{
  return lock_memory;
}

int CNF_GetNTPRateLimit(int *interval, int *burst, int *leak)
{
  *interval = ntp_ratelimit_interval;
  *burst = ntp_ratelimit_burst;
  *leak = ntp_ratelimit_leak;
  return ntp_ratelimit_enabled;
}

int CNF_GetCommandRateLimit(int *interval, int *burst, int *leak)
{
  *interval = cmd_ratelimit_interval;
  *burst = cmd_ratelimit_burst;
  *leak = cmd_ratelimit_leak;
  return cmd_ratelimit_enabled;
}

void CNF_GetSmooth(double *max_freq_0, double *max_wander_0, int *leap_only)
{
  *max_freq_0 = smooth_max_freq;
  *max_wander_0 = smooth_max_wander;
  *leap_only = smooth_leap_only;
  return;
}

void CNF_GetTempComp(char **file, double *interval, char **point_file,
                     double *T0, double *k0, double *k1, double *k2)
{
  *file = tempcomp_sensor_file;
  *point_file = tempcomp_point_file;
  *interval = tempcomp_interval;
  *T0 = tempcomp_T0;
  *k0 = tempcomp_k0;
  *k1 = tempcomp_k1;
  *k2 = tempcomp_k2;
  return;
}

char *CNF_GetUser(void)
{
  return user;
}

int CNF_GetMaxSamples(void)
{
  return max_samples;
}

int CNF_GetMinSamples(void)
{
  return min_samples;
}

int CNF_GetMinSources(void)
{
  return min_sources;
}

char *CNF_GetHwclockFile(void)
{
  return hwclock_file;
}

int CNF_GetInitSources(void)
{
  int __retres;
  unsigned int tmp;
  tmp = ARR_GetSize(init_sources);
  __retres = (int)tmp;
  return __retres;
}

double CNF_GetInitStepThreshold(void)
{
  return init_slew_threshold;
}

int CNF_GetHwTsInterface(unsigned int index_0, CNF_HwTsInterface **iface)
{
  int __retres;
  unsigned int tmp;
  tmp = ARR_GetSize(hwts_interfaces);
  ;
  if (index_0 >= tmp) {
    __retres = 0;
    goto return_label;
  }
  *iface = (CNF_HwTsInterface *)ARR_GetElement(hwts_interfaces,index_0);
  __retres = 1;
  return_label: return __retres;
}

void MD5Init(MD5_CTX *mdContext) __attribute__((__FC_OLDSTYLEPROTO__));

void MD5Update(MD5_CTX *mdContext, unsigned char const *inBuf,
               unsigned int inLen) __attribute__((__FC_OLDSTYLEPROTO__));

void MD5Final(MD5_CTX *mdContext) __attribute__((__FC_OLDSTYLEPROTO__));

static void Transform(UINT4 *buf, UINT4 *in) __attribute__((__FC_OLDSTYLEPROTO__));

static unsigned char const PADDING[64] =
  {(unsigned char)0x80,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00,
   (unsigned char)0x00};
void MD5Init(MD5_CTX *mdContext) __attribute__((__FC_OLDSTYLEPROTO__));
void MD5Init(MD5_CTX *mdContext)
{
  UINT4 tmp;
  tmp = (UINT4)0;
  mdContext->i[1] = tmp;
  mdContext->i[0] = tmp;
  mdContext->buf[0] = (UINT4)0x67452301;
  mdContext->buf[1] = 0xefcdab89;
  mdContext->buf[2] = 0x98badcfe;
  mdContext->buf[3] = (UINT4)0x10325476;
  return;
}

void MD5Update(MD5_CTX *mdContext, unsigned char const *inBuf,
               unsigned int inLen) __attribute__((__FC_OLDSTYLEPROTO__));
void MD5Update(MD5_CTX *mdContext, unsigned char const *inBuf,
               unsigned int inLen)
{
  UINT4 in[16];
  int mdi;
  unsigned int i;
  unsigned int ii;
  mdi = (int)((mdContext->i[0] >> 3) & (unsigned int)0x3F);
  if (mdContext->i[0] + (inLen << 3) < mdContext->i[0]) (mdContext->i[1]) ++;
  mdContext->i[0] += inLen << 3;
  mdContext->i[1] += inLen >> 29;
  while (1) {
    unsigned int tmp_1;
    tmp_1 = inLen;
    inLen --;
    ;
    if (! tmp_1) break;
    {
      int tmp;
      unsigned char const *tmp_0;
      tmp = mdi;
      mdi ++;
      tmp_0 = inBuf;
      inBuf ++;
      mdContext->in[tmp] = *tmp_0;
      if (mdi == 0x40) {
        i = (unsigned int)0;
        ii = (unsigned int)0;
        /*@ loop unroll 16; */
        while (i < (unsigned int)16) {
          in[i] = ((((UINT4)mdContext->in[ii + (unsigned int)3] << 24) | (
                    (UINT4)mdContext->in[ii + (unsigned int)2] << 16)) | (
                   (UINT4)mdContext->in[ii + (unsigned int)1] << 8)) | (UINT4)mdContext->in[ii];
          i ++;
          ii += (unsigned int)4;
        }
        Transform(mdContext->buf,in);
        mdi = 0;
      }
    }
  }
  return;
}

void MD5Final(MD5_CTX *mdContext) __attribute__((__FC_OLDSTYLEPROTO__));
void MD5Final(MD5_CTX *mdContext)
{
  UINT4 in[16];
  int mdi;
  unsigned int i;
  unsigned int ii;
  unsigned int padLen;
  in[14] = mdContext->i[0];
  in[15] = mdContext->i[1];
  mdi = (int)((mdContext->i[0] >> 3) & (unsigned int)0x3F);
  if (mdi < 56) padLen = (unsigned int)(56 - mdi);
  else padLen = (unsigned int)(120 - mdi);
  MD5Update(mdContext,PADDING,padLen);
  i = (unsigned int)0;
  ii = (unsigned int)0;
  /*@ loop unroll 14; */
  while (i < (unsigned int)14) {
    in[i] = ((((UINT4)mdContext->in[ii + (unsigned int)3] << 24) | ((UINT4)mdContext->in[
                                                                    ii + (unsigned int)2] << 16)) | (
             (UINT4)mdContext->in[ii + (unsigned int)1] << 8)) | (UINT4)mdContext->in[ii];
    i ++;
    ii += (unsigned int)4;
  }
  Transform(mdContext->buf,in);
  i = (unsigned int)0;
  ii = (unsigned int)0;
  /*@ loop unroll 4; */
  while (i < (unsigned int)4) {
    mdContext->digest[ii] = (unsigned char)(mdContext->buf[i] & (unsigned int)0xFF);
    mdContext->digest[ii + (unsigned int)1] = (unsigned char)((mdContext->buf[i] >> 8) & (unsigned int)0xFF);
    mdContext->digest[ii + (unsigned int)2] = (unsigned char)((mdContext->buf[i] >> 16) & (unsigned int)0xFF);
    mdContext->digest[ii + (unsigned int)3] = (unsigned char)((mdContext->buf[i] >> 24) & (unsigned int)0xFF);
    i ++;
    ii += (unsigned int)4;
  }
  return;
}

/*@ requires \initialized(in + (0 .. 15));
    assigns *(buf + (0 .. 3));
    assigns *(buf + (0 .. 3)) \from (indirect: in), *(in + (0 .. 15));
 */
static void Transform(UINT4 *buf, UINT4 *in) __attribute__((__FC_OLDSTYLEPROTO__));
static void Transform(UINT4 *buf, UINT4 *in)
{
  UINT4 a = *(buf + 0);
  UINT4 b = *(buf + 1);
  UINT4 c = *(buf + 2);
  UINT4 d = *(buf + 3);
  a += (((b & c) | (~ b & d)) + *(in + 0)) + 0xd76aa478;
  a = (a << 7) | (a >> (32 - 7));
  a += b;
  d += (((a & b) | (~ a & c)) + *(in + 1)) + 0xe8c7b756;
  d = (d << 12) | (d >> (32 - 12));
  d += a;
  c += (((d & a) | (~ d & b)) + *(in + 2)) + (UINT4)0x242070db;
  c = (c << 17) | (c >> (32 - 17));
  c += d;
  b += (((c & d) | (~ c & a)) + *(in + 3)) + 0xc1bdceee;
  b = (b << 22) | (b >> (32 - 22));
  b += c;
  a += (((b & c) | (~ b & d)) + *(in + 4)) + 0xf57c0faf;
  a = (a << 7) | (a >> (32 - 7));
  a += b;
  d += (((a & b) | (~ a & c)) + *(in + 5)) + (UINT4)0x4787c62a;
  d = (d << 12) | (d >> (32 - 12));
  d += a;
  c += (((d & a) | (~ d & b)) + *(in + 6)) + 0xa8304613;
  c = (c << 17) | (c >> (32 - 17));
  c += d;
  b += (((c & d) | (~ c & a)) + *(in + 7)) + 0xfd469501;
  b = (b << 22) | (b >> (32 - 22));
  b += c;
  a += (((b & c) | (~ b & d)) + *(in + 8)) + (UINT4)0x698098d8;
  a = (a << 7) | (a >> (32 - 7));
  a += b;
  d += (((a & b) | (~ a & c)) + *(in + 9)) + 0x8b44f7af;
  d = (d << 12) | (d >> (32 - 12));
  d += a;
  c += (((d & a) | (~ d & b)) + *(in + 10)) + 0xffff5bb1;
  c = (c << 17) | (c >> (32 - 17));
  c += d;
  b += (((c & d) | (~ c & a)) + *(in + 11)) + 0x895cd7be;
  b = (b << 22) | (b >> (32 - 22));
  b += c;
  a += (((b & c) | (~ b & d)) + *(in + 12)) + (UINT4)0x6b901122;
  a = (a << 7) | (a >> (32 - 7));
  a += b;
  d += (((a & b) | (~ a & c)) + *(in + 13)) + 0xfd987193;
  d = (d << 12) | (d >> (32 - 12));
  d += a;
  c += (((d & a) | (~ d & b)) + *(in + 14)) + 0xa679438e;
  c = (c << 17) | (c >> (32 - 17));
  c += d;
  b += (((c & d) | (~ c & a)) + *(in + 15)) + (UINT4)0x49b40821;
  b = (b << 22) | (b >> (32 - 22));
  b += c;
  a += (((b & d) | (c & ~ d)) + *(in + 1)) + 0xf61e2562;
  a = (a << 5) | (a >> (32 - 5));
  a += b;
  d += (((a & c) | (b & ~ c)) + *(in + 6)) + 0xc040b340;
  d = (d << 9) | (d >> (32 - 9));
  d += a;
  c += (((d & b) | (a & ~ b)) + *(in + 11)) + (UINT4)0x265e5a51;
  c = (c << 14) | (c >> (32 - 14));
  c += d;
  b += (((c & a) | (d & ~ a)) + *(in + 0)) + 0xe9b6c7aa;
  b = (b << 20) | (b >> (32 - 20));
  b += c;
  a += (((b & d) | (c & ~ d)) + *(in + 5)) + 0xd62f105d;
  a = (a << 5) | (a >> (32 - 5));
  a += b;
  d += (((a & c) | (b & ~ c)) + *(in + 10)) + (UINT4)0x2441453;
  d = (d << 9) | (d >> (32 - 9));
  d += a;
  c += (((d & b) | (a & ~ b)) + *(in + 15)) + 0xd8a1e681;
  c = (c << 14) | (c >> (32 - 14));
  c += d;
  b += (((c & a) | (d & ~ a)) + *(in + 4)) + 0xe7d3fbc8;
  b = (b << 20) | (b >> (32 - 20));
  b += c;
  a += (((b & d) | (c & ~ d)) + *(in + 9)) + (UINT4)0x21e1cde6;
  a = (a << 5) | (a >> (32 - 5));
  a += b;
  d += (((a & c) | (b & ~ c)) + *(in + 14)) + 0xc33707d6;
  d = (d << 9) | (d >> (32 - 9));
  d += a;
  c += (((d & b) | (a & ~ b)) + *(in + 3)) + 0xf4d50d87;
  c = (c << 14) | (c >> (32 - 14));
  c += d;
  b += (((c & a) | (d & ~ a)) + *(in + 8)) + (UINT4)0x455a14ed;
  b = (b << 20) | (b >> (32 - 20));
  b += c;
  a += (((b & d) | (c & ~ d)) + *(in + 13)) + 0xa9e3e905;
  a = (a << 5) | (a >> (32 - 5));
  a += b;
  d += (((a & c) | (b & ~ c)) + *(in + 2)) + 0xfcefa3f8;
  d = (d << 9) | (d >> (32 - 9));
  d += a;
  c += (((d & b) | (a & ~ b)) + *(in + 7)) + (UINT4)0x676f02d9;
  c = (c << 14) | (c >> (32 - 14));
  c += d;
  b += (((c & a) | (d & ~ a)) + *(in + 12)) + 0x8d2a4c8a;
  b = (b << 20) | (b >> (32 - 20));
  b += c;
  a += (((b ^ c) ^ d) + *(in + 5)) + 0xfffa3942;
  a = (a << 4) | (a >> (32 - 4));
  a += b;
  d += (((a ^ b) ^ c) + *(in + 8)) + 0x8771f681;
  d = (d << 11) | (d >> (32 - 11));
  d += a;
  c += (((d ^ a) ^ b) + *(in + 11)) + (UINT4)0x6d9d6122;
  c = (c << 16) | (c >> (32 - 16));
  c += d;
  b += (((c ^ d) ^ a) + *(in + 14)) + 0xfde5380c;
  b = (b << 23) | (b >> (32 - 23));
  b += c;
  a += (((b ^ c) ^ d) + *(in + 1)) + 0xa4beea44;
  a = (a << 4) | (a >> (32 - 4));
  a += b;
  d += (((a ^ b) ^ c) + *(in + 4)) + (UINT4)0x4bdecfa9;
  d = (d << 11) | (d >> (32 - 11));
  d += a;
  c += (((d ^ a) ^ b) + *(in + 7)) + 0xf6bb4b60;
  c = (c << 16) | (c >> (32 - 16));
  c += d;
  b += (((c ^ d) ^ a) + *(in + 10)) + 0xbebfbc70;
  b = (b << 23) | (b >> (32 - 23));
  b += c;
  a += (((b ^ c) ^ d) + *(in + 13)) + (UINT4)0x289b7ec6;
  a = (a << 4) | (a >> (32 - 4));
  a += b;
  d += (((a ^ b) ^ c) + *(in + 0)) + 0xeaa127fa;
  d = (d << 11) | (d >> (32 - 11));
  d += a;
  c += (((d ^ a) ^ b) + *(in + 3)) + 0xd4ef3085;
  c = (c << 16) | (c >> (32 - 16));
  c += d;
  b += (((c ^ d) ^ a) + *(in + 6)) + (UINT4)0x4881d05;
  b = (b << 23) | (b >> (32 - 23));
  b += c;
  a += (((b ^ c) ^ d) + *(in + 9)) + 0xd9d4d039;
  a = (a << 4) | (a >> (32 - 4));
  a += b;
  d += (((a ^ b) ^ c) + *(in + 12)) + 0xe6db99e5;
  d = (d << 11) | (d >> (32 - 11));
  d += a;
  c += (((d ^ a) ^ b) + *(in + 15)) + (UINT4)0x1fa27cf8;
  c = (c << 16) | (c >> (32 - 16));
  c += d;
  b += (((c ^ d) ^ a) + *(in + 2)) + 0xc4ac5665;
  b = (b << 23) | (b >> (32 - 23));
  b += c;
  a += ((c ^ (b | ~ d)) + *(in + 0)) + 0xf4292244;
  a = (a << 6) | (a >> (32 - 6));
  a += b;
  d += ((b ^ (a | ~ c)) + *(in + 7)) + (UINT4)0x432aff97;
  d = (d << 10) | (d >> (32 - 10));
  d += a;
  c += ((a ^ (d | ~ b)) + *(in + 14)) + 0xab9423a7;
  c = (c << 15) | (c >> (32 - 15));
  c += d;
  b += ((d ^ (c | ~ a)) + *(in + 5)) + 0xfc93a039;
  b = (b << 21) | (b >> (32 - 21));
  b += c;
  a += ((c ^ (b | ~ d)) + *(in + 12)) + (UINT4)0x655b59c3;
  a = (a << 6) | (a >> (32 - 6));
  a += b;
  d += ((b ^ (a | ~ c)) + *(in + 3)) + 0x8f0ccc92;
  d = (d << 10) | (d >> (32 - 10));
  d += a;
  c += ((a ^ (d | ~ b)) + *(in + 10)) + 0xffeff47d;
  c = (c << 15) | (c >> (32 - 15));
  c += d;
  b += ((d ^ (c | ~ a)) + *(in + 1)) + 0x85845dd1;
  b = (b << 21) | (b >> (32 - 21));
  b += c;
  a += ((c ^ (b | ~ d)) + *(in + 8)) + (UINT4)0x6fa87e4f;
  a = (a << 6) | (a >> (32 - 6));
  a += b;
  d += ((b ^ (a | ~ c)) + *(in + 15)) + 0xfe2ce6e0;
  d = (d << 10) | (d >> (32 - 10));
  d += a;
  c += ((a ^ (d | ~ b)) + *(in + 6)) + 0xa3014314;
  c = (c << 15) | (c >> (32 - 15));
  c += d;
  b += ((d ^ (c | ~ a)) + *(in + 13)) + (UINT4)0x4e0811a1;
  b = (b << 21) | (b >> (32 - 21));
  b += c;
  a += ((c ^ (b | ~ d)) + *(in + 4)) + 0xf7537e82;
  a = (a << 6) | (a >> (32 - 6));
  a += b;
  d += ((b ^ (a | ~ c)) + *(in + 11)) + 0xbd3af235;
  d = (d << 10) | (d >> (32 - 10));
  d += a;
  c += ((a ^ (d | ~ b)) + *(in + 2)) + (UINT4)0x2ad7d2bb;
  c = (c << 15) | (c >> (32 - 15));
  c += d;
  b += ((d ^ (c | ~ a)) + *(in + 9)) + 0xeb86d391;
  b = (b << 21) | (b >> (32 - 21));
  b += c;
  *(buf + 0) += a;
  *(buf + 1) += b;
  *(buf + 2) += c;
  *(buf + 3) += d;
  return;
}

static MD5_CTX ctx;
int HSH_GetHashId(char const *name)
{
  int __retres;
  int tmp;
  tmp = strcmp(name,"MD5");
  if (tmp) {
    __retres = -1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

unsigned int HSH_Hash(int id, unsigned char const *in1, unsigned int in1_len,
                      unsigned char const *in2, unsigned int in2_len,
                      unsigned char *out, unsigned int out_len)
{
  MD5Init(& ctx);
  MD5Update(& ctx,in1,in1_len);
  if (in2) MD5Update(& ctx,in2,in2_len);
  MD5Final(& ctx);
  if (out_len < (unsigned int)16) out_len = out_len;
  else out_len = (unsigned int)16;
  memcpy((void *)out,(void const *)(ctx.digest),(size_t)out_len);
  return out_len;
}

void HSH_Finalise(void)
{
  return;
}

void KEY_Initialise(void);

void KEY_Finalise(void);

void KEY_Reload(void);

int KEY_KeyKnown(uint32_t key_id);

int KEY_GetAuthDelay(uint32_t key_id);

int KEY_GetAuthLength(uint32_t key_id);

int KEY_CheckKeyLength(uint32_t key_id);

int KEY_GenerateAuth(uint32_t key_id, unsigned char const *data,
                     int data_len, unsigned char *auth, int auth_len);

int KEY_CheckAuth(uint32_t key_id, unsigned char const *data, int data_len,
                  unsigned char const *auth, int auth_len, int trunc_len);

void LCL_ReadRawTime(struct timespec *ts);

void LCL_ReadCookedTime(struct timespec *result, double *err);

void LCL_CookTime(struct timespec *raw, struct timespec *cooked, double *err);

void LCL_GetOffsetCorrection(struct timespec *raw, double *correction,
                             double *err);

void LCL_AddParameterChangeHandler(void (*handler)(struct timespec *raw,
                                                   struct timespec *cooked,
                                                   double dfreq,
                                                   double doffset,
                                                   LCL_ChangeType change_type,
                                                   void *anything),
                                   void *anything);

void LCL_RemoveParameterChangeHandler(void (*handler)(struct timespec *raw,
                                                      struct timespec *cooked,
                                                      double dfreq,
                                                      double doffset,
                                                      LCL_ChangeType change_type,
                                                      void *anything),
                                      void *anything);

int LCL_IsFirstParameterChangeHandler(void (*handler)(struct timespec *raw,
                                                      struct timespec *cooked,
                                                      double dfreq,
                                                      double doffset,
                                                      LCL_ChangeType change_type,
                                                      void *anything));

void LCL_AddDispersionNotifyHandler(void (*handler)(double dispersion,
                                                    void *anything),
                                    void *anything);

extern void LCL_RemoveDispersionNotifyHandler(void (*handler)(double dispersion,
                                                              void *anything),
                                              void *anything);

double LCL_ReadAbsoluteFrequency(void);

void LCL_SetAbsoluteFrequency(double afreq_ppm);

void LCL_AccumulateDeltaFrequency(double dfreq);

void LCL_AccumulateOffset(double offset, double corr_rate);

int LCL_ApplyStepOffset(double offset);

void LCL_NotifyExternalTimeStep(struct timespec *raw,
                                struct timespec *cooked, double offset,
                                double dispersion);

void LCL_NotifyLeap(int leap);

void LCL_AccumulateFrequencyAndOffset(double dfreq, double doffset,
                                      double corr_rate);

int LCL_GetSysPrecisionAsLog(void);

double LCL_GetSysPrecisionAsQuantum(void);

double LCL_GetMaxClockError(void);

void LCL_Initialise(void);

void LCL_Finalise(void);

int LCL_MakeStep(void);

int LCL_CanSystemLeap(void);

void LCL_SetSystemLeap(int leap, int tai_offset);

double LCL_SetTempComp(double comp);

void LCL_SetSyncStatus(int synchronised, double est_error, double max_error);

static ARR_Instance keys;
static int cache_valid;
static uint32_t cache_key_id;
static int cache_key_pos;
static void free_keys(void)
{
  unsigned int i;
  i = (unsigned int)0;
  while (1) {
    unsigned int tmp_0;
    void *tmp;
    tmp_0 = ARR_GetSize(keys);
    ;
    if (! (i < tmp_0)) break;
    tmp = ARR_GetElement(keys,i);
    free((void *)((Key *)tmp)->val);
    i ++;
  }
  ARR_SetSize(keys,(unsigned int)0);
  cache_valid = 0;
  return;
}

void KEY_Initialise(void)
{
  keys = ARR_CreateInstance((unsigned int)sizeof(Key));
  cache_valid = 0;
  KEY_Reload();
  return;
}

void KEY_Finalise(void)
{
  free_keys();
  ARR_DestroyInstance(keys);
  return;
}

static Key *get_key(unsigned int index_0)
{
  Key *__retres;
  void *tmp;
  tmp = ARR_GetElements(keys);
  ;
  __retres = (Key *)tmp + index_0;
  return __retres;
}

static int determine_hash_delay(uint32_t key_id)
{
  NTP_Packet pkt;
  struct timespec before;
  struct timespec after;
  double diff;
  double min_diff;
  int i;
  int nsecs;
  memset((void *)(& pkt),0,sizeof(pkt));
  i = 0;
  /*@ loop unroll 10; */
  while (i < 10) {
    LCL_ReadRawTime(& before);
    KEY_GenerateAuth(key_id,(unsigned char const *)(& pkt),48,
                     (unsigned char *)(& pkt.auth_data),
                     (int)sizeof(pkt.auth_data));
    LCL_ReadRawTime(& after);
    diff = UTI_DiffTimespecsToDouble(& after,& before);
    if (i == 0) min_diff = diff;
    else 
      if (min_diff > diff) min_diff = diff;
    i ++;
  }
  nsecs = (int)(1.0625e9 * min_diff);
  return nsecs;
}

static int decode_password(char *key)
{
  int __retres;
  int i;
  int j;
  size_t tmp;
  char buf[3];
  char *p;
  int tmp_2;
  tmp = strlen((char const *)key);
  int len = (int)tmp;
  tmp_2 = strncmp((char const *)key,"ASCII:",(size_t)6);
  if (tmp_2) {
    int tmp_1;
    tmp_1 = strncmp((char const *)key,"HEX:",(size_t)4);
    if (tmp_1) {
      __retres = len;
      goto return_label;
    }
    else {
      if ((len - 4) % 2) {
        __retres = 0;
        goto return_label;
      }
      i = 0;
      j = 4;
      while (j + 1 < len) {
        {
          long tmp_0;
          buf[0] = *(key + j);
          buf[1] = *(key + (j + 1));
          buf[2] = (char)'\000';
          tmp_0 = strtol((char const *)(buf),& p,16);
          *(key + i) = (char)tmp_0;
          if (p != & buf[2]) {
            __retres = 0;
            goto return_label;
          }
        }
        i ++;
        j += 2;
      }
      __retres = i;
      goto return_label;
    }
  }
  else {
    memmove((void *)key,(void const *)(key + 6),(size_t)(len - 6));
    __retres = len - 6;
    goto return_label;
  }
  return_label: return __retres;
}

static int compare_keys_by_id(void const *a, void const *b)
{
  int __retres;
  Key const *c = (Key const *)a;
  Key const *d = (Key const *)b;
  if (c->id < d->id) {
    __retres = -1;
    goto return_label;
  }
  else 
    if (c->id > d->id) {
      __retres = 1;
      goto return_label;
    }
    else {
      __retres = 0;
      goto return_label;
    }
  return_label: return __retres;
}

void KEY_Reload(void)
{
  unsigned int i;
  unsigned int line_number_0;
  FILE *in;
  uint32_t key_id;
  char line[2048];
  char *keyval;
  char *key_file;
  char const *hashname;
  Key key;
  unsigned int tmp_2;
  void *tmp_3;
  free_keys();
  key_file = CNF_GetKeysFile();
  line_number_0 = (unsigned int)0;
  if (! key_file) goto return_label;
  in = fopen((char const *)key_file,"r");
  if (! in) {
    {
      char *__va_arg0 = key_file;
      void *__va_args[1] = {& __va_arg0};
      LOG_Message(LOGS_WARN,"Could not open keyfile %s",
                  (void * const *)(__va_args));
    }
    goto return_label;
  }
  while (1) {
    char *tmp_1;
    tmp_1 = fgets(line,(int)sizeof(line),in);
    if (! tmp_1) break;
    {
      int tmp;
      line_number_0 ++;
      CPS_NormalizeLine(line);
      if (! line[0]) continue;
      tmp = CPS_ParseKey(line,& key_id,& hashname,& keyval);
      if (! tmp) {
        {
          unsigned int __va_arg0_25 = line_number_0;
          char *__va_arg1 = key_file;
          void *__va_args_28[2] = {& __va_arg0_25, & __va_arg1};
          LOG_Message(LOGS_WARN,"Could not parse key at line %u in file %s",
                      (void * const *)(__va_args_28));
        }
        continue;
      }
      key.hash_id = HSH_GetHashId(hashname);
      if (key.hash_id < 0) {
        {
          uint32_t __va_arg0_30 = key_id;
          void *__va_args_32[1] = {& __va_arg0_30};
          LOG_Message(LOGS_WARN,"Unknown hash function in key %u",
                      (void * const *)(__va_args_32));
        }
        continue;
      }
      key.len = decode_password(keyval);
      if (! key.len) {
        {
          uint32_t __va_arg0_34 = key_id;
          void *__va_args_36[1] = {& __va_arg0_34};
          LOG_Message(LOGS_WARN,"Could not decode password in key %u",
                      (void * const *)(__va_args_36));
        }
        continue;
      }
      key.id = key_id;
      key.val = (char *)Malloc2((size_t)key.len,sizeof(char));
      memcpy((void *)key.val,(void const *)keyval,(size_t)key.len);
      ARR_AppendElement(keys,(void *)(& key));
    }
  }
  fclose(in);
  tmp_2 = ARR_GetSize(keys);
  tmp_3 = ARR_GetElements(keys);
  qsort(tmp_3,(size_t)tmp_2,sizeof(Key),& compare_keys_by_id);
  i = (unsigned int)1;
  while (1) {
    unsigned int tmp_7;
    tmp_7 = ARR_GetSize(keys);
    ;
    if (! (i < tmp_7)) break;
    {
      Key *tmp_5;
      Key *tmp_6;
      tmp_5 = get_key(i - (unsigned int)1);
      tmp_6 = get_key(i);
      ;
      if (tmp_5->id == tmp_6->id) {
        Key *tmp_4;
        tmp_4 = get_key(i - (unsigned int)1);
        {
          uint32_t __va_arg0_38 = tmp_4->id;
          void *__va_args_40[1] = {& __va_arg0_38};
          LOG_Message(LOGS_WARN,"Detected duplicate key %u",
                      (void * const *)(__va_args_40));
        }
      }
    }
    i ++;
  }
  memset((void *)(line),0,sizeof(line));
  i = (unsigned int)0;
  while (1) {
    unsigned int tmp_10;
    Key *tmp_8;
    Key *tmp_9;
    tmp_10 = ARR_GetSize(keys);
    ;
    if (! (i < tmp_10)) break;
    tmp_8 = get_key(i);
    tmp_9 = get_key(i);
    tmp_8->auth_delay = determine_hash_delay(tmp_9->id);
    i ++;
  }
  return_label: return;
}

static int lookup_key(uint32_t id)
{
  int __retres;
  Key specimen;
  Key *where;
  Key *keys_ptr;
  int pos;
  void *tmp_0;
  unsigned int tmp;
  keys_ptr = (Key *)ARR_GetElements(keys);
  specimen.id = id;
  tmp = ARR_GetSize(keys);
  ;
  tmp_0 = bsearch((void const *)(& specimen),(void const *)keys_ptr,
                  (size_t)tmp,sizeof(Key),& compare_keys_by_id);
  where = (Key *)tmp_0;
  if (! where) {
    __retres = -1;
    goto return_label;
  }
  else {
    pos = (int)(where - keys_ptr);
    __retres = pos;
    goto return_label;
  }
  return_label: return __retres;
}

static Key *get_key_by_id(uint32_t key_id)
{
  Key *__retres;
  int position;
  if (cache_valid) 
    if (key_id == cache_key_id) {
      Key *tmp;
      tmp = get_key((unsigned int)cache_key_pos);
      __retres = tmp;
      goto return_label;
    }
  position = lookup_key(key_id);
  if (position >= 0) {
    Key *tmp_0;
    cache_valid = 1;
    cache_key_pos = position;
    cache_key_id = key_id;
    tmp_0 = get_key((unsigned int)position);
    __retres = tmp_0;
    goto return_label;
  }
  __retres = (Key *)0;
  return_label: return __retres;
}

int KEY_KeyKnown(uint32_t key_id)
{
  int __retres;
  Key *tmp;
  tmp = get_key_by_id(key_id);
  __retres = tmp != (Key *)0;
  return __retres;
}

int KEY_GetAuthDelay(uint32_t key_id)
{
  int __retres;
  Key *key;
  key = get_key_by_id(key_id);
  if (! key) {
    __retres = 0;
    goto return_label;
  }
  __retres = key->auth_delay;
  return_label: return __retres;
}

int KEY_GetAuthLength(uint32_t key_id)
{
  int __retres;
  unsigned char buf[64];
  Key *key;
  unsigned int tmp;
  key = get_key_by_id(key_id);
  if (! key) {
    __retres = 0;
    goto return_label;
  }
  tmp = HSH_Hash(key->hash_id,(unsigned char const *)(buf),(unsigned int)0,
                 (unsigned char const *)(buf),(unsigned int)0,buf,
                 (unsigned int)sizeof(buf));
  __retres = (int)tmp;
  return_label: return __retres;
}

int KEY_CheckKeyLength(uint32_t key_id)
{
  int __retres;
  Key *key;
  key = get_key_by_id(key_id);
  if (! key) {
    __retres = 0;
    goto return_label;
  }
  __retres = key->len >= 10;
  return_label: return __retres;
}

static int generate_ntp_auth(int hash_id, unsigned char const *key,
                             int key_len, unsigned char const *data,
                             int data_len, unsigned char *auth, int auth_len)
{
  int __retres;
  unsigned int tmp;
  tmp = HSH_Hash(hash_id,key,(unsigned int)key_len,data,
                 (unsigned int)data_len,auth,(unsigned int)auth_len);
  __retres = (int)tmp;
  return __retres;
}

static int check_ntp_auth(int hash_id, unsigned char const *key, int key_len,
                          unsigned char const *data, int data_len,
                          unsigned char const *auth, int auth_len,
                          int trunc_len)
{
  unsigned char buf[64];
  int hash_len;
  int tmp_1;
  int tmp;
  hash_len = generate_ntp_auth(hash_id,key,key_len,data,data_len,buf,
                               (int)sizeof(buf));
  if (hash_len < trunc_len) tmp = hash_len; else tmp = trunc_len;
  ;
  if (tmp == auth_len) {
    int tmp_0;
    tmp_0 = memcmp((void const *)(buf),(void const *)auth,(size_t)auth_len);
    if (tmp_0) tmp_1 = 0; else tmp_1 = 1;
  }
  else tmp_1 = 0;
  return tmp_1;
}

int KEY_GenerateAuth(uint32_t key_id, unsigned char const *data,
                     int data_len, unsigned char *auth, int auth_len)
{
  int __retres;
  Key *key;
  int tmp;
  key = get_key_by_id(key_id);
  if (! key) {
    __retres = 0;
    goto return_label;
  }
  tmp = generate_ntp_auth(key->hash_id,(unsigned char const *)key->val,
                          key->len,data,data_len,auth,auth_len);
  __retres = tmp;
  return_label: return __retres;
}

int KEY_CheckAuth(uint32_t key_id, unsigned char const *data, int data_len,
                  unsigned char const *auth, int auth_len, int trunc_len)
{
  int __retres;
  Key *key;
  int tmp;
  key = get_key_by_id(key_id);
  if (! key) {
    __retres = 0;
    goto return_label;
  }
  tmp = check_ntp_auth(key->hash_id,(unsigned char const *)key->val,key->len,
                       data,data_len,auth,auth_len,trunc_len);
  __retres = tmp;
  return_label: return __retres;
}

void SMT_Initialise(void);

void SMT_Finalise(void);

int SMT_IsEnabled(void);

double SMT_GetOffset(struct timespec *now);

void SMT_Activate(struct timespec *now);

void SMT_Reset(struct timespec *now);

void SMT_Leap(struct timespec *now, int leap);

int SMT_GetSmoothingReport(RPT_SmoothingReport *report, struct timespec *now);

static double current_freq_ppm;
static double max_freq_ppm;
static double temp_comp_ppm;
static double (*drv_read_freq)(void);
static double (*drv_set_freq)(double freq_ppm);
static void (*drv_accrue_offset)(double offset, double corr_rate);
static int (*drv_apply_step_offset)(double offset);
static void (*drv_offset_convert)(struct timespec *raw, double *corr,
                                  double *err);
static void (*drv_set_leap)(int leap, int tai_offset);
static void (*drv_set_sync_status)(int synchronised, double est_error,
                                   double max_error);
static ChangeListEntry change_list;
static DispersionNotifyListEntry dispersion_notify_list;
static int precision_log;
static double precision_quantum;
static double max_clock_error_0;
static void calculate_sys_precision(void)
{
  struct timespec ts;
  struct timespec old_ts;
  int iters;
  int diff;
  int best;
  LCL_ReadRawTime(& old_ts);
  best = 1000000000;
  iters = 0;
  while (1) {
    LCL_ReadRawTime(& ts);
    diff = (int)((long)1000000000 * (ts.tv_sec - old_ts.tv_sec) + (ts.tv_nsec - old_ts.tv_nsec));
    old_ts = ts;
    if (diff > 0) {
      if (diff < best) best = diff;
      iters ++;
    }
    if (! (iters < 100)) break;
  }
  __FC_assert((best > 0) != 0,"local.c",136,"best > 0");
  precision_quantum = 1.0e-9 * (double)best;
  precision_log = 0;
  while (best < 707106781) {
    precision_log --;
    best *= 2;
  }
  __FC_assert((precision_log >= -30) != 0,"local.c",147,
              "precision_log >= -30");
  return;
}

void LCL_Initialise(void)
{
  double tmp;
  double tmp_1;
  change_list.prev = & change_list;
  change_list.next = change_list.prev;
  dispersion_notify_list.prev = & dispersion_notify_list;
  dispersion_notify_list.next = dispersion_notify_list.prev;
  drv_read_freq = (double (*)(void))0;
  drv_set_freq = (double (*)(double freq_ppm))0;
  drv_accrue_offset = (void (*)(double offset, double corr_rate))0;
  drv_offset_convert = (void (*)(struct timespec *raw, double *corr,
                                 double *err))0;
  current_freq_ppm = 0.0;
  temp_comp_ppm = 0.0;
  calculate_sys_precision();
  max_freq_ppm = CNF_GetMaxDrift();
  if (max_freq_ppm < 500000.0) tmp = max_freq_ppm; else tmp = 500000.0;
  if (0.0 > tmp) max_freq_ppm = 0.0;
  else {
    double tmp_0;
    if (max_freq_ppm < 500000.0) tmp_0 = max_freq_ppm; else tmp_0 = 500000.0;
    max_freq_ppm = tmp_0;
  }
  tmp_1 = CNF_GetMaxClockError();
  max_clock_error_0 = tmp_1 * 1e-6;
  return;
}

void LCL_Finalise(void)
{
  while (change_list.next != & change_list) LCL_RemoveParameterChangeHandler
                                            ((change_list.next)->handler,
                                             (change_list.next)->anything);
  while (dispersion_notify_list.next != & dispersion_notify_list) LCL_RemoveDispersionNotifyHandler
                                                                  ((dispersion_notify_list.next)->handler,
                                                                   (dispersion_notify_list.next)->anything);
  return;
}

int LCL_GetSysPrecisionAsLog(void)
{
  return precision_log;
}

double LCL_GetSysPrecisionAsQuantum(void)
{
  return precision_quantum;
}

double LCL_GetMaxClockError(void)
{
  return max_clock_error_0;
}

void LCL_AddParameterChangeHandler(void (*handler)(struct timespec *raw,
                                                   struct timespec *cooked,
                                                   double dfreq,
                                                   double doffset,
                                                   LCL_ChangeType change_type,
                                                   void *anything),
                                   void *anything)
{
  ChangeListEntry *ptr;
  ChangeListEntry *new_entry;
  ptr = change_list.next;
  while (ptr != & change_list) {
    if (! (ptr->handler != handler)) 
      if (! (ptr->anything != anything)) __FC_assert(0 != 0,"local.c",233,
                                                     "0");
    ptr = ptr->next;
  }
  new_entry = (ChangeListEntry *)Malloc(sizeof(ChangeListEntry));
  new_entry->handler = handler;
  new_entry->anything = anything;
  new_entry->next = & change_list;
  new_entry->prev = change_list.prev;
  (change_list.prev)->next = new_entry;
  change_list.prev = new_entry;
  return;
}

void LCL_RemoveParameterChangeHandler(void (*handler)(struct timespec *raw,
                                                      struct timespec *cooked,
                                                      double dfreq,
                                                      double doffset,
                                                      LCL_ChangeType change_type,
                                                      void *anything),
                                      void *anything)
{
  ChangeListEntry *ptr;
  int ok;
  ptr = (ChangeListEntry *)0;
  ok = 0;
  ptr = change_list.next;
  while (ptr != & change_list) {
    if (ptr->handler == handler) 
      if (ptr->anything == anything) {
        ok = 1;
        break;
      }
    ptr = ptr->next;
  }
  __FC_assert(ok != 0,"local.c",268,"ok");
  (ptr->next)->prev = ptr->prev;
  (ptr->prev)->next = ptr->next;
  free((void *)ptr);
  return;
}

int LCL_IsFirstParameterChangeHandler(void (*handler)(struct timespec *raw,
                                                      struct timespec *cooked,
                                                      double dfreq,
                                                      double doffset,
                                                      LCL_ChangeType change_type,
                                                      void *anything))
{
  int __retres;
  __retres = (change_list.next)->handler == handler;
  return __retres;
}

static void invoke_parameter_change_handlers(struct timespec *raw,
                                             struct timespec *cooked,
                                             double dfreq, double doffset,
                                             LCL_ChangeType change_type)
{
  ChangeListEntry *ptr;
  ptr = change_list.next;
  while (ptr != & change_list) {
    (*(ptr->handler))(raw,cooked,dfreq,doffset,change_type,ptr->anything);
    ptr = ptr->next;
  }
  return;
}

void LCL_AddDispersionNotifyHandler(void (*handler)(double dispersion,
                                                    void *anything),
                                    void *anything)
{
  DispersionNotifyListEntry *ptr;
  DispersionNotifyListEntry *new_entry;
  ptr = dispersion_notify_list.next;
  while (ptr != & dispersion_notify_list) {
    if (! (ptr->handler != handler)) 
      if (! (ptr->anything != anything)) __FC_assert(0 != 0,"local.c",309,
                                                     "0");
    ptr = ptr->next;
  }
  new_entry = (DispersionNotifyListEntry *)Malloc(sizeof(DispersionNotifyListEntry));
  new_entry->handler = handler;
  new_entry->anything = anything;
  new_entry->next = & dispersion_notify_list;
  new_entry->prev = dispersion_notify_list.prev;
  (dispersion_notify_list.prev)->next = new_entry;
  dispersion_notify_list.prev = new_entry;
  return;
}

extern void LCL_RemoveDispersionNotifyHandler(void (*handler)(double dispersion,
                                                              void *anything),
                                              void *anything)
{
  DispersionNotifyListEntry *ptr;
  int ok;
  ptr = (DispersionNotifyListEntry *)0;
  ok = 0;
  ptr = dispersion_notify_list.next;
  while (ptr != & dispersion_notify_list) {
    if (ptr->handler == handler) 
      if (ptr->anything == anything) {
        ok = 1;
        break;
      }
    ptr = ptr->next;
  }
  __FC_assert(ok != 0,"local.c",345,"ok");
  (ptr->next)->prev = ptr->prev;
  (ptr->prev)->next = ptr->next;
  free((void *)ptr);
  return;
}

void LCL_ReadRawTime(struct timespec *ts)
{
  int tmp_0;
  tmp_0 = clock_gettime(666,ts);
  if (tmp_0 < 0) {
    char *tmp;
    tmp = strerror(__fc_errno);
    {
      char *__va_arg0 = tmp;
      void *__va_args[1] = {& __va_arg0};
      LOG_Message(LOGS_FATAL,"clock_gettime() failed : %s",
                  (void * const *)(__va_args));
    }
    exit(1);
  }
  return;
}

void LCL_ReadCookedTime(struct timespec *result, double *err)
{
  struct timespec raw;
  LCL_ReadRawTime(& raw);
  LCL_CookTime(& raw,result,err);
  return;
}

void LCL_CookTime(struct timespec *raw, struct timespec *cooked, double *err)
{
  double correction;
  LCL_GetOffsetCorrection(raw,& correction,err);
  UTI_AddDoubleToTimespec(raw,correction,cooked);
  return;
}

void LCL_GetOffsetCorrection(struct timespec *raw, double *correction,
                             double *err)
{
  (*drv_offset_convert)(raw,correction,err);
  return;
}

double LCL_ReadAbsoluteFrequency(void)
{
  double freq;
  freq = current_freq_ppm;
  if (temp_comp_ppm != 0.0) freq = (freq + temp_comp_ppm) / (1.0 - 1.0e-6 * temp_comp_ppm);
  return freq;
}

static double clamp_freq(double freq)
{
  double __retres;
  double tmp_1;
  double tmp;
  if (freq <= max_freq_ppm) 
    if (freq >= - max_freq_ppm) {
      __retres = freq;
      goto return_label;
    }
  {
    double __va_arg0 = freq;
    void *__va_args[1] = {& __va_arg0};
    LOG_Message(LOGS_WARN,"Frequency %.1f ppm exceeds allowed maximum",
                (void * const *)(__va_args));
  }
  if (freq < max_freq_ppm) tmp = freq; else tmp = max_freq_ppm;
  ;
  if (- max_freq_ppm > tmp) tmp_1 = - max_freq_ppm;
  else {
    double tmp_0;
    if (freq < max_freq_ppm) tmp_0 = freq; else tmp_0 = max_freq_ppm;
    tmp_1 = tmp_0;
  }
  __retres = tmp_1;
  return_label: return __retres;
}

static int check_offset(struct timespec *now, double offset)
{
  int __retres;
  int tmp;
  tmp = UTI_IsTimeOffsetSane(now,- offset);
  if (tmp) {
    __retres = 1;
    goto return_label;
  }
  {
    double __va_arg0 = - offset;
    void *__va_args[1] = {& __va_arg0};
    LOG_Message(LOGS_WARN,"Adjustment of %.1f seconds is invalid",
                (void * const *)(__va_args));
  }
  __retres = 0;
  return_label: return __retres;
}

void LCL_SetAbsoluteFrequency(double afreq_ppm)
{
  struct timespec raw;
  struct timespec cooked;
  double dfreq;
  afreq_ppm = clamp_freq(afreq_ppm);
  if (temp_comp_ppm != 0.0) afreq_ppm = afreq_ppm * (1.0 - 1.0e-6 * temp_comp_ppm) - temp_comp_ppm;
  afreq_ppm = (*drv_set_freq)(afreq_ppm);
  dfreq = (afreq_ppm - current_freq_ppm) / (1.0e6 - current_freq_ppm);
  LCL_ReadRawTime(& raw);
  LCL_CookTime(& raw,& cooked,(double *)0);
  invoke_parameter_change_handlers(& raw,& cooked,dfreq,0.0,LCL_ChangeAdjust);
  current_freq_ppm = afreq_ppm;
  return;
}

void LCL_AccumulateDeltaFrequency(double dfreq)
{
  struct timespec raw;
  struct timespec cooked;
  double old_freq_ppm;
  old_freq_ppm = current_freq_ppm;
  current_freq_ppm += dfreq * (1.0e6 - current_freq_ppm);
  current_freq_ppm = clamp_freq(current_freq_ppm);
  current_freq_ppm = (*drv_set_freq)(current_freq_ppm);
  dfreq = (current_freq_ppm - old_freq_ppm) / (1.0e6 - old_freq_ppm);
  LCL_ReadRawTime(& raw);
  LCL_CookTime(& raw,& cooked,(double *)0);
  invoke_parameter_change_handlers(& raw,& cooked,dfreq,0.0,LCL_ChangeAdjust);
  return;
}

void LCL_AccumulateOffset(double offset, double corr_rate)
{
  struct timespec raw;
  struct timespec cooked;
  int tmp;
  LCL_ReadRawTime(& raw);
  LCL_CookTime(& raw,& cooked,(double *)0);
  tmp = check_offset(& cooked,offset);
  if (! tmp) goto return_label;
  (*drv_accrue_offset)(offset,corr_rate);
  invoke_parameter_change_handlers(& raw,& cooked,0.0,offset,
                                   LCL_ChangeAdjust);
  return_label: return;
}

int LCL_ApplyStepOffset(double offset)
{
  int __retres;
  struct timespec raw;
  struct timespec cooked;
  int tmp;
  int tmp_0;
  LCL_ReadRawTime(& raw);
  LCL_CookTime(& raw,& cooked,(double *)0);
  tmp = check_offset(& raw,offset);
  if (! tmp) {
    __retres = 0;
    goto return_label;
  }
  tmp_0 = (*drv_apply_step_offset)(offset);
  if (! tmp_0) {
    {
      void *__va_args[1] = {(void *)0};
      LOG_Message(LOGS_ERR,"Could not step system clock",
                  (void * const *)(__va_args));
    }
    __retres = 0;
    goto return_label;
  }
  SMT_Reset(& cooked);
  invoke_parameter_change_handlers(& raw,& cooked,0.0,offset,LCL_ChangeStep);
  __retres = 1;
  return_label: return __retres;
}

void LCL_NotifyExternalTimeStep(struct timespec *raw,
                                struct timespec *cooked, double offset,
                                double dispersion)
{
  invoke_parameter_change_handlers(raw,cooked,0.0,offset,
                                   LCL_ChangeUnknownStep);
  lcl_InvokeDispersionNotifyHandlers(dispersion);
  return;
}

void LCL_NotifyLeap(int leap)
{
  struct timespec raw;
  struct timespec cooked;
  LCL_ReadRawTime(& raw);
  LCL_CookTime(& raw,& cooked,(double *)0);
  SMT_Leap(& cooked,leap);
  invoke_parameter_change_handlers(& raw,& cooked,0.0,(double)(- leap),
                                   LCL_ChangeStep);
  return;
}

void LCL_AccumulateFrequencyAndOffset(double dfreq, double doffset,
                                      double corr_rate)
{
  struct timespec raw;
  struct timespec cooked;
  double old_freq_ppm;
  int tmp;
  LCL_ReadRawTime(& raw);
  LCL_CookTime(& raw,& cooked,(double *)0);
  tmp = check_offset(& cooked,doffset);
  if (! tmp) goto return_label;
  old_freq_ppm = current_freq_ppm;
  current_freq_ppm += dfreq * (1.0e6 - current_freq_ppm);
  current_freq_ppm = clamp_freq(current_freq_ppm);
  current_freq_ppm = (*drv_set_freq)(current_freq_ppm);
  dfreq = (current_freq_ppm - old_freq_ppm) / (1.0e6 - old_freq_ppm);
  (*drv_accrue_offset)(doffset,corr_rate);
  invoke_parameter_change_handlers(& raw,& cooked,dfreq,doffset,
                                   LCL_ChangeAdjust);
  return_label: return;
}

void lcl_InvokeDispersionNotifyHandlers(double dispersion)
{
  DispersionNotifyListEntry *ptr;
  ptr = dispersion_notify_list.next;
  while (ptr != & dispersion_notify_list) {
    (*(ptr->handler))(dispersion,ptr->anything);
    ptr = ptr->next;
  }
  return;
}

void lcl_RegisterSystemDrivers(double (*read_freq)(void),
                               double (*set_freq)(double freq_ppm),
                               void (*accrue_offset_0)(double offset,
                                                       double corr_rate),
                               int (*apply_step_offset_0)(double offset),
                               void (*offset_convert_0)(struct timespec *raw,
                                                        double *corr,
                                                        double *err),
                               void (*set_leap)(int leap, int tai_offset),
                               void (*set_sync_status)(int synchronised,
                                                       double est_error,
                                                       double max_error))
{
  drv_read_freq = read_freq;
  drv_set_freq = set_freq;
  drv_accrue_offset = accrue_offset_0;
  drv_apply_step_offset = apply_step_offset_0;
  drv_offset_convert = offset_convert_0;
  drv_set_leap = set_leap;
  drv_set_sync_status = set_sync_status;
  current_freq_ppm = (*drv_read_freq)();
  return;
}

int LCL_MakeStep(void)
{
  int __retres;
  struct timespec raw;
  double correction;
  int tmp;
  int tmp_0;
  LCL_ReadRawTime(& raw);
  LCL_GetOffsetCorrection(& raw,& correction,(double *)0);
  tmp = check_offset(& raw,- correction);
  if (! tmp) {
    __retres = 0;
    goto return_label;
  }
  LCL_AccumulateOffset(correction,0.0);
  tmp_0 = LCL_ApplyStepOffset(- correction);
  if (! tmp_0) {
    __retres = 0;
    goto return_label;
  }
  {
    double __va_arg0 = correction;
    void *__va_args[1] = {& __va_arg0};
    LOG_Message(LOGS_WARN,"System clock was stepped by %.6f seconds",
                (void * const *)(__va_args));
  }
  __retres = 1;
  return_label: return __retres;
}

int LCL_CanSystemLeap(void)
{
  int tmp;
  if (drv_set_leap) tmp = 1; else tmp = 0;
  return tmp;
}

void LCL_SetSystemLeap(int leap, int tai_offset)
{
  if (drv_set_leap) (*drv_set_leap)(leap,tai_offset);
  return;
}

double LCL_SetTempComp(double comp)
{
  double __retres;
  double uncomp_freq_ppm;
  if (temp_comp_ppm == comp) {
    __retres = comp;
    goto return_label;
  }
  current_freq_ppm = (current_freq_ppm + temp_comp_ppm) / (1.0 - 1.0e-6 * temp_comp_ppm);
  uncomp_freq_ppm = current_freq_ppm;
  current_freq_ppm = current_freq_ppm * (1.0 - 1.0e-6 * comp) - comp;
  current_freq_ppm = (*drv_set_freq)(current_freq_ppm);
  temp_comp_ppm = (uncomp_freq_ppm - current_freq_ppm) / (1.0e-6 * uncomp_freq_ppm + 1.0);
  __retres = temp_comp_ppm;
  return_label: return __retres;
}

void LCL_SetSyncStatus(int synchronised, double est_error, double max_error)
{
  if (drv_set_sync_status) (*drv_set_sync_status)(synchronised,est_error,
                                                  max_error);
  return;
}

void *Malloc(size_t size)
{
  void *r;
  r = malloc(size);
  if (! r) 
    if (size) {
      {
        void *__va_args[1] = {(void *)0};
        LOG_Message(LOGS_FATAL,"Could not allocate memory",
                    (void * const *)(__va_args));
      }
      exit(1);
    }
  return r;
}

void *Realloc(void *ptr, size_t size)
{
  void *r;
  r = realloc(ptr,size);
  if (! r) 
    if (size) {
      {
        void *__va_args[1] = {(void *)0};
        LOG_Message(LOGS_FATAL,"Could not allocate memory",
                    (void * const *)(__va_args));
      }
      exit(1);
    }
  return r;
}

static size_t get_array_size(size_t nmemb, size_t size)
{
  size_t array_size;
  array_size = nmemb * size;
  if (nmemb > (size_t)0) 
    if (array_size / nmemb != size) {
      {
        void *__va_args[1] = {(void *)0};
        LOG_Message(LOGS_FATAL,"Could not allocate memory",
                    (void * const *)(__va_args));
      }
      exit(1);
    }
  return array_size;
}

void *Malloc2(size_t nmemb, size_t size)
{
  void *tmp_0;
  size_t tmp;
  tmp = get_array_size(nmemb,size);
  tmp_0 = Malloc(tmp);
  return tmp_0;
}

void *Realloc2(void *ptr, size_t nmemb, size_t size)
{
  void *tmp_0;
  size_t tmp;
  tmp = get_array_size(nmemb,size);
  ;
  tmp_0 = Realloc(ptr,tmp);
  return tmp_0;
}

char *Strdup(char const *s)
{
  char *__retres;
  void *r;
  r = (void *)strdup(s);
  if (! r) {
    {
      void *__va_args[1] = {(void *)0};
      LOG_Message(LOGS_FATAL,"Could not allocate memory",
                  (void * const *)(__va_args));
    }
    exit(1);
  }
  __retres = (char *)r;
  return __retres;
}

static int address_family = 0;
void DNS_SetAddressFamily(int family)
{
  address_family = family;
  return;
}

DNS_Status DNS_Name2IPAddress(char const *name, IPAddr *ip_addrs,
                              int max_addrs)
{
  DNS_Status __retres;
  struct hostent *host;
  int i;
  if (address_family != 0) 
    if (address_family != 1) {
      __retres = DNS_Failure;
      goto return_label;
    }
  if (max_addrs < 16) max_addrs = max_addrs; else max_addrs = 16;
  host = gethostbyname(name);
  if (host == (struct hostent *)0) {
    if (h_errno == 2) {
      __retres = DNS_TryAgain;
      goto return_label;
    }
  }
  else {
    if (host->h_addrtype != 2) {
      __retres = DNS_Failure;
      goto return_label;
    }
    else 
      if (! *(host->h_addr_list + 0)) {
        __retres = DNS_Failure;
        goto return_label;
      }
    i = 0;
    while (1) {
      if (*(host->h_addr_list + i)) {
        if (! (i < max_addrs)) break;
      }
      else break;
      (ip_addrs + i)->family = (uint16_t)1;
      (ip_addrs + i)->addr.in4 = ntohl(*((uint32_t *)*(host->h_addr_list + i)));
      i ++;
    }
    while (i < max_addrs) {
      (ip_addrs + i)->family = (uint16_t)0;
      i ++;
    }
    __retres = DNS_Success;
    goto return_label;
  }
  __retres = DNS_Failure;
  return_label: return __retres;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) 
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int snprintf_va_1(char * restrict s, size_t n, char const * restrict format,
                  char *param0);

int DNS_IPAddress2Name(IPAddr *ip_addr, char *name, int len)
{
  int __retres;
  struct hostent *host;
  uint32_t addr;
  int tmp;
  char *result = (char *)0;
  switch ((int)ip_addr->family) {
    case 1: addr = htonl(ip_addr->addr.in4);
    host = gethostbyaddr((void const *)(& addr),(socklen_t)sizeof(ip_addr),2);
    break;
    default: host = (struct hostent *)0;
  }
  if (host) result = host->h_name;
  if (result == (char *)0) result = UTI_IPToString(ip_addr);
  tmp = snprintf(name,(size_t)len,"%s",result); /* snprintf_va_1 */
  ;
  if (tmp >= len) {
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

void DNS_Reload(void)
{
  res_init();
  return;
}

void NIO_Initialise(int family);

void NIO_Finalise(void);

int NIO_OpenClientSocket(NTP_Remote_Address *remote_addr);

int NIO_OpenServerSocket(NTP_Remote_Address *remote_addr);

void NIO_CloseClientSocket(int sock_fd);

void NIO_CloseServerSocket(int sock_fd);

int NIO_IsServerSocket(int sock_fd);

int NIO_IsServerConnectable(NTP_Remote_Address *remote_addr);

int NIO_SendPacket(NTP_Packet *packet, NTP_Remote_Address *remote_addr,
                   NTP_Local_Address *local_addr, int length, int process_tx);

void SCH_Initialise(void);

void SCH_Finalise(void);

void SCH_AddFileHandler(int fd, int events,
                        void (*handler)(int fd, int event,
                                        SCH_ArbitraryArgument ),
                        SCH_ArbitraryArgument arg);

void SCH_RemoveFileHandler(int fd);

void SCH_SetFileHandlerEvent(int fd, int event, int enable);

void SCH_GetLastEventTime(struct timespec *cooked, double *err,
                          struct timespec *raw);

SCH_TimeoutID SCH_AddTimeout(struct timespec *ts,
                             void (*handler)(SCH_ArbitraryArgument ),
                             SCH_ArbitraryArgument arg);

SCH_TimeoutID SCH_AddTimeoutByDelay(double delay,
                                    void (*handler)(SCH_ArbitraryArgument ),
                                    SCH_ArbitraryArgument arg);

SCH_TimeoutID SCH_AddTimeoutInClass(double min_delay, double separation,
                                    double randomness,
                                    SCH_TimeoutClass class,
                                    void (*handler)(SCH_ArbitraryArgument ),
                                    SCH_ArbitraryArgument arg);

void SCH_RemoveTimeout(SCH_TimeoutID id);

void SCH_MainLoop(void);

void SCH_QuitProgram(void);

static ARR_Instance recv_messages;
static ARR_Instance recv_headers;
static int server_sock_fd4;
static int client_sock_fd4;
static int server_sock_ref4;
static int separate_client_sockets;
static int permanent_server_sockets;
static int initialised = 0;
static void read_from_socket(int sock_fd, int event, void *anything);

static int prepare_socket(int family, int port_number, int client_only)
{
  int __retres;
  union sockaddr_in46 my_addr;
  socklen_t my_addr_len;
  int sock_fd;
  IPAddr bind_address;
  int tmp_8;
  int events = 1;
  int on_off = 1;
  sock_fd = socket(family,2,0);
  if (sock_fd < 0) {
    if (! client_only) {
      char *tmp;
      char const *tmp_0;
      tmp = strerror(__fc_errno);
      tmp_0 = UTI_SockaddrFamilyToString(family);
      {
        char const *__va_arg0 = tmp_0;
        char *__va_arg1 = tmp;
        void *__va_args[2] = {& __va_arg0, & __va_arg1};
        LOG_Message(LOGS_ERR,"Could not open %s NTP socket : %s",
                    (void * const *)(__va_args));
      }
    }
    __retres = -1;
    goto return_label;
  }
  UTI_FdSetCloexec(sock_fd);
  if (! client_only) {
    int tmp_4;
    tmp_4 = fcntl(sock_fd,4,0x800); /* __va_fcntl_int */
    if (tmp_4) ;
  }
  memset((void *)(& my_addr),0,sizeof(my_addr));
  my_addr_len = (socklen_t)0;
  switch (family) {
    case 2:
    if (! client_only) CNF_GetBindAddress(1,& bind_address);
    else CNF_GetBindAcquisitionAddress(1,& bind_address);
    if ((int)bind_address.family == 1) my_addr.in4.sin_addr.s_addr = htonl
                                       (bind_address.addr.in4);
    else 
      if (port_number) my_addr.in4.sin_addr.s_addr = htonl((uint32_t)0);
      else break;
    my_addr.in4.sin_family = (sa_family_t)family;
    my_addr.in4.sin_port = htons((uint16_t)port_number);
    my_addr_len = (socklen_t)sizeof(my_addr.in4);
    break;
    default: __FC_assert(0 != 0,"ntp_io.c",194,"0");
  }
  if (port_number) {
    int tmp_5;
    tmp_5 = setsockopt(sock_fd,1,2,(void const *)(& on_off),
                       (socklen_t)sizeof(on_off));
    if (tmp_5 < 0) {
      {
        char const *__va_arg0_25 = "SO_REUSEADDR";
        void *__va_args_27[1] = {& __va_arg0_25};
        LOG_Message(LOGS_ERR,"Could not set %s socket option",
                    (void * const *)(__va_args_27));
      }
    }
  }
  if (! client_only) {
    int tmp_6;
    tmp_6 = setsockopt(sock_fd,1,6,(void const *)(& on_off),
                       (socklen_t)sizeof(on_off));
    if (tmp_6 < 0) {
      {
        char const *__va_arg0_29 = "SO_BROADCAST";
        void *__va_args_31[1] = {& __va_arg0_29};
        LOG_Message(LOGS_ERR,"Could not set %s socket option",
                    (void * const *)(__va_args_31));
      }
    }
  }
  tmp_8 = setsockopt(sock_fd,1,35,(void const *)(& on_off),
                     (socklen_t)sizeof(on_off));
  if (tmp_8 < 0) {
    int tmp_7;
    tmp_7 = setsockopt(sock_fd,1,29,(void const *)(& on_off),
                       (socklen_t)sizeof(on_off));
    if (tmp_7 < 0) {
      {
        char const *__va_arg0_33 = "SO_TIMESTAMP";
        void *__va_args_35[1] = {& __va_arg0_33};
        LOG_Message(LOGS_ERR,"Could not set %s socket option",
                    (void * const *)(__va_args_35));
      }
    }
  }
  if (my_addr_len > (socklen_t)0) {
    int tmp_9;
    tmp_9 = setsockopt(sock_fd,IPPROTO_IP,15,(void const *)(& on_off),
                       (socklen_t)sizeof(on_off));
    if (tmp_9 < 0) {
      {
        char const *__va_arg0_37 = "IP_FREEBIND";
        void *__va_args_39[1] = {& __va_arg0_37};
        LOG_Message(LOGS_ERR,"Could not set %s socket option",
                    (void * const *)(__va_args_39));
      }
    }
  }
  if (family == 2) ;
  if (my_addr_len > (socklen_t)0) {
    int tmp_12;
    tmp_12 = bind(sock_fd,(struct sockaddr const *)(& my_addr.u),my_addr_len);
    if (tmp_12 < 0) {
      char *tmp_10;
      char const *tmp_11;
      tmp_10 = strerror(__fc_errno);
      tmp_11 = UTI_SockaddrFamilyToString(family);
      {
        char const *__va_arg0_41 = tmp_11;
        char *__va_arg1_43 = tmp_10;
        void *__va_args_45[2] = {& __va_arg0_41, & __va_arg1_43};
        LOG_Message(LOGS_ERR,"Could not bind %s NTP socket : %s",
                    (void * const *)(__va_args_45));
      }
      close(sock_fd);
      __retres = -1;
      goto return_label;
    }
  }
  SCH_AddFileHandler(sock_fd,events,& read_from_socket,(void *)0);
  __retres = sock_fd;
  return_label: return __retres;
}

static int prepare_separate_client_socket(int family)
{
  int __retres;
  switch (family) {
    int tmp;
    case 1: tmp = prepare_socket(2,0,1);
    __retres = tmp;
    goto return_label;
    default: __retres = -1;
    goto return_label;
  }
  return_label: return __retres;
}

static int connect_socket(int sock_fd, NTP_Remote_Address *remote_addr)
{
  int __retres;
  union sockaddr_in46 addr;
  socklen_t addr_len;
  int tmp;
  int tmp_2;
  tmp = UTI_IPAndPortToSockaddr(& remote_addr->ip_addr,remote_addr->port,
                                & addr.u);
  addr_len = (socklen_t)tmp;
  __FC_assert(addr_len != (socklen_t)0,"ntp_io.c",305,"addr_len");
  tmp_2 = connect(sock_fd,(struct sockaddr const *)(& addr.u),addr_len);
  if (tmp_2 < 0) {
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static void close_socket(int sock_fd)
{
  if (sock_fd == -1) goto return_label;
  SCH_RemoveFileHandler(sock_fd);
  close(sock_fd);
  return_label: return;
}

static void prepare_buffers(unsigned int n)
{
  struct MessageHeader *hdr;
  struct Message *msg;
  unsigned int i;
  i = (unsigned int)0;
  while (i < n) {
    msg = (struct Message *)ARR_GetElement(recv_messages,i);
    hdr = (struct MessageHeader *)ARR_GetElement(recv_headers,i);
    msg->iov.iov_base = (void *)(& msg->buf);
    msg->iov.iov_len = sizeof(msg->buf);
    hdr->msg_hdr.msg_name = (void *)(& msg->name);
    hdr->msg_hdr.msg_namelen = (socklen_t)sizeof(msg->name);
    hdr->msg_hdr.msg_iov = & msg->iov;
    hdr->msg_hdr.msg_iovlen = 1;
    hdr->msg_hdr.msg_control = (void *)(& msg->cmsgbuf);
    hdr->msg_hdr.msg_controllen = (socklen_t)sizeof(msg->cmsgbuf);
    hdr->msg_hdr.msg_flags = 0;
    hdr->msg_len = (unsigned int)0;
    i ++;
  }
  return;
}

void NIO_Initialise(int family)
{
  int server_port;
  int client_port;
  int tmp_0;
  __FC_assert(! initialised != 0,"ntp_io.c",365,"!initialised");
  initialised = 1;
  {
    CNF_HwTsInterface *conf_iface;
    int tmp;
    tmp = CNF_GetHwTsInterface((unsigned int)0,& conf_iface);
    if (tmp) {
      {
        void *__va_args[1] = {(void *)0};
        LOG_Message(LOGS_FATAL,"HW timestamping not supported",
                    (void * const *)(__va_args));
      }
      exit(1);
    }
  }
  recv_messages = ARR_CreateInstance((unsigned int)sizeof(struct Message));
  ARR_SetSize(recv_messages,(unsigned int)1);
  recv_headers = ARR_CreateInstance((unsigned int)sizeof(struct MessageHeader));
  ARR_SetSize(recv_headers,(unsigned int)1);
  prepare_buffers((unsigned int)1);
  server_port = CNF_GetNTPPort();
  client_port = CNF_GetAcquisitionPort();
  separate_client_sockets = client_port < 0;
  if (client_port < 0) client_port = 0;
  if (! server_port) tmp_0 = 1;
  else 
    if (! separate_client_sockets) 
      if (client_port == server_port) tmp_0 = 1; else tmp_0 = 0;
    else tmp_0 = 0;
  permanent_server_sockets = tmp_0;
  server_sock_fd4 = -1;
  client_sock_fd4 = -1;
  server_sock_ref4 = 0;
  if (family == 0) goto _LOR;
  else 
    if (family == 1) {
      _LOR:
      {
        if (permanent_server_sockets) 
          if (server_port) server_sock_fd4 = prepare_socket(2,server_port,0);
        if (! separate_client_sockets) 
          if (client_port != server_port) client_sock_fd4 = prepare_socket
                                          (2,client_port,1);
          else 
            if (! server_port) client_sock_fd4 = prepare_socket(2,
                                                                client_port,
                                                                1);
            else client_sock_fd4 = server_sock_fd4;
      }
    }
  if (server_port) {
    if (server_sock_fd4 == -1) {
      if (permanent_server_sockets) goto _LOR_0; else goto _LAND_0;
    }
    else goto _LAND_0;
  }
  else 
    _LAND_0:
    if (! separate_client_sockets) 
      if (client_sock_fd4 == -1) {
        _LOR_0:
        {
          {
            void *__va_args_9[1] = {(void *)0};
            LOG_Message(LOGS_FATAL,"Could not open NTP sockets",
                        (void * const *)(__va_args_9));
          }
          exit(1);
        }
      }
  return;
}

void NIO_Finalise(void)
{
  if (server_sock_fd4 != client_sock_fd4) close_socket(client_sock_fd4);
  close_socket(server_sock_fd4);
  client_sock_fd4 = -1;
  server_sock_fd4 = client_sock_fd4;
  ARR_DestroyInstance(recv_headers);
  ARR_DestroyInstance(recv_messages);
  initialised = 0;
  return;
}

int NIO_OpenClientSocket(NTP_Remote_Address *remote_addr)
{
  int __retres;
  if (separate_client_sockets) {
    int tmp_0;
    int sock_fd =
      prepare_separate_client_socket((int)remote_addr->ip_addr.family);
    if (sock_fd == -1) {
      __retres = -1;
      goto return_label;
    }
    tmp_0 = connect_socket(sock_fd,remote_addr);
    if (! tmp_0) {
      close_socket(sock_fd);
      __retres = -1;
      goto return_label;
    }
    __retres = sock_fd;
    goto return_label;
  }
  else 
    switch ((int)remote_addr->ip_addr.family) {
      case 1: ;
      __retres = client_sock_fd4;
      goto return_label;
      default: __retres = -1;
      goto return_label;
    }
  return_label: return __retres;
}

int NIO_OpenServerSocket(NTP_Remote_Address *remote_addr)
{
  int __retres;
  switch ((int)remote_addr->ip_addr.family) {
    case 1: ;
    if (permanent_server_sockets) {
      __retres = server_sock_fd4;
      goto return_label;
    }
    if (server_sock_fd4 == -1) {
      int tmp;
      tmp = CNF_GetNTPPort();
      server_sock_fd4 = prepare_socket(2,tmp,0);
    }
    if (server_sock_fd4 != -1) server_sock_ref4 ++;
    __retres = server_sock_fd4;
    goto return_label;
    default: __retres = -1;
    goto return_label;
  }
  return_label: return __retres;
}

void NIO_CloseClientSocket(int sock_fd)
{
  if (separate_client_sockets) close_socket(sock_fd);
  return;
}

void NIO_CloseServerSocket(int sock_fd)
{
  if (permanent_server_sockets) goto return_label;
  else 
    if (sock_fd == -1) goto return_label;
  if (sock_fd == server_sock_fd4) {
    server_sock_ref4 --;
    if (server_sock_ref4 <= 0) {
      close_socket(server_sock_fd4);
      server_sock_fd4 = -1;
    }
  }
  else __FC_assert(0 != 0,"ntp_io.c",558,"0");
  return_label: return;
}

int NIO_IsServerSocket(int sock_fd)
{
  int tmp;
  if (sock_fd != -1) 
    if (sock_fd == server_sock_fd4) tmp = 1; else tmp = 0;
  else tmp = 0;
  return tmp;
}

int NIO_IsServerConnectable(NTP_Remote_Address *remote_addr)
{
  int __retres;
  int sock_fd;
  int r;
  sock_fd = prepare_separate_client_socket((int)remote_addr->ip_addr.family);
  if (sock_fd == -1) {
    __retres = 0;
    goto return_label;
  }
  r = connect_socket(sock_fd,remote_addr);
  close_socket(sock_fd);
  __retres = r;
  return_label: return __retres;
}

static void process_message(struct msghdr *hdr, int length, int sock_fd)
{
  NTP_Remote_Address remote_addr;
  NTP_Local_Address local_addr;
  NTP_Local_Timestamp local_ts;
  struct timespec sched_ts;
  struct cmsghdr *cmsg;
  SCH_GetLastEventTime(& local_ts.ts,& local_ts.err,(struct timespec *)0);
  local_ts.source = NTP_TS_DAEMON;
  sched_ts = local_ts.ts;
  if ((unsigned long)hdr->msg_namelen > sizeof(union sockaddr_in46)) 
    goto return_label;
  if ((unsigned long)hdr->msg_namelen >= sizeof(((struct sockaddr *)hdr->msg_name)->sa_family)) 
    UTI_SockaddrToIPAndPort((struct sockaddr *)hdr->msg_name,
                            & remote_addr.ip_addr,& remote_addr.port);
  else {
    remote_addr.ip_addr.family = (uint16_t)0;
    remote_addr.port = (unsigned short)0;
  }
  local_addr.ip_addr.family = (uint16_t)0;
  local_addr.if_index = -1;
  local_addr.sock_fd = sock_fd;
  if (hdr->msg_flags & 0x20) goto return_label;
  if (hdr->msg_flags & 0x8) ;
  cmsg = CMSG_FIRSTHDR(hdr);
  while (cmsg) {
    if (cmsg->cmsg_level == 1) 
      if (cmsg->cmsg_type == 29) {
        struct timeval tv;
        struct timespec ts;
        memcpy((void *)(& tv),(void const *)(cmsg + 1),sizeof(tv));
        UTI_TimevalToTimespec(& tv,& ts);
        LCL_CookTime(& ts,& local_ts.ts,& local_ts.err);
        local_ts.source = NTP_TS_KERNEL;
      }
    if (cmsg->cmsg_level == 1) 
      if (cmsg->cmsg_type == 35) {
        struct timespec ts_0;
        memcpy((void *)(& ts_0),(void const *)(cmsg + 1),sizeof(ts_0));
        LCL_CookTime(& ts_0,& local_ts.ts,& local_ts.err);
        local_ts.source = NTP_TS_KERNEL;
      }
    cmsg = CMSG_NXTHDR(hdr,cmsg);
  }
  if (length < 48) goto return_label;
  else 
    if ((unsigned long)length > sizeof(NTP_Receive_Buffer)) goto return_label;
  NSR_ProcessRx(& remote_addr,& local_addr,& local_ts,
                (NTP_Packet *)(hdr->msg_iov + 0)->iov_base,length);
  return_label: return;
}

static void read_from_socket(int sock_fd, int event, void *anything)
{
  struct MessageHeader *hdr;
  unsigned int i;
  unsigned int n;
  int status;
  ssize_t tmp;
  int flags = 0;
  hdr = (struct MessageHeader *)ARR_GetElements(recv_headers);
  n = ARR_GetSize(recv_headers);
  __FC_assert((n >= (unsigned int)1) != 0,"ntp_io.c",727,"n >= 1");
  if (event == 4) __FC_assert(0 != 0,"ntp_io.c",733,"0");
  n = (unsigned int)1;
  tmp = recvmsg(sock_fd,& (hdr + 0)->msg_hdr,flags);
  status = (int)tmp;
  if (status >= 0) (hdr + 0)->msg_len = (unsigned int)status;
  if (status < 0) goto return_label;
  i = (unsigned int)0;
  while (i < n) {
    hdr = (struct MessageHeader *)ARR_GetElement(recv_headers,i);
    process_message(& hdr->msg_hdr,(int)hdr->msg_len,sock_fd);
    i ++;
  }
  prepare_buffers(n);
  return_label: return;
}

int NIO_SendPacket(NTP_Packet *packet, NTP_Remote_Address *remote_addr,
                   NTP_Local_Address *local_addr, int length, int process_tx)
{
  int __retres;
  union sockaddr_in46 remote;
  struct msghdr msg;
  struct iovec iov;
  struct cmsghdr *cmsg;
  struct cmsghdr cmsgbuf[(unsigned long)256 / sizeof(struct cmsghdr)];
  int cmsglen;
  int tmp_1;
  ssize_t tmp_5;
  socklen_t addrlen = (socklen_t)0;
  __FC_assert(initialised != 0,"ntp_io.c",791,"initialised");
  if (local_addr->sock_fd == -1) {
    __retres = 0;
    goto return_label;
  }
  tmp_1 = NIO_IsServerSocket(local_addr->sock_fd);
  if (tmp_1) goto _LOR;
  else 
    if (! separate_client_sockets) {
      _LOR:
      {
        int tmp_0;
        tmp_0 = UTI_IPAndPortToSockaddr(& remote_addr->ip_addr,
                                        remote_addr->port,& remote.u);
        addrlen = (socklen_t)tmp_0;
        if (! addrlen) {
          __retres = 0;
          goto return_label;
        }
      }
    }
  if (addrlen) {
    msg.msg_name = (void *)(& remote.u);
    msg.msg_namelen = addrlen;
  }
  else {
    msg.msg_name = (void *)0;
    msg.msg_namelen = (socklen_t)0;
  }
  iov.iov_base = (void *)packet;
  iov.iov_len = (size_t)length;
  msg.msg_iov = & iov;
  msg.msg_iovlen = 1;
  msg.msg_control = (void *)(cmsgbuf);
  msg.msg_controllen = (socklen_t)sizeof(cmsgbuf);
  msg.msg_flags = 0;
  cmsglen = 0;
  if ((int)local_addr->ip_addr.family == 1) ;
  msg.msg_controllen = (socklen_t)cmsglen;
  if (! cmsglen) msg.msg_control = (void *)0;
  tmp_5 = sendmsg(local_addr->sock_fd,(struct msghdr const *)(& msg),0);
  if (tmp_5 < (ssize_t)0) {
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static int are_we_synchronised;
static int enable_local_stratum;
static int local_stratum_0;
static int local_orphan_0;
static double local_distance_0;
static NTP_Leap our_leap_status;
static int our_leap_sec;
static int our_tai_offset;
static int our_stratum;
static uint32_t our_ref_id;
static IPAddr our_ref_ip;
static struct timespec our_ref_time;
static double our_skew;
static double our_residual_freq;
static double our_root_delay;
static double our_root_dispersion;
static double max_update_skew_0;
static double last_offset;
static double avg2_offset;
static int avg2_moving;
static double correction_time_ratio_0;
static int initialised_0 = 0;
static REF_Mode mode;
static int make_step_limit_0;
static double make_step_threshold_0;
static int max_offset_delay_0;
static int max_offset_ignore_0;
static double max_offset_0;
static double log_change_threshold_0;
static int do_mail_change;
static double mail_change_threshold_0;
static char *mail_change_user;
static void (*mode_end_handler)(int result) = (void (*)(int result))0;
static char *drift_file_0 = (char *)0;
static double drift_file_age;
static void update_drift_file(double freq_ppm, double skew);

static REF_LeapMode leap_mode;
static int leap_in_progress;
static SCH_TimeoutID leap_timeout_id;
static char *leap_tzname;
static LOG_FileID logfileid;
static int fb_drift_min_0;
static int fb_drift_max_0;
static struct fb_drift *fb_drifts = (struct fb_drift *)0;
static int next_fb_drift;
static SCH_TimeoutID fb_drift_timeout_id;
static struct timespec last_ref_update;
static double last_ref_update_interval;
static NTP_Leap get_tz_leap(time_t when, int *tai_offset);

static void update_leap_status(NTP_Leap leap, time_t now, int reset);

static void handle_slew(struct timespec *raw, struct timespec *cooked,
                        double dfreq, double doffset,
                        LCL_ChangeType change_type, void *anything)
{
  double delta;
  struct timespec now;
  int tmp;
  tmp = UTI_IsZeroTimespec(& our_ref_time);
  if (! tmp) UTI_AdjustTimespec(& our_ref_time,cooked,& our_ref_time,& delta,
                                dfreq,doffset);
  if (change_type == (unsigned int)LCL_ChangeUnknownStep) UTI_ZeroTimespec
                                                          (& last_ref_update);
  else 
    if (last_ref_update.tv_sec) UTI_AdjustTimespec(& last_ref_update,cooked,
                                                   & last_ref_update,& delta,
                                                   dfreq,doffset);
  if (change_type != (unsigned int)LCL_ChangeAdjust) 
    if (our_leap_sec) 
      if (! leap_in_progress) {
        LCL_ReadRawTime(& now);
        update_leap_status(our_leap_status,now.tv_sec,1);
      }
  return;
}

/*@ requires \valid(param0);
    requires \valid(param1);
    requires valid_read_string(format);
    ensures \initialized(param0);
    ensures \initialized(param1);
    assigns \result, stream->__fc_FILE_data, *param1, *param0;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fscanf_va_1(FILE * restrict stream, char const * restrict format,
                double *param0, double *param1);

void REF_Initialise(void)
{
  FILE *in;
  double file_freq_ppm;
  double file_skew_ppm;
  double our_frequency_ppm;
  int tai_offset;
  int tmp_0;
  double tmp_3;
  double tmp_2;
  mode = REF_ModeNormal;
  are_we_synchronised = 0;
  our_leap_status = LEAP_Unsynchronised;
  our_leap_sec = 0;
  our_tai_offset = 0;
  initialised_0 = 1;
  our_root_dispersion = 1.0;
  our_root_delay = 1.0;
  our_frequency_ppm = 0.0;
  our_skew = 1.0;
  our_residual_freq = 0.0;
  drift_file_age = 0.0;
  drift_file_0 = CNF_GetDriftFile();
  if (drift_file_0) {
    in = fopen((char const *)drift_file_0,"r");
    if (in) {
      int tmp;
      tmp = fscanf(in,"%lf%lf",& file_freq_ppm,& file_skew_ppm); /* fscanf_va_1 */
      if (tmp == 2) {
        our_frequency_ppm = file_freq_ppm;
        our_skew = 1.0e-6 * file_skew_ppm;
        if (our_skew < 1.0e-12) our_skew = 1.0e-12;
        {
          double __va_arg0 = file_freq_ppm;
          double __va_arg1 = file_skew_ppm;
          char *__va_arg2 = drift_file_0;
          void *__va_args[3] = {& __va_arg0, & __va_arg1, & __va_arg2};
          LOG_Message(LOGS_INFO,"Frequency %.3f +/- %.3f ppm read from %s",
                      (void * const *)(__va_args));
        }
        LCL_SetAbsoluteFrequency(our_frequency_ppm);
      }
      else {
        {
          char *__va_arg0_20 = drift_file_0;
          void *__va_args_22[1] = {& __va_arg0_20};
          LOG_Message(LOGS_WARN,
                      "Could not read valid frequency and skew from driftfile %s",
                      (void * const *)(__va_args_22));
        }
      }
      fclose(in);
    }
  }
  if (our_frequency_ppm == 0.0) {
    our_frequency_ppm = LCL_ReadAbsoluteFrequency();
    if (our_frequency_ppm != 0.0) {
      {
        double __va_arg0_24 = our_frequency_ppm;
        void *__va_args_26[1] = {& __va_arg0_24};
        LOG_Message(LOGS_INFO,"Initial frequency %.3f ppm",
                    (void * const *)(__va_args_26));
      }
    }
  }
  tmp_0 = CNF_GetLogTracking();
  if (tmp_0) logfileid = LOG_FileOpen("tracking",
                                      "   Date (UTC) Time     IP Address   St   Freq ppm   Skew ppm     Offset L Co  Offset sd Rem. corr. Root delay Root disp. Max. error");
  else logfileid = -1;
  tmp_2 = CNF_GetMaxUpdateSkew();
  tmp_3 = fabs(tmp_2);
  max_update_skew_0 = tmp_3 * 1.0e-6;
  correction_time_ratio_0 = CNF_GetCorrectionTimeRatio();
  enable_local_stratum = CNF_AllowLocalReference(& local_stratum_0,
                                                 & local_orphan_0,
                                                 & local_distance_0);
  leap_timeout_id = (SCH_TimeoutID)0;
  leap_in_progress = 0;
  leap_mode = CNF_GetLeapSecMode();
  if (leap_mode == (unsigned int)REF_LeapModeSystem) {
    int tmp_4;
    tmp_4 = LCL_CanSystemLeap();
    if (! tmp_4) leap_mode = REF_LeapModeStep;
  }
  leap_tzname = CNF_GetLeapSecTimezone();
  if (leap_tzname) {
    NTP_Leap tmp_5;
    tmp_5 = get_tz_leap((time_t)1341014400,& tai_offset);
    if (tmp_5 == (unsigned int)LEAP_InsertSecond) {
      if (tai_offset == 34) {
        NTP_Leap tmp_6;
        tmp_6 = get_tz_leap((time_t)1356912000,& tai_offset);
        if (tmp_6 == (unsigned int)LEAP_Normal) {
          if (tai_offset == 35) {
            {
              char *__va_arg0_28 = leap_tzname;
              void *__va_args_30[1] = {& __va_arg0_28};
              LOG_Message(LOGS_INFO,
                          "Using %s timezone to obtain leap second data",
                          (void * const *)(__va_args_30));
            }
          }
          else goto _LAND_1;
        }
        else goto _LAND_1;
      }
      else goto _LAND_1;
    }
    else {
      _LAND_1:
      {
        {
          char *__va_arg0_32 = leap_tzname;
          void *__va_args_34[1] = {& __va_arg0_32};
          LOG_Message(LOGS_WARN,
                      "Timezone %s failed leap second check, ignoring",
                      (void * const *)(__va_args_34));
        }
        leap_tzname = (char *)0;
      }
    }
  }
  CNF_GetMakeStep(& make_step_limit_0,& make_step_threshold_0);
  CNF_GetMaxChange(& max_offset_delay_0,& max_offset_ignore_0,& max_offset_0);
  CNF_GetMailOnChange(& do_mail_change,& mail_change_threshold_0,
                      & mail_change_user);
  log_change_threshold_0 = CNF_GetLogChange();
  CNF_GetFallbackDrifts(& fb_drift_min_0,& fb_drift_max_0);
  if (fb_drift_max_0 >= fb_drift_min_0) 
    if (fb_drift_min_0 > 0) {
      fb_drifts = (struct fb_drift *)Malloc2((size_t)((fb_drift_max_0 - fb_drift_min_0) + 1),
                                             sizeof(struct fb_drift));
      memset((void *)fb_drifts,0,
             sizeof(struct fb_drift) * (unsigned long)((fb_drift_max_0 - fb_drift_min_0) + 1));
      next_fb_drift = 0;
      fb_drift_timeout_id = (SCH_TimeoutID)0;
    }
  UTI_ZeroTimespec(& our_ref_time);
  UTI_ZeroTimespec(& last_ref_update);
  last_ref_update_interval = 0.0;
  LCL_AddParameterChangeHandler(& handle_slew,(void *)0);
  REF_SetUnsynchronised();
  return;
}

void REF_Finalise(void)
{
  update_leap_status(LEAP_Unsynchronised,(time_t)0,0);
  if (drift_file_0) {
    double tmp;
    ;
    tmp = LCL_ReadAbsoluteFrequency();
    update_drift_file(tmp,our_skew);
  }
  free((void *)fb_drifts);
  initialised_0 = 0;
  return;
}

void REF_SetMode(REF_Mode new_mode)
{
  mode = new_mode;
  return;
}

REF_Mode REF_GetMode(void)
{
  return mode;
}

void REF_SetModeEndHandler(void (*handler)(int result))
{
  mode_end_handler = handler;
  return;
}

REF_LeapMode REF_GetLeapMode(void)
{
  return leap_mode;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param1, param0;
 */
int fprintf_va_2(FILE * restrict stream, char const * restrict format,
                 double param0, double param1);

static void update_drift_file(double freq_ppm, double skew)
{
  struct stat buf;
  char *temp_drift_file;
  FILE *out;
  int r1;
  int r2;
  void *tmp_0;
  size_t tmp;
  int tmp_3;
  int tmp_4;
  tmp = strlen((char const *)drift_file_0);
  tmp_0 = Malloc(tmp + (size_t)8);
  temp_drift_file = (char *)tmp_0;
  if (! temp_drift_file) goto return_label;
  strcpy(temp_drift_file,(char const *)drift_file_0);
  strcat(temp_drift_file,".tmp");
  out = fopen((char const *)temp_drift_file,"w");
  if (! out) {
    free((void *)temp_drift_file);
    {
      char *__va_arg0 = drift_file_0;
      void *__va_args[1] = {& __va_arg0};
      LOG_Message(LOGS_WARN,
                  "Could not open temporary driftfile %s.tmp for writing",
                  (void * const *)(__va_args));
    }
    goto return_label;
  }
  r1 = fprintf(out,"%20.6f %20.6f\n",freq_ppm,1.0e6 * skew); /* fprintf_va_2 */
  r2 = fclose(out);
  if (r1 < 0) goto _LOR;
  else 
    if (r2) {
      _LOR:
      {
        free((void *)temp_drift_file);
        {
          char *__va_arg0_17 = drift_file_0;
          void *__va_args_19[1] = {& __va_arg0_17};
          LOG_Message(LOGS_WARN,
                      "Could not write to temporary driftfile %s.tmp",
                      (void * const *)(__va_args_19));
        }
        goto return_label;
      }
    }
  tmp_3 = stat((char const *)drift_file_0,& buf);
  if (! tmp_3) {
    int tmp_1;
    tmp_1 = chown((char const *)temp_drift_file,buf.st_uid,buf.st_gid);
    if (tmp_1) goto _LOR_0;
    else {
      int tmp_2;
      tmp_2 = chmod((char const *)temp_drift_file,
                    buf.st_mode & (unsigned int)0777);
      if (tmp_2) {
        _LOR_0:
        {
          char *__va_arg0_21 = drift_file_0;
          void *__va_args_23[1] = {& __va_arg0_21};
          LOG_Message(LOGS_WARN,
                      "Could not change ownership or permissions of temporary driftfile %s.tmp",
                      (void * const *)(__va_args_23));
        }
      }
    }
  }
  tmp_4 = rename((char const *)temp_drift_file,(char const *)drift_file_0);
  if (tmp_4) {
    unlink((char const *)temp_drift_file);
    free((void *)temp_drift_file);
    {
      char *__va_arg0_25 = drift_file_0;
      char *__va_arg1 = drift_file_0;
      void *__va_args_28[2] = {& __va_arg0_25, & __va_arg1};
      LOG_Message(LOGS_WARN,
                  "Could not replace old driftfile %s with new one %s.tmp",
                  (void * const *)(__va_args_28));
    }
    goto return_label;
  }
  free((void *)temp_drift_file);
  return_label: return;
}

static void update_fb_drifts(double freq_ppm, double update_interval)
{
  int i;
  int secs;
  __FC_assert(are_we_synchronised != 0,"reference.c",398,
              "are_we_synchronised");
  if (next_fb_drift > 0) next_fb_drift = 0;
  SCH_RemoveTimeout(fb_drift_timeout_id);
  fb_drift_timeout_id = (SCH_TimeoutID)0;
  if (update_interval < 1.0) goto return_label;
  else 
    if (update_interval > last_ref_update_interval * 4.0) goto return_label;
  i = 0;
  while (i < (fb_drift_max_0 - fb_drift_min_0) + 1) {
    secs = 1 << (i + fb_drift_min_0);
    if ((fb_drifts + i)->secs < (double)secs) {
      (fb_drifts + i)->freq = ((fb_drifts + i)->freq * (fb_drifts + i)->secs + 
                               (update_interval * 0.5) * freq_ppm) / (
                              update_interval * 0.5 + (fb_drifts + i)->secs);
      (fb_drifts + i)->secs += update_interval * 0.5;
    }
    else {
      double tmp;
      tmp = exp(update_interval / (double)secs);
      (fb_drifts + i)->freq += ((double)1 - 1.0 / tmp) * (freq_ppm - (
                                                          fb_drifts + i)->freq);
    }
    i ++;
  }
  return_label: return;
}

static void fb_drift_timeout(void *arg)
{
  int tmp;
  if (next_fb_drift >= fb_drift_min_0) 
    if (next_fb_drift <= fb_drift_max_0) tmp = 1; else tmp = 0;
  else tmp = 0;
  __FC_assert(tmp != 0,"reference.c",441,
              "next_fb_drift >= fb_drift_min && next_fb_drift <= fb_drift_max");
  fb_drift_timeout_id = (SCH_TimeoutID)0;
  LCL_SetAbsoluteFrequency((fb_drifts + (next_fb_drift - fb_drift_min_0))->freq);
  REF_SetUnsynchronised();
  return;
}

static void schedule_fb_drift(struct timespec *now)
{
  int i;
  int c;
  int secs;
  double unsynchronised;
  struct timespec when;
  if (fb_drift_timeout_id) goto return_label;
  unsynchronised = UTI_DiffTimespecsToDouble(now,& last_ref_update);
  secs = 0;
  c = secs;
  i = fb_drift_min_0;
  while (i <= fb_drift_max_0) {
    secs = 1 << i;
    if ((fb_drifts + (i - fb_drift_min_0))->secs < (double)secs) goto __Cont;
    if (unsynchronised < (double)secs) 
      if (i > next_fb_drift) break;
    c = i;
    __Cont: i ++;
  }
  if (c > next_fb_drift) {
    LCL_SetAbsoluteFrequency((fb_drifts + (c - fb_drift_min_0))->freq);
    next_fb_drift = c;
  }
  if (i <= fb_drift_max_0) {
    next_fb_drift = i;
    UTI_AddDoubleToTimespec(now,(double)secs - unsynchronised,& when);
    fb_drift_timeout_id = SCH_AddTimeout(& when,& fb_drift_timeout,(void *)0);
  }
  return_label: return;
}

static void end_ref_mode(int result)
{
  mode = REF_ModeIgnore;
  if (mode_end_handler) (*mode_end_handler)(result);
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) 
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int snprintf_va_2(char * restrict s, size_t n, char const * restrict format,
                  char *param0);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_3(FILE * restrict stream, char const * restrict format,
                 char *param0);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_4(FILE * restrict stream, char const * restrict format,
                 char *param0);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param1, param0;
 */
int fprintf_va_5(FILE * restrict stream, char const * restrict format,
                 double param0, double param1);

static void maybe_log_offset(double offset, time_t now)
{
  double abs_offset;
  FILE *p;
  char buffer[255];
  char host[255];
  struct tm *tm;
  abs_offset = fabs(offset);
  if (abs_offset > log_change_threshold_0) {
    {
      double __va_arg0 = - offset;
      void *__va_args[1] = {& __va_arg0};
      LOG_Message(LOGS_WARN,
                  "System clock wrong by %.6f seconds, adjustment started",
                  (void * const *)(__va_args));
    }
  }
  if (do_mail_change) 
    if (abs_offset > mail_change_threshold_0) {
      snprintf(buffer,sizeof(buffer),"%s -t",(char *)"/usr/lib/sendmail"); /* snprintf_va_2 */
      p = popen((char const *)(buffer),"w");
      if (p) {
        int tmp;
        tmp = gethostname(host,sizeof(host));
        if (tmp < 0) strcpy(host,"<UNKNOWN>");
        host[sizeof(host) - (unsigned long)1] = (char)'\000';
        fprintf(p,"To: %s\n",mail_change_user); /* fprintf_va_3 */
        fprintf(p,
                "Subject: chronyd reports change to system clock on node [%s]\n",
                host); /* fprintf_va_4 */
        fputs("\n",p);
        tm = localtime((time_t const *)(& now));
        if (tm) {
          strftime(buffer,sizeof(buffer),
                   "On %A, %d %B %Y\n  with the system clock reading %H:%M:%S (%Z)",
                   (struct tm const *)tm);
          fputs((char const *)(buffer),p);
        }
        fprintf(p,
                "\n\nchronyd started to apply an adjustment of %.3f seconds to it,\n  which exceeded the reporting threshold of %.3f seconds\n\n",
                - offset,mail_change_threshold_0); /* fprintf_va_5 */
        pclose(p);
      }
      else {
        {
          char *__va_arg0_12 = mail_change_user;
          void *__va_args_14[1] = {& __va_arg0_12};
          LOG_Message(LOGS_ERR,
                      "Could not send mail notification to user %s\n",
                      (void * const *)(__va_args_14));
        }
      }
    }
  return;
}

static int is_step_limit_reached(double offset, double offset_correction)
{
  int __retres;
  double tmp;
  if (make_step_limit_0 == 0) {
    __retres = 0;
    goto return_label;
  }
  else 
    if (make_step_limit_0 > 0) make_step_limit_0 --;
  tmp = fabs(offset - offset_correction);
  ;
  __retres = tmp > make_step_threshold_0;
  return_label: return __retres;
}

static int is_offset_ok(double offset)
{
  int __retres;
  if (max_offset_delay_0 < 0) {
    __retres = 1;
    goto return_label;
  }
  if (max_offset_delay_0 > 0) {
    max_offset_delay_0 --;
    __retres = 1;
    goto return_label;
  }
  offset = fabs(offset);
  if (offset > max_offset_0) {
    char const *tmp;
    if (! max_offset_ignore_0) tmp = "exiting"; else tmp = "ignored";
    ;
    ;
    {
      double __va_arg0 = - offset;
      double __va_arg1 = max_offset_0;
      char const *__va_arg2 = tmp;
      void *__va_args[3] = {& __va_arg0, & __va_arg1, & __va_arg2};
      LOG_Message(LOGS_WARN,
                  "Adjustment of %.3f seconds exceeds the allowed maximum of %.3f seconds (%s) ",
                  (void * const *)(__va_args));
    }
    if (! max_offset_ignore_0) end_ref_mode(0);
    else 
      if (max_offset_ignore_0 > 0) max_offset_ignore_0 --;
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static int is_leap_second_day(time_t when)
{
  int __retres;
  struct tm *stm;
  int tmp;
  stm = gmtime((time_t const *)(& when));
  if (! stm) {
    __retres = 0;
    goto return_label;
  }
  if (stm->tm_mon == 5) {
    if (stm->tm_mday == 30) tmp = 1; else goto _LAND;
  }
  else {
    _LAND: ;
    if (stm->tm_mon == 11) 
      if (stm->tm_mday == 31) tmp = 1; else tmp = 0;
    else tmp = 0;
  }
  __retres = tmp;
  return_label: return __retres;
}

static time_t get_tz_leap_last_tz_leap_check;
static NTP_Leap get_tz_leap_tz_leap;
static int get_tz_leap_tz_tai_offset;
static NTP_Leap get_tz_leap(time_t when, int *tai_offset)
{
  NTP_Leap __retres;
  struct tm stm;
  struct tm *tm;
  time_t t;
  char *tz_env;
  char tz_orig[128];
  *tai_offset = get_tz_leap_tz_tai_offset;
  when = (when / (time_t)(12 * 3600)) * (time_t)(12 * 3600);
  if (get_tz_leap_last_tz_leap_check == when) {
    __retres = get_tz_leap_tz_leap;
    goto return_label;
  }
  get_tz_leap_last_tz_leap_check = when;
  get_tz_leap_tz_leap = LEAP_Normal;
  get_tz_leap_tz_tai_offset = 0;
  tm = gmtime((time_t const *)(& when));
  if (! tm) {
    __retres = get_tz_leap_tz_leap;
    goto return_label;
  }
  stm = *tm;
  tz_env = getenv("TZ");
  if (tz_env) {
    size_t tmp;
    tmp = strlen((char const *)tz_env);
    if (tmp >= sizeof(tz_orig)) {
      __retres = get_tz_leap_tz_leap;
      goto return_label;
    }
    strcpy(tz_orig,(char const *)tz_env);
  }
  setenv("TZ",(char const *)leap_tzname,1);
  tzset();
  t = mktime(& stm);
  if (t != (time_t)(-1)) get_tz_leap_tz_tai_offset = (int)((t - when) + (time_t)10);
  stm.tm_sec = 60;
  stm.tm_min = 59;
  stm.tm_hour = 23;
  t = mktime(& stm);
  if (tz_env) setenv("TZ",(char const *)(tz_orig),1); else unsetenv("TZ");
  tzset();
  if (t == (time_t)(-1)) {
    __retres = get_tz_leap_tz_leap;
    goto return_label;
  }
  if (stm.tm_sec == 60) get_tz_leap_tz_leap = LEAP_InsertSecond;
  else 
    if (stm.tm_sec == 1) get_tz_leap_tz_leap = LEAP_DeleteSecond;
  *tai_offset = get_tz_leap_tz_tai_offset;
  __retres = get_tz_leap_tz_leap;
  return_label: return __retres;
}

static void leap_end_timeout(void *arg)
{
  leap_timeout_id = (SCH_TimeoutID)0;
  leap_in_progress = 0;
  if (our_tai_offset) our_tai_offset += our_leap_sec;
  our_leap_sec = 0;
  if (leap_mode == (unsigned int)REF_LeapModeSystem) LCL_SetSystemLeap
                                                     (our_leap_sec,
                                                      our_tai_offset);
  if (our_leap_status == (unsigned int)LEAP_InsertSecond) our_leap_status = LEAP_Normal;
  else 
    if (our_leap_status == (unsigned int)LEAP_DeleteSecond) our_leap_status = LEAP_Normal;
  return;
}

static void leap_start_timeout(void *arg)
{
  leap_in_progress = 1;
  switch (leap_mode) {
    case REF_LeapModeSystem: ;
    break;
    case REF_LeapModeSlew: LCL_NotifyLeap(our_leap_sec);
    LCL_AccumulateOffset((double)our_leap_sec,0.0);
    {
      void *__va_args[1] = {(void *)0};
      LOG_Message(LOGS_WARN,"Adjusting system clock for leap second",
                  (void * const *)(__va_args));
    }
    break;
    case REF_LeapModeStep: LCL_NotifyLeap(our_leap_sec);
    LCL_ApplyStepOffset((double)our_leap_sec);
    {
      void *__va_args_4[1] = {(void *)0};
      LOG_Message(LOGS_WARN,"System clock was stepped for leap second",
                  (void * const *)(__va_args_4));
    }
    break;
    case REF_LeapModeIgnore:
    {
      void *__va_args_6[1] = {(void *)0};
      LOG_Message(LOGS_WARN,"Ignoring leap second",
                  (void * const *)(__va_args_6));
    }
    break;
    default: break;
  }
  leap_timeout_id = SCH_AddTimeoutByDelay(2.0,& leap_end_timeout,(void *)0);
  return;
}

static void set_leap_timeout(time_t now)
{
  struct timespec when;
  SCH_RemoveTimeout(leap_timeout_id);
  leap_timeout_id = (SCH_TimeoutID)0;
  leap_in_progress = 0;
  if (! our_leap_sec) goto return_label;
  when.tv_sec = (now / (time_t)(24 * 3600) + (time_t)1) * (time_t)(24 * 3600);
  when.tv_nsec = (long)0;
  if (our_leap_sec < 0) (when.tv_sec) --;
  if (leap_mode == (unsigned int)REF_LeapModeSystem) {
    (when.tv_sec) --;
    when.tv_nsec = (long)500000000;
  }
  leap_timeout_id = SCH_AddTimeout(& when,& leap_start_timeout,(void *)0);
  return_label: return;
}

static void update_leap_status(NTP_Leap leap, time_t now, int reset)
{
  NTP_Leap tz_leap;
  int leap_sec;
  int tai_offset;
  leap_sec = 0;
  tai_offset = 0;
  if (leap_tzname) 
    if (now) {
      tz_leap = get_tz_leap(now,& tai_offset);
      if (leap == (unsigned int)LEAP_Normal) leap = tz_leap;
    }
  if (leap == (unsigned int)LEAP_InsertSecond) goto _LOR;
  else 
    if (leap == (unsigned int)LEAP_DeleteSecond) {
      _LOR:
      {
        int tmp;
        tmp = is_leap_second_day(now);
        if (tmp) 
          if (leap == (unsigned int)LEAP_InsertSecond) leap_sec = 1;
          else leap_sec = -1;
        else leap = LEAP_Normal;
      }
    }
  if (leap_sec != our_leap_sec) goto _LOR_0;
  else 
    if (tai_offset != our_tai_offset) {
      int tmp_0;
      _LOR_0: tmp_0 = REF_IsLeapSecondClose();
      if (tmp_0) goto _LAND;
      else {
        our_leap_sec = leap_sec;
        our_tai_offset = tai_offset;
        switch (leap_mode) {
          case REF_LeapModeSystem:
          LCL_SetSystemLeap(our_leap_sec,our_tai_offset);
          case REF_LeapModeSlew: case REF_LeapModeStep:
          case REF_LeapModeIgnore:
          set_leap_timeout(now);
          break;
          default: __FC_assert(0 != 0,"reference.c",815,"0");
          break;
        }
      }
    }
    else {
      _LAND: ;
      if (reset) set_leap_timeout(now);
    }
  our_leap_status = leap;
  return;
}

static double get_root_dispersion(struct timespec *ts)
{
  double __retres;
  int tmp;
  double tmp_1;
  double tmp_0;
  double tmp_2;
  double tmp_3;
  tmp = UTI_IsZeroTimespec(& our_ref_time);
  if (tmp) {
    __retres = 1.0;
    goto return_label;
  }
  tmp_0 = UTI_DiffTimespecsToDouble(ts,& our_ref_time);
  tmp_1 = fabs(tmp_0);
  tmp_2 = fabs(our_residual_freq);
  tmp_3 = LCL_GetMaxClockError();
  ;
  __retres = our_root_dispersion + tmp_1 * ((our_skew + tmp_2) + tmp_3);
  return_label: return __retres;
}

static void write_log(struct timespec *now, int combined_sources,
                      double freq, double offset, double offset_sd,
                      double uncorrected_offset, double orig_root_distance);

static double write_log_last_sys_offset = 0.0;
static void write_log(struct timespec *now, int combined_sources,
                      double freq, double offset, double offset_sd,
                      double uncorrected_offset, double orig_root_distance)
{
  double root_dispersion;
  double max_error;
  double tmp;
  char *tmp_2;
  char *tmp_3;
  char const leap_codes[4] = {(char)'N', (char)'+', (char)'-', (char)'?'};
  if (logfileid == -1) goto return_label;
  tmp = fabs(write_log_last_sys_offset);
  max_error = orig_root_distance + tmp;
  root_dispersion = get_root_dispersion(now);
  write_log_last_sys_offset = offset - uncorrected_offset;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  if ((int)our_ref_ip.family != 0) tmp_2 = UTI_IPToString(& our_ref_ip);
  else tmp_2 = UTI_RefidToString(our_ref_id);
  tmp_3 = UTI_TimeToLogForm(now->tv_sec);
  ;
  {
    char *__va_arg0 = tmp_3;
    char *__va_arg1 = tmp_2;
    int __va_arg2 = our_stratum;
    double __va_arg3 = freq;
    double __va_arg4 = 1.0e6 * our_skew;
    double __va_arg5 = offset;
    int __va_arg6 = (int)leap_codes[our_leap_status];
    int __va_arg7 = combined_sources;
    double __va_arg8 = offset_sd;
    double __va_arg9 = uncorrected_offset;
    double __va_arg10 = our_root_delay;
    double __va_arg11 = root_dispersion;
    double __va_arg12 = max_error;
    void *__va_args[13] =
      {& __va_arg0,
       & __va_arg1,
       & __va_arg2,
       & __va_arg3,
       & __va_arg4,
       & __va_arg5,
       & __va_arg6,
       & __va_arg7,
       & __va_arg8,
       & __va_arg9,
       & __va_arg10,
       & __va_arg11,
       & __va_arg12};
    LOG_FileWrite(logfileid,
                  "%s %-15s %2d %10.3f %10.3f %10.3e %1c %2d %10.3e %10.3e %10.3e %10.3e %10.3e",
                  (void * const *)(__va_args));
  }
  return_label: return;
}

static void special_mode_sync(int valid, double offset)
{
  int step;
  switch (mode) {
    double tmp;
    double tmp_0;
    char const *tmp_1;
    char const *tmp_2;
    double tmp_3;
    char const *tmp_4;
    case REF_ModeInitStepSlew:
    if (! valid) {
      {
        void *__va_args[1] = {(void *)0};
        LOG_Message(LOGS_WARN,"No suitable source for initstepslew",
                    (void * const *)(__va_args));
      }
      end_ref_mode(0);
      break;
    }
    tmp = fabs(offset);
    tmp_0 = CNF_GetInitStepThreshold();
    step = tmp >= tmp_0;
    if (step) tmp_1 = "step"; else tmp_1 = "slew";
    if (offset >= (double)0) tmp_2 = "fast"; else tmp_2 = "slow";
    tmp_3 = fabs(offset);
    {
      double __va_arg0 = tmp_3;
      char const *__va_arg1 = tmp_2;
      char const *__va_arg2 = tmp_1;
      void *__va_args_15[3] = {& __va_arg0, & __va_arg1, & __va_arg2};
      LOG_Message(LOGS_INFO,
                  "System\'s initial offset : %.6f seconds %s of true (%s)",
                  (void * const *)(__va_args_15));
    }
    if (step) LCL_ApplyStepOffset(offset);
    else LCL_AccumulateOffset(offset,0.0);
    end_ref_mode(1);
    break;
    case REF_ModeUpdateOnce: case REF_ModePrintOnce:
    if (! valid) {
      {
        void *__va_args_17[1] = {(void *)0};
        LOG_Message(LOGS_WARN,"No suitable source for synchronisation",
                    (void * const *)(__va_args_17));
      }
      end_ref_mode(0);
      break;
    }
    step = mode == (unsigned int)REF_ModeUpdateOnce;
    if (step) tmp_4 = "step"; else tmp_4 = "ignored";
    ;
    {
      double __va_arg0_19 = - offset;
      char const *__va_arg1_21 = tmp_4;
      void *__va_args_23[2] = {& __va_arg0_19, & __va_arg1_21};
      LOG_Message(LOGS_INFO,"System clock wrong by %.6f seconds (%s)",
                  (void * const *)(__va_args_23));
    }
    if (step) LCL_ApplyStepOffset(offset);
    end_ref_mode(1);
    break;
    case REF_ModeIgnore: break;
    default: __FC_assert(0 != 0,"reference.c",917,"0");
  }
  return;
}

static void get_clock_estimates(int manual, double measured_freq,
                                double measured_skew, double *estimated_freq,
                                double *estimated_skew, double *residual_freq)
{
  double gain;
  double expected_freq;
  double expected_skew;
  double extra_skew;
  double tmp_0;
  expected_freq = 0.0;
  expected_skew = our_skew;
  if (manual) gain = 1.0;
  else {
    double tmp;
    tmp = fabs(measured_skew);
    ;
    if (tmp > max_update_skew_0) gain = 0.0;
    else gain = (3.0 * (expected_skew * expected_skew)) / (3.0 * (expected_skew * expected_skew) + 
                                                           measured_skew * measured_skew);
  }
  if (gain < 1.0) tmp_0 = gain; else tmp_0 = 1.0;
  if (0.0 > tmp_0) gain = 0.0;
  else {
    double tmp_1;
    if (gain < 1.0) tmp_1 = gain; else tmp_1 = 1.0;
    gain = tmp_1;
  }
  *estimated_freq = expected_freq + gain * (measured_freq - expected_freq);
  *residual_freq = measured_freq - *estimated_freq;
  extra_skew = sqrt(((expected_freq - *estimated_freq) * (expected_freq - *estimated_freq)) * (
                    1.0 - gain) + ((measured_freq - *estimated_freq) * (
                                   measured_freq - *estimated_freq)) * gain);
  *estimated_skew = (expected_skew + gain * (measured_skew - expected_skew)) + extra_skew;
  return;
}

void REF_SetReference(int stratum, NTP_Leap leap, int combined_sources,
                      uint32_t ref_id, IPAddr *ref_ip,
                      struct timespec *ref_time, double offset,
                      double offset_sd, double frequency,
                      double frequency_sd, double skew, double root_delay,
                      double root_dispersion)
{
  double uncorrected_offset;
  double accumulate_offset;
  double step_offset;
  double residual_frequency;
  double local_abs_frequency;
  double elapsed;
  double update_interval;
  double correction_rate;
  double orig_root_distance;
  struct timespec now;
  struct timespec raw_now;
  NTP_int64 ref_fuzz;
  int manual;
  int tmp;
  double tmp_0;
  int tmp_1;
  double tmp_3;
  int tmp_4;
  __FC_assert(initialised_0 != 0,"reference.c",976,"initialised");
  if (mode != (unsigned int)REF_ModeNormal) {
    special_mode_sync(1,offset);
    goto return_label;
  }
  manual = leap == (unsigned int)LEAP_Unsynchronised;
  LCL_ReadRawTime(& raw_now);
  LCL_GetOffsetCorrection(& raw_now,& uncorrected_offset,(double *)0);
  UTI_AddDoubleToTimespec(& raw_now,uncorrected_offset,& now);
  elapsed = UTI_DiffTimespecsToDouble(& now,ref_time);
  offset += elapsed * frequency;
  offset_sd += elapsed * frequency_sd;
  if (last_ref_update.tv_sec) {
    update_interval = UTI_DiffTimespecsToDouble(& now,& last_ref_update);
    if (update_interval > 0.0) update_interval = update_interval;
    else update_interval = 0.0;
  }
  else update_interval = 0.0;
  get_clock_estimates(manual,frequency,skew,& frequency,& skew,
                      & residual_frequency);
  tmp = is_offset_ok(offset);
  if (! tmp) goto return_label;
  tmp_0 = get_root_dispersion(& now);
  orig_root_distance = our_root_delay / 2.0 + tmp_0;
  are_we_synchronised = leap != (unsigned int)LEAP_Unsynchronised;
  our_stratum = stratum + 1;
  our_ref_id = ref_id;
  if (ref_ip) our_ref_ip = *ref_ip; else our_ref_ip.family = (uint16_t)0;
  our_ref_time = *ref_time;
  our_skew = skew;
  our_residual_freq = residual_frequency;
  our_root_delay = root_delay;
  our_root_dispersion = root_dispersion;
  last_ref_update = now;
  last_ref_update_interval = update_interval;
  last_offset = offset;
  correction_rate = ((correction_time_ratio_0 * 0.5) * offset_sd) * update_interval;
  tmp_1 = is_step_limit_reached(offset,uncorrected_offset);
  if (tmp_1) {
    accumulate_offset = uncorrected_offset;
    step_offset = offset - uncorrected_offset;
  }
  else {
    accumulate_offset = offset;
    step_offset = 0.0;
  }
  LCL_AccumulateFrequencyAndOffset(frequency,accumulate_offset,
                                   correction_rate);
  update_leap_status(leap,raw_now.tv_sec,0);
  maybe_log_offset(offset,raw_now.tv_sec);
  if (step_offset != 0.0) {
    int tmp_2;
    tmp_2 = LCL_ApplyStepOffset(step_offset);
    if (tmp_2) {
      {
        double __va_arg0 = - step_offset;
        void *__va_args[1] = {& __va_arg0};
        LOG_Message(LOGS_WARN,"System clock was stepped by %.6f seconds",
                    (void * const *)(__va_args));
      }
    }
  }
  tmp_3 = get_root_dispersion(& now);
  ;
  ;
  ;
  LCL_SetSyncStatus(are_we_synchronised,offset_sd,root_delay / 2.0 + tmp_3);
  UTI_GetNtp64Fuzz(& ref_fuzz,0);
  UTI_TimespecToNtp64(& our_ref_time,& ref_fuzz,& ref_fuzz);
  UTI_Ntp64ToTimespec(& ref_fuzz,& our_ref_time);
  tmp_4 = UTI_CompareTimespecs(& our_ref_time,ref_time);
  if (tmp_4 >= 0) (our_ref_time.tv_sec) --;
  local_abs_frequency = LCL_ReadAbsoluteFrequency();
  write_log(& now,combined_sources,local_abs_frequency,offset,offset_sd,
            uncorrected_offset,orig_root_distance);
  if (drift_file_0) {
    drift_file_age += update_interval;
    if (drift_file_age < 0.0) goto _LOR;
    else 
      if (drift_file_age > 3600.0) {
        _LOR:
        {
          update_drift_file(local_abs_frequency,our_skew);
          drift_file_age = 0.0;
        }
      }
  }
  if (fb_drifts) 
    if (are_we_synchronised) {
      update_fb_drifts(local_abs_frequency,update_interval);
      schedule_fb_drift(& now);
    }
  if (avg2_moving) avg2_offset += 0.1 * (offset * offset - avg2_offset);
  else {
    if (avg2_offset > 0.0) 
      if (avg2_offset < offset * offset) avg2_moving = 1;
    avg2_offset = offset * offset;
  }
  return_label: return;
}

void REF_SetManualReference(struct timespec *ref_time, double offset,
                            double frequency, double skew)
{
  REF_SetReference(0,LEAP_Unsynchronised,1,(uint32_t)0x4D414E55UL,
                   (IPAddr *)0,ref_time,offset,0.0,frequency,skew,skew,0.0,
                   0.0);
  return;
}

void REF_SetUnsynchronised(void)
{
  struct timespec now;
  struct timespec now_raw;
  double uncorrected_offset;
  double tmp;
  double tmp_0;
  __FC_assert(initialised_0 != 0,"reference.c",1131,"initialised");
  if (mode != (unsigned int)REF_ModeNormal) {
    special_mode_sync(0,0.0);
    goto return_label;
  }
  LCL_ReadRawTime(& now_raw);
  LCL_GetOffsetCorrection(& now_raw,& uncorrected_offset,(double *)0);
  UTI_AddDoubleToTimespec(& now_raw,uncorrected_offset,& now);
  if (fb_drifts) schedule_fb_drift(& now);
  update_leap_status(LEAP_Unsynchronised,(time_t)0,0);
  our_ref_ip.family = (uint16_t)1;
  our_ref_ip.addr.in4 = (uint32_t)0;
  our_stratum = 0;
  are_we_synchronised = 0;
  LCL_SetSyncStatus(0,0.0,0.0);
  tmp = get_root_dispersion(& now);
  ;
  ;
  tmp_0 = LCL_ReadAbsoluteFrequency();
  write_log(& now,0,tmp_0,0.0,0.0,uncorrected_offset,
            our_root_delay / 2.0 + tmp);
  return_label: return;
}

void REF_GetReferenceParams(struct timespec *local_time,
                            int *is_synchronised, NTP_Leap *leap_status,
                            int *stratum, uint32_t *ref_id,
                            struct timespec *ref_time, double *root_delay,
                            double *root_dispersion)
{
  double dispersion;
  __FC_assert(initialised_0 != 0,"reference.c",1176,"initialised");
  if (are_we_synchronised) dispersion = get_root_dispersion(local_time);
  else dispersion = 0.0;
  if (are_we_synchronised) 
    if (enable_local_stratum) {
      if (our_root_delay / (double)2 + dispersion > local_distance_0) 
        goto _LAND;
      else goto _LAND_0;
    }
    else {
      _LAND_0:
      {
        *is_synchronised = 1;
        *stratum = our_stratum;
        if (! leap_in_progress) *leap_status = our_leap_status;
        else *leap_status = LEAP_Unsynchronised;
        *ref_id = our_ref_id;
        *ref_time = our_ref_time;
        *root_delay = our_root_delay;
        *root_dispersion = dispersion;
      }
    }
  else {
    _LAND: ;
    if (enable_local_stratum) {
      *is_synchronised = 0;
      *stratum = local_stratum_0;
      *ref_id = (uint32_t)0x7F7F0101UL;
      *ref_time = *local_time;
      (ref_time->tv_sec) --;
      *leap_status = LEAP_Normal;
      *root_delay = 0.0;
      *root_dispersion = 0.0;
    }
    else {
      *is_synchronised = 0;
      *leap_status = LEAP_Unsynchronised;
      *stratum = 16;
      *ref_id = (uint32_t)0x0UL;
      UTI_ZeroTimespec(ref_time);
      *root_dispersion = 1.0;
      *root_delay = 1.0;
    }
  }
  return;
}

int REF_GetOurStratum(void)
{
  struct timespec now_cooked;
  struct timespec ref_time;
  int synchronised;
  int stratum;
  NTP_Leap leap_status;
  uint32_t ref_id;
  double root_delay;
  double root_dispersion;
  SCH_GetLastEventTime(& now_cooked,(double *)0,(struct timespec *)0);
  REF_GetReferenceParams(& now_cooked,& synchronised,& leap_status,& stratum,
                         & ref_id,& ref_time,& root_delay,& root_dispersion);
  return stratum;
}

int REF_GetOrphanStratum(void)
{
  int __retres;
  if (! enable_local_stratum) {
    __retres = 16;
    goto return_label;
  }
  else 
    if (! local_orphan_0) {
      __retres = 16;
      goto return_label;
    }
    else 
      if (mode != (unsigned int)REF_ModeNormal) {
        __retres = 16;
        goto return_label;
      }
  __retres = local_stratum_0;
  return_label: return __retres;
}

double REF_GetSkew(void)
{
  return our_skew;
}

void REF_ModifyMaxupdateskew(double new_max_update_skew)
{
  max_update_skew_0 = new_max_update_skew * 1.0e-6;
  return;
}

void REF_ModifyMakestep(int limit, double threshold)
{
  make_step_limit_0 = limit;
  make_step_threshold_0 = threshold;
  return;
}

void REF_EnableLocal(int stratum, double distance, int orphan)
{
  int tmp;
  enable_local_stratum = 1;
  if (stratum < 16 - 1) tmp = stratum; else tmp = 16 - 1;
  if (1 > tmp) local_stratum_0 = 1;
  else {
    int tmp_0;
    if (stratum < 16 - 1) tmp_0 = stratum; else tmp_0 = 16 - 1;
    local_stratum_0 = tmp_0;
  }
  local_distance_0 = distance;
  local_orphan_0 = ! (! orphan);
  return;
}

void REF_DisableLocal(void)
{
  enable_local_stratum = 0;
  return;
}

int REF_IsLeapSecondClose(void)
{
  int __retres;
  struct timespec now;
  struct timespec now_raw;
  time_t t;
  if (! our_leap_sec) {
    __retres = 0;
    goto return_label;
  }
  SCH_GetLastEventTime(& now,(double *)0,& now_raw);
  if (now.tv_sec > (long)0) t = now.tv_sec; else t = - now.tv_sec;
  if ((t + (time_t)5) % (long)(24 * 3600) < (long)(2 * 5)) {
    __retres = 1;
    goto return_label;
  }
  if (now_raw.tv_sec > (long)0) t = now_raw.tv_sec;
  else t = - now_raw.tv_sec;
  if ((t + (time_t)5) % (long)(24 * 3600) < (long)(2 * 5)) {
    __retres = 1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int REF_GetTaiOffset(struct timespec *ts)
{
  int tai_offset;
  get_tz_leap(ts->tv_sec,& tai_offset);
  return tai_offset;
}

void REF_GetTrackingReport(RPT_TrackingReport *rep)
{
  struct timespec now_raw;
  struct timespec now_cooked;
  double correction;
  int synchronised;
  LCL_ReadRawTime(& now_raw);
  LCL_GetOffsetCorrection(& now_raw,& correction,(double *)0);
  UTI_AddDoubleToTimespec(& now_raw,correction,& now_cooked);
  REF_GetReferenceParams(& now_cooked,& synchronised,& rep->leap_status,
                         & rep->stratum,& rep->ref_id,& rep->ref_time,
                         & rep->root_delay,& rep->root_dispersion);
  if (rep->stratum == 16) 
    if (! synchronised) rep->stratum = 0;
  rep->ip_addr.family = (uint16_t)0;
  rep->current_correction = correction;
  rep->freq_ppm = LCL_ReadAbsoluteFrequency();
  rep->resid_freq_ppm = 0.0;
  rep->skew_ppm = 0.0;
  rep->last_update_interval = last_ref_update_interval;
  rep->last_offset = last_offset;
  rep->rms_offset = sqrt(avg2_offset);
  if (synchronised) {
    rep->ip_addr = our_ref_ip;
    rep->resid_freq_ppm = 1.0e6 * our_residual_freq;
    rep->skew_ppm = 1.0e6 * our_skew;
  }
  return;
}

void RGR_WeightedRegression(double *x, double *y, double *w, int n,
                            double *b0, double *b1, double *s2, double *sb0,
                            double *sb1);

double RGR_GetTCoef(int dof);

double RGR_GetChi2Coef(int dof);

int RGR_FindBestRegression(double *x, double *y, double *w, int n, int m,
                           int min_samples_0, double *b0, double *b1,
                           double *s2, double *sb0, double *sb1,
                           int *new_start, int *n_runs, int *dof);

int RGR_FindBestRobustRegression(double *x, double *y, int n, double tol,
                                 double *b0, double *b1, int *n_runs,
                                 int *best_start);

int RGR_MultipleRegress(double *x1, double *x2, double *y, int n, double *b2);

double RGR_FindMedian(double *x, int n);

void RGR_WeightedRegression(double *x, double *y, double *w, int n,
                            double *b0, double *b1, double *s2, double *sb0,
                            double *sb1)
{
  double P;
  double Q;
  double U;
  double V;
  double W;
  double diff;
  double u;
  double ui;
  double aa;
  int i;
  __FC_assert((n >= 3) != 0,"regress.c",67,"n >= 3");
  U = (double)0;
  W = U;
  i = 0;
  while (i < n) {
    U += *(x + i) / *(w + i);
    W += 1.0 / *(w + i);
    i ++;
  }
  u = U / W;
  V = 0.0;
  Q = V;
  P = Q;
  i = 0;
  while (i < n) {
    ui = *(x + i) - u;
    P += *(y + i) / *(w + i);
    Q += (*(y + i) * ui) / *(w + i);
    V += (ui * ui) / *(w + i);
    i ++;
  }
  *b1 = Q / V;
  *b0 = P / W - *b1 * u;
  *s2 = 0.0;
  i = 0;
  while (i < n) {
    diff = (*(y + i) - *b0) - *b1 * *(x + i);
    *s2 += (diff * diff) / *(w + i);
    i ++;
  }
  *s2 /= (double)(n - 2);
  *sb1 = sqrt(*s2 / V);
  aa = u * *sb1;
  *sb0 = sqrt(*s2 / W + aa * aa);
  *s2 *= (double)n / W;
  return;
}

static float const RGR_GetTCoef_coefs[40] =
  {(float)636.6,
   (float)31.6,
   (float)12.92,
   (float)8.61,
   (float)6.869,
   (float)5.959,
   (float)5.408,
   (float)5.041,
   (float)4.781,
   (float)4.587,
   (float)4.437,
   (float)4.318,
   (float)4.221,
   (float)4.140,
   (float)4.073,
   (float)4.015,
   (float)3.965,
   (float)3.922,
   (float)3.883,
   (float)3.850,
   (float)3.819,
   (float)3.792,
   (float)3.768,
   (float)3.745,
   (float)3.725,
   (float)3.707,
   (float)3.690,
   (float)3.674,
   (float)3.659,
   (float)3.646,
   (float)3.633,
   (float)3.622,
   (float)3.611,
   (float)3.601,
   (float)3.591,
   (float)3.582,
   (float)3.574,
   (float)3.566,
   (float)3.558,
   (float)3.551};
double RGR_GetTCoef(int dof)
{
  double __retres;
  if (dof <= 40) {
    __retres = (double)RGR_GetTCoef_coefs[dof - 1];
    goto return_label;
  }
  else {
    __retres = 3.5;
    goto return_label;
  }
  return_label: return __retres;
}

static float const RGR_GetChi2Coef_coefs[64] =
  {(float)2.706,
   (float)4.605,
   (float)6.251,
   (float)7.779,
   (float)9.236,
   (float)10.645,
   (float)12.017,
   (float)13.362,
   (float)14.684,
   (float)15.987,
   (float)17.275,
   (float)18.549,
   (float)19.812,
   (float)21.064,
   (float)22.307,
   (float)23.542,
   (float)24.769,
   (float)25.989,
   (float)27.204,
   (float)28.412,
   (float)29.615,
   (float)30.813,
   (float)32.007,
   (float)33.196,
   (float)34.382,
   (float)35.563,
   (float)36.741,
   (float)37.916,
   (float)39.087,
   (float)40.256,
   (float)41.422,
   (float)42.585,
   (float)43.745,
   (float)44.903,
   (float)46.059,
   (float)47.212,
   (float)48.363,
   (float)49.513,
   (float)50.660,
   (float)51.805,
   (float)52.949,
   (float)54.090,
   (float)55.230,
   (float)56.369,
   (float)57.505,
   (float)58.641,
   (float)59.774,
   (float)60.907,
   (float)62.038,
   (float)63.167,
   (float)64.295,
   (float)65.422,
   (float)66.548,
   (float)67.673,
   (float)68.796,
   (float)69.919,
   (float)71.040,
   (float)72.160,
   (float)73.279,
   (float)74.397,
   (float)75.514,
   (float)76.630,
   (float)77.745,
   (float)78.860};
double RGR_GetChi2Coef(int dof)
{
  double __retres;
  if (dof <= 64) {
    __retres = (double)RGR_GetChi2Coef_coefs[dof - 1];
    goto return_label;
  }
  else {
    __retres = 1.2 * (double)dof;
    goto return_label;
  }
  return_label: return __retres;
}

static char critical_runs[130] =
  {(char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)0,
   (char)2,
   (char)3,
   (char)3,
   (char)3,
   (char)4,
   (char)4,
   (char)5,
   (char)5,
   (char)5,
   (char)6,
   (char)6,
   (char)7,
   (char)7,
   (char)7,
   (char)8,
   (char)8,
   (char)9,
   (char)9,
   (char)9,
   (char)10,
   (char)10,
   (char)11,
   (char)11,
   (char)11,
   (char)12,
   (char)12,
   (char)13,
   (char)13,
   (char)14,
   (char)14,
   (char)14,
   (char)15,
   (char)15,
   (char)16,
   (char)16,
   (char)17,
   (char)17,
   (char)18,
   (char)18,
   (char)18,
   (char)19,
   (char)19,
   (char)20,
   (char)20,
   (char)21,
   (char)21,
   (char)21,
   (char)22,
   (char)22,
   (char)23,
   (char)23,
   (char)24,
   (char)24,
   (char)25,
   (char)25,
   (char)26,
   (char)26,
   (char)26,
   (char)27,
   (char)27,
   (char)28,
   (char)28,
   (char)29,
   (char)29,
   (char)30,
   (char)30,
   (char)30,
   (char)31,
   (char)31,
   (char)32,
   (char)32,
   (char)33,
   (char)33,
   (char)34,
   (char)34,
   (char)35,
   (char)35,
   (char)35,
   (char)36,
   (char)36,
   (char)37,
   (char)37,
   (char)38,
   (char)38,
   (char)39,
   (char)39,
   (char)40,
   (char)40,
   (char)40,
   (char)41,
   (char)41,
   (char)42,
   (char)42,
   (char)43,
   (char)43,
   (char)44,
   (char)44,
   (char)45,
   (char)45,
   (char)46,
   (char)46,
   (char)46,
   (char)47,
   (char)47,
   (char)48,
   (char)48,
   (char)49,
   (char)49,
   (char)50,
   (char)50,
   (char)51,
   (char)51,
   (char)52,
   (char)52,
   (char)52,
   (char)53,
   (char)53,
   (char)54,
   (char)54,
   (char)55,
   (char)55,
   (char)56};
static int n_runs_from_residuals(double *resid, int n)
{
  int nruns;
  int i;
  nruns = 1;
  i = 1;
  while (i < n) {
    if (*(resid + (i - 1)) < 0.0) {
      if (*(resid + i) < 0.0) goto _LOR; else goto _LAND_0;
    }
    else {
      _LAND_0: ;
      if (*(resid + (i - 1)) > 0.0) {
        if (*(resid + i) > 0.0) _LOR: ; else goto _LAND;
      }
      else _LAND: nruns ++;
    }
    i ++;
  }
  return nruns;
}

int RGR_FindBestRegression(double *x, double *y, double *w, int n, int m,
                           int min_samples_0, double *b0, double *b1,
                           double *s2, double *sb0, double *sb1,
                           int *new_start, int *n_runs, int *dof)
{
  int __retres;
  double P;
  double Q;
  double U;
  double V;
  double W;
  double resid[64 * 2];
  double ss;
  double a;
  double b;
  double u;
  double ui;
  double aa;
  int start;
  int resid_start;
  int nruns;
  int npoints;
  int i;
  int tmp;
  if (n <= 64) 
    if (m >= 0) tmp = 1; else tmp = 0;
  else tmp = 0;
  __FC_assert(tmp != 0,"regress.c",242,"n <= MAX_POINTS && m >= 0");
  __FC_assert(((unsigned long)(n * 2) < sizeof(critical_runs) / sizeof(critical_runs[0])) != 0,
              "regress.c",243,
              "n * REGRESS_RUNS_RATIO < sizeof (critical_runs) / sizeof (critical_runs[0])");
  if (n < 3) {
    __retres = 0;
    goto return_label;
  }
  start = 0;
  while (1) {
    U = (double)0;
    W = U;
    i = start;
    while (i < n) {
      U += *(x + i) / *(w + i);
      W += 1.0 / *(w + i);
      i ++;
    }
    u = U / W;
    V = 0.0;
    Q = V;
    P = Q;
    i = start;
    while (i < n) {
      ui = *(x + i) - u;
      P += *(y + i) / *(w + i);
      Q += (*(y + i) * ui) / *(w + i);
      V += (ui * ui) / *(w + i);
      i ++;
    }
    b = Q / V;
    a = P / W - b * u;
    resid_start = n - (n - start) * 2;
    if (resid_start < - m) resid_start = - m;
    i = resid_start;
    while (i < n) {
      resid[i - resid_start] = (*(y + i) - a) - b * *(x + i);
      i ++;
    }
    nruns = n_runs_from_residuals(resid,n - resid_start);
    if (nruns > (int)critical_runs[n - resid_start]) goto _LOR;
    else 
      if (n - start <= 3) goto _LOR;
      else 
        if (n - start <= min_samples_0) {
          _LOR:
          {
            if (start != resid_start) nruns = n_runs_from_residuals(& resid[
                                                                    start - resid_start],
                                                                    n - start);
            break;
          }
        }
        else start ++;
  }
  *b1 = b;
  *b0 = a;
  ss = 0.0;
  i = start;
  while (i < n) {
    ss += (resid[i - resid_start] * resid[i - resid_start]) / *(w + i);
    i ++;
  }
  npoints = n - start;
  ss /= (double)(npoints - 2);
  *sb1 = sqrt(ss / V);
  aa = u * *sb1;
  *sb0 = sqrt(ss / W + aa * aa);
  *s2 = (ss * (double)npoints) / W;
  *new_start = start;
  *dof = npoints - 2;
  *n_runs = nruns;
  __retres = 1;
  return_label: return __retres;
}

static double find_ordered_entry_with_flags(double *x, int n, int index_0,
                                            char *flags)
{
  double __retres;
  int u;
  int v;
  int l;
  int r;
  double temp;
  double piv;
  int pivind;
  __FC_assert((index_0 >= 0) != 0,"regress.c",350,"index >= 0");
  if (*(flags + index_0)) {
    __retres = *(x + index_0);
    goto return_label;
  }
  v = index_0;
  u = v;
  while (1) {
    if (u > 0) {
      if (! (! *(flags + u))) break;
    }
    else break;
    u --;
  }
  if (*(flags + u)) u ++;
  while (1) {
    if (v < n - 1) {
      if (! (! *(flags + v))) break;
    }
    else break;
    v ++;
  }
  if (*(flags + v)) v --;
  while (1) 
    if (v - u < 2) {
      char tmp;
      if (*(x + v) < *(x + u)) {
        temp = *(x + v);
        *(x + v) = *(x + u);
        *(x + u) = temp;
      }
      tmp = (char)1;
      *(flags + u) = tmp;
      *(flags + v) = tmp;
      __retres = *(x + index_0);
      goto return_label;
    }
    else {
      pivind = (u + v) >> 1;
      temp = *(x + u);
      *(x + u) = *(x + pivind);
      *(x + pivind) = temp;
      piv = *(x + u);
      l = u + 1;
      r = v;
      while (1) {
        while (1) {
          if (l < v) {
            if (! (*(x + l) < piv)) break;
          }
          else break;
          l ++;
        }
        while (*(x + r) > piv) r --;
        if (r <= l) break;
        temp = *(x + l);
        *(x + l) = *(x + r);
        *(x + r) = temp;
        l ++;
        r --;
      }
      temp = *(x + u);
      *(x + u) = *(x + r);
      *(x + r) = temp;
      *(flags + r) = (char)1;
      if (index_0 == r) {
        __retres = *(x + r);
        goto return_label;
      }
      else 
        if (index_0 < r) v = r - 1;
        else 
          if (index_0 > r) u = l;
    }
  return_label: return __retres;
}

static double find_median(double *x, int n)
{
  double __retres;
  int k;
  char flags[64];
  memset((void *)(flags),0,(unsigned long)n * sizeof(flags[0]));
  k = n >> 1;
  if (n & 1) {
    double tmp;
    tmp = find_ordered_entry_with_flags(x,n,k,flags);
    __retres = tmp;
    goto return_label;
  }
  else {
    double tmp_0;
    double tmp_1;
    tmp_0 = find_ordered_entry_with_flags(x,n,k,flags);
    tmp_1 = find_ordered_entry_with_flags(x,n,k - 1,flags);
    __retres = 0.5 * (tmp_0 + tmp_1);
    goto return_label;
  }
  return_label: return __retres;
}

double RGR_FindMedian(double *x, int n)
{
  double tmp[64];
  int tmp_0;
  double tmp_1;
  if (n > 0) 
    if (n <= 64) tmp_0 = 1; else tmp_0 = 0;
  else tmp_0 = 0;
  __FC_assert(tmp_0 != 0,"regress.c",439,"n > 0 && n <= MAX_POINTS");
  memcpy((void *)(tmp),(void const *)x,(unsigned long)n * sizeof(tmp[0]));
  tmp_1 = find_median(tmp,n);
  return tmp_1;
}

static void eval_robust_residual(double *x, double *y, int n, double b,
                                 double *aa, double *rr)
{
  int i;
  double a;
  double res;
  double del;
  double d[64];
  i = 0;
  while (i < n) {
    d[i] = *(y + i) - b * *(x + i);
    i ++;
  }
  a = find_median(d,n);
  res = 0.0;
  i = 0;
  while (i < n) {
    del = (*(y + i) - a) - b * *(x + i);
    if (del > 0.0) res += *(x + i);
    else 
      if (del < 0.0) res -= *(x + i);
    i ++;
  }
  *aa = a;
  *rr = res;
  return;
}

int RGR_FindBestRobustRegression(double *x, double *y, int n, double tol,
                                 double *b0, double *b1, int *n_runs,
                                 int *best_start)
{
  int __retres;
  int i;
  int start;
  int n_points;
  double a;
  double b;
  double P;
  double U;
  double V;
  double W;
  double X;
  double resid;
  double resids[64];
  double blo;
  double bhi;
  double bmid;
  double rlo;
  double rhi;
  double rmid;
  double s2;
  double sb;
  double incr;
  double mx;
  double dx;
  double my;
  double dy;
  int nruns = 0;
  __FC_assert((n <= 64) != 0,"regress.c",525,"n <= MAX_POINTS");
  if (n < 2) {
    __retres = 0;
    goto return_label;
  }
  else 
    if (n == 2) {
      *b1 = (*(y + 1) - *(y + 0)) / (*(x + 1) - *(x + 0));
      *b0 = *(y + 0) - *b1 * *(x + 0);
      *n_runs = 0;
      *best_start = 0;
      __retres = 1;
      goto return_label;
    }
  start = 0;
  while (1) {
    n_points = n - start;
    U = 0.0;
    P = U;
    i = start;
    while (i < n) {
      P += *(y + i);
      U += *(x + i);
      i ++;
    }
    W = (double)n_points;
    my = P / W;
    mx = U / W;
    V = 0.0;
    X = V;
    i = start;
    while (i < n) {
      dy = *(y + i) - my;
      dx = *(x + i) - mx;
      X += dy * dx;
      V += dx * dx;
      i ++;
    }
    b = X / V;
    a = my - b * mx;
    s2 = 0.0;
    i = start;
    while (i < n) {
      resid = (*(y + i) - a) - b * *(x + i);
      s2 += resid * resid;
      i ++;
    }
    sb = sqrt((s2 * W) / V);
    if (sb > tol) incr = sb; else incr = tol;
    while (1) {
      incr *= 2.0;
      if (incr > 100.0) {
        __retres = 0;
        goto return_label;
      }
      blo = b - incr;
      bhi = b + incr;
      eval_robust_residual(x + start,y + start,n_points,blo,& a,& rlo);
      eval_robust_residual(x + start,y + start,n_points,bhi,& a,& rhi);
      if (! (rlo * rhi >= 0.0)) break;
    }
    while (1) {
      bmid = 0.5 * (blo + bhi);
      if (blo < bmid) {
        if (! (bmid < bhi)) break;
      }
      else break;
      eval_robust_residual(x + start,y + start,n_points,bmid,& a,& rmid);
      if (rmid == 0.0) break;
      else 
        if (rmid * rlo > 0.0) {
          blo = bmid;
          rlo = rmid;
        }
        else 
          if (rmid * rhi > 0.0) {
            bhi = bmid;
            rhi = rmid;
          }
          else __FC_assert(0 != 0,"regress.c",616,"0");
      if (! (bhi - blo > tol)) break;
    }
    *b0 = a;
    *b1 = bmid;
    if (n_points == 3) break;
    i = start;
    while (i < n) {
      resids[i] = (*(y + i) - a) - bmid * *(x + i);
      i ++;
    }
    nruns = n_runs_from_residuals(& resids[start],n_points);
    if (nruns > (int)critical_runs[n_points]) break; else start ++;
  }
  *n_runs = nruns;
  *best_start = start;
  __retres = 1;
  return_label: return __retres;
}

int RGR_MultipleRegress(double *x1, double *x2, double *y, int n, double *b2)
{
  int __retres;
  double Sx1;
  double Sx2;
  double Sx1x1;
  double Sx1x2;
  double Sx2x2;
  double Sx1y;
  double Sx2y;
  double Sy;
  double U;
  double V;
  double V1;
  double V2;
  double V3;
  int i;
  double tmp;
  double tmp_0;
  if (n < 4) {
    __retres = 0;
    goto return_label;
  }
  Sy = 0.0;
  Sx2y = Sy;
  Sx1y = Sx2y;
  Sx2x2 = Sx1y;
  Sx1x2 = Sx2x2;
  Sx1x1 = Sx1x2;
  Sx2 = Sx1x1;
  Sx1 = Sx2;
  i = 0;
  while (i < n) {
    Sx1 += *(x1 + i);
    Sx2 += *(x2 + i);
    Sx1x1 += *(x1 + i) * *(x1 + i);
    Sx1x2 += *(x1 + i) * *(x2 + i);
    Sx2x2 += *(x2 + i) * *(x2 + i);
    Sx1y += *(x1 + i) * *(y + i);
    Sx2y += *(x2 + i) * *(y + i);
    Sy += *(y + i);
    i ++;
  }
  U = (((double)n * (Sx1x2 * Sx1y - Sx1x1 * Sx2y) + (Sx1 * Sx1) * Sx2y) - 
       (Sx1 * Sx2) * Sx1y) + Sy * (Sx2 * Sx1x1 - Sx1 * Sx1x2);
  V1 = (double)n * (Sx1x2 * Sx1x2 - Sx1x1 * Sx2x2);
  V2 = (Sx1 * Sx1) * Sx2x2 + (Sx2 * Sx2) * Sx1x1;
  V3 = ((- 2.0 * Sx1) * Sx2) * Sx1x2;
  V = (V1 + V2) + V3;
  tmp = fabs(V);
  tmp_0 = fabs(V3);
  ;
  if (tmp * 1.0e10 <= (- V1 + V2) + tmp_0) {
    __retres = 0;
    goto return_label;
  }
  *b2 = U / V;
  __retres = 1;
  return_label: return __retres;
}

static int initialised_1 = 0;
static unsigned int one_highest_fd;
static ARR_Instance file_handlers;
static struct timespec last_select_ts;
static struct timespec last_select_ts_raw;
static double last_select_ts_err;
static TimerQueueEntry timer_queue;
static unsigned long n_timer_queue_entries;
static SCH_TimeoutID next_tqe_id;
static TimerQueueEntry *tqe_free_list = (TimerQueueEntry *)0;
static struct timespec last_class_dispatch[SCH_NumberOfClasses];
static int need_to_exit;
static void handle_slew_0(struct timespec *raw, struct timespec *cooked,
                          double dfreq, double doffset,
                          LCL_ChangeType change_type, void *anything);

void SCH_Initialise(void)
{
  file_handlers = ARR_CreateInstance((unsigned int)sizeof(FileHandlerEntry));
  n_timer_queue_entries = (unsigned long)0;
  next_tqe_id = (SCH_TimeoutID)0;
  timer_queue.next = & timer_queue;
  timer_queue.prev = & timer_queue;
  need_to_exit = 0;
  LCL_AddParameterChangeHandler(& handle_slew_0,(void *)0);
  LCL_ReadRawTime(& last_select_ts_raw);
  last_select_ts = last_select_ts_raw;
  initialised_1 = 1;
  return;
}

void SCH_Finalise(void)
{
  ARR_DestroyInstance(file_handlers);
  initialised_1 = 0;
  return;
}

void SCH_AddFileHandler(int fd, int events,
                        void (*handler)(int fd, int event,
                                        SCH_ArbitraryArgument ),
                        SCH_ArbitraryArgument arg)
{
  FileHandlerEntry *ptr;
  __FC_assert(initialised_1 != 0,"sched.c",161,"initialised");
  __FC_assert(events != 0,"sched.c",162,"events");
  __FC_assert((fd >= 0) != 0,"sched.c",163,"fd >= 0");
  if (fd >= 1024) {
    {
      void *__va_args[1] = {(void *)0};
      LOG_Message(LOGS_FATAL,"Too many file descriptors",
                  (void * const *)(__va_args));
    }
    exit(1);
  }
  while (1) {
    unsigned int tmp;
    tmp = ARR_GetSize(file_handlers);
    ;
    if (! (tmp <= (unsigned int)fd)) break;
    ptr = (FileHandlerEntry *)ARR_GetNewElement(file_handlers);
    ptr->handler = (void (*)(int fd, int event, SCH_ArbitraryArgument ))0;
    ptr->arg = (void *)0;
    ptr->events = 0;
  }
  ptr = (FileHandlerEntry *)ARR_GetElement(file_handlers,(unsigned int)fd);
  __FC_assert(! ptr->handler != 0,"sched.c",181,"!ptr->handler");
  ptr->handler = handler;
  ptr->arg = arg;
  ptr->events = events;
  if (one_highest_fd < (unsigned int)(fd + 1)) one_highest_fd = (unsigned int)(
                                               fd + 1);
  return;
}

void SCH_RemoveFileHandler(int fd)
{
  FileHandlerEntry *ptr;
  __FC_assert(initialised_1 != 0,"sched.c",199,"initialised");
  ptr = (FileHandlerEntry *)ARR_GetElement(file_handlers,(unsigned int)fd);
  __FC_assert(ptr->handler != (void (*)(int fd, int event,
                                        SCH_ArbitraryArgument ))0,"sched.c",
              204,"ptr->handler");
  ptr->handler = (void (*)(int fd, int event, SCH_ArbitraryArgument ))0;
  ptr->arg = (void *)0;
  ptr->events = 0;
  while (one_highest_fd > (unsigned int)0) {
    ptr = (FileHandlerEntry *)ARR_GetElement(file_handlers,
                                             one_highest_fd - (unsigned int)1);
    if (ptr->handler) break;
    one_highest_fd --;
  }
  return;
}

void SCH_SetFileHandlerEvent(int fd, int event, int enable)
{
  FileHandlerEntry *ptr;
  ptr = (FileHandlerEntry *)ARR_GetElement(file_handlers,(unsigned int)fd);
  if (enable) ptr->events |= event; else ptr->events &= ~ event;
  return;
}

void SCH_GetLastEventTime(struct timespec *cooked, double *err,
                          struct timespec *raw)
{
  if (cooked) {
    *cooked = last_select_ts;
    if (err) *err = last_select_ts_err;
  }
  if (raw) *raw = last_select_ts_raw;
  return;
}

static TimerQueueEntry *allocate_tqe(void)
{
  TimerQueueEntry *new_block;
  TimerQueueEntry *result;
  int i;
  if (tqe_free_list == (TimerQueueEntry *)0) {
    new_block = (TimerQueueEntry *)Malloc2((size_t)32,
                                           sizeof(TimerQueueEntry));
    i = 1;
    while (i < 32) {
      (new_block + i)->next = new_block + (i - 1);
      i ++;
    }
    (new_block + 0)->next = (struct _TimerQueueEntry *)0;
    tqe_free_list = new_block + (32 - 1);
  }
  result = tqe_free_list;
  tqe_free_list = tqe_free_list->next;
  return result;
}

static void release_tqe(TimerQueueEntry *node)
{
  node->next = tqe_free_list;
  tqe_free_list = node;
  return;
}

static SCH_TimeoutID get_new_tqe_id(void)
{
  TimerQueueEntry *ptr;
  try_again: next_tqe_id ++;
  if (! next_tqe_id) goto try_again;
  ptr = timer_queue.next;
  while (ptr != & timer_queue) {
    if (ptr->id == next_tqe_id) goto try_again;
    ptr = ptr->next;
  }
  return next_tqe_id;
}

/*@ assigns \result;
    assigns \result \from \nothing; */
SCH_TimeoutID SCH_AddTimeout(struct timespec *ts,
                             void (*handler)(SCH_ArbitraryArgument ),
                             SCH_ArbitraryArgument arg)
{
  SCH_TimeoutID __retres;
  TimerQueueEntry *new_tqe;
  TimerQueueEntry *ptr;
  __FC_assert(initialised_1 != 0,"sched.c",313,"initialised");
  new_tqe = allocate_tqe();
  new_tqe->id = get_new_tqe_id();
  new_tqe->handler = handler;
  new_tqe->arg = arg;
  new_tqe->ts = *ts;
  new_tqe->class = SCH_ReservedTimeoutValue;
  ptr = timer_queue.next;
  while (ptr != & timer_queue) {
    {
      int tmp;
      tmp = UTI_CompareTimespecs(& new_tqe->ts,& ptr->ts);
      if (tmp == -1) break;
    }
    ptr = ptr->next;
  }
  new_tqe->next = ptr;
  new_tqe->prev = ptr->prev;
  (ptr->prev)->next = new_tqe;
  ptr->prev = new_tqe;
  n_timer_queue_entries ++;
  __retres = new_tqe->id;
  return __retres;
}

SCH_TimeoutID SCH_AddTimeoutByDelay(double delay,
                                    void (*handler)(SCH_ArbitraryArgument ),
                                    SCH_ArbitraryArgument arg)
{
  struct timespec now;
  struct timespec then;
  int tmp;
  SCH_TimeoutID tmp_0;
  __FC_assert(initialised_1 != 0,"sched.c",354,"initialised");
  __FC_assert((delay >= 0.0) != 0,"sched.c",355,"delay >= 0.0");
  LCL_ReadRawTime(& now);
  UTI_AddDoubleToTimespec(& now,delay,& then);
  tmp = UTI_CompareTimespecs(& now,& then);
  if (tmp > 0) {
    {
      void *__va_args[1] = {(void *)0};
      LOG_Message(LOGS_FATAL,"Timeout overflow",(void * const *)(__va_args));
    }
    exit(1);
  }
  tmp_0 = SCH_AddTimeout(& then,handler,arg);
  return tmp_0;
}

SCH_TimeoutID SCH_AddTimeoutInClass(double min_delay, double separation,
                                    double randomness,
                                    SCH_TimeoutClass class,
                                    void (*handler)(SCH_ArbitraryArgument ),
                                    SCH_ArbitraryArgument arg)
{
  SCH_TimeoutID __retres;
  TimerQueueEntry *new_tqe;
  TimerQueueEntry *ptr;
  struct timespec now;
  double diff;
  double r;
  double new_min_delay;
  __FC_assert(initialised_1 != 0,"sched.c",380,"initialised");
  __FC_assert((min_delay >= 0.0) != 0,"sched.c",381,"min_delay >= 0.0");
  __FC_assert((class < (unsigned int)SCH_NumberOfClasses) != 0,"sched.c",382,
              "class < SCH_NumberOfClasses");
  if (randomness > 0.0) {
    uint32_t rnd;
    UTI_GetRandomBytes((void *)(& rnd),(unsigned int)sizeof(rnd));
    r = (double)rnd * (randomness / (double)((uint32_t)(-1))) + 1.0;
    min_delay *= r;
    separation *= r;
  }
  LCL_ReadRawTime(& now);
  new_min_delay = min_delay;
  diff = UTI_DiffTimespecsToDouble(& now,& last_class_dispatch[class]);
  if (diff < separation) 
    if (diff >= 0.0) 
      if (diff + new_min_delay < separation) new_min_delay = separation - diff;
  ptr = timer_queue.next;
  while (ptr != & timer_queue) {
    if (ptr->class == class) {
      diff = UTI_DiffTimespecsToDouble(& ptr->ts,& now);
      if (new_min_delay > diff) {
        if (new_min_delay - diff < separation) new_min_delay = diff + separation;
      }
      else 
        if (diff - new_min_delay < separation) new_min_delay = diff + separation;
    }
    ptr = ptr->next;
  }
  ptr = timer_queue.next;
  while (ptr != & timer_queue) {
    diff = UTI_DiffTimespecsToDouble(& ptr->ts,& now);
    if (diff > new_min_delay) break;
    ptr = ptr->next;
  }
  new_tqe = allocate_tqe();
  new_tqe->id = get_new_tqe_id();
  new_tqe->handler = handler;
  new_tqe->arg = arg;
  UTI_AddDoubleToTimespec(& now,new_min_delay,& new_tqe->ts);
  new_tqe->class = class;
  new_tqe->next = ptr;
  new_tqe->prev = ptr->prev;
  (ptr->prev)->next = new_tqe;
  ptr->prev = new_tqe;
  n_timer_queue_entries ++;
  __retres = new_tqe->id;
  return __retres;
}

void SCH_RemoveTimeout(SCH_TimeoutID id)
{
  TimerQueueEntry *ptr;
  __FC_assert(initialised_1 != 0,"sched.c",451,"initialised");
  if (! id) goto return_label;
  ptr = timer_queue.next;
  while (ptr != & timer_queue) {
    if (ptr->id == id) {
      (ptr->next)->prev = ptr->prev;
      (ptr->prev)->next = ptr->next;
      n_timer_queue_entries --;
      release_tqe(ptr);
      goto return_label;
    }
    ptr = ptr->next;
  }
  __FC_assert(0 != 0,"sched.c",476,"0");
  return_label: return;
}

static void dispatch_timeouts(struct timespec *now)
{
  TimerQueueEntry *ptr;
  void (*handler)(SCH_ArbitraryArgument );
  SCH_ArbitraryArgument arg;
  int n_done = 0;
  int n_entries_on_start = (int)n_timer_queue_entries;
  while (1) {
    LCL_ReadRawTime(now);
    if (n_timer_queue_entries > (unsigned long)0) {
      int tmp;
      tmp = UTI_CompareTimespecs(now,& (timer_queue.next)->ts);
      if (! (tmp >= 0)) goto _LAND;
    }
    else _LAND: break;
    ptr = timer_queue.next;
    last_class_dispatch[ptr->class] = *now;
    handler = ptr->handler;
    arg = ptr->arg;
    SCH_RemoveTimeout(ptr->id);
    (*handler)(arg);
    n_done ++;
    if ((unsigned long)n_done > n_timer_queue_entries * (unsigned long)4) 
      if (n_done > n_entries_on_start * 4) {
        {
          void *__va_args[1] = {(void *)0};
          LOG_Message(LOGS_FATAL,"Possible infinite loop in scheduling",
                      (void * const *)(__va_args));
        }
        exit(1);
      }
  }
  return;
}

static void dispatch_filehandlers(int nfd, fd_set *read_fds,
                                  fd_set *write_fds, fd_set *except_fds)
{
  FileHandlerEntry *ptr;
  int fd;
  fd = 0;
  while (1) {
    if (nfd) {
      if (! ((unsigned int)fd < one_highest_fd)) break;
    }
    else break;
    if (except_fds) {
      int tmp_1;
      tmp_1 = FD_ISSET(fd,(fd_set const *)except_fds);
      if (tmp_1) {
        ptr = (FileHandlerEntry *)ARR_GetElement(file_handlers,
                                                 (unsigned int)fd);
        if (ptr->handler) (*(ptr->handler))(fd,4,ptr->arg);
        nfd --;
        if (read_fds) {
          int tmp_0;
          tmp_0 = FD_ISSET(fd,(fd_set const *)read_fds);
          if (tmp_0) {
            FD_CLR(fd,read_fds);
            nfd --;
          }
        }
      }
    }
    if (read_fds) {
      int tmp_3;
      tmp_3 = FD_ISSET(fd,(fd_set const *)read_fds);
      if (tmp_3) {
        ptr = (FileHandlerEntry *)ARR_GetElement(file_handlers,
                                                 (unsigned int)fd);
        if (ptr->handler) (*(ptr->handler))(fd,1,ptr->arg);
        nfd --;
      }
    }
    if (write_fds) {
      int tmp_5;
      tmp_5 = FD_ISSET(fd,(fd_set const *)write_fds);
      if (tmp_5) {
        ptr = (FileHandlerEntry *)ARR_GetElement(file_handlers,
                                                 (unsigned int)fd);
        if (ptr->handler) (*(ptr->handler))(fd,2,ptr->arg);
        nfd --;
      }
    }
    fd ++;
  }
  return;
}

static void handle_slew_0(struct timespec *raw, struct timespec *cooked,
                          double dfreq, double doffset,
                          LCL_ChangeType change_type, void *anything)
{
  TimerQueueEntry *ptr;
  double delta;
  int i;
  if (change_type != (unsigned int)LCL_ChangeAdjust) {
    int tmp;
    tmp = LCL_IsFirstParameterChangeHandler(& handle_slew_0);
    __FC_assert(tmp != 0,"sched.c",587,
                "LCL_IsFirstParameterChangeHandler(handle_slew)");
    ptr = timer_queue.next;
    while (ptr != & timer_queue) {
      UTI_AddDoubleToTimespec(& ptr->ts,- doffset,& ptr->ts);
      ptr = ptr->next;
    }
    i = 0;
    while (i < SCH_NumberOfClasses) {
      UTI_AddDoubleToTimespec(& last_class_dispatch[i],- doffset,
                              & last_class_dispatch[i]);
      i ++;
    }
    UTI_AddDoubleToTimespec(& last_select_ts_raw,- doffset,
                            & last_select_ts_raw);
  }
  UTI_AdjustTimespec(& last_select_ts,cooked,& last_select_ts,& delta,dfreq,
                     doffset);
  return;
}

static void fill_fd_sets(fd_set **read_fds, fd_set **write_fds,
                         fd_set **except_fds)
{
  FileHandlerEntry *handlers;
  fd_set *rd;
  fd_set *wr;
  fd_set *ex;
  int i;
  int n;
  int events;
  unsigned int tmp;
  tmp = ARR_GetSize(file_handlers);
  n = (int)tmp;
  handlers = (FileHandlerEntry *)ARR_GetElements(file_handlers);
  ex = (fd_set *)0;
  wr = ex;
  rd = wr;
  i = 0;
  while (i < n) {
    events = (handlers + i)->events;
    if (! events) goto __Cont;
    if (events & 1) {
      if (! rd) {
        rd = *read_fds;
        FD_ZERO(rd);
      }
      FD_SET(i,rd);
    }
    if (events & 2) {
      if (! wr) {
        wr = *write_fds;
        FD_ZERO(wr);
      }
      FD_SET(i,wr);
    }
    if (events & 4) {
      if (! ex) {
        ex = *except_fds;
        FD_ZERO(ex);
      }
      FD_SET(i,ex);
    }
    __Cont: i ++;
  }
  if (! rd) *read_fds = (fd_set *)0;
  if (! wr) *write_fds = (fd_set *)0;
  if (! ex) *except_fds = (fd_set *)0;
  return;
}

static int check_current_time(struct timespec *prev_raw,
                              struct timespec *raw, int timeout,
                              struct timeval *orig_select_tv,
                              struct timeval *rem_select_tv)
{
  int __retres;
  struct timespec elapsed_min;
  struct timespec elapsed_max;
  struct timespec orig_select_ts;
  struct timespec rem_select_ts;
  double step;
  double elapsed;
  double tmp;
  UTI_TimevalToTimespec(orig_select_tv,& orig_select_ts);
  if (timeout) {
    elapsed_min = orig_select_ts;
    elapsed_max = elapsed_min;
  }
  else 
    if (rem_select_tv) {
      if (rem_select_tv->tv_sec >= (time_t)0) {
        if (rem_select_tv->tv_sec <= orig_select_tv->tv_sec) {
          if (rem_select_tv->tv_sec != orig_select_tv->tv_sec) goto _LOR;
          else 
            if (rem_select_tv->tv_usec != orig_select_tv->tv_usec) {
              _LOR:
              {
                UTI_TimevalToTimespec(rem_select_tv,& rem_select_ts);
                UTI_DiffTimespecs(& elapsed_min,& orig_select_ts,
                                  & rem_select_ts);
                elapsed_max = elapsed_min;
              }
            }
            else goto _LAND_1;
        }
        else goto _LAND_1;
      }
      else goto _LAND_1;
    }
    else {
      _LAND_1:
      {
        if (rem_select_tv) elapsed_max = orig_select_ts;
        else UTI_DiffTimespecs(& elapsed_max,raw,prev_raw);
        UTI_ZeroTimespec(& elapsed_min);
      }
    }
  if (last_select_ts_raw.tv_sec + elapsed_min.tv_sec > raw->tv_sec + (long)10) {
    {
      void *__va_args[1] = {(void *)0};
      LOG_Message(LOGS_WARN,"Backward time jump detected!",
                  (void * const *)(__va_args));
    }
  }
  else 
    if ((prev_raw->tv_sec + elapsed_max.tv_sec) + (long)10 < raw->tv_sec) {
      {
        void *__va_args_15[1] = {(void *)0};
        LOG_Message(LOGS_WARN,"Forward time jump detected!",
                    (void * const *)(__va_args_15));
      }
    }
    else {
      __retres = 1;
      goto return_label;
    }
  step = UTI_DiffTimespecsToDouble(& last_select_ts_raw,raw);
  elapsed = UTI_TimespecToDouble(& elapsed_min);
  step += elapsed;
  tmp = fabs(step);
  ;
  ;
  ;
  LCL_NotifyExternalTimeStep(raw,raw,step,tmp);
  __retres = 0;
  return_label: return __retres;
}

void SCH_MainLoop(void)
{
  fd_set read_fds;
  fd_set write_fds;
  fd_set except_fds;
  fd_set *p_read_fds;
  fd_set *p_write_fds;
  fd_set *p_except_fds;
  int status;
  int errsv;
  struct timeval tv;
  struct timeval saved_tv;
  struct timeval *ptv;
  struct timespec ts;
  struct timespec now;
  struct timespec saved_now;
  struct timespec cooked;
  double err;
  __FC_assert(initialised_1 != 0,"sched.c",723,"initialised");
  while (! need_to_exit) {
    int tmp_0;
    dispatch_timeouts(& now);
    saved_now = now;
    if (need_to_exit) break;
    if (n_timer_queue_entries > (unsigned long)0) {
      int tmp;
      UTI_DiffTimespecs(& ts,& (timer_queue.next)->ts,& now);
      if (ts.tv_sec > (long)0) tmp = 1;
      else 
        if (ts.tv_nsec > (long)0) tmp = 1; else tmp = 0;
      __FC_assert(tmp != 0,"sched.c",737,"ts.tv_sec > 0 || ts.tv_nsec > 0");
      UTI_TimespecToTimeval(& ts,& tv);
      ptv = & tv;
      saved_tv = tv;
    }
    else {
      ptv = (struct timeval *)0;
      saved_tv.tv_usec = 0;
      saved_tv.tv_sec = (time_t)saved_tv.tv_usec;
    }
    p_read_fds = & read_fds;
    p_write_fds = & write_fds;
    p_except_fds = & except_fds;
    fill_fd_sets(& p_read_fds,& p_write_fds,& p_except_fds);
    if (! ptv) 
      if (! p_read_fds) 
        if (! p_write_fds) {
          {
            void *__va_args[1] = {(void *)0};
            LOG_Message(LOGS_FATAL,"Nothing to do",
                        (void * const *)(__va_args));
          }
          exit(1);
        }
    status = select((int)one_highest_fd,p_read_fds,p_write_fds,p_except_fds,
                    ptv);
    errsv = __fc_errno;
    LCL_ReadRawTime(& now);
    LCL_CookTime(& now,& cooked,& err);
    tmp_0 = check_current_time(& saved_now,& now,status == 0,& saved_tv,ptv);
    if (! tmp_0) LCL_CookTime(& now,& cooked,& err);
    last_select_ts_raw = now;
    last_select_ts = cooked;
    last_select_ts_err = err;
    if (status < 0) {
      if (! need_to_exit) 
        if (errsv != 4) {
          char *tmp_1;
          tmp_1 = strerror(errsv);
          {
            char *__va_arg0 = tmp_1;
            void *__va_args_23[1] = {& __va_arg0};
            LOG_Message(LOGS_FATAL,"select() failed : %s",
                        (void * const *)(__va_args_23));
          }
          exit(1);
        }
    }
    else 
      if (status > 0) dispatch_filehandlers(status,p_read_fds,p_write_fds,
                                            p_except_fds);
      else __FC_assert(ptv != (struct timeval *)0,"sched.c",783,"ptv");
  }
  return;
}

void SCH_QuitProgram(void)
{
  need_to_exit = 1;
  return;
}

static struct stage stages[3];
static int enabled;
static int leap_only_mode;
static int locked;
static double max_wander;
static double max_freq;
static double smooth_freq;
static double smooth_offset;
static struct timespec last_update;
static void get_smoothing(struct timespec *now, double *poffset,
                          double *pfreq, double *pwander)
{
  double elapsed;
  double length;
  double offset;
  double freq;
  double wander;
  int i;
  elapsed = UTI_DiffTimespecsToDouble(now,& last_update);
  offset = smooth_offset;
  freq = smooth_freq;
  wander = 0.0;
  i = 0;
  while (i < 3) {
    if (elapsed <= 0.0) break;
    length = stages[i].length;
    if (length >= elapsed) length = elapsed;
    wander = stages[i].wander;
    offset -= (length * (2.0 * freq + wander * length)) / 2.0;
    freq += wander * length;
    elapsed -= length;
    i ++;
  }
  if (elapsed > 0.0) {
    wander = 0.0;
    offset -= elapsed * freq;
  }
  *poffset = offset;
  *pfreq = freq;
  if (pwander) *pwander = wander;
  return;
}

static void update_stages(void)
{
  double s1;
  double s2;
  double s;
  double l1;
  double l2;
  double l3;
  double lc;
  double f;
  double f2;
  double l1t[2];
  double l3t[2];
  double err[2];
  int i;
  int dir;
  s1 = smooth_offset / max_wander;
  s2 = (smooth_freq * smooth_freq) / (2.0 * (max_wander * max_wander));
  i = 0;
  dir = -1;
  while (i <= 1) {
    err[i] = 0.0;
    s = (double)dir * s1 + s2;
    if (s < 0.0) {
      err[i] += - s;
      s = 0.0;
    }
    l3t[i] = sqrt(s);
    l1t[i] = l3t[i] - ((double)dir * smooth_freq) / max_wander;
    if (l1t[i] < 0.0) {
      err[i] += l1t[i] * l1t[i];
      l1t[i] = 0.0;
    }
    i ++;
    dir += 2;
  }
  if (err[0] < err[1]) {
    l1 = l1t[0];
    l3 = l3t[0];
    dir = -1;
  }
  else {
    l1 = l1t[1];
    l3 = l3t[1];
    dir = 1;
  }
  l2 = 0.0;
  f = ((double)dir * smooth_freq + l1 * max_wander) - max_freq;
  if (f > 0.0) {
    lc = f / max_wander;
    if (lc > l1) {
      lc = l1;
      f2 = (double)dir * smooth_freq;
    }
    else f2 = max_freq;
    l2 = lc * (2.0 + f / f2);
    l1 -= lc;
    l3 -= lc;
  }
  stages[0].wander = (double)dir * max_wander;
  stages[0].length = l1;
  stages[1].wander = 0.0;
  stages[1].length = l2;
  stages[2].wander = (double)(- dir) * max_wander;
  stages[2].length = l3;
  i = 0;
  while (i < 3) i ++;
  return;
}

static void update_smoothing(struct timespec *now, double offset, double freq)
{
  if (locked) {
    double tmp;
    tmp = REF_GetSkew();
    ;
    if (tmp / max_wander < (double)10000) SMT_Activate(now);
    else 
      if (leap_only_mode) SMT_Activate(now);
    goto return_label;
  }
  get_smoothing(now,& smooth_offset,& smooth_freq,(double *)0);
  smooth_offset += offset;
  smooth_freq = (smooth_freq - freq) / (1.0 - freq);
  last_update = *now;
  update_stages();
  return_label: return;
}

static void handle_slew_1(struct timespec *raw, struct timespec *cooked,
                          double dfreq, double doffset,
                          LCL_ChangeType change_type, void *anything)
{
  double delta;
  int tmp;
  if (change_type == (unsigned int)LCL_ChangeAdjust) 
    if (leap_only_mode) update_smoothing(cooked,0.0,0.0);
    else update_smoothing(cooked,doffset,dfreq);
  tmp = UTI_IsZeroTimespec(& last_update);
  if (! tmp) UTI_AdjustTimespec(& last_update,cooked,& last_update,& delta,
                                dfreq,doffset);
  return;
}

void SMT_Initialise(void)
{
  CNF_GetSmooth(& max_freq,& max_wander,& leap_only_mode);
  if (max_freq <= 0.0) goto _LOR;
  else 
    if (max_wander <= 0.0) {
      _LOR: {
              enabled = 0;
              goto return_label;
            }
    }
  enabled = 1;
  locked = 1;
  max_freq *= 1e-6;
  max_wander *= 1e-6;
  UTI_ZeroTimespec(& last_update);
  LCL_AddParameterChangeHandler(& handle_slew_1,(void *)0);
  return_label: return;
}

void SMT_Finalise(void)
{
  return;
}

int SMT_IsEnabled(void)
{
  return enabled;
}

double SMT_GetOffset(struct timespec *now)
{
  double __retres;
  double offset;
  double freq;
  if (! enabled) {
    __retres = 0.0;
    goto return_label;
  }
  get_smoothing(now,& offset,& freq,(double *)0);
  __retres = offset;
  return_label: return __retres;
}

void SMT_Activate(struct timespec *now)
{
  char const *tmp;
  if (! enabled) goto return_label;
  else 
    if (! locked) goto return_label;
  if (leap_only_mode) tmp = " (leap seconds only)"; else tmp = "";
  {
    char const *__va_arg0 = tmp;
    void *__va_args[1] = {& __va_arg0};
    LOG_Message(LOGS_INFO,"Time smoothing activated%s",
                (void * const *)(__va_args));
  }
  locked = 0;
  last_update = *now;
  return_label: return;
}

void SMT_Reset(struct timespec *now)
{
  int i;
  if (! enabled) goto return_label;
  smooth_offset = 0.0;
  smooth_freq = 0.0;
  last_update = *now;
  i = 0;
  while (i < 3) {
    double tmp;
    tmp = 0.0;
    stages[i].length = tmp;
    stages[i].wander = tmp;
    i ++;
  }
  return_label: return;
}

void SMT_Leap(struct timespec *now, int leap)
{
  if (! enabled) goto return_label;
  else 
    if (! leap_only_mode) goto return_label;
  update_smoothing(now,(double)leap,0.0);
  return_label: return;
}

int SMT_GetSmoothingReport(RPT_SmoothingReport *report, struct timespec *now)
{
  int __retres;
  double length;
  double elapsed;
  int i;
  if (! enabled) {
    __retres = 0;
    goto return_label;
  }
  report->active = ! locked;
  report->leap_only = leap_only_mode;
  get_smoothing(now,& report->offset,& report->freq_ppm,& report->wander_ppm);
  report->freq_ppm *= - 1.0e6;
  report->wander_ppm *= - 1.0e6;
  elapsed = UTI_DiffTimespecsToDouble(now,& last_update);
  if (! locked) {
    if (elapsed >= 0.0) {
      i = 0;
      length = 0.0;
      while (i < 3) {
        length += stages[i].length;
        i ++;
      }
      report->last_update_ago = elapsed;
      if (elapsed < length) report->remaining_time = length - elapsed;
      else report->remaining_time = 0.0;
    }
    else goto _LAND;
  }
  else {
    _LAND: {
             report->last_update_ago = 0.0;
             report->remaining_time = 0.0;
           }
  }
  __retres = 1;
  return_label: return __retres;
}

static int initialised_2 = 0;
static struct SRC_Instance_Record **sources;
static struct Sort_Element *sort_list;
static int *sel_sources;
static int n_sources;
static int max_n_sources;
static int selected_source_index;
static double max_distance_0;
static double max_jitter_0;
static double reselect_distance_0;
static double stratum_weight_0;
static double combine_limit_0;
static void slew_sources(struct timespec *raw, struct timespec *cooked,
                         double dfreq, double doffset,
                         LCL_ChangeType change_type, void *anything);

static void add_dispersion(double dispersion, void *anything);

static char *source_to_string(SRC_Instance inst);

void SRC_Initialise(void)
{
  sources = (struct SRC_Instance_Record **)0;
  sort_list = (struct Sort_Element *)0;
  sel_sources = (int *)0;
  n_sources = 0;
  max_n_sources = 0;
  selected_source_index = -1;
  max_distance_0 = CNF_GetMaxDistance();
  max_jitter_0 = CNF_GetMaxJitter();
  reselect_distance_0 = CNF_GetReselectDistance();
  stratum_weight_0 = CNF_GetStratumWeight();
  combine_limit_0 = CNF_GetCombineLimit();
  initialised_2 = 1;
  LCL_AddParameterChangeHandler(& slew_sources,(void *)0);
  LCL_AddDispersionNotifyHandler(& add_dispersion,(void *)0);
  return;
}

void SRC_Finalise(void)
{
  LCL_RemoveParameterChangeHandler(& slew_sources,(void *)0);
  LCL_RemoveDispersionNotifyHandler(& add_dispersion,(void *)0);
  free((void *)sources);
  free((void *)sort_list);
  free((void *)sel_sources);
  initialised_2 = 0;
  return;
}

SRC_Instance SRC_CreateNewInstance(uint32_t ref_id, SRC_Type type,
                                   int sel_options, IPAddr *addr,
                                   int min_samples_0, int max_samples_0,
                                   double min_delay, double asymmetry)
{
  SRC_Instance result;
  __FC_assert(initialised_2 != 0,"sources.c",222,"initialised");
  if (min_samples_0 == -1) min_samples_0 = CNF_GetMinSamples();
  if (max_samples_0 == -1) max_samples_0 = CNF_GetMaxSamples();
  result = (SRC_Instance)Malloc(sizeof(struct SRC_Instance_Record));
  result->stats = SST_CreateInstance(ref_id,addr,min_samples_0,max_samples_0,
                                     min_delay,asymmetry);
  if (n_sources == max_n_sources) {
    if (max_n_sources > 0) max_n_sources = 2 * max_n_sources;
    else max_n_sources = 4;
    if (sources) {
      sources = (struct SRC_Instance_Record **)Realloc2((void *)sources,
                                                        (size_t)max_n_sources,
                                                        sizeof(struct SRC_Instance_Record *));
      sort_list = (struct Sort_Element *)Realloc2((void *)sort_list,
                                                  (size_t)(3 * max_n_sources),
                                                  sizeof(struct Sort_Element));
      sel_sources = (int *)Realloc2((void *)sel_sources,
                                    (size_t)max_n_sources,sizeof(int));
    }
    else {
      sources = (struct SRC_Instance_Record **)Malloc2((size_t)max_n_sources,
                                                       sizeof(struct SRC_Instance_Record *));
      sort_list = (struct Sort_Element *)Malloc2((size_t)(3 * max_n_sources),
                                                 sizeof(struct Sort_Element));
      sel_sources = (int *)Malloc2((size_t)max_n_sources,sizeof(int));
    }
  }
  *(sources + n_sources) = result;
  result->index = n_sources;
  result->type = type;
  result->sel_options = sel_options;
  SRC_SetRefid(result,ref_id,addr);
  SRC_ResetInstance(result);
  n_sources ++;
  return result;
}

void SRC_DestroyInstance(SRC_Instance instance)
{
  int dead_index;
  int i;
  __FC_assert(initialised_2 != 0,"sources.c",271,"initialised");
  SST_DeleteInstance(instance->stats);
  dead_index = instance->index;
  i = dead_index;
  while (i < n_sources - 1) {
    *(sources + i) = *(sources + (i + 1));
    (*(sources + i))->index = i;
    i ++;
  }
  n_sources --;
  free((void *)instance);
  if (selected_source_index == dead_index) SRC_ReselectSource();
  else 
    if (selected_source_index > dead_index) selected_source_index --;
  return;
}

void SRC_ResetInstance(SRC_Instance instance)
{
  instance->active = 0;
  instance->updates = 0;
  instance->reachability = 0;
  instance->reachability_size = 0;
  instance->distant = 0;
  instance->status = SRC_BAD_STATS;
  instance->sel_score = 1.0;
  SST_ResetInstance(instance->stats);
  return;
}

void SRC_SetRefid(SRC_Instance instance, uint32_t ref_id, IPAddr *addr)
{
  instance->ref_id = ref_id;
  instance->ip_addr = addr;
  SST_SetRefid(instance->stats,ref_id,addr);
  return;
}

SST_Stats SRC_GetSourcestats(SRC_Instance instance)
{
  SST_Stats __retres;
  __FC_assert(initialised_2 != 0,"sources.c",320,"initialised");
  __retres = instance->stats;
  return __retres;
}

void SRC_AccumulateSample(SRC_Instance inst, NTP_Sample *sample)
{
  int tmp_1;
  __FC_assert(initialised_2 != 0,"sources.c",338,"initialised");
  tmp_1 = REF_IsLeapSecondClose();
  if (tmp_1) {
    {
      void *__va_args[1] = {(void *)0};
      LOG_Message(LOGS_INFO,"Dropping sample around leap second",
                  (void * const *)(__va_args));
    }
    goto return_label;
  }
  SST_AccumulateSample(inst->stats,sample);
  SST_DoNewRegression(inst->stats);
  return_label: return;
}

void SRC_SetActive(SRC_Instance inst)
{
  inst->active = 1;
  return;
}

void SRC_UnsetActive(SRC_Instance inst)
{
  inst->active = 0;
  return;
}

static int special_mode_end(void)
{
  int __retres;
  int i;
  i = 0;
  while (i < n_sources) {
    {
      int tmp;
      if (! (*(sources + i))->active) goto __Cont;
      if ((*(sources + i))->reachability_size >= 8 - 1) goto __Cont;
      tmp = SST_Samples((*(sources + i))->stats);
      ;
      if (((8 - 1) - (*(sources + i))->reachability_size) + tmp >= 3) {
        __retres = 0;
        goto return_label;
      }
    }
    __Cont: i ++;
  }
  __retres = 1;
  return_label: return __retres;
}

void SRC_UpdateReachability(SRC_Instance inst, int reachable)
{
  REF_Mode tmp;
  inst->reachability <<= 1;
  inst->reachability |= ! (! reachable);
  inst->reachability = (int)((unsigned int)inst->reachability % (1U << 8));
  if (inst->reachability_size < 8) (inst->reachability_size) ++;
  if (! reachable) 
    if (inst->index == selected_source_index) SRC_SelectSource((SRC_Instance)0);
  tmp = REF_GetMode();
  if (tmp != (unsigned int)REF_ModeNormal) {
    int tmp_0;
    tmp_0 = special_mode_end();
    if (tmp_0) REF_SetUnsynchronised();
  }
  if (inst->type == (unsigned int)SRC_NTP) 
    if (! inst->reachability) {
      if (inst->reachability_size == 8) goto _LOR; else goto _LAND;
    }
    else {
      _LAND: ;
      if (inst->status == (unsigned int)SRC_BAD_DISTANCE) goto _LOR;
      else 
        if (inst->status == (unsigned int)SRC_JITTERY) goto _LOR;
        else 
          if (inst->status == (unsigned int)SRC_FALSETICKER) _LOR:
                                                             NSR_HandleBadSource
                                                             (inst->ip_addr);
    }
  return;
}

void SRC_ResetReachability(SRC_Instance inst)
{
  inst->reachability = 0;
  inst->reachability_size = 0;
  SRC_UpdateReachability(inst,0);
  return;
}

static void log_selection_message(char *format, char *arg)
{
  REF_Mode tmp;
  tmp = REF_GetMode();
  if (tmp != (unsigned int)REF_ModeNormal) goto return_label;
  {
    char *__va_arg0 = arg;
    void *__va_args[1] = {& __va_arg0};
    LOG_Message(LOGS_INFO,(char const *)format,(void * const *)(__va_args));
  }
  return_label: return;
}

static int compare_sort_elements(void const *a, void const *b)
{
  int __retres;
  struct Sort_Element const *u = (struct Sort_Element const *)a;
  struct Sort_Element const *v = (struct Sort_Element const *)b;
  if (u->offset < v->offset) {
    __retres = -1;
    goto return_label;
  }
  else 
    if (u->offset > v->offset) {
      __retres = 1;
      goto return_label;
    }
    else 
      if (u->tag < v->tag) {
        __retres = -1;
        goto return_label;
      }
      else 
        if (u->tag > v->tag) {
          __retres = 1;
          goto return_label;
        }
        else {
          __retres = 0;
          goto return_label;
        }
  return_label: return __retres;
}

static char *source_to_string(SRC_Instance inst)
{
  char *__retres;
  switch (inst->type) {
    char *tmp;
    char *tmp_0;
    case SRC_NTP: tmp = UTI_IPToString(inst->ip_addr);
    __retres = tmp;
    goto return_label;
    case SRC_REFCLOCK: tmp_0 = UTI_RefidToString(inst->ref_id);
    __retres = tmp_0;
    goto return_label;
    default: __FC_assert(0 != 0,"sources.c",476,"0");
  }
  __retres = (char *)0;
  return_label: return __retres;
}

static void mark_ok_sources(SRC_Status status)
{
  int i;
  i = 0;
  /*@ loop unroll 2; */
  while (i < n_sources) {
    if ((*(sources + i))->status != (unsigned int)SRC_OK) goto __Cont;
    (*(sources + i))->status = status;
    __Cont: i ++;
  }
  return;
}

static int combine_sources(int n_sel_sources, struct timespec *ref_time,
                           double *offset, double *offset_sd,
                           double *frequency, double *frequency_sd,
                           double *skew)
{
  int __retres;
  struct timespec src_ref_time;
  double src_offset;
  double src_offset_sd;
  double src_frequency;
  double src_frequency_sd;
  double src_skew;
  double src_root_delay;
  double src_root_dispersion;
  double sel_src_distance;
  double elapsed;
  double offset_weight;
  double sum_offset_weight;
  double sum_offset;
  double sum2_offset_sd;
  double frequency_weight;
  double sum_frequency_weight;
  double sum_frequency;
  double inv_sum2_frequency_sd;
  double inv_sum2_skew;
  int i;
  int index_0;
  int combined;
  double tmp_1;
  double tmp_2;
  if (n_sel_sources == 1) {
    __retres = 1;
    goto return_label;
  }
  sum2_offset_sd = 0.0;
  sum_offset = sum2_offset_sd;
  sum_offset_weight = sum_offset;
  inv_sum2_skew = 0.0;
  inv_sum2_frequency_sd = inv_sum2_skew;
  sum_frequency = inv_sum2_frequency_sd;
  sum_frequency_weight = sum_frequency;
  sel_src_distance = (*(sources + selected_source_index))->sel_info.root_distance;
  if ((*(sources + selected_source_index))->type == (unsigned int)SRC_NTP) 
    sel_src_distance += reselect_distance_0;
  combined = 0;
  i = combined;
  /*@ loop unroll 2; */
  while (i < n_sel_sources) {
    index_0 = *(sel_sources + i);
    SST_GetTrackingData((*(sources + index_0))->stats,& src_ref_time,
                        & src_offset,& src_offset_sd,& src_frequency,
                        & src_frequency_sd,& src_skew,& src_root_delay,
                        & src_root_dispersion);
    if (index_0 != selected_source_index) {
      if ((*(sources + index_0))->sel_info.root_distance > combine_limit_0 * sel_src_distance) 
        goto _LOR;
      else {
        double tmp;
        double tmp_0;
        tmp = fabs(*frequency - src_frequency);
        tmp_0 = LCL_GetMaxClockError();
        ;
        if (tmp > combine_limit_0 * ((*skew + src_skew) + tmp_0)) 
          _LOR:
          if ((*(sources + index_0))->reachability_size >= 8) (*(sources + index_0))->distant = 32;
          else (*(sources + index_0))->distant = 1;
        else goto _LAND;
      }
    }
    else {
      _LAND: ;
      if ((*(sources + index_0))->distant) ((*(sources + index_0))->distant) --;
    }
    if ((*(sources + index_0))->distant) {
      (*(sources + index_0))->status = SRC_DISTANT;
      goto __Cont;
    }
    if ((*(sources + index_0))->status == (unsigned int)SRC_OK) (*(sources + index_0))->status = SRC_UNSELECTED;
    elapsed = UTI_DiffTimespecsToDouble(ref_time,& src_ref_time);
    src_offset += elapsed * src_frequency;
    src_offset_sd += elapsed * src_frequency_sd;
    offset_weight = 1.0 / (*(sources + index_0))->sel_info.root_distance;
    frequency_weight = 1.0 / (src_frequency_sd * src_frequency_sd);
    sum_offset_weight += offset_weight;
    sum_offset += offset_weight * src_offset;
    sum2_offset_sd += offset_weight * (src_offset_sd * src_offset_sd + 
                                       (src_offset - *offset) * (src_offset - *offset));
    sum_frequency_weight += frequency_weight;
    sum_frequency += frequency_weight * src_frequency;
    inv_sum2_frequency_sd += 1.0 / (src_frequency_sd * src_frequency_sd);
    inv_sum2_skew += 1.0 / (src_skew * src_skew);
    combined ++;
    __Cont: i ++;
  }
  __FC_assert(combined != 0,"sources.c",574,"combined");
  *offset = sum_offset / sum_offset_weight;
  *offset_sd = sqrt(sum2_offset_sd / sum_offset_weight);
  *frequency = sum_frequency / sum_frequency_weight;
  tmp_1 = sqrt(inv_sum2_frequency_sd);
  *frequency_sd = 1.0 / tmp_1;
  tmp_2 = sqrt(inv_sum2_skew);
  *skew = 1.0 / tmp_2;
  __retres = combined;
  return_label: return __retres;
}

void SRC_SelectSource(SRC_Instance updated_inst)
{
  struct SelectInfo *si;
  struct timespec now;
  struct timespec ref_time;
  int i;
  int j;
  int j1;
  int j2;
  int index_0;
  int sel_prefer;
  int n_endpoints;
  int n_sel_sources;
  int sel_req_source;
  int n_badstats_sources;
  int max_sel_reach;
  int max_sel_reach_size;
  int max_badstat_reach;
  int depth;
  int best_depth;
  int trust_depth;
  int best_trust_depth;
  int combined;
  int stratum;
  int min_stratum;
  int max_score_index;
  int orphan_stratum;
  int orphan_source;
  int leap_votes;
  int leap_ins;
  int leap_del;
  double src_offset;
  double src_offset_sd;
  double src_frequency;
  double src_frequency_sd;
  double src_skew;
  double src_root_delay;
  double src_root_dispersion;
  double best_lo;
  double best_hi;
  double distance;
  double sel_src_distance;
  double max_score;
  double first_sample_ago;
  double max_reach_sample_ago;
  NTP_Leap leap_status;
  if (updated_inst) (updated_inst->updates) ++;
  if (n_sources == 0) {
    if (selected_source_index != -1) {
      log_selection_message((char *)"Can\'t synchronise: no sources",
                            (char *)0);
      selected_source_index = -1;
    }
    goto return_label;
  }
  SCH_GetLastEventTime(& now,(double *)0,(struct timespec *)0);
  n_endpoints = 0;
  n_sel_sources = 0;
  n_badstats_sources = 0;
  sel_req_source = 0;
  max_badstat_reach = 0;
  max_sel_reach = max_badstat_reach;
  max_sel_reach_size = 0;
  max_reach_sample_ago = 0.0;
  i = 0;
  /*@ loop unroll 2; */
  while (i < n_sources) {
    __FC_assert(((*(sources + i))->status != (unsigned int)SRC_OK) != 0,
                "sources.c",634,"sources[i]->status != SRC_OK");
    if ((*(sources + i))->sel_options & 0x8) sel_req_source = 1;
    if ((*(sources + i))->sel_options & 0x1) {
      (*(sources + i))->status = SRC_UNSELECTABLE;
      goto __Cont;
    }
    si = & (*(sources + i))->sel_info;
    SST_GetSelectionData((*(sources + i))->stats,& now,& si->stratum,
                         & si->leap,& si->lo_limit,& si->hi_limit,
                         & si->root_distance,& si->std_dev,
                         & first_sample_ago,& si->last_sample_ago,
                         & si->select_ok);
    if (! si->select_ok) {
      n_badstats_sources ++;
      (*(sources + i))->status = SRC_BAD_STATS;
      if (max_badstat_reach < (*(sources + i))->reachability) max_badstat_reach = (*(
                                                              sources + i))->reachability;
      goto __Cont;
    }
    if (first_sample_ago < 2.0 * si->last_sample_ago) {
      double tmp;
      tmp = LCL_GetMaxClockError();
      double extra_disp =
        tmp * (2.0 * si->last_sample_ago - first_sample_ago);
      si->root_distance += extra_disp;
      si->lo_limit -= extra_disp;
      si->hi_limit += extra_disp;
    }
    if (si->root_distance > max_distance_0) {
      (*(sources + i))->status = SRC_BAD_DISTANCE;
      goto __Cont;
    }
    if (si->std_dev > max_jitter_0) {
      (*(sources + i))->status = SRC_JITTERY;
      goto __Cont;
    }
    (*(sources + i))->status = SRC_OK;
    if ((*(sources + i))->reachability) 
      if (max_reach_sample_ago < first_sample_ago) max_reach_sample_ago = first_sample_ago;
    if (max_sel_reach < (*(sources + i))->reachability) max_sel_reach = (*(
                                                        sources + i))->reachability;
    if (max_sel_reach_size < (*(sources + i))->reachability_size) max_sel_reach_size = (*(
                                                                  sources + i))->reachability_size;
    __Cont: i ++;
  }
  orphan_stratum = REF_GetOrphanStratum();
  orphan_source = -1;
  i = 0;
  /*@ loop unroll 2; */
  while (i < n_sources) {
    if ((*(sources + i))->status != (unsigned int)SRC_OK) goto __Cont_0;
    si = & (*(sources + i))->sel_info;
    if (! (*(sources + i))->reachability) 
      if (max_reach_sample_ago < si->last_sample_ago) {
        (*(sources + i))->status = SRC_STALE;
        goto __Cont_0;
      }
    if (si->stratum >= orphan_stratum) 
      if ((*(sources + i))->type == (unsigned int)SRC_NTP) {
        (*(sources + i))->status = SRC_ORPHAN;
        if (si->stratum == orphan_stratum) 
          if ((*(sources + i))->reachability) 
            if (orphan_source == -1) orphan_source = i;
            else 
              if ((*(sources + i))->ref_id < (*(sources + orphan_source))->ref_id) 
                orphan_source = i;
        goto __Cont_0;
      }
    n_sel_sources ++;
    __Cont_0: i ++;
  }
  if (! n_sel_sources) 
    if (orphan_source != -1) {
      uint32_t local_ref_id =
        NSR_GetLocalRefid((*(sources + orphan_source))->ip_addr);
      if (! local_ref_id) {
        {
          void *__va_args[1] = {(void *)0};
          LOG_Message(LOGS_ERR,"Unknown local refid in orphan mode",
                      (void * const *)(__va_args));
        }
      }
      else 
        if ((*(sources + orphan_source))->ref_id < local_ref_id) {
          (*(sources + orphan_source))->status = SRC_OK;
          n_sel_sources = 1;
        }
    }
  i = 0;
  /*@ loop unroll 2; */
  while (i < n_sources) {
    if ((*(sources + i))->status != (unsigned int)SRC_OK) goto __Cont_1;
    si = & (*(sources + i))->sel_info;
    j1 = n_endpoints;
    j2 = j1 + 1;
    (sort_list + j1)->index = i;
    (sort_list + j1)->offset = si->lo_limit;
    (sort_list + j1)->tag = LOW;
    (sort_list + j2)->index = i;
    (sort_list + j2)->offset = si->hi_limit;
    (sort_list + j2)->tag = HIGH;
    n_endpoints += 2;
    __Cont_1: i ++;
  }
  if (n_badstats_sources) 
    if (n_sel_sources) 
      if (selected_source_index == -1) 
        if (max_sel_reach_size < 8) 
          if (max_sel_reach >> 1 == max_badstat_reach) {
            mark_ok_sources(SRC_WAITS_STATS);
            goto return_label;
          }
  if (n_endpoints == 0) {
    if (selected_source_index != -1) {
      log_selection_message((char *)"Can\'t synchronise: no selectable sources",
                            (char *)0);
      selected_source_index = -1;
    }
    goto return_label;
  }
  qsort((void *)sort_list,(size_t)n_endpoints,sizeof(struct Sort_Element),
        & compare_sort_elements);
  best_trust_depth = 0;
  trust_depth = best_trust_depth;
  best_depth = 0;
  depth = best_depth;
  best_hi = 0.0;
  best_lo = best_hi;
  i = 0;
  /*@ loop unroll 4; */
  while (i < n_endpoints) {
    switch ((sort_list + i)->tag) {
      case LOW: depth ++;
      if ((*(sources + (sort_list + i)->index))->sel_options & 0x4) trust_depth ++;
      if (trust_depth > best_trust_depth) goto _LOR;
      else 
        if (trust_depth == best_trust_depth) 
          if (depth > best_depth) {
            _LOR:
            {
              best_trust_depth = trust_depth;
              best_depth = depth;
              best_lo = (sort_list + i)->offset;
            }
          }
      break;
      case HIGH: ;
      if (trust_depth == best_trust_depth) 
        if (depth == best_depth) best_hi = (sort_list + i)->offset;
      if ((*(sources + (sort_list + i)->index))->sel_options & 0x4) trust_depth --;
      depth --;
      break;
      default: __FC_assert(0 != 0,"sources.c",858,"0");
    }
    i ++;
  }
  if (best_depth <= n_sel_sources / 2) 
    if (! best_trust_depth) {
      if (selected_source_index != -1) {
        log_selection_message((char *)"Can\'t synchronise: no majority",
                              (char *)0);
        REF_SetUnsynchronised();
        selected_source_index = -1;
      }
      mark_ok_sources(SRC_FALSETICKER);
      goto return_label;
    }
  n_sel_sources = 0;
  i = 0;
  /*@ loop unroll 2; */
  while (i < n_sources) {
    if ((*(sources + i))->status != (unsigned int)SRC_OK) goto __Cont_2;
    if (! best_trust_depth) goto _LOR_1;
    else 
      if ((*(sources + i))->sel_options & 0x4) {
        _LOR_1: ;
        if ((*(sources + i))->sel_info.lo_limit <= best_lo) {
          if ((*(sources + i))->sel_info.hi_limit >= best_hi) goto _LOR_0;
          else goto _LAND_2;
        }
        else goto _LAND_2;
      }
      else {
        _LAND_2: ;
        if ((*(sources + i))->sel_info.lo_limit >= best_lo) {
          if ((*(sources + i))->sel_info.hi_limit <= best_hi) {
            _LOR_0:
            {
              int tmp_1;
              tmp_1 = n_sel_sources;
              n_sel_sources ++;
              *(sel_sources + tmp_1) = i;
              if ((*(sources + i))->sel_options & 0x8) sel_req_source = 0;
            }
          }
          else goto _LAND_0;
        }
        else {
          _LAND_0: ;
          if ((*(sources + i))->sel_info.lo_limit <= best_lo) {
            if ((*(sources + i))->sel_info.hi_limit >= best_hi) (*(sources + i))->status = SRC_UNTRUSTED;
            else goto _LAND;
          }
          else _LAND: (*(sources + i))->status = SRC_FALSETICKER;
        }
      }
    __Cont_2: i ++;
  }
  if (! n_sel_sources) goto _LOR_2;
  else 
    if (sel_req_source) goto _LOR_2;
    else {
      int tmp_4;
      tmp_4 = CNF_GetMinSources();
      ;
      if (n_sel_sources < tmp_4) {
        _LOR_2:
        {
          if (selected_source_index != -1) {
            char const *tmp_3;
            if (! n_sel_sources) tmp_3 = "no";
            else {
              char const *tmp_2;
              if (sel_req_source) tmp_2 = "no required source in";
              else tmp_2 = "not enough";
              tmp_3 = tmp_2;
            }
            log_selection_message((char *)"Can\'t synchronise: %s selectable sources",
                                  (char *)tmp_3);
            selected_source_index = -1;
          }
          mark_ok_sources(SRC_WAITS_SOURCES);
          goto return_label;
        }
      }
    }
  leap_votes = 0;
  leap_del = leap_votes;
  leap_ins = leap_del;
  i = leap_ins;
  /*@ loop unroll 2; */
  while (i < n_sel_sources) {
    index_0 = *(sel_sources + i);
    if (best_trust_depth) 
      if (! ((*(sources + index_0))->sel_options & 0x4)) goto __Cont_3;
    leap_votes ++;
    if ((*(sources + index_0))->sel_info.leap == (unsigned int)LEAP_InsertSecond) 
      leap_ins ++;
    else 
      if ((*(sources + index_0))->sel_info.leap == (unsigned int)LEAP_DeleteSecond) 
        leap_del ++;
    __Cont_3: i ++;
  }
  if (leap_ins > leap_votes / 2) leap_status = LEAP_InsertSecond;
  else 
    if (leap_del > leap_votes / 2) leap_status = LEAP_DeleteSecond;
    else leap_status = LEAP_Normal;
  i = 0;
  /*@ loop unroll 2; */
  while (i < n_sel_sources) {
    if ((*(sources + *(sel_sources + i)))->sel_options & 0x2) break;
    i ++;
  }
  if (i < n_sel_sources) {
    j = 0;
    i = j;
    /*@ loop unroll 2; */
    while (i < n_sel_sources) {
      if (! ((*(sources + *(sel_sources + i)))->sel_options & 0x2)) (*(
                                                                    sources + *(
                                                                    sel_sources + i)))->status = SRC_NONPREFERRED;
      else {
        int tmp_5;
        tmp_5 = j;
        j ++;
        *(sel_sources + tmp_5) = *(sel_sources + i);
      }
      i ++;
    }
    __FC_assert((j > 0) != 0,"sources.c",960,"j > 0");
    n_sel_sources = j;
    sel_prefer = 1;
  }
  else sel_prefer = 0;
  index_0 = *(sel_sources + 0);
  min_stratum = (*(sources + index_0))->sel_info.stratum;
  i = 1;
  /*@ loop unroll 2; */
  while (i < n_sel_sources) {
    index_0 = *(sel_sources + i);
    stratum = (*(sources + index_0))->sel_info.stratum;
    if (stratum < min_stratum) min_stratum = stratum;
    i ++;
  }
  max_score_index = -1;
  max_score = 0.0;
  sel_src_distance = 0.0;
  if (selected_source_index != -1) sel_src_distance = (*(sources + selected_source_index))->sel_info.root_distance + 
                                                      (double)((*(sources + selected_source_index))->sel_info.stratum - min_stratum) * stratum_weight_0;
  i = 0;
  /*@ loop unroll 2; */
  while (i < n_sources) {
    if ((*(sources + i))->status != (unsigned int)SRC_OK) goto _LOR_3;
    else 
      if (sel_prefer) 
        if (! ((*(sources + i))->sel_options & 0x2)) {
          _LOR_3:
          {
            (*(sources + i))->sel_score = 1.0;
            (*(sources + i))->distant = 32;
            goto __Cont_4;
          }
        }
    distance = (*(sources + i))->sel_info.root_distance + (double)((*(
                                                                   sources + i))->sel_info.stratum - min_stratum) * stratum_weight_0;
    if ((*(sources + i))->type == (unsigned int)SRC_NTP) distance += reselect_distance_0;
    if (selected_source_index != -1) {
      if (*(sources + i) == updated_inst) goto _LOR_4;
      else 
        if (*(sources + selected_source_index) == updated_inst) {
          _LOR_4:
          {
            (*(sources + i))->sel_score *= sel_src_distance / distance;
            if ((*(sources + i))->sel_score < 1.0) (*(sources + i))->sel_score = 1.0;
          }
        }
    }
    else (*(sources + i))->sel_score = 1.0 / distance;
    if (max_score < (*(sources + i))->sel_score) {
      max_score = (*(sources + i))->sel_score;
      max_score_index = i;
    }
    __Cont_4: i ++;
  }
  __FC_assert((max_score_index != -1) != 0,"sources.c",1033,
              "max_score_index != INVALID_SOURCE");
  if (selected_source_index == -1) goto _LOR_5;
  else 
    if ((*(sources + selected_source_index))->status != (unsigned int)SRC_OK) 
      goto _LOR_5;
    else 
      if (max_score_index != selected_source_index) 
        if (max_score > 10.0) {
          _LOR_5:
          {
            char *tmp_7;
            if ((*(sources + max_score_index))->updates == 0) {
              selected_source_index = -1;
              mark_ok_sources(SRC_WAITS_UPDATE);
              goto return_label;
            }
            selected_source_index = max_score_index;
            tmp_7 = source_to_string(*(sources + selected_source_index));
            log_selection_message((char *)"Selected source %s",tmp_7);
            i = 0;
            /*@ loop unroll 2; */
            while (i < n_sources) {
              (*(sources + i))->sel_score = 1.0;
              (*(sources + i))->distant = 0;
              i ++;
            }
          }
        }
  (*(sources + selected_source_index))->status = SRC_SELECTED;
  if ((*(sources + selected_source_index))->updates == 0) {
    i = 0;
    /*@ loop unroll 2; */
    while (i < n_sel_sources) {
      index_0 = *(sel_sources + i);
      if ((*(sources + index_0))->status == (unsigned int)SRC_OK) 
        if ((*(sources + index_0))->distant) (*(sources + index_0))->status = SRC_DISTANT;
        else (*(sources + index_0))->status = SRC_UNSELECTED;
      i ++;
    }
    goto return_label;
  }
  i = 0;
  /*@ loop unroll 2; */
  while (i < n_sources) {
    (*(sources + i))->updates = 0;
    i ++;
  }
  SST_GetTrackingData((*(sources + selected_source_index))->stats,& ref_time,
                      & src_offset,& src_offset_sd,& src_frequency,
                      & src_frequency_sd,& src_skew,& src_root_delay,
                      & src_root_dispersion);
  combined = combine_sources(n_sel_sources,& ref_time,& src_offset,
                             & src_offset_sd,& src_frequency,
                             & src_frequency_sd,& src_skew);
  REF_SetReference((*(sources + selected_source_index))->sel_info.stratum,
                   leap_status,combined,
                   (*(sources + selected_source_index))->ref_id,
                   (*(sources + selected_source_index))->ip_addr,& ref_time,
                   src_offset,src_offset_sd,src_frequency,src_frequency_sd,
                   src_skew,src_root_delay,src_root_dispersion);
  return_label: return;
}

void SRC_ReselectSource(void)
{
  selected_source_index = -1;
  SRC_SelectSource((SRC_Instance)0);
  return;
}

void SRC_SetReselectDistance(double distance)
{
  if (reselect_distance_0 != distance) {
    reselect_distance_0 = distance;
    {
      double __va_arg0 = distance;
      void *__va_args[1] = {& __va_arg0};
      LOG_Message(LOGS_INFO,"New reselect distance %f",
                  (void * const *)(__va_args));
    }
  }
  return;
}

static void slew_sources(struct timespec *raw, struct timespec *cooked,
                         double dfreq, double doffset,
                         LCL_ChangeType change_type, void *anything)
{
  int i;
  i = 0;
  /*@ loop unroll 2; */
  while (i < n_sources) {
    if (change_type == (unsigned int)LCL_ChangeUnknownStep) SST_ResetInstance
                                                            ((*(sources + i))->stats);
    else SST_SlewSamples((*(sources + i))->stats,cooked,dfreq,doffset);
    i ++;
  }
  if (change_type == (unsigned int)LCL_ChangeUnknownStep) SRC_SelectSource
                                                          ((SRC_Instance)0);
  return;
}

static void add_dispersion(double dispersion, void *anything)
{
  int i;
  i = 0;
  /*@ loop unroll 2; */
  while (i < n_sources) {
    SST_AddDispersion((*(sources + i))->stats,dispersion);
    i ++;
  }
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) 
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: *(param1 + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))),
            *(param1 + (0 ..)), *(param0 + (0 ..));
 */
int snprintf_va_3(char * restrict s, size_t n, char const * restrict format,
                  char *param0, char *param1);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) 
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: param1), (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param1,
            *(param0 + (0 ..));
 */
int snprintf_va_4(char * restrict s, size_t n, char const * restrict format,
                  char *param0, unsigned int param1);

static FILE *open_dumpfile(SRC_Instance inst, char const *mode_0)
{
  FILE *__retres;
  FILE *f;
  char filename[1024];
  char *dumpdir_0;
  dumpdir_0 = CNF_GetDumpDir();
  if ((int)*(dumpdir_0 + 0) == '\000') {
    {
      void *__va_args[1] = {(void *)0};
      LOG_Message(LOGS_WARN,"dumpdir not specified",
                  (void * const *)(__va_args));
    }
    __retres = (FILE *)0;
    goto return_label;
  }
  if (inst->type == (unsigned int)SRC_NTP) {
    int tmp_0;
    char *tmp;
    tmp = source_to_string(inst);
    ;
    tmp_0 = snprintf(filename,sizeof(filename),"%s/%s.dat",dumpdir_0,tmp); /* snprintf_va_3 */
    if ((unsigned long)tmp_0 >= sizeof(filename)) goto _LOR; else goto _LAND;
  }
  else {
    _LAND: ;
    if (inst->type != (unsigned int)SRC_NTP) {
      int tmp_1;
      tmp_1 = snprintf(filename,sizeof(filename),"%s/refid:%08x.dat",
                       dumpdir_0,inst->ref_id); /* snprintf_va_4 */
      if ((unsigned long)tmp_1 >= sizeof(filename)) {
        _LOR:
        {
          {
            void *__va_args_12[1] = {(void *)0};
            LOG_Message(LOGS_WARN,"dumpdir too long",
                        (void * const *)(__va_args_12));
          }
          __retres = (FILE *)0;
          goto return_label;
        }
      }
    }
  }
  f = fopen((char const *)(filename),mode_0);
  if (! f) 
    if ((int)*(mode_0 + 0) != 'r') {
      char *tmp_2;
      tmp_2 = source_to_string(inst);
      {
        char *__va_arg0 = tmp_2;
        void *__va_args_15[1] = {& __va_arg0};
        LOG_Message(LOGS_WARN,"Could not open dump file for %s",
                    (void * const *)(__va_args_15));
      }
    }
  __retres = f;
  return_label: return __retres;
}

void SRC_DumpSources(void)
{
  FILE *out;
  int i;
  i = 0;
  /*@ loop unroll 2; */
  while (i < n_sources) {
    out = open_dumpfile(*(sources + i),"w");
    if (! out) goto __Cont;
    SST_SaveToFile((*(sources + i))->stats,out);
    fclose(out);
    __Cont: i ++;
  }
  return;
}

void SRC_ReloadSources(void)
{
  FILE *in;
  int i;
  i = 0;
  /*@ loop unroll 2; */
  while (i < n_sources) {
    {
      int tmp_1;
      in = open_dumpfile(*(sources + i),"r");
      if (! in) goto __Cont;
      tmp_1 = SST_LoadFromFile((*(sources + i))->stats,in);
      if (tmp_1) {
        char *tmp_0;
        tmp_0 = source_to_string(*(sources + i));
        {
          char *__va_arg0 = tmp_0;
          void *__va_args[1] = {& __va_arg0};
          LOG_Message(LOGS_INFO,"Loaded dump file for %s",
                      (void * const *)(__va_args));
        }
      }
      else {
        char *tmp;
        tmp = source_to_string(*(sources + i));
        {
          char *__va_arg0_9 = tmp;
          void *__va_args_11[1] = {& __va_arg0_9};
          LOG_Message(LOGS_WARN,"Could not load dump file for %s",
                      (void * const *)(__va_args_11));
        }
      }
      fclose(in);
    }
    __Cont: i ++;
  }
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) 
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int snprintf_va_5(char * restrict s, size_t n, char const * restrict format,
                  char *param0);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) 
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int snprintf_va_6(char * restrict s, size_t n, char const * restrict format,
                  char *param0);

void SRC_RemoveDumpFiles(void)
{
  char pattern[1024];
  char name[64];
  char *dumpdir_0;
  char *s;
  IPAddr ip_addr;
  glob_t gl;
  size_t i;
  int tmp_0;
  dumpdir_0 = CNF_GetDumpDir();
  if ((int)*(dumpdir_0 + 0) == '\000') goto return_label;
  else {
    int tmp;
    tmp = snprintf(pattern,sizeof(pattern),"%s/*.dat",dumpdir_0); /* snprintf_va_5 */
    if ((unsigned long)tmp >= sizeof(pattern)) goto return_label;
  }
  tmp_0 = glob((char const *)(pattern),0,
               (int (*)(char const *epath, int eerrno))0,& gl);
  if (tmp_0) goto return_label;
  i = (size_t)0;
  while (i < gl.gl_pathc) {
    {
      size_t tmp_2;
      size_t tmp_3;
      int tmp_4;
      s = strrchr((char const *)*(gl.gl_pathv + i),'/');
      if (! s) goto __Cont;
      else {
        int tmp_1;
        tmp_1 = snprintf(name,sizeof(name),"%s",s + 1); /* snprintf_va_6 */
        if ((unsigned long)tmp_1 >= sizeof(name)) goto __Cont;
      }
      tmp_2 = strlen((char const *)(name));
      if (tmp_2 < (size_t)4) goto __Cont;
      tmp_3 = strlen((char const *)(name));
      name[tmp_3 - (size_t)4] = (char)'\000';
      tmp_4 = strncmp((char const *)(name),"refid:",(size_t)6);
      if (tmp_4) {
        int tmp_5;
        tmp_5 = UTI_StringToIP((char const *)(name),& ip_addr);
        if (! tmp_5) goto __Cont;
      }
      unlink((char const *)*(gl.gl_pathv + i));
    }
    __Cont: i ++;
  }
  globfree(& gl);
  return_label: return;
}

int SRC_IsSyncPeer(SRC_Instance inst)
{
  int __retres;
  if (inst->index == selected_source_index) {
    __retres = 1;
    goto return_label;
  }
  else {
    __retres = 0;
    goto return_label;
  }
  return_label: return __retres;
}

int SRC_IsReachable(SRC_Instance inst)
{
  int __retres;
  __retres = inst->reachability != 0;
  return __retres;
}

int SRC_ReadNumberOfSources(void)
{
  return n_sources;
}

int SRC_ActiveSources(void)
{
  int i;
  int r;
  r = 0;
  i = r;
  /*@ loop unroll 2; */
  while (i < n_sources) {
    if ((*(sources + i))->active) r ++;
    i ++;
  }
  return r;
}

int SRC_ReportSource(int index_0, RPT_SourceReport *report,
                     struct timespec *now)
{
  int __retres;
  SRC_Instance src;
  if (index_0 >= n_sources) goto _LOR;
  else 
    if (index_0 < 0) {
      _LOR: {
              __retres = 0;
              goto return_label;
            }
    }
    else {
      src = *(sources + index_0);
      if (src->ip_addr) report->ip_addr = *(src->ip_addr);
      else {
        report->ip_addr.addr.in4 = src->ref_id;
        report->ip_addr.family = (uint16_t)1;
      }
      switch (src->status) {
        case SRC_FALSETICKER: report->state = RPT_FALSETICKER;
        break;
        case SRC_JITTERY: report->state = RPT_JITTERY;
        break;
        case SRC_UNTRUSTED: case SRC_WAITS_SOURCES: case SRC_NONPREFERRED:
        case SRC_WAITS_UPDATE: case SRC_DISTANT: case SRC_OUTLIER:
        report->state = RPT_OUTLIER;
        break;
        case SRC_UNSELECTED: report->state = RPT_CANDIDATE;
        break;
        case SRC_SELECTED: report->state = RPT_SYNC;
        break;
        default: report->state = RPT_UNREACH;
        break;
      }
      report->sel_options = src->sel_options;
      report->reachability = src->reachability;
      SST_DoSourceReport(src->stats,report,now);
      __retres = 1;
      goto return_label;
    }
  return_label: return __retres;
}

int SRC_ReportSourcestats(int index_0, RPT_SourcestatsReport *report,
                          struct timespec *now)
{
  int __retres;
  SRC_Instance src;
  if (index_0 >= n_sources) goto _LOR;
  else 
    if (index_0 < 0) {
      _LOR: {
              __retres = 0;
              goto return_label;
            }
    }
    else {
      src = *(sources + index_0);
      report->ref_id = src->ref_id;
      if (src->ip_addr) report->ip_addr = *(src->ip_addr);
      else report->ip_addr.family = (uint16_t)0;
      SST_DoSourcestatsReport(src->stats,report,now);
      __retres = 1;
      goto return_label;
    }
  return_label: return __retres;
}

SRC_Type SRC_GetType(int index_0)
{
  SRC_Type __retres;
  if (index_0 >= n_sources) {
    __retres = (SRC_Type)(-1);
    goto return_label;
  }
  else 
    if (index_0 < 0) {
      __retres = (SRC_Type)(-1);
      goto return_label;
    }
  __retres = (*(sources + index_0))->type;
  return_label: return __retres;
}

static LOG_FileID logfileid_0;
static void find_min_delay_sample(SST_Stats inst);

static int get_buf_index(SST_Stats inst, int i);

void SST_Initialise(void)
{
  int tmp;
  tmp = CNF_GetLogStatistics();
  if (tmp) logfileid_0 = LOG_FileOpen("statistics",
                                      "   Date (UTC) Time     IP Address    Std dev\'n Est offset  Offset sd  Diff freq   Est skew  Stress  Ns  Bs  Nr  Asym");
  else logfileid_0 = -1;
  return;
}

void SST_Finalise(void)
{
  return;
}

SST_Stats SST_CreateInstance(uint32_t refid, IPAddr *addr, int min_samples_0,
                             int max_samples_0, double min_delay,
                             double asymmetry)
{
  SST_Stats inst;
  inst = (SST_Stats)Malloc(sizeof(struct SST_Stats_Record));
  inst->min_samples = min_samples_0;
  inst->max_samples = max_samples_0;
  inst->fixed_min_delay = min_delay;
  inst->fixed_asymmetry = asymmetry;
  SST_SetRefid(inst,refid,addr);
  SST_ResetInstance(inst);
  return inst;
}

void SST_DeleteInstance(SST_Stats inst)
{
  free((void *)inst);
  return;
}

void SST_ResetInstance(SST_Stats inst)
{
  inst->n_samples = 0;
  inst->runs_samples = 0;
  inst->last_sample = 0;
  inst->regression_ok = 0;
  inst->best_single_sample = 0;
  inst->min_delay_sample = 0;
  inst->estimated_frequency = (double)0;
  inst->estimated_frequency_sd = 2000.0 / 1.0e6;
  inst->skew = 2000.0 / 1.0e6;
  inst->estimated_offset = 0.0;
  inst->estimated_offset_sd = 86400.0;
  UTI_ZeroTimespec(& inst->offset_time);
  inst->std_dev = 4.0;
  inst->nruns = 0;
  inst->asymmetry_run = 0;
  inst->asymmetry = 0.0;
  inst->leap = LEAP_Unsynchronised;
  return;
}

void SST_SetRefid(SST_Stats inst, uint32_t refid, IPAddr *addr)
{
  inst->refid = refid;
  inst->ip_addr = addr;
  return;
}

static void prune_register(SST_Stats inst, int new_oldest)
{
  if (! new_oldest) goto return_label;
  __FC_assert((inst->n_samples >= new_oldest) != 0,"sourcestats.c",280,
              "inst->n_samples >= new_oldest");
  inst->n_samples -= new_oldest;
  inst->runs_samples += new_oldest;
  if (inst->runs_samples > inst->n_samples * (2 - 1)) inst->runs_samples = 
                                                      inst->n_samples * (
                                                      2 - 1);
  __FC_assert((inst->n_samples + inst->runs_samples <= 64 * 2) != 0,
              "sourcestats.c",286,
              "inst->n_samples + inst->runs_samples <= MAX_SAMPLES * REGRESS_RUNS_RATIO");
  find_min_delay_sample(inst);
  return_label: return;
}

void SST_AccumulateSample(SST_Stats inst, NTP_Sample *sample)
{
  int n;
  int m;
  int tmp_3;
  if (inst->n_samples > 0) 
    if (inst->n_samples == 64) goto _LOR;
    else 
      if (inst->n_samples == inst->max_samples) _LOR: prune_register(inst,1);
  if (inst->n_samples) {
    int tmp_2;
    tmp_2 = UTI_CompareTimespecs(& inst->sample_times[inst->last_sample],
                                 & sample->time);
    if (tmp_2 >= 0) {
      char *tmp_1;
      if (inst->ip_addr) tmp_1 = UTI_IPToString(inst->ip_addr);
      else tmp_1 = UTI_RefidToString(inst->refid);
      {
        char *__va_arg0 = tmp_1;
        void *__va_args[1] = {& __va_arg0};
        LOG_Message(LOGS_WARN,
                    "Out of order sample detected, discarding history for %s",
                    (void * const *)(__va_args));
      }
      SST_ResetInstance(inst);
    }
  }
  tmp_3 = (inst->last_sample + 1) % (64 * 2);
  inst->last_sample = tmp_3;
  n = tmp_3;
  m = n % 64;
  inst->sample_times[n] = sample->time;
  inst->offsets[n] = - sample->offset;
  inst->orig_offsets[m] = - sample->offset;
  inst->peer_delays[n] = sample->peer_delay;
  inst->peer_dispersions[m] = sample->peer_dispersion;
  inst->root_delays[m] = sample->root_delay;
  inst->root_dispersions[m] = sample->root_dispersion;
  inst->stratum = sample->stratum;
  inst->leap = sample->leap;
  if (inst->peer_delays[n] < inst->fixed_min_delay) inst->peer_delays[n] = 
                                                    2.0 * inst->fixed_min_delay - inst->peer_delays[n];
  if (! inst->n_samples) inst->min_delay_sample = n;
  else 
    if (inst->peer_delays[n] < inst->peer_delays[inst->min_delay_sample]) 
      inst->min_delay_sample = n;
  (inst->n_samples) ++;
  return;
}

static int get_runsbuf_index(SST_Stats inst, int i)
{
  int __retres;
  __retres = (int)((unsigned int)((((inst->last_sample + (2 * 64) * 2) - inst->n_samples) + i) + 1) % (unsigned int)(
                   64 * 2));
  return __retres;
}

static int get_buf_index(SST_Stats inst, int i)
{
  int __retres;
  __retres = (int)((unsigned int)((((inst->last_sample + 64 * 2) - inst->n_samples) + i) + 1) % (unsigned int)64);
  return __retres;
}

static void convert_to_intervals(SST_Stats inst, double *times_back)
{
  struct timespec *ts;
  int i;
  ts = & inst->sample_times[inst->last_sample];
  i = - inst->runs_samples;
  while (i < inst->n_samples) {
    {
      int tmp;
      ;
      tmp = get_runsbuf_index(inst,i);
      ;
      *(times_back + i) = UTI_DiffTimespecsToDouble(& inst->sample_times[tmp],
                                                    ts);
    }
    i ++;
  }
  return;
}

static void find_best_sample_index(SST_Stats inst, double *times_back)
{
  double root_distance;
  double best_root_distance;
  double elapsed;
  int i;
  int j;
  int best_index;
  if (! inst->n_samples) goto return_label;
  best_index = -1;
  best_root_distance = 0x1.fffffffffffffp+1023;
  i = 0;
  while (i < inst->n_samples) {
    j = get_buf_index(inst,i);
    elapsed = - *(times_back + i);
    __FC_assert((elapsed >= 0.0) != 0,"sourcestats.c",398,"elapsed >= 0.0");
    root_distance = (inst->root_dispersions[j] + elapsed * inst->skew) + 
                    0.5 * inst->root_delays[j];
    if (root_distance < best_root_distance) {
      best_root_distance = root_distance;
      best_index = i;
    }
    i ++;
  }
  __FC_assert((best_index >= 0) != 0,"sourcestats.c",407,"best_index >= 0");
  inst->best_single_sample = best_index;
  return_label: return;
}

static void find_min_delay_sample(SST_Stats inst)
{
  int i;
  int index_0;
  inst->min_delay_sample = get_runsbuf_index(inst,- inst->runs_samples);
  i = - inst->runs_samples + 1;
  while (i < inst->n_samples) {
    index_0 = get_runsbuf_index(inst,i);
    if (inst->peer_delays[index_0] < inst->peer_delays[inst->min_delay_sample]) 
      inst->min_delay_sample = index_0;
    i ++;
  }
  return;
}

static int estimate_asymmetry(double *times_back, double *offsets,
                              double *delays, int n, double *asymmetry,
                              int *asymmetry_run)
{
  int __retres;
  double a;
  int tmp;
  int tmp_0;
  double tmp_1;
  tmp = RGR_MultipleRegress(times_back,delays,offsets,n,& a);
  if (tmp) {
    if (a * (double)*asymmetry_run < 0.0) {
      _LOR:
      {
        *asymmetry = (double)0;
        *asymmetry_run = (int)0.0;
        __retres = 0;
        goto return_label;
      }
    }
  }
  else goto _LOR;
  if (a <= - 0.45) {
    if (*asymmetry_run > -1000) (*asymmetry_run) --; else goto _LAND;
  }
  else {
    _LAND: ;
    if (a >= 0.45) 
      if (*asymmetry_run < 1000) (*asymmetry_run) ++;
  }
  tmp_0 = abs(*asymmetry_run);
  if (tmp_0 < 10) {
    __retres = 0;
    goto return_label;
  }
  if (a < 0.5) tmp_1 = a; else tmp_1 = 0.5;
  if (- 0.5 > tmp_1) *asymmetry = - 0.5;
  else {
    double tmp_2;
    if (a < 0.5) tmp_2 = a; else tmp_2 = 0.5;
    *asymmetry = tmp_2;
  }
  __retres = 1;
  return_label: return __retres;
}

static void correct_asymmetry(SST_Stats inst, double *times_back,
                              double *offsets)
{
  double min_delay;
  double delays[64 * 2];
  int i;
  int n;
  double tmp_1;
  if (inst->fixed_asymmetry == 0.0) goto return_label;
  min_delay = SST_MinRoundTripDelay(inst);
  n = inst->runs_samples + inst->n_samples;
  i = 0;
  while (i < n) {
    int tmp;
    tmp = get_runsbuf_index(inst,i - inst->runs_samples);
    delays[i] = inst->peer_delays[tmp] - min_delay;
    i ++;
  }
  tmp_1 = fabs(inst->fixed_asymmetry);
  if (tmp_1 <= 0.5) inst->asymmetry = inst->fixed_asymmetry;
  else {
    int tmp_0;
    tmp_0 = estimate_asymmetry(times_back,offsets,delays,n,& inst->asymmetry,
                               & inst->asymmetry_run);
    if (! tmp_0) goto return_label;
  }
  i = 0;
  while (i < n) {
    *(offsets + i) -= inst->asymmetry * delays[i];
    i ++;
  }
  return_label: return;
}

void SST_DoNewRegression(SST_Stats inst)
{
  double times_back[64 * 2];
  double offsets[64 * 2];
  double peer_distances[64];
  double weights[64];
  int degrees_of_freedom;
  int best_start;
  int times_back_start;
  double est_intercept;
  double est_slope;
  double est_var;
  double est_intercept_sd;
  double est_slope_sd;
  int i;
  int j;
  int nruns;
  double min_distance;
  double median_distance;
  double sd_weight;
  double sd;
  double old_skew;
  double old_freq;
  double stress;
  double precision;
  convert_to_intervals(inst,& times_back[inst->runs_samples]);
  if (inst->n_samples > 0) {
    double tmp_1;
    i = - inst->runs_samples;
    while (i < inst->n_samples) {
      {
        int tmp;
        tmp = get_runsbuf_index(inst,i);
        offsets[i + inst->runs_samples] = inst->offsets[tmp];
      }
      i ++;
    }
    i = 0;
    min_distance = 0x1.fffffffffffffp+1023;
    while (i < inst->n_samples) {
      {
        int tmp_0;
        j = get_buf_index(inst,i);
        tmp_0 = get_runsbuf_index(inst,i);
        peer_distances[i] = 0.5 * inst->peer_delays[tmp_0] + inst->peer_dispersions[j];
        if (peer_distances[i] < min_distance) min_distance = peer_distances[i];
      }
      i ++;
    }
    precision = LCL_GetSysPrecisionAsQuantum();
    median_distance = RGR_FindMedian(peer_distances,inst->n_samples);
    sd = (median_distance - min_distance) / 0.7;
    if (sd < min_distance) tmp_1 = sd; else tmp_1 = min_distance;
    ;
    if (precision > tmp_1) sd = precision;
    else {
      double tmp_2;
      if (sd < min_distance) tmp_2 = sd; else tmp_2 = min_distance;
      sd = tmp_2;
    }
    min_distance += precision;
    i = 0;
    while (i < inst->n_samples) {
      sd_weight = 1.0;
      if (peer_distances[i] > min_distance) sd_weight += (peer_distances[i] - min_distance) / sd;
      weights[i] = sd_weight * sd_weight;
      i ++;
    }
  }
  correct_asymmetry(inst,times_back,offsets);
  inst->regression_ok = RGR_FindBestRegression(& times_back[inst->runs_samples],
                                               & offsets[inst->runs_samples],
                                               weights,inst->n_samples,
                                               inst->runs_samples,
                                               inst->min_samples,
                                               & est_intercept,& est_slope,
                                               & est_var,& est_intercept_sd,
                                               & est_slope_sd,& best_start,
                                               & nruns,& degrees_of_freedom);
  if (inst->regression_ok) {
    double tmp_3;
    double tmp_5;
    double tmp_6;
    double tmp_8;
    double tmp_10;
    old_skew = inst->skew;
    old_freq = inst->estimated_frequency;
    inst->estimated_frequency = est_slope;
    if (est_slope_sd < 1.0e+02) tmp_3 = est_slope_sd; else tmp_3 = 1.0e+02;
    if (1.0e-12 > tmp_3) inst->estimated_frequency_sd = 1.0e-12;
    else {
      double tmp_4;
      if (est_slope_sd < 1.0e+02) tmp_4 = est_slope_sd; else tmp_4 = 1.0e+02;
      inst->estimated_frequency_sd = tmp_4;
    }
    tmp_5 = RGR_GetTCoef(degrees_of_freedom);
    inst->skew = est_slope_sd * tmp_5;
    inst->estimated_offset = est_intercept;
    inst->offset_time = inst->sample_times[inst->last_sample];
    inst->estimated_offset_sd = est_intercept_sd;
    tmp_6 = sqrt(est_var);
    if (1.0e-9 > tmp_6) inst->std_dev = 1.0e-9;
    else inst->std_dev = sqrt(est_var);
    inst->nruns = nruns;
    if (inst->skew < 1.0e+02) tmp_8 = inst->skew; else tmp_8 = 1.0e+02;
    if (1.0e-12 > tmp_8) inst->skew = 1.0e-12;
    else {
      double tmp_9;
      if (inst->skew < 1.0e+02) tmp_9 = inst->skew; else tmp_9 = 1.0e+02;
      inst->skew = tmp_9;
    }
    tmp_10 = fabs(old_freq - inst->estimated_frequency);
    stress = tmp_10 / old_skew;
    if (logfileid_0 != -1) {
      char *tmp_13;
      char *tmp_14;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      if (inst->ip_addr) tmp_13 = UTI_IPToString(inst->ip_addr);
      else tmp_13 = UTI_RefidToString(inst->refid);
      tmp_14 = UTI_TimeToLogForm(inst->offset_time.tv_sec);
      ;
      {
        char *__va_arg0 = tmp_14;
        char *__va_arg1 = tmp_13;
        double __va_arg2 = inst->std_dev;
        double __va_arg3 = inst->estimated_offset;
        double __va_arg4 = inst->estimated_offset_sd;
        double __va_arg5 = inst->estimated_frequency;
        double __va_arg6 = inst->skew;
        double __va_arg7 = stress;
        int __va_arg8 = inst->n_samples;
        int __va_arg9 = best_start;
        int __va_arg10 = inst->nruns;
        double __va_arg11 = inst->asymmetry;
        void *__va_args[12] =
          {& __va_arg0,
           & __va_arg1,
           & __va_arg2,
           & __va_arg3,
           & __va_arg4,
           & __va_arg5,
           & __va_arg6,
           & __va_arg7,
           & __va_arg8,
           & __va_arg9,
           & __va_arg10,
           & __va_arg11};
        LOG_FileWrite(logfileid_0,
                      "%s %-15s %10.3e %10.3e %10.3e %10.3e %10.3e %7.1e %3d %3d %3d %5.2f",
                      (void * const *)(__va_args));
      }
    }
    times_back_start = inst->runs_samples + best_start;
    prune_register(inst,best_start);
  }
  else {
    inst->estimated_frequency = 0.0;
    inst->estimated_frequency_sd = 2000.0 / 1.0e6;
    inst->skew = 2000.0 / 1.0e6;
    times_back_start = 0;
  }
  find_best_sample_index(inst,& times_back[times_back_start]);
  return;
}

void SST_GetFrequencyRange(SST_Stats inst, double *lo, double *hi)
{
  double freq;
  double skew;
  freq = inst->estimated_frequency;
  skew = inst->skew;
  *lo = freq - skew;
  *hi = freq + skew;
  if (skew > 2000.0 / 1.0e6) {
    *lo = - (2000.0 / 1.0e6);
    *hi = 2000.0 / 1.0e6;
  }
  return;
}

void SST_GetSelectionData(SST_Stats inst, struct timespec *now, int *stratum,
                          NTP_Leap *leap, double *offset_lo_limit,
                          double *offset_hi_limit, double *root_distance,
                          double *std_dev, double *first_sample_ago,
                          double *last_sample_ago, int *select_ok)
{
  double offset;
  double sample_elapsed;
  int i;
  int j;
  double tmp;
  if (! inst->n_samples) {
    *select_ok = 0;
    goto return_label;
  }
  i = get_runsbuf_index(inst,inst->best_single_sample);
  j = get_buf_index(inst,inst->best_single_sample);
  *stratum = inst->stratum;
  *leap = inst->leap;
  *std_dev = inst->std_dev;
  tmp = UTI_DiffTimespecsToDouble(now,& inst->sample_times[i]);
  sample_elapsed = fabs(tmp);
  offset = inst->offsets[i] + sample_elapsed * inst->estimated_frequency;
  *root_distance = (0.5 * inst->root_delays[j] + inst->root_dispersions[j]) + 
                   sample_elapsed * inst->skew;
  *offset_lo_limit = offset - *root_distance;
  *offset_hi_limit = offset + *root_distance;
  i = get_runsbuf_index(inst,0);
  *first_sample_ago = UTI_DiffTimespecsToDouble(now,& inst->sample_times[i]);
  i = get_runsbuf_index(inst,inst->n_samples - 1);
  *last_sample_ago = UTI_DiffTimespecsToDouble(now,& inst->sample_times[i]);
  *select_ok = inst->regression_ok;
  return_label: return;
}

void SST_GetTrackingData(SST_Stats inst, struct timespec *ref_time,
                         double *average_offset, double *offset_sd,
                         double *frequency, double *frequency_sd,
                         double *skew, double *root_delay,
                         double *root_dispersion)
{
  int i;
  int j;
  double elapsed_sample;
  __FC_assert((inst->n_samples > 0) != 0,"sourcestats.c",713,
              "inst->n_samples > 0");
  i = get_runsbuf_index(inst,inst->best_single_sample);
  j = get_buf_index(inst,inst->best_single_sample);
  *ref_time = inst->offset_time;
  *average_offset = inst->estimated_offset;
  *offset_sd = inst->estimated_offset_sd;
  *frequency = inst->estimated_frequency;
  *frequency_sd = inst->estimated_frequency_sd;
  *skew = inst->skew;
  *root_delay = inst->root_delays[j];
  elapsed_sample = UTI_DiffTimespecsToDouble(& inst->offset_time,
                                             & inst->sample_times[i]);
  *root_dispersion = (inst->root_dispersions[j] + inst->skew * elapsed_sample) + *offset_sd;
  return;
}

void SST_SlewSamples(SST_Stats inst, struct timespec *when, double dfreq,
                     double doffset)
{
  int m;
  int i;
  double delta_time;
  struct timespec *sample;
  struct timespec prev;
  double prev_offset;
  double prev_freq;
  if (! inst->n_samples) goto return_label;
  m = - inst->runs_samples;
  while (m < inst->n_samples) {
    i = get_runsbuf_index(inst,m);
    sample = & inst->sample_times[i];
    prev = *sample;
    UTI_AdjustTimespec(sample,when,sample,& delta_time,dfreq,doffset);
    inst->offsets[i] += delta_time;
    m ++;
  }
  prev = inst->offset_time;
  prev_offset = inst->estimated_offset;
  prev_freq = inst->estimated_frequency;
  UTI_AdjustTimespec(& inst->offset_time,when,& inst->offset_time,
                     & delta_time,dfreq,doffset);
  inst->estimated_offset += delta_time;
  inst->estimated_frequency = (inst->estimated_frequency - dfreq) / (
                              1.0 - dfreq);
  return_label: return;
}

void SST_AddDispersion(SST_Stats inst, double dispersion)
{
  int m;
  int i;
  m = 0;
  while (m < inst->n_samples) {
    i = get_buf_index(inst,m);
    inst->root_dispersions[i] += dispersion;
    inst->peer_dispersions[i] += dispersion;
    m ++;
  }
  return;
}

double SST_PredictOffset(SST_Stats inst, struct timespec *when)
{
  double __retres;
  double elapsed;
  if (inst->n_samples < 3) 
    if (inst->n_samples > 0) {
      __retres = inst->offsets[inst->last_sample];
      goto return_label;
    }
    else {
      __retres = 0.0;
      goto return_label;
    }
  else {
    elapsed = UTI_DiffTimespecsToDouble(when,& inst->offset_time);
    __retres = inst->estimated_offset + elapsed * inst->estimated_frequency;
    goto return_label;
  }
  return_label: return __retres;
}

double SST_MinRoundTripDelay(SST_Stats inst)
{
  double __retres;
  if (inst->fixed_min_delay > 0.0) {
    __retres = inst->fixed_min_delay;
    goto return_label;
  }
  if (! inst->n_samples) {
    __retres = 0x1.fffffffffffffp+1023;
    goto return_label;
  }
  __retres = inst->peer_delays[inst->min_delay_sample];
  return_label: return __retres;
}

int SST_GetDelayTestData(SST_Stats inst, struct timespec *sample_time,
                         double *last_sample_ago, double *predicted_offset,
                         double *min_delay, double *skew, double *std_dev)
{
  int __retres;
  if (inst->n_samples < 6) {
    __retres = 0;
    goto return_label;
  }
  *last_sample_ago = UTI_DiffTimespecsToDouble(sample_time,
                                               & inst->offset_time);
  *predicted_offset = inst->estimated_offset + *last_sample_ago * inst->estimated_frequency;
  *min_delay = SST_MinRoundTripDelay(inst);
  *skew = inst->skew;
  *std_dev = inst->std_dev;
  __retres = 1;
  return_label: return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param0;
 */
int fprintf_va_6(FILE * restrict stream, char const * restrict format,
                 int param0);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param9),
            (indirect: param8), (indirect: param7), (indirect: param6),
            (indirect: param5), (indirect: param4), (indirect: param3),
            (indirect: param2), (indirect: param1), (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param9, param8, param7, param6,
            param5, param4, param3, param2, param1, param0;
 */
int fprintf_va_7(FILE * restrict stream, char const * restrict format,
                 unsigned long param0, unsigned long param1, double param2,
                 double param3, double param4, double param5, double param6,
                 double param7, double param8, int param9);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param0;
 */
int fprintf_va_8(FILE * restrict stream, char const * restrict format,
                 int param0);

void SST_SaveToFile(SST_Stats inst, FILE *out)
{
  int m;
  int i;
  int j;
  fprintf(out,"%d\n",inst->n_samples); /* fprintf_va_6 */
  m = 0;
  while (m < inst->n_samples) {
    i = get_runsbuf_index(inst,m);
    j = get_buf_index(inst,m);
    fprintf(out,"%08lx %08lx %.6e %.6e %.6e %.6e %.6e %.6e %.6e %d\n",
            (uint64_t)inst->sample_times[i].tv_sec,
            (unsigned long)inst->sample_times[i].tv_nsec / (unsigned long)1000,
            inst->offsets[i],inst->orig_offsets[j],inst->peer_delays[i],
            inst->peer_dispersions[j],inst->root_delays[j],
            inst->root_dispersions[j],1.0,inst->stratum); /* fprintf_va_7 */
    m ++;
  }
  fprintf(out,"%d\n",inst->asymmetry_run); /* fprintf_va_8 */
  return;
}

/*@ requires \valid(param0);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    assigns \result, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_60(char const * restrict s, char const * restrict format,
                 int *param0);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires \valid(param2);
    requires \valid(param3);
    requires \valid(param4);
    requires \valid(param5);
    requires \valid(param6);
    requires \valid(param7);
    requires \valid(param8);
    requires \valid(param9);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    ensures \initialized(param2);
    ensures \initialized(param3);
    ensures \initialized(param4);
    ensures \initialized(param5);
    ensures \initialized(param6);
    ensures \initialized(param7);
    ensures \initialized(param8);
    ensures \initialized(param9);
    assigns \result, *param9, *param8, *param7, *param6, *param5, *param4,
            *param3, *param2, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param9
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param8
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param7
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param6
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param5
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param4
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param3
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param2
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_61(char const * restrict s, char const * restrict format,
                 unsigned long *param0, unsigned long *param1,
                 double *param2, double *param3, double *param4,
                 double *param5, double *param6, double *param7,
                 double *param8, int *param9);

/*@ requires \valid(param0);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    assigns \result, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_62(char const * restrict s, char const * restrict format,
                 int *param0);

int SST_LoadFromFile(SST_Stats inst, FILE *in)
{
  int __retres;
  uint64_t sec;
  unsigned long usec;
  int i;
  char line[1024];
  double weight;
  char *tmp_3;
  SST_ResetInstance(inst);
  tmp_3 = fgets(line,(int)sizeof(line),in);
  if (tmp_3) {
    int tmp_4;
    tmp_4 = sscanf((char const *)(line),"%d",& inst->n_samples); /* sscanf_va_60 */
    if (tmp_4 == 1) {
      if (inst->n_samples >= 0) {
        if (inst->n_samples <= 64) {
          char *tmp_1;
          i = 0;
          while (i < inst->n_samples) {
            {
              char *tmp;
              tmp = fgets(line,(int)sizeof(line),in);
              if (tmp) {
                int tmp_0;
                tmp_0 = sscanf((char const *)(line),
                               "%lx%lx%lf%lf%lf%lf%lf%lf%lf%d\n",& sec,
                               & usec,& inst->offsets[i],
                               & inst->orig_offsets[i],
                               & inst->peer_delays[i],
                               & inst->peer_dispersions[i],
                               & inst->root_delays[i],
                               & inst->root_dispersions[i],& weight,
                               & inst->stratum); /* sscanf_va_61 */
                if (tmp_0 != 10) {
                  _LOR:
                  {
                    inst->n_samples = 0;
                    __retres = 0;
                    goto return_label;
                  }
                }
                else {
                  inst->sample_times[i].tv_sec = (long)sec;
                  inst->sample_times[i].tv_nsec = (long)((unsigned long)1000 * usec);
                  UTI_NormaliseTimespec(& inst->sample_times[i]);
                }
              }
              else goto _LOR;
            }
            i ++;
          }
          tmp_1 = fgets(line,(int)sizeof(line),in);
          if (tmp_1) {
            int tmp_2;
            tmp_2 = sscanf((char const *)(line),"%d\n",& inst->asymmetry_run); /* sscanf_va_62 */
            if (tmp_2 != 1) inst->asymmetry_run = 0;
          }
          else inst->asymmetry_run = 0;
        }
        else goto _LAND_1;
      }
      else goto _LAND_1;
    }
    else goto _LAND_1;
  }
  else {
    _LAND_1: {
               inst->n_samples = 0;
               __retres = 0;
               goto return_label;
             }
  }
  if (! inst->n_samples) {
    __retres = 1;
    goto return_label;
  }
  inst->last_sample = inst->n_samples - 1;
  find_min_delay_sample(inst);
  SST_DoNewRegression(inst);
  __retres = 1;
  return_label: return __retres;
}

void SST_DoSourceReport(SST_Stats inst, RPT_SourceReport *report,
                        struct timespec *now)
{
  int i;
  int j;
  struct timespec last_sample_time;
  if (inst->n_samples > 0) {
    double tmp;
    i = get_runsbuf_index(inst,inst->n_samples - 1);
    j = get_buf_index(inst,inst->n_samples - 1);
    report->orig_latest_meas = inst->orig_offsets[j];
    report->latest_meas = inst->offsets[i];
    report->latest_meas_err = 0.5 * inst->root_delays[j] + inst->root_dispersions[j];
    report->stratum = inst->stratum;
    last_sample_time = inst->sample_times[i];
    last_sample_time.tv_nsec = (long)0;
    tmp = UTI_DiffTimespecsToDouble(now,& last_sample_time);
    report->latest_meas_ago = (unsigned long)tmp;
  }
  else {
    report->latest_meas_ago = (unsigned long)((uint32_t)(-1));
    report->orig_latest_meas = (double)0;
    report->latest_meas = (double)0;
    report->latest_meas_err = (double)0;
    report->stratum = 0;
  }
  return;
}

int SST_Samples(SST_Stats inst)
{
  int __retres;
  __retres = inst->n_samples;
  return __retres;
}

void SST_DoSourcestatsReport(SST_Stats inst, RPT_SourcestatsReport *report,
                             struct timespec *now)
{
  double dspan;
  double elapsed;
  double sample_elapsed;
  int li;
  int lj;
  int bi;
  int bj;
  report->n_samples = (unsigned long)inst->n_samples;
  report->n_runs = (unsigned long)inst->nruns;
  if (inst->n_samples > 1) {
    int tmp;
    li = get_runsbuf_index(inst,inst->n_samples - 1);
    lj = get_buf_index(inst,inst->n_samples - 1);
    tmp = get_runsbuf_index(inst,0);
    ;
    ;
    dspan = UTI_DiffTimespecsToDouble(& inst->sample_times[li],
                                      & inst->sample_times[tmp]);
    report->span_seconds = (unsigned long)(dspan + 0.5);
    if (inst->n_samples > 3) {
      elapsed = UTI_DiffTimespecsToDouble(now,& inst->offset_time);
      bi = get_runsbuf_index(inst,inst->best_single_sample);
      bj = get_buf_index(inst,inst->best_single_sample);
      sample_elapsed = UTI_DiffTimespecsToDouble(now,
                                                 & inst->sample_times[bi]);
      report->est_offset = inst->estimated_offset + elapsed * inst->estimated_frequency;
      report->est_offset_err = (inst->estimated_offset_sd + sample_elapsed * inst->skew) + (
                               0.5 * inst->root_delays[bj] + inst->root_dispersions[bj]);
    }
    else {
      report->est_offset = inst->offsets[li];
      report->est_offset_err = 0.5 * inst->root_delays[lj] + inst->root_dispersions[lj];
    }
  }
  else {
    report->span_seconds = (unsigned long)0;
    report->est_offset = (double)0;
    report->est_offset_err = (double)0;
  }
  report->resid_freq_ppm = 1.0e6 * inst->estimated_frequency;
  report->skew_ppm = 1.0e6 * inst->skew;
  report->sd = inst->std_dev;
  return;
}

double SST_GetJitterAsymmetry(SST_Stats inst)
{
  double __retres;
  __retres = inst->asymmetry;
  return __retres;
}

void UTI_ZeroTimespec(struct timespec *ts)
{
  ts->tv_sec = (long)0;
  ts->tv_nsec = (long)0;
  return;
}

int UTI_IsZeroTimespec(struct timespec *ts)
{
  int tmp;
  if (! ts->tv_sec) 
    if (! ts->tv_nsec) tmp = 1; else tmp = 0;
  else tmp = 0;
  return tmp;
}

void UTI_TimevalToTimespec(struct timeval *tv, struct timespec *ts)
{
  ts->tv_sec = tv->tv_sec;
  ts->tv_nsec = (long)(1000 * tv->tv_usec);
  return;
}

void UTI_TimespecToTimeval(struct timespec *ts, struct timeval *tv)
{
  tv->tv_sec = ts->tv_sec;
  tv->tv_usec = (suseconds_t)(ts->tv_nsec / (long)1000);
  return;
}

double UTI_TimespecToDouble(struct timespec *ts)
{
  double __retres;
  __retres = (double)ts->tv_sec + 1.0e-9 * (double)ts->tv_nsec;
  return __retres;
}

void UTI_DoubleToTimespec(double d, struct timespec *ts)
{
  ts->tv_sec = (long)d;
  ts->tv_nsec = (long)(1.0e9 * (d - (double)ts->tv_sec));
  UTI_NormaliseTimespec(ts);
  return;
}

void UTI_NormaliseTimespec(struct timespec *ts)
{
  if (ts->tv_nsec >= (long)1000000000) goto _LOR;
  else 
    if (ts->tv_nsec < (long)0) {
      _LOR:
      {
        ts->tv_sec += ts->tv_nsec / (long)1000000000;
        ts->tv_nsec %= (long)1000000000;
        if (ts->tv_nsec < (long)0) {
          (ts->tv_sec) --;
          ts->tv_nsec += (long)1000000000;
        }
      }
    }
  return;
}

double UTI_TimevalToDouble(struct timeval *tv)
{
  double __retres;
  __retres = (double)tv->tv_sec + 1.0e-6 * (double)tv->tv_usec;
  return __retres;
}

void UTI_DoubleToTimeval(double a, struct timeval *b)
{
  double frac_part;
  b->tv_sec = (time_t)a;
  frac_part = 1.0e6 * (a - (double)b->tv_sec);
  if (frac_part > (double)0) b->tv_usec = (suseconds_t)(frac_part + 0.5);
  else b->tv_usec = (suseconds_t)(frac_part - 0.5);
  UTI_NormaliseTimeval(b);
  return;
}

void UTI_NormaliseTimeval(struct timeval *x)
{
  if (x->tv_usec >= 1000000) goto _LOR;
  else 
    if (x->tv_usec <= -1000000) {
      _LOR:
      {
        x->tv_sec += (time_t)(x->tv_usec / 1000000);
        x->tv_usec %= 1000000;
      }
    }
  if (x->tv_usec < 0) {
    (x->tv_sec) --;
    x->tv_usec += 1000000;
  }
  return;
}

int UTI_CompareTimespecs(struct timespec *a, struct timespec *b)
{
  int __retres;
  if (a->tv_sec < b->tv_sec) {
    __retres = -1;
    goto return_label;
  }
  if (a->tv_sec > b->tv_sec) {
    __retres = 1;
    goto return_label;
  }
  if (a->tv_nsec < b->tv_nsec) {
    __retres = -1;
    goto return_label;
  }
  if (a->tv_nsec > b->tv_nsec) {
    __retres = 1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

void UTI_DiffTimespecs(struct timespec *result, struct timespec *a,
                       struct timespec *b)
{
  result->tv_sec = a->tv_sec - b->tv_sec;
  result->tv_nsec = a->tv_nsec - b->tv_nsec;
  UTI_NormaliseTimespec(result);
  return;
}

double UTI_DiffTimespecsToDouble(struct timespec *a, struct timespec *b)
{
  double __retres;
  __retres = ((double)a->tv_sec - (double)b->tv_sec) + 1.0e-9 * (double)(
                                                       a->tv_nsec - b->tv_nsec);
  return __retres;
}

void UTI_AddDoubleToTimespec(struct timespec *start, double increment,
                             struct timespec *end)
{
  time_t int_part;
  int_part = (time_t)increment;
  end->tv_sec = start->tv_sec + int_part;
  end->tv_nsec = (long)((double)start->tv_nsec + 1.0e9 * (increment - (double)int_part));
  UTI_NormaliseTimespec(end);
  return;
}

void UTI_AverageDiffTimespecs(struct timespec *earlier,
                              struct timespec *later,
                              struct timespec *average, double *diff)
{
  *diff = UTI_DiffTimespecsToDouble(later,earlier);
  UTI_AddDoubleToTimespec(earlier,*diff / 2.0,average);
  return;
}

void UTI_AddDiffToTimespec(struct timespec *a, struct timespec *b,
                           struct timespec *c, struct timespec *result)
{
  double diff;
  diff = UTI_DiffTimespecsToDouble(a,b);
  UTI_AddDoubleToTimespec(c,diff,result);
  return;
}

static char buffer_pool[16][64];
static int pool_ptr = 0;
/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) 
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: param1), (indirect: param0);
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param1, param0;
 */
int snprintf_va_7(char * restrict s, size_t n, char const * restrict format,
                  long param0, unsigned long param1);

char *UTI_TimespecToString(struct timespec *ts)
{
  char *result;
  pool_ptr = (pool_ptr + 1) % 16;
  result = buffer_pool[pool_ptr];
  snprintf(result,(size_t)64,"%ld.%09lu",ts->tv_sec,
           (unsigned long)ts->tv_nsec); /* snprintf_va_7 */
  return result;
}

char *UTI_Ntp64ToString(NTP_int64 *ntp_ts)
{
  struct timespec ts;
  char *tmp;
  UTI_Ntp64ToTimespec(ntp_ts,& ts);
  tmp = UTI_TimespecToString(& ts);
  return tmp;
}

char *UTI_RefidToString(uint32_t ref_id)
{
  unsigned int i;
  unsigned int j;
  unsigned int c;
  char *result;
  pool_ptr = (pool_ptr + 1) % 16;
  result = buffer_pool[pool_ptr];
  j = (unsigned int)0;
  i = j;
  while (1) {
    if (i < (unsigned int)4) {
      if (! (i < (unsigned int)(64 - 1))) break;
    }
    else break;
    {
      int tmp_0;
      c = (ref_id >> ((unsigned int)24 - i * (unsigned int)8)) & (unsigned int)0xff;
      tmp_0 = isprint((int)c);
      if (tmp_0) {
        unsigned int tmp;
        tmp = j;
        j ++;
        *(result + tmp) = (char)c;
      }
    }
    i ++;
  }
  *(result + j) = (char)'\000';
  return result;
}

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) 
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_8(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) 
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: param3), (indirect: param2), (indirect: param1),
            (indirect: param0);
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param3, param2,
            param1, param0;
 */
int snprintf_va_9(char * restrict s, size_t n, char const * restrict format,
                  unsigned long param0, unsigned long param1,
                  unsigned long param2, unsigned long param3);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) 
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))), (indirect: param0);
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param0;
 */
int snprintf_va_10(char * restrict s, size_t n, char const * restrict format,
                   unsigned int param0);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) 
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_11(char * restrict s, size_t n, char const * restrict format);

char *UTI_IPToString(IPAddr *addr)
{
  unsigned long a;
  unsigned long b;
  unsigned long c;
  unsigned long d;
  unsigned long ip;
  uint8_t *ip6;
  char *result;
  pool_ptr = (pool_ptr + 1) % 16;
  result = buffer_pool[pool_ptr];
  switch ((int)addr->family) {
    case 0: snprintf(result,(size_t)64,"[UNSPEC]"); /* snprintf_va_8 */
    break;
    case 1: ip = (unsigned long)addr->addr.in4;
    a = (ip >> 24) & (unsigned long)0xff;
    b = (ip >> 16) & (unsigned long)0xff;
    c = (ip >> 8) & (unsigned long)0xff;
    d = (ip >> 0) & (unsigned long)0xff;
    snprintf(result,(size_t)64,"%lu.%lu.%lu.%lu",a,b,c,d); /* snprintf_va_9 */
    break;
    case 2: ip6 = addr->addr.in6;
    __FC_assert((64 >= 40) != 0,"util.c",308,"BUFFER_LENGTH >= 40");
    a = (unsigned long)0;
    while (a < (unsigned long)8) {
      snprintf(result + a * (unsigned long)5,
               (unsigned long)40 - a * (unsigned long)5,"%04x:",
               (unsigned int)(((int)*(ip6 + (unsigned long)2 * a) << 8) | (int)*(
                              ip6 + ((unsigned long)2 * a + (unsigned long)1)))); /* snprintf_va_10 */
      a ++;
    }
    break;
    default: snprintf(result,(size_t)64,"[UNKNOWN]"); /* snprintf_va_11 */
  }
  return result;
}

/*@ requires \valid(param0);
    requires \valid(param1);
    requires \valid(param2);
    requires \valid(param3);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    ensures \initialized(param2);
    ensures \initialized(param3);
    assigns \result, *param3, *param2, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param3
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param2
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_63(char const * restrict s, char const * restrict format,
                 unsigned long *param0, unsigned long *param1,
                 unsigned long *param2, unsigned long *param3);

int UTI_StringToIP(char const *addr, IPAddr *ip)
{
  int __retres;
  unsigned long a;
  unsigned long b;
  unsigned long c;
  unsigned long d;
  unsigned long n;
  int tmp;
  tmp = sscanf(addr,"%lu.%lu.%lu.%lu",& a,& b,& c,& d); /* sscanf_va_63 */
  n = (unsigned long)tmp;
  if (n == (unsigned long)4) {
    ip->family = (uint16_t)1;
    ip->_pad = (uint16_t)0;
    ip->addr.in4 = (uint32_t)(((((a & (unsigned long)0xff) << 24) | (
                                (b & (unsigned long)0xff) << 16)) | (
                               (c & (unsigned long)0xff) << 8)) | (d & (unsigned long)0xff));
    __retres = 1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static int UTI_IPToRefid_MD5_hash = -1;
uint32_t UTI_IPToRefid(IPAddr *ip)
{
  uint32_t __retres;
  unsigned char buf[16];
  switch ((int)ip->family) {
    case 1: ;
    __retres = ip->addr.in4;
    goto return_label;
    case 2: ;
    if (UTI_IPToRefid_MD5_hash < 0) UTI_IPToRefid_MD5_hash = HSH_GetHashId
                                    ("MD5");
    if (UTI_IPToRefid_MD5_hash < 0) goto _LOR;
    else {
      unsigned int tmp;
      tmp = HSH_Hash(UTI_IPToRefid_MD5_hash,
                     (unsigned char const *)(ip->addr.in6),
                     (unsigned int)sizeof(ip->addr.in6),
                     (unsigned char const *)0,(unsigned int)0,buf,
                     (unsigned int)sizeof(buf));
      if ((unsigned long)tmp != sizeof(buf)) {
        _LOR:
        {
          {
            void *__va_args[1] = {(void *)0};
            LOG_Message(LOGS_FATAL,"Could not get MD5",
                        (void * const *)(__va_args));
          }
          exit(1);
        }
      }
    }
    __retres = ((((uint32_t)buf[0] << 24) | (unsigned int)((int)buf[1] << 16)) | (unsigned int)(
                (int)buf[2] << 8)) | (unsigned int)buf[3];
    goto return_label;
  }
  __retres = (uint32_t)0;
  return_label: return __retres;
}

static uint32_t UTI_IPToHash_seed = (uint32_t)0;
uint32_t UTI_IPToHash(IPAddr *ip)
{
  uint32_t __retres;
  unsigned char *addr;
  unsigned int i;
  unsigned int len;
  uint32_t hash;
  switch ((int)ip->family) {
    case 1: addr = (unsigned char *)(& ip->addr.in4);
    len = (unsigned int)sizeof(ip->addr.in4);
    break;
    case 2: addr = ip->addr.in6;
    len = (unsigned int)sizeof(ip->addr.in6);
    break;
    default: __retres = (uint32_t)0;
    goto return_label;
  }
  while (! UTI_IPToHash_seed) UTI_GetRandomBytes((void *)(& UTI_IPToHash_seed),
                                                 (unsigned int)sizeof(UTI_IPToHash_seed));
  i = (unsigned int)0;
  hash = UTI_IPToHash_seed;
  while (i < len) {
    hash = (uint32_t)71 * hash + (uint32_t)*(addr + i);
    i ++;
  }
  __retres = hash + UTI_IPToHash_seed;
  return_label: return __retres;
}

void UTI_IPHostToNetwork(IPAddr *src, IPAddr *dest)
{
  memset((void *)dest,0,sizeof(IPAddr));
  dest->family = htons(src->family);
  switch ((int)src->family) {
    case 1: dest->addr.in4 = htonl(src->addr.in4);
    break;
    case 2:
    memcpy((void *)(dest->addr.in6),(void const *)(src->addr.in6),
           sizeof(dest->addr.in6));
    break;
    default: dest->family = htons((uint16_t)0);
  }
  return;
}

void UTI_IPNetworkToHost(IPAddr *src, IPAddr *dest)
{
  dest->family = ntohs(src->family);
  dest->_pad = (uint16_t)0;
  switch ((int)dest->family) {
    case 1: dest->addr.in4 = ntohl(src->addr.in4);
    break;
    case 2:
    memcpy((void *)(dest->addr.in6),(void const *)(src->addr.in6),
           sizeof(dest->addr.in6));
    break;
    default: dest->family = (uint16_t)0;
  }
  return;
}

int UTI_CompareIPs(IPAddr *a, IPAddr *b, IPAddr *mask)
{
  int __retres;
  int i;
  int d;
  if ((int)a->family != (int)b->family) {
    __retres = (int)a->family - (int)b->family;
    goto return_label;
  }
  if (mask) 
    if ((int)mask->family != (int)b->family) mask = (IPAddr *)0;
  switch ((int)a->family) {
    case 0: __retres = 0;
    goto return_label;
    case 1: ;
    if (mask) {
      __retres = (int)((a->addr.in4 & mask->addr.in4) - (b->addr.in4 & mask->addr.in4));
      goto return_label;
    }
    else {
      __retres = (int)(a->addr.in4 - b->addr.in4);
      goto return_label;
    }
    case 2: i = 0;
    d = 0;
    while (1) {
      if (! d) {
        if (! (i < 16)) break;
      }
      else break;
      if (mask) d = ((int)a->addr.in6[i] & (int)mask->addr.in6[i]) - (
                    (int)b->addr.in6[i] & (int)mask->addr.in6[i]);
      else d = (int)a->addr.in6[i] - (int)b->addr.in6[i];
      i ++;
    }
    __retres = d;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

void UTI_SockaddrToIPAndPort(struct sockaddr *sa, IPAddr *ip,
                             unsigned short *port)
{
  switch ((int)sa->sa_family) {
    case 2: ip->family = (uint16_t)1;
    ip->addr.in4 = ntohl(((struct sockaddr_in *)sa)->sin_addr.s_addr);
    *port = ntohs(((struct sockaddr_in *)sa)->sin_port);
    break;
    default: ip->family = (uint16_t)0;
    *port = (unsigned short)0;
  }
  return;
}

int UTI_IPAndPortToSockaddr(IPAddr *ip, unsigned short port,
                            struct sockaddr *sa)
{
  int __retres;
  switch ((int)ip->family) {
    case 1: memset((void *)sa,0,sizeof(struct sockaddr_in));
    sa->sa_family = (sa_family_t)2;
    ((struct sockaddr_in *)sa)->sin_addr.s_addr = htonl(ip->addr.in4);
    ((struct sockaddr_in *)sa)->sin_port = htons(port);
    __retres = (int)sizeof(struct sockaddr_in);
    goto return_label;
    default: memset((void *)sa,0,sizeof(struct sockaddr));
    sa->sa_family = (sa_family_t)0;
    __retres = 0;
    goto return_label;
  }
  return_label: return __retres;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) 
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: param1), (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param1,
            *(param0 + (0 ..));
 */
int snprintf_va_12(char * restrict s, size_t n, char const * restrict format,
                   char *param0, int param1);

/*@ requires valid_read_nstring(param1, param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) 
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: *(param1 + (0 ..))), (indirect: param0);
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))),
            *(param1 + (0 ..)), param0;
 */
int snprintf_va_13(char * restrict s, size_t n, char const * restrict format,
                   int param0, char *param1);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) 
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_14(char * restrict s, size_t n, char const * restrict format);

char *UTI_SockaddrToString(struct sockaddr *sa)
{
  unsigned short port;
  IPAddr ip;
  char *result;
  char *sun_path;
  pool_ptr = (pool_ptr + 1) % 16;
  result = buffer_pool[pool_ptr];
  switch ((int)sa->sa_family) {
    char *tmp;
    size_t tmp_0;
    case 2: case 10: UTI_SockaddrToIPAndPort(sa,& ip,& port);
    ;
    tmp = UTI_IPToString(& ip);
    ;
    snprintf(result,(size_t)64,"%s:%hu",tmp,(int)port); /* snprintf_va_12 */
    break;
    case 1: sun_path = ((struct sockaddr_un *)sa)->sun_path;
    snprintf(result,(size_t)64,"%.*s",64 - 1,sun_path); /* snprintf_va_13 */
    tmp_0 = strlen((char const *)sun_path);
    if (tmp_0 >= (size_t)64) *(result + (64 - 2)) = (char)'>';
    break;
    default: snprintf(result,(size_t)64,"[UNKNOWN]"); /* snprintf_va_14 */
  }
  return result;
}

char const *UTI_SockaddrFamilyToString(int family)
{
  char const *__retres;
  switch (family) {
    case 2: __retres = "IPv4";
    goto return_label;
    case 10: __retres = "IPv6";
    goto return_label;
    case 1: __retres = "Unix";
    goto return_label;
    case 0: __retres = "UNSPEC";
    goto return_label;
    default: __retres = "?";
    goto return_label;
  }
  return_label: return __retres;
}

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) 
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_15(char * restrict s, size_t n, char const * restrict format);

char *UTI_TimeToLogForm(time_t t)
{
  struct tm *stm;
  char *result;
  pool_ptr = (pool_ptr + 1) % 16;
  result = buffer_pool[pool_ptr];
  stm = gmtime((time_t const *)(& t));
  if (stm) strftime(result,(size_t)64,"%Y-%m-%d %H:%M:%S",
                    (struct tm const *)stm);
  else snprintf(result,(size_t)64,"INVALID    INVALID "); /* snprintf_va_15 */
  return result;
}

void UTI_AdjustTimespec(struct timespec *old_ts, struct timespec *when,
                        struct timespec *new_ts, double *delta_time,
                        double dfreq, double doffset)
{
  double elapsed;
  elapsed = UTI_DiffTimespecsToDouble(when,old_ts);
  *delta_time = elapsed * dfreq - doffset;
  UTI_AddDoubleToTimespec(old_ts,*delta_time,new_ts);
  return;
}

void UTI_GetNtp64Fuzz(NTP_int64 *ts, int precision)
{
  int start;
  int bits;
  int tmp;
  uint32_t tmp_0;
  if (precision >= -32) 
    if (precision <= 32) tmp = 1; else tmp = 0;
  else tmp = 0;
  __FC_assert(tmp != 0,"util.c",644,"precision >= -32 && precision <= 32");
  __FC_assert((sizeof(*ts) == (unsigned long)8) != 0,"util.c",645,
              "sizeof (*ts) == 8");
  start = (int)(sizeof(*ts) - (unsigned long)(((precision + 32) + 7) / 8));
  tmp_0 = (uint32_t)0;
  ts->lo = tmp_0;
  ts->hi = tmp_0;
  UTI_GetRandomBytes((void *)((unsigned char *)ts + start),
                     (unsigned int)(sizeof(*ts) - (unsigned long)start));
  bits = (precision + 32) % 8;
  if (bits) *((unsigned char *)ts + start) = (unsigned char)((unsigned int)*(
                                                             (unsigned char *)ts + start) % (
                                                             1U << bits));
  return;
}

double UTI_Ntp32ToDouble(NTP_int32 x)
{
  double __retres;
  uint32_t tmp;
  tmp = ntohl(x);
  __retres = (double)tmp / 65536.0;
  return __retres;
}

NTP_int32 UTI_DoubleToNtp32(double x)
{
  NTP_int32 r;
  NTP_int32 tmp;
  if (x >= 4294967295.0 / 65536.0) r = 0xffffffff;
  else 
    if (x <= 0.0) r = (NTP_int32)0;
    else {
      x *= 65536.0;
      r = (NTP_int32)x;
      if ((double)r < x) r ++;
    }
  tmp = htonl(r);
  return tmp;
}

void UTI_ZeroNtp64(NTP_int64 *ts)
{
  uint32_t tmp;
  tmp = htonl((uint32_t)0);
  ts->lo = tmp;
  ts->hi = tmp;
  return;
}

int UTI_IsZeroNtp64(NTP_int64 *ts)
{
  int tmp;
  if (! ts->hi) 
    if (! ts->lo) tmp = 1; else tmp = 0;
  else tmp = 0;
  return tmp;
}

int UTI_CompareNtp64(NTP_int64 *a, NTP_int64 *b)
{
  int __retres;
  int32_t diff;
  uint32_t tmp;
  uint32_t tmp_0;
  int tmp_3;
  uint32_t tmp_1;
  uint32_t tmp_2;
  if (a->hi == b->hi) 
    if (a->lo == b->lo) {
      __retres = 0;
      goto return_label;
    }
  tmp = ntohl(a->hi);
  tmp_0 = ntohl(b->hi);
  diff = (int32_t)(tmp - tmp_0);
  if (diff < 0) {
    __retres = -1;
    goto return_label;
  }
  if (diff > 0) {
    __retres = 1;
    goto return_label;
  }
  tmp_1 = ntohl(a->lo);
  tmp_2 = ntohl(b->lo);
  if (tmp_1 < tmp_2) tmp_3 = -1; else tmp_3 = 1;
  __retres = tmp_3;
  return_label: return __retres;
}

int UTI_IsEqualAnyNtp64(NTP_int64 *a, NTP_int64 *b1, NTP_int64 *b2,
                        NTP_int64 *b3)
{
  int __retres;
  if (b1) 
    if (a->lo == b1->lo) 
      if (a->hi == b1->hi) {
        __retres = 1;
        goto return_label;
      }
  if (b2) 
    if (a->lo == b2->lo) 
      if (a->hi == b2->hi) {
        __retres = 1;
        goto return_label;
      }
  if (b3) 
    if (a->lo == b3->lo) 
      if (a->hi == b3->hi) {
        __retres = 1;
        goto return_label;
      }
  __retres = 0;
  return_label: return __retres;
}

void UTI_TimespecToNtp64(struct timespec *src, NTP_int64 *dest,
                         NTP_int64 *fuzz)
{
  uint32_t hi;
  uint32_t lo;
  uint32_t sec;
  uint32_t nsec;
  sec = (uint32_t)src->tv_sec;
  nsec = (uint32_t)src->tv_nsec;
  if (! nsec) {
    if (! sec) {
      lo = (uint32_t)0;
      hi = lo;
    }
    else goto _LAND;
  }
  else {
    _LAND:
    {
      hi = htonl((uint32_t)((unsigned long)sec + 0x83aa7e80UL));
      lo = htonl((uint32_t)(4.294967296 * (double)nsec));
      if (fuzz) {
        hi ^= fuzz->hi;
        lo ^= fuzz->lo;
      }
    }
  }
  dest->hi = hi;
  dest->lo = lo;
  return;
}

void UTI_Ntp64ToTimespec(NTP_int64 *src, struct timespec *dest)
{
  uint32_t ntp_sec;
  uint32_t ntp_frac;
  int tmp;
  tmp = UTI_IsZeroNtp64(src);
  if (tmp) {
    UTI_ZeroTimespec(dest);
    goto return_label;
  }
  ntp_sec = ntohl(src->hi);
  ntp_frac = ntohl(src->lo);
  dest->tv_sec = (time_t)(ntp_sec - (uint32_t)((unsigned long long)(1640995200LL - (long long)(
                                                                    (
                                                                    0 * 24) * 3600)) + (unsigned long long)0x83aa7e80UL)) + (time_t)(
                 1640995200LL - (long long)((0 * 24) * 3600));
  dest->tv_nsec = (long)((double)ntp_frac / 4.294967296);
  return_label: return;
}

int UTI_IsTimeOffsetSane(struct timespec *ts, double offset)
{
  int __retres;
  double t;
  double tmp;
  if (offset > - 4294967296.0) {
    if (! (offset < 4294967296.0)) {
      __retres = 0;
      goto return_label;
    }
  }
  else {
    __retres = 0;
    goto return_label;
  }
  tmp = UTI_TimespecToDouble(ts);
  t = tmp + offset;
  if (t < 0.0) {
    __retres = 0;
    goto return_label;
  }
  if (t < (double)(1640995200LL - (long long)((0 * 24) * 3600))) {
    __retres = 0;
    goto return_label;
  }
  else 
    if (t > (double)((1640995200LL - (long long)((0 * 24) * 3600)) + (
                     1LL << 32))) {
      __retres = 0;
      goto return_label;
    }
  __retres = 1;
  return_label: return __retres;
}

double UTI_Log2ToDouble(int l)
{
  double __retres;
  if (l >= 0) {
    if (l > 31) l = 31;
    __retres = (double)((uint32_t)1 << l);
    goto return_label;
  }
  else {
    if (l < -31) l = -31;
    __retres = 1.0 / (double)((uint32_t)1 << - l);
    goto return_label;
  }
  return_label: return __retres;
}

void UTI_TimespecNetworkToHost(Timespec *src, struct timespec *dest)
{
  uint32_t sec_low;
  uint32_t nsec;
  uint32_t sec_high;
  sec_low = ntohl(src->tv_sec_low);
  sec_high = ntohl(src->tv_sec_high);
  if (sec_high == (uint32_t)0x7fffffff) sec_high = (uint32_t)0;
  dest->tv_sec = (long)(((uint64_t)sec_high << 32) | (unsigned long)sec_low);
  nsec = ntohl(src->tv_nsec);
  if (nsec < 999999999U) dest->tv_nsec = (long)nsec;
  else dest->tv_nsec = (long)999999999U;
  return;
}

void UTI_TimespecHostToNetwork(struct timespec *src, Timespec *dest)
{
  dest->tv_nsec = htonl((uint32_t)src->tv_nsec);
  dest->tv_sec_high = htonl((uint32_t)((uint64_t)src->tv_sec >> 32));
  dest->tv_sec_low = htonl((uint32_t)src->tv_sec);
  return;
}

double UTI_FloatNetworkToHost(Float f)
{
  double __retres;
  int32_t exp_0;
  int32_t coef;
  uint32_t x;
  double tmp;
  x = ntohl((uint32_t)f.f);
  exp_0 = (int32_t)(x >> ((int)sizeof(int32_t) * 8 - 7));
  if (exp_0 >= 1 << (7 - 1)) exp_0 -= 1 << 7;
  exp_0 -= (int)sizeof(int32_t) * 8 - 7;
  coef = (int32_t)(x % (1U << ((int)sizeof(int32_t) * 8 - 7)));
  if (coef >= 1 << (((int)sizeof(int32_t) * 8 - 7) - 1)) coef -= 1 << (
                                                                 (int)sizeof(int32_t) * 8 - 7);
  tmp = pow(2.0,(double)exp_0);
  ;
  __retres = (double)coef * tmp;
  return __retres;
}

Float UTI_FloatHostToNetwork(double x)
{
  int32_t exp_0;
  int32_t coef;
  int32_t neg;
  Float f;
  uint32_t tmp_2;
  if (x < 0.0) {
    x = - x;
    neg = 1;
  }
  else 
    if (x >= 0.0) neg = 0;
    else {
      x = 0.0;
      neg = 0;
    }
  if (x < 1.0e-100) {
    coef = 0;
    exp_0 = coef;
  }
  else 
    if (x > 1.0e100) {
      exp_0 = - (- (1 << (7 - 1))) - 1;
      coef = (- (- (1 << (((int)sizeof(int32_t) * 8 - 7) - 1))) - 1) + neg;
    }
    else {
      double tmp;
      double tmp_0;
      double tmp_1;
      tmp = log(x);
      tmp_0 = log((double)2);
      exp_0 = (int32_t)(tmp / tmp_0 + (double)1);
      tmp_1 = pow(2.0,(double)(- exp_0 + ((int)sizeof(int32_t) * 8 - 7)));
      coef = (int32_t)(x * tmp_1 + 0.5);
      __FC_assert((coef > 0) != 0,"util.c",949,"coef > 0");
      while (coef > (- (- (1 << (((int)sizeof(int32_t) * 8 - 7) - 1))) - 1) + neg) {
        coef >>= 1;
        exp_0 ++;
      }
      if (exp_0 > - (- (1 << (7 - 1))) - 1) {
        exp_0 = - (- (1 << (7 - 1))) - 1;
        coef = (- (- (1 << (((int)sizeof(int32_t) * 8 - 7) - 1))) - 1) + neg;
      }
      else 
        if (exp_0 < - (1 << (7 - 1))) 
          if (exp_0 + ((int)sizeof(int32_t) * 8 - 7) >= - (1 << (7 - 1))) {
            coef >>= - (1 << (7 - 1)) - exp_0;
            exp_0 = - (1 << (7 - 1));
          }
          else {
            coef = 0;
            exp_0 = coef;
          }
    }
  if (neg) coef = (int32_t)(((uint32_t)(- coef) << 7) >> 7);
  tmp_2 = htonl(((uint32_t)exp_0 << ((int)sizeof(int32_t) * 8 - 7)) | (unsigned int)coef);
  f.f = (int32_t)tmp_2;
  return f;
}

int UTI_FdSetCloexec(int fd)
{
  int __retres;
  int flags;
  flags = fcntl(fd,1); /* __va_fcntl_void */
  if (flags != -1) {
    int tmp_0;
    int tmp;
    flags |= 1;
    tmp = fcntl(fd,2,flags); /* __va_fcntl_int */
    if (tmp) tmp_0 = 0; else tmp_0 = 1;
    __retres = tmp_0;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

void UTI_SetQuitSignalsHandler(void (*handler)(int ), int ignore_sigpipe)
{
  struct sigaction sa;
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  int tmp_4;
  sa.sa_handler = handler;
  sa.sa_flags = 0x10000000;
  tmp = sigemptyset(& sa.sa_mask);
  if (tmp < 0) {
    {
      void *__va_args[1] = {(void *)0};
      LOG_Message(LOGS_FATAL,"sigemptyset() failed",
                  (void * const *)(__va_args));
    }
    exit(1);
  }
  tmp_0 = sigaction(2,(struct sigaction const *)(& sa),(struct sigaction *)0);
  if (tmp_0 < 0) {
    {
      int __va_arg0 = 2;
      void *__va_args_13[1] = {& __va_arg0};
      LOG_Message(LOGS_FATAL,"sigaction(%d) failed",
                  (void * const *)(__va_args_13));
    }
    exit(1);
  }
  tmp_1 = sigaction(15,(struct sigaction const *)(& sa),
                    (struct sigaction *)0);
  if (tmp_1 < 0) {
    {
      int __va_arg0_15 = 15;
      void *__va_args_17[1] = {& __va_arg0_15};
      LOG_Message(LOGS_FATAL,"sigaction(%d) failed",
                  (void * const *)(__va_args_17));
    }
    exit(1);
  }
  tmp_2 = sigaction(3,(struct sigaction const *)(& sa),(struct sigaction *)0);
  if (tmp_2 < 0) {
    {
      int __va_arg0_19 = 3;
      void *__va_args_21[1] = {& __va_arg0_19};
      LOG_Message(LOGS_FATAL,"sigaction(%d) failed",
                  (void * const *)(__va_args_21));
    }
    exit(1);
  }
  tmp_3 = sigaction(1,(struct sigaction const *)(& sa),(struct sigaction *)0);
  if (tmp_3 < 0) {
    {
      int __va_arg0_23 = 1;
      void *__va_args_25[1] = {& __va_arg0_23};
      LOG_Message(LOGS_FATAL,"sigaction(%d) failed",
                  (void * const *)(__va_args_25));
    }
    exit(1);
  }
  if (ignore_sigpipe) sa.sa_handler = SIG_IGN;
  tmp_4 = sigaction(13,(struct sigaction const *)(& sa),
                    (struct sigaction *)0);
  if (tmp_4 < 0) {
    {
      int __va_arg0_27 = 13;
      void *__va_args_29[1] = {& __va_arg0_27};
      LOG_Message(LOGS_FATAL,"sigaction(%d) failed",
                  (void * const *)(__va_args_29));
    }
    exit(1);
  }
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) 
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int snprintf_va_16(char * restrict s, size_t n, char const * restrict format,
                   char *param0);

char *UTI_PathToDir(char const *path)
{
  char *__retres;
  char *dir;
  char *slash;
  slash = strrchr(path,'/');
  if (! slash) {
    char *tmp;
    tmp = Strdup(".");
    __retres = tmp;
    goto return_label;
  }
  if ((void *)slash == (void *)path) {
    char *tmp_0;
    tmp_0 = Strdup("/");
    __retres = tmp_0;
    goto return_label;
  }
  dir = (char *)Malloc((size_t)((slash - path) + (long)1));
  snprintf(dir,(size_t)((slash - path) + (long)1),"%s",(char *)path); /* snprintf_va_16 */
  __retres = dir;
  return_label: return __retres;
}

static int create_dir(char *p, mode_t mode_0, uid_t uid, gid_t gid)
{
  int __retres;
  int status;
  struct stat buf;
  int tmp_1;
  int tmp_3;
  status = stat((char const *)p,& buf);
  if (status < 0) {
    if (__fc_errno != 2) {
      char *tmp;
      tmp = strerror(__fc_errno);
      ;
      {
        char *__va_arg0 = p;
        char *__va_arg1 = tmp;
        void *__va_args[2] = {& __va_arg0, & __va_arg1};
        LOG_Message(LOGS_ERR,"Could not access %s : %s",
                    (void * const *)(__va_args));
      }
      __retres = 0;
      goto return_label;
    }
  }
  else {
    if ((buf.st_mode & (unsigned int)0170000) == (unsigned int)0040000) {
      __retres = 1;
      goto return_label;
    }
    {
      char *__va_arg0_16 = p;
      void *__va_args_18[1] = {& __va_arg0_16};
      LOG_Message(LOGS_ERR,"%s is not directory",
                  (void * const *)(__va_args_18));
    }
    __retres = 0;
    goto return_label;
  }
  tmp_1 = mkdir((char const *)p,mode_0);
  if (tmp_1 < 0) {
    char *tmp_0;
    tmp_0 = strerror(__fc_errno);
    ;
    {
      char *__va_arg0_20 = p;
      char *__va_arg1_22 = tmp_0;
      void *__va_args_24[2] = {& __va_arg0_20, & __va_arg1_22};
      LOG_Message(LOGS_ERR,"Could not create directory %s : %s",
                  (void * const *)(__va_args_24));
    }
    __retres = 0;
    goto return_label;
  }
  tmp_3 = chown((char const *)p,uid,gid);
  if (tmp_3 < 0) {
    char *tmp_2;
    tmp_2 = strerror(__fc_errno);
    ;
    {
      char *__va_arg0_26 = p;
      char *__va_arg1_28 = tmp_2;
      void *__va_args_30[2] = {& __va_arg0_26, & __va_arg1_28};
      LOG_Message(LOGS_ERR,"Could not change ownership of %s : %s",
                  (void * const *)(__va_args_30));
    }
    rmdir((char const *)p);
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

int UTI_CreateDirAndParents(char const *path, mode_t mode_0, uid_t uid,
                            gid_t gid)
{
  int __retres;
  char *p;
  int i;
  int j;
  int k;
  int last;
  int tmp;
  void *tmp_1;
  size_t tmp_0;
  tmp = strcmp(path,".");
  if (! tmp) {
    __retres = 1;
    goto return_label;
  }
  tmp_0 = strlen(path);
  tmp_1 = Malloc((size_t)1 + tmp_0);
  p = (char *)tmp_1;
  k = 0;
  i = k;
  while (1) {
    {
      int tmp_2;
      int tmp_3;
      tmp_2 = i;
      i ++;
      tmp_3 = k;
      k ++;
      *(p + tmp_2) = *(path + tmp_3);
      if ((int)*(path + k) == '/') goto _LOR;
      else 
        if (! *(path + k)) {
          _LOR:
          {
            int tmp_7;
            gid_t tmp_4;
            uid_t tmp_5;
            mode_t tmp_6;
            last = 1;
            j = k;
            while (*(path + j)) {
              if ((int)*(path + j) != '/') {
                k = j - 1;
                last = 0;
                break;
              }
              j ++;
            }
            *(p + i) = (char)0;
            if (last) tmp_4 = gid; else tmp_4 = (gid_t)0;
            if (last) tmp_5 = uid; else tmp_5 = (uid_t)0;
            if (last) tmp_6 = mode_0; else tmp_6 = (mode_t)0755;
            ;
            tmp_7 = create_dir(p,tmp_6,tmp_5,tmp_4);
            if (! tmp_7) {
              free((void *)p);
              __retres = 0;
              goto return_label;
            }
            if (last) break;
          }
        }
      if (! *(path + k)) break;
    }
  }
  free((void *)p);
  __retres = 1;
  return_label: return __retres;
}

int UTI_CheckDirPermissions(char const *path, mode_t perm, uid_t uid,
                            gid_t gid)
{
  int __retres;
  struct stat buf;
  int tmp_0;
  tmp_0 = stat(path,& buf);
  if (tmp_0) {
    char *tmp;
    tmp = strerror(__fc_errno);
    ;
    {
      char const *__va_arg0 = path;
      char *__va_arg1 = tmp;
      void *__va_args[2] = {& __va_arg0, & __va_arg1};
      LOG_Message(LOGS_ERR,"Could not access %s : %s",
                  (void * const *)(__va_args));
    }
    __retres = 0;
    goto return_label;
  }
  if (! ((buf.st_mode & (unsigned int)0170000) == (unsigned int)0040000)) {
    {
      char const *__va_arg0_12 = path;
      void *__va_args_14[1] = {& __va_arg0_12};
      LOG_Message(LOGS_ERR,"%s is not directory",
                  (void * const *)(__va_args_14));
    }
    __retres = 0;
    goto return_label;
  }
  if ((buf.st_mode & (unsigned int)0777) & ~ perm) {
    {
      char const *__va_arg0_16 = path;
      void *__va_args_18[1] = {& __va_arg0_16};
      LOG_Message(LOGS_ERR,"Wrong permissions on %s",
                  (void * const *)(__va_args_18));
    }
    __retres = 0;
    goto return_label;
  }
  if (buf.st_uid != uid) {
    {
      char const *__va_arg0_20 = path;
      char const *__va_arg1_22 = "UID";
      uid_t __va_arg2 = uid;
      void *__va_args_25[3] = {& __va_arg0_20, & __va_arg1_22, & __va_arg2};
      LOG_Message(LOGS_ERR,"Wrong owner of %s (%s != %u)",
                  (void * const *)(__va_args_25));
    }
    __retres = 0;
    goto return_label;
  }
  if (buf.st_gid != gid) {
    {
      char const *__va_arg0_27 = path;
      char const *__va_arg1_29 = "GID";
      gid_t __va_arg2_31 = gid;
      void *__va_args_33[3] =
        {& __va_arg0_27, & __va_arg1_29, & __va_arg2_31};
      LOG_Message(LOGS_ERR,"Wrong owner of %s (%s != %u)",
                  (void * const *)(__va_args_33));
    }
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

void UTI_DropRoot(uid_t uid, gid_t gid)
{
  int tmp_0;
  int tmp_2;
  int tmp_4;
  tmp_0 = setgroups((size_t)0,(gid_t const *)0);
  if (tmp_0) {
    char *tmp;
    tmp = strerror(__fc_errno);
    {
      char *__va_arg0 = tmp;
      void *__va_args[1] = {& __va_arg0};
      LOG_Message(LOGS_FATAL,"setgroups() failed : %s",
                  (void * const *)(__va_args));
    }
    exit(1);
  }
  tmp_2 = setgid(gid);
  if (tmp_2) {
    char *tmp_1;
    tmp_1 = strerror(__fc_errno);
    ;
    {
      gid_t __va_arg0_12 = gid;
      char *__va_arg1 = tmp_1;
      void *__va_args_15[2] = {& __va_arg0_12, & __va_arg1};
      LOG_Message(LOGS_FATAL,"setgid(%u) failed : %s",
                  (void * const *)(__va_args_15));
    }
    exit(1);
  }
  tmp_4 = setuid(uid);
  if (tmp_4) {
    char *tmp_3;
    tmp_3 = strerror(__fc_errno);
    ;
    {
      uid_t __va_arg0_17 = uid;
      char *__va_arg1_19 = tmp_3;
      void *__va_args_21[2] = {& __va_arg0_17, & __va_arg1_19};
      LOG_Message(LOGS_FATAL,"setuid(%u) failed : %s",
                  (void * const *)(__va_args_21));
    }
    exit(1);
  }
  return;
}

static FILE *UTI_GetRandomBytesUrandom_f = (FILE *)0;
void UTI_GetRandomBytesUrandom(void *buf, unsigned int len)
{
  size_t tmp_0;
  if (! UTI_GetRandomBytesUrandom_f) UTI_GetRandomBytesUrandom_f = fopen
                                     ("/dev/urandom","r");
  if (! UTI_GetRandomBytesUrandom_f) {
    char *tmp;
    tmp = strerror(__fc_errno);
    {
      char const *__va_arg0 = "/dev/urandom";
      char *__va_arg1 = tmp;
      void *__va_args[2] = {& __va_arg0, & __va_arg1};
      LOG_Message(LOGS_FATAL,"Can\'t open %s : %s",
                  (void * const *)(__va_args));
    }
    exit(1);
  }
  tmp_0 = fread(buf,(size_t)1,(size_t)len,UTI_GetRandomBytesUrandom_f);
  ;
  if (tmp_0 != (size_t)len) {
    {
      char const *__va_arg0_9 = "/dev/urandom";
      void *__va_args_11[1] = {& __va_arg0_9};
      LOG_Message(LOGS_FATAL,"Can\'t read from %s",
                  (void * const *)(__va_args_11));
    }
    exit(1);
  }
  return;
}

void UTI_GetRandomBytes(void *buf, unsigned int len)
{
  UTI_GetRandomBytesUrandom(buf,len);
  return;
}

void DNS_Name2IPAddressAsync(char const *name,
                             void (*handler)(DNS_Status status, int n_addrs,
                                             IPAddr *ip_addrs, void *anything),
                             void *anything);

void NSD_Initialise(void);

void NSD_Finalise(void);

int NSD_GetAuthDelay(uint32_t key_id);

int NSD_SignAndSendPacket(uint32_t key_id, NTP_Packet *packet,
                          NTP_Remote_Address *remote_addr,
                          NTP_Local_Address *local_addr, int length);

static void resolve_name(int fd, int event, void *anything)
{
  struct DNS_Async_Instance *inst;
  IPAddr addrs[16];
  DNS_Status status;
  int i;
  inst = (struct DNS_Async_Instance *)anything;
  SCH_RemoveFileHandler(inst->pipe[0]);
  close(inst->pipe[0]);
  close(inst->pipe[1]);
  status = DNS_Name2IPAddress(inst->name,addrs,16);
  i = 0;
  while (1) {
    if (status == (unsigned int)DNS_Success) 
      if (i < 16) {
        if (! ((int)addrs[i].family != 0)) break;
      }
      else break;
    else break;
    i ++;
  }
  (*(inst->handler))(status,i,addrs,inst->arg);
  free((void *)inst);
  return;
}

void DNS_Name2IPAddressAsync(char const *name,
                             void (*handler)(DNS_Status status, int n_addrs,
                                             IPAddr *ip_addrs, void *anything),
                             void *anything)
{
  struct DNS_Async_Instance *inst;
  int tmp_0;
  ssize_t tmp_1;
  inst = (struct DNS_Async_Instance *)Malloc(sizeof(struct DNS_Async_Instance));
  inst->name = name;
  inst->handler = handler;
  inst->arg = anything;
  tmp_0 = pipe(inst->pipe);
  if (tmp_0) {
    {
      void *__va_args[1] = {(void *)0};
      LOG_Message(LOGS_FATAL,"pipe() failed",(void * const *)(__va_args));
    }
    exit(1);
  }
  UTI_FdSetCloexec(inst->pipe[0]);
  UTI_FdSetCloexec(inst->pipe[1]);
  SCH_AddFileHandler(inst->pipe[0],1,& resolve_name,
                     (SCH_ArbitraryArgument)inst);
  tmp_1 = write(inst->pipe[1],(void const *)"",(size_t)1);
  return;
}

void NSD_Initialise(void)
{
  return;
}

void NSD_Finalise(void)
{
  return;
}

int NSD_GetAuthDelay(uint32_t key_id)
{
  int __retres;
  __retres = 0;
  return __retres;
}

int NSD_SignAndSendPacket(uint32_t key_id, NTP_Packet *packet,
                          NTP_Remote_Address *remote_addr,
                          NTP_Local_Address *local_addr, int length)
{
  int __retres;
  __retres = 0;
  return __retres;
}

int volatile qsort_nondet;
int eva_main(void)
{
  char argv0[256];
  char argv1[256];
  char argv2[256];
  char argv3[256];
  char argv4[256];
  int tmp_0;
  int argc = Frama_C_interval(0,5);
  char *argv[6] = {argv0, argv1, argv2, argv3, argv4, (char *)0};
  {
    int i = 0;
    /*@ loop unroll 5; */
    while (i < 5) {
      Frama_C_make_unknown(argv[i],(size_t)255);
      *(argv[i] + 255) = (char)0;
      i ++;
    }
  }
  tmp_0 = main(argc,argv);
  return tmp_0;
}

static struct timespec current_time;
static NTP_Receive_Buffer req_buffer;
static NTP_Receive_Buffer res_buffer;
static int req_length;
static int res_length;
static SCH_TimeoutID add_timeout_in_class(double min_delay,
                                          double separation,
                                          double randomness,
                                          SCH_TimeoutClass class,
                                          void (*handler)(SCH_ArbitraryArgument ),
                                          SCH_ArbitraryArgument arg)
{
  SCH_TimeoutID __retres;
  __retres = (SCH_TimeoutID)102;
  return __retres;
}

extern SPF_Instance SPF_CreateInstance(int min_samples, int max_samples,
                                       double max_dispersion,
                                       double combine_ratio);

extern void SPF_DestroyInstance(SPF_Instance filter);

extern int SPF_AccumulateSample(SPF_Instance filter, NTP_Sample *sample);

extern int SPF_GetNumberOfSamples(SPF_Instance filter);

extern void SPF_DropSamples(SPF_Instance filter);

extern int SPF_GetFilteredSample(SPF_Instance filter, NTP_Sample *sample);

extern void SPF_SlewSamples(SPF_Instance filter, struct timespec *when,
                            double dfreq, double doffset);

static LOG_FileID logfileid_1;
static int log_raw_measurements;
static ARR_Instance broadcasts_0;
static int server_sock_fd4_0;
static int server_sock_fd6;
static ADF_AuthTable access_auth_table;
static char const leap_chars[4] =
  {(char)'N', (char)'+', (char)'-', (char)'?'};
static char const tss_chars[3] = {(char)'D', (char)'K', (char)'H'};
static void transmit_timeout(void *arg);

static double get_transmit_delay(NCR_Instance inst, int on_tx, double last_tx);

static double get_separation(int poll);

static void do_size_checks(void)
{
  __FC_assert((sizeof(NTP_int32) == (unsigned long)4) != 0,"ntp_core.c",324,
              "sizeof(NTP_int32) == 4");
  __FC_assert((sizeof(NTP_int64) == (unsigned long)8) != 0,"ntp_core.c",325,
              "sizeof(NTP_int64) == 8");
  __FC_assert((0UL == (unsigned long)0) != 0,"ntp_core.c",328,
              "offsetof(NTP_Packet, lvm) == 0");
  __FC_assert((1UL == (unsigned long)1) != 0,"ntp_core.c",329,
              "offsetof(NTP_Packet, stratum) == 1");
  __FC_assert((2UL == (unsigned long)2) != 0,"ntp_core.c",330,
              "offsetof(NTP_Packet, poll) == 2");
  __FC_assert((3UL == (unsigned long)3) != 0,"ntp_core.c",331,
              "offsetof(NTP_Packet, precision) == 3");
  __FC_assert((4UL == (unsigned long)4) != 0,"ntp_core.c",332,
              "offsetof(NTP_Packet, root_delay) == 4");
  __FC_assert((8UL == (unsigned long)8) != 0,"ntp_core.c",333,
              "offsetof(NTP_Packet, root_dispersion) == 8");
  __FC_assert((12UL == (unsigned long)12) != 0,"ntp_core.c",334,
              "offsetof(NTP_Packet, reference_id) == 12");
  __FC_assert((16UL == (unsigned long)16) != 0,"ntp_core.c",335,
              "offsetof(NTP_Packet, reference_ts) == 16");
  __FC_assert((24UL == (unsigned long)24) != 0,"ntp_core.c",336,
              "offsetof(NTP_Packet, originate_ts) == 24");
  __FC_assert((32UL == (unsigned long)32) != 0,"ntp_core.c",337,
              "offsetof(NTP_Packet, receive_ts) == 32");
  __FC_assert((40UL == (unsigned long)40) != 0,"ntp_core.c",338,
              "offsetof(NTP_Packet, transmit_ts) == 40");
  return;
}

static void do_time_checks(void)
{
  struct timespec now;
  NTP_int64 nts1;
  NTP_int64 nts2;
  int r;
  int tmp;
  time_t warning_advance = (time_t)(((3600 * 24) * 365) * 10);
  struct timespec ts1 =
    {.tv_sec = (long)(1640995200LL - (long long)((0 * 24) * 3600)),
     .tv_nsec = (long)1};
  struct timespec ts2 =
    {.tv_sec = (long)((1640995200LL - (long long)((0 * 24) * 3600)) - (long long)1),
     .tv_nsec = (long)1};
  UTI_TimespecToNtp64(& ts1,& nts1,(NTP_int64 *)0);
  UTI_TimespecToNtp64(& ts2,& nts2,(NTP_int64 *)0);
  UTI_Ntp64ToTimespec(& nts1,& ts1);
  UTI_Ntp64ToTimespec(& nts2,& ts2);
  if ((long long)ts1.tv_sec == 1640995200LL - (long long)((0 * 24) * 3600)) 
    if (((unsigned long long)ts1.tv_sec + (1ULL << 32)) - (unsigned long long)1 == (unsigned long long)ts2.tv_sec) 
      tmp = 1;
    else tmp = 0;
  else tmp = 0;
  r = tmp;
  __FC_assert(r != 0,"ntp_core.c",364,"r");
  now = current_time;
  if (ts2.tv_sec - now.tv_sec < warning_advance) {
    char *tmp_0;
    tmp_0 = UTI_TimeToLogForm(ts2.tv_sec);
    {
      char *__va_arg0 = tmp_0;
      void *__va_args[1] = {& __va_arg0};
      LOG_Message(LOGS_WARN,"Assumed NTP time ends at %s!",
                  (void * const *)(__va_args));
    }
  }
  return;
}

static void zero_local_timestamp(NTP_Local_Timestamp *ts)
{
  UTI_ZeroTimespec(& ts->ts);
  ts->err = 0.0;
  ts->source = NTP_TS_DAEMON;
  return;
}

void NCR_Initialise(void)
{
  int tmp;
  do_size_checks();
  do_time_checks();
  tmp = CNF_GetLogMeasurements(& log_raw_measurements);
  if (tmp) logfileid_1 = LOG_FileOpen("measurements",
                                      "   Date (UTC) Time     IP Address   L St 123 567 ABCD  LP RP Score    Offset  Peer del. Peer disp.  Root del. Root disp. Refid     MTxRx");
  else logfileid_1 = -1;
  access_auth_table = ADF_CreateTable();
  broadcasts_0 = ARR_CreateInstance((unsigned int)sizeof(BroadcastDestination));
  server_sock_fd4_0 = -2;
  server_sock_fd6 = -2;
  return;
}

void NCR_Finalise(void)
{
  unsigned int i;
  if (server_sock_fd4_0 != -2) __FC_assert((server_sock_fd4_0 == 100) != 0,
                                           "ntp_core.c",414,
                                           "server_sock_fd4 == 100");
  if (server_sock_fd6 != -2) __FC_assert((server_sock_fd6 == 100) != 0,
                                         "ntp_core.c",416,
                                         "server_sock_fd6 == 100");
  i = (unsigned int)0;
  while (1) {
    unsigned int tmp_0;
    void *tmp;
    tmp_0 = ARR_GetSize(broadcasts_0);
    ;
    if (! (i < tmp_0)) break;
    tmp = ARR_GetElement(broadcasts_0,i);
    ;
    __FC_assert((((BroadcastDestination *)tmp)->local_addr.sock_fd == 100) != 0,
                "ntp_core.c",419,
                "((BroadcastDestination *)ARR_GetElement(broadcasts, i))->local_addr.sock_fd == 100");
    i ++;
  }
  ARR_DestroyInstance(broadcasts_0);
  ADF_DestroyTable(access_auth_table);
  return;
}

static void restart_timeout(NCR_Instance inst, double delay)
{
  int tmp;
  int tmp_0;
  int tmp_1;
  double tmp_2;
  if (inst->tx_suspended) {
    __FC_assert(! inst->tx_timeout_id != 0,"ntp_core.c",432,
                "!inst->tx_timeout_id");
    goto return_label;
  }
  if (! inst->rx_timeout_id) tmp = 1;
  else 
    if (inst->rx_timeout_id == (SCH_TimeoutID)102) tmp = 1; else tmp = 0;
  __FC_assert(tmp != 0,"ntp_core.c",437,
              "!inst->rx_timeout_id || inst->rx_timeout_id == 102");
  inst->rx_timeout_id = (SCH_TimeoutID)0;
  if (! inst->tx_timeout_id) tmp_0 = 1;
  else 
    if (inst->tx_timeout_id == (SCH_TimeoutID)102) tmp_0 = 1; else tmp_0 = 0;
  __FC_assert(tmp_0 != 0,"ntp_core.c",439,
              "!inst->tx_timeout_id || inst->tx_timeout_id == 102");
  ;
  if (inst->mode == (unsigned int)MODE_CLIENT) tmp_1 = SCH_NtpClientClass;
  else tmp_1 = SCH_NtpPeerClass;
  tmp_2 = get_separation(inst->local_poll);
  ;
  inst->tx_timeout_id = add_timeout_in_class(delay,tmp_2,0.02,
                                             (SCH_TimeoutClass)tmp_1,
                                             & transmit_timeout,(void *)inst);
  return_label: return;
}

static void start_initial_timeout(NCR_Instance inst)
{
  double delay;
  double last_tx;
  struct timespec now;
  double tmp;
  if (! inst->tx_timeout_id) SRC_SetActive(inst->source);
  SCH_GetLastEventTime(& now,(double *)0,(struct timespec *)0);
  last_tx = UTI_DiffTimespecsToDouble(& now,& inst->local_tx.ts);
  if (last_tx < 0.0) last_tx = 0.0;
  tmp = get_transmit_delay(inst,0,0.0);
  delay = tmp - last_tx;
  if (delay < 0.2) delay = 0.2;
  restart_timeout(inst,delay);
  return;
}

static void close_client_socket(NCR_Instance inst)
{
  int tmp;
  if (inst->mode == (unsigned int)MODE_CLIENT) 
    if (inst->local_addr.sock_fd != -2) {
      __FC_assert((inst->local_addr.sock_fd == 101) != 0,"ntp_core.c",484,
                  "inst->local_addr.sock_fd == 101");
      inst->local_addr.sock_fd = -2;
    }
  if (! inst->rx_timeout_id) tmp = 1;
  else 
    if (inst->rx_timeout_id == (SCH_TimeoutID)102) tmp = 1; else tmp = 0;
  __FC_assert(tmp != 0,"ntp_core.c",488,
              "!inst->rx_timeout_id || inst->rx_timeout_id == 102");
  inst->rx_timeout_id = (SCH_TimeoutID)0;
  return;
}

static void take_offline(NCR_Instance inst)
{
  int tmp;
  inst->opmode = MD_OFFLINE;
  if (! inst->tx_timeout_id) tmp = 1;
  else 
    if (inst->tx_timeout_id == (SCH_TimeoutID)102) tmp = 1; else tmp = 0;
  __FC_assert(tmp != 0,"ntp_core.c",499,
              "!inst->tx_timeout_id || inst->tx_timeout_id == 102");
  inst->tx_timeout_id = (SCH_TimeoutID)0;
  SRC_UnsetActive(inst->source);
  close_client_socket(inst);
  NCR_ResetInstance(inst);
  return;
}

NCR_Instance NCR_GetInstance(NTP_Remote_Address *remote_addr,
                             NTP_Source_Type type, SourceParameters *params)
{
  NCR_Instance result;
  double tmp_0;
  double tmp_2;
  double tmp_4;
  uint32_t tmp_13;
  result = (NCR_Instance)Malloc(sizeof(struct NCR_Instance_Record));
  result->remote_addr = *remote_addr;
  result->local_addr.ip_addr.family = (uint16_t)0;
  result->local_addr.if_index = -1;
  switch (type) {
    case NTP_SERVER: result->local_addr.sock_fd = -2;
    result->mode = MODE_CLIENT;
    break;
    case NTP_PEER:
    if ((int)remote_addr->ip_addr.family != 0) result->local_addr.sock_fd = 100;
    else result->local_addr.sock_fd = 0;
    result->mode = MODE_ACTIVE;
    break;
    default: __FC_assert(0 != 0,"ntp_core.c",537,"0");
  }
  result->interleaved = params->interleaved;
  result->minpoll = params->minpoll;
  if (result->minpoll < -6) result->minpoll = 6;
  else 
    if (result->minpoll > 24) result->minpoll = 24;
  result->maxpoll = params->maxpoll;
  if (result->maxpoll < -6) result->maxpoll = 10;
  else 
    if (result->maxpoll > 24) result->maxpoll = 24;
  if (result->maxpoll < result->minpoll) result->maxpoll = result->minpoll;
  result->min_stratum = params->min_stratum;
  if (result->min_stratum >= 16) result->min_stratum = 16 - 1;
  result->presend_minpoll = params->presend_minpoll;
  if (result->presend_minpoll <= 24) 
    if (result->mode != (unsigned int)MODE_CLIENT) result->presend_minpoll = 
                                                   24 + 1;
  if (params->max_delay < 1.0e3) tmp_0 = params->max_delay;
  else tmp_0 = 1.0e3;
  if (0.0 > tmp_0) result->max_delay = 0.0;
  else {
    double tmp_1;
    if (params->max_delay < 1.0e3) tmp_1 = params->max_delay;
    else tmp_1 = 1.0e3;
    result->max_delay = tmp_1;
  }
  if (params->max_delay_ratio < 1.0e6) tmp_2 = params->max_delay_ratio;
  else tmp_2 = 1.0e6;
  if (0.0 > tmp_2) result->max_delay_ratio = 0.0;
  else {
    double tmp_3;
    if (params->max_delay_ratio < 1.0e6) tmp_3 = params->max_delay_ratio;
    else tmp_3 = 1.0e6;
    result->max_delay_ratio = tmp_3;
  }
  if (params->max_delay_dev_ratio < 1.0e6) tmp_4 = params->max_delay_dev_ratio;
  else tmp_4 = 1.0e6;
  if (0.0 > tmp_4) result->max_delay_dev_ratio = 0.0;
  else {
    double tmp_5;
    if (params->max_delay_dev_ratio < 1.0e6) tmp_5 = params->max_delay_dev_ratio;
    else tmp_5 = 1.0e6;
    result->max_delay_dev_ratio = tmp_5;
  }
  result->offset_correction = params->offset;
  result->auto_burst = params->burst;
  result->auto_offline = params->auto_offline;
  result->poll_target = params->poll_target;
  result->version = 4;
  if (params->authkey == (uint32_t)0) {
    result->auth_mode = AUTH_NONE;
    result->auth_key_id = (uint32_t)0;
  }
  else {
    int tmp_9;
    int tmp_10;
    result->auth_mode = AUTH_SYMMETRIC;
    result->auth_key_id = params->authkey;
    tmp_9 = KEY_KeyKnown(result->auth_key_id);
    if (tmp_9) {
      int tmp_8;
      tmp_8 = KEY_CheckKeyLength(result->auth_key_id);
      if (! tmp_8) {
        char *tmp_7;
        tmp_7 = UTI_IPToString(& result->remote_addr.ip_addr);
        ;
        {
          uint32_t __va_arg0 = result->auth_key_id;
          char *__va_arg1 = tmp_7;
          char const *__va_arg2 = "too short";
          void *__va_args[3] = {& __va_arg0, & __va_arg1, & __va_arg2};
          LOG_Message(LOGS_WARN,"Key %u used by source %s is %s",
                      (void * const *)(__va_args));
        }
      }
    }
    else {
      char *tmp_6;
      tmp_6 = UTI_IPToString(& result->remote_addr.ip_addr);
      ;
      {
        uint32_t __va_arg0_26 = result->auth_key_id;
        char *__va_arg1_28 = tmp_6;
        char const *__va_arg2_30 = "missing";
        void *__va_args_32[3] =
          {& __va_arg0_26, & __va_arg1_28, & __va_arg2_30};
        LOG_Message(LOGS_WARN,"Key %u used by source %s is %s",
                    (void * const *)(__va_args_32));
      }
    }
    tmp_10 = KEY_GetAuthLength(result->auth_key_id);
    if (tmp_10 + 4 > 4 + 20) result->version = 3;
  }
  if (params->version) {
    int tmp_11;
    if (params->version < 4) tmp_11 = params->version; else tmp_11 = 4;
    if (1 > tmp_11) result->version = 1;
    else {
      int tmp_12;
      if (params->version < 4) tmp_12 = params->version; else tmp_12 = 4;
      result->version = tmp_12;
    }
  }
  ;
  ;
  ;
  ;
  ;
  ;
  tmp_13 = UTI_IPToRefid(& remote_addr->ip_addr);
  result->source = SRC_CreateNewInstance(tmp_13,SRC_NTP,params->sel_options,
                                         & result->remote_addr.ip_addr,
                                         params->min_samples,
                                         params->max_samples,
                                         params->min_delay,params->asymmetry);
  if (params->filter_length >= 1) result->filter = SPF_CreateInstance
                                  (params->filter_length,
                                   params->filter_length,16.0,0.0);
  else result->filter = (SPF_Instance)0;
  result->rx_timeout_id = (SCH_TimeoutID)0;
  result->tx_timeout_id = (SCH_TimeoutID)0;
  result->tx_suspended = 1;
  if (params->connectivity == (unsigned int)SRC_ONLINE) result->opmode = MD_ONLINE;
  else 
    if (params->connectivity == (unsigned int)SRC_MAYBE_ONLINE) {
      int tmp_14;
      tmp_14 = NIO_IsServerConnectable(remote_addr);
      if (tmp_14) result->opmode = MD_ONLINE;
      else result->opmode = MD_OFFLINE;
    }
    else result->opmode = MD_OFFLINE;
  result->local_poll = result->minpoll;
  result->poll_score = 0.0;
  zero_local_timestamp(& result->local_tx);
  result->burst_good_samples_to_go = 0;
  result->burst_total_samples_to_go = 0;
  memset((void *)(& result->report),0,sizeof(result->report));
  NCR_ResetInstance(result);
  if (params->iburst) NCR_InitiateSampleBurst(result,4,8);
  return result;
}

void NCR_DestroyInstance(NCR_Instance instance)
{
  if (instance->opmode != (unsigned int)MD_OFFLINE) take_offline(instance);
  if (instance->mode == (unsigned int)MODE_ACTIVE) __FC_assert((instance->local_addr.sock_fd == 100) != 0,
                                                               "ntp_core.c",
                                                               645,
                                                               "instance->local_addr.sock_fd == 100");
  if (instance->filter) SPF_DestroyInstance(instance->filter);
  SRC_DestroyInstance(instance->source);
  free((void *)instance);
  return;
}

void NCR_StartInstance(NCR_Instance instance)
{
  instance->tx_suspended = 0;
  if (instance->opmode != (unsigned int)MD_OFFLINE) start_initial_timeout
                                                    (instance);
  return;
}

void NCR_ResetInstance(NCR_Instance instance)
{
  instance->tx_count = (unsigned int)0;
  instance->presend_done = 0;
  instance->remote_poll = 0;
  instance->remote_stratum = 0;
  instance->valid_rx = 0;
  instance->valid_timestamps = 0;
  UTI_ZeroNtp64(& instance->remote_ntp_rx);
  UTI_ZeroNtp64(& instance->remote_ntp_tx);
  UTI_ZeroNtp64(& instance->local_ntp_rx);
  UTI_ZeroNtp64(& instance->local_ntp_tx);
  zero_local_timestamp(& instance->local_rx);
  zero_local_timestamp(& instance->prev_local_tx);
  instance->prev_local_poll = 0;
  instance->prev_tx_count = (unsigned int)0;
  instance->updated_init_timestamps = 0;
  UTI_ZeroNtp64(& instance->init_remote_ntp_tx);
  zero_local_timestamp(& instance->init_local_rx);
  if (instance->filter) SPF_DropSamples(instance->filter);
  return;
}

void NCR_ResetPoll(NCR_Instance instance)
{
  if (instance->local_poll != instance->minpoll) {
    instance->local_poll = instance->minpoll;
    if (instance->tx_timeout_id) {
      double tmp;
      tmp = get_transmit_delay(instance,0,0.0);
      ;
      restart_timeout(instance,tmp);
    }
  }
  return;
}

void NCR_ChangeRemoteAddress(NCR_Instance inst,
                             NTP_Remote_Address *remote_addr)
{
  uint32_t tmp;
  memset((void *)(& inst->report),0,sizeof(inst->report));
  NCR_ResetInstance(inst);
  inst->remote_addr = *remote_addr;
  if (inst->mode == (unsigned int)MODE_CLIENT) close_client_socket(inst);
  else {
    __FC_assert((inst->local_addr.sock_fd == 100) != 0,"ntp_core.c",726,
                "inst->local_addr.sock_fd == 100");
    inst->local_addr.ip_addr.family = (uint16_t)0;
    inst->local_addr.if_index = -1;
    if ((int)remote_addr->ip_addr.family != 0) inst->local_addr.sock_fd = 100;
    else inst->local_addr.sock_fd = 0;
  }
  ;
  tmp = UTI_IPToRefid(& remote_addr->ip_addr);
  ;
  SRC_SetRefid(inst->source,tmp,& inst->remote_addr.ip_addr);
  SRC_ResetInstance(inst->source);
  return;
}

static void adjust_poll(NCR_Instance inst, double adj)
{
  inst->poll_score += adj;
  if (inst->poll_score >= 1.0) {
    inst->local_poll += (int)inst->poll_score;
    inst->poll_score -= (double)((int)inst->poll_score);
  }
  if (inst->poll_score < 0.0) {
    inst->local_poll += (int)(inst->poll_score - 1.0);
    inst->poll_score -= (double)((int)(inst->poll_score - 1.0));
  }
  if (inst->local_poll < inst->minpoll) {
    inst->local_poll = inst->minpoll;
    inst->poll_score = (double)0;
  }
  else 
    if (inst->local_poll > inst->maxpoll) {
      inst->local_poll = inst->maxpoll;
      inst->poll_score = 1.0;
    }
  if (inst->local_poll < 0) {
    int tmp;
    tmp = SRC_IsReachable(inst->source);
    if (tmp) {
      double tmp_1;
      SST_Stats tmp_0;
      tmp_0 = SRC_GetSourcestats(inst->source);
      tmp_1 = SST_MinRoundTripDelay(tmp_0);
      if (tmp_1 > 0.01) inst->local_poll = 0;
    }
    else inst->local_poll = 0;
  }
  return;
}

static double get_poll_adj(NCR_Instance inst, double error_in_estimate,
                           double peer_distance)
{
  double poll_adj;
  int samples;
  if (error_in_estimate > peer_distance) {
    double tmp;
    double tmp_0;
    tmp = log(error_in_estimate / peer_distance);
    tmp_0 = log(2.0);
    poll_adj = - tmp / tmp_0;
  }
  else {
    SST_Stats tmp_1;
    tmp_1 = SRC_GetSourcestats(inst->source);
    samples = SST_Samples(tmp_1);
    poll_adj = ((double)samples / (double)inst->poll_target - 1.0) / (double)inst->poll_target;
    if (samples < inst->poll_target) poll_adj *= 2.0;
  }
  return poll_adj;
}

static int get_transmit_poll(NCR_Instance inst)
{
  int poll;
  poll = inst->local_poll;
  if (inst->mode == (unsigned int)MODE_ACTIVE) 
    if (poll > inst->remote_poll) {
      int tmp;
      tmp = SRC_IsReachable(inst->source);
      if (tmp) 
        if (inst->remote_poll > inst->minpoll) poll = inst->remote_poll;
        else poll = inst->minpoll;
    }
  return poll;
}

static double get_transmit_delay(NCR_Instance inst, int on_tx, double last_tx)
{
  int poll_to_use;
  int stratum_diff;
  double delay_time;
  poll_to_use = get_transmit_poll(inst);
  delay_time = UTI_Log2ToDouble(poll_to_use);
  switch (inst->opmode) {
    case MD_OFFLINE: __FC_assert(0 != 0,"ntp_core.c",844,"0");
    break;
    case MD_ONLINE: ;
    switch (inst->mode) {
      int tmp;
      case MODE_CLIENT: ;
      if (inst->presend_done) delay_time = 2.0;
      break;
      case MODE_ACTIVE:
      { /* sequence */
        tmp = REF_GetOurStratum();
        stratum_diff = inst->remote_stratum - tmp;
      }
      if (stratum_diff > 0) {
        if (last_tx * 1.1 < delay_time) delay_time *= 1.1; else goto _LAND;
      }
      else 
        _LAND:
        if (! on_tx) 
          if (! stratum_diff) 
            if (last_tx / delay_time > 1.1 - 0.5) delay_time *= 1.1;
      if (last_tx > 0.0) delay_time -= last_tx;
      if (delay_time < 0.0) delay_time = 0.0;
      break;
      default: __FC_assert(0 != 0,"ntp_core.c",873,"0");
      break;
    }
    break;
    case MD_BURST_WAS_ONLINE: case MD_BURST_WAS_OFFLINE:
    if (2.0 < 0.25 * delay_time) delay_time = 2.0;
    else delay_time = 0.25 * delay_time;
    break;
    default: __FC_assert(0 != 0,"ntp_core.c",884,"0");
    break;
  }
  return delay_time;
}

static double get_separation(int poll)
{
  double separation;
  int tmp;
  double tmp_2;
  double tmp_0;
  if (poll >= -6) 
    if (poll <= 24) tmp = 1; else tmp = 0;
  else tmp = 0;
  __FC_assert(tmp != 0,"ntp_core.c",899,
              "poll >= MIN_POLL && poll <= MAX_POLL");
  separation = UTI_Log2ToDouble(poll - 3);
  if (separation < 0.2) tmp_0 = separation; else tmp_0 = 0.2;
  if (0.002 > tmp_0) tmp_2 = 0.002;
  else {
    double tmp_1;
    if (separation < 0.2) tmp_1 = separation; else tmp_1 = 0.2;
    tmp_2 = tmp_1;
  }
  return tmp_2;
}

static void receive_timeout(void *arg)
{
  NCR_Instance inst = (NCR_Instance)arg;
  inst->rx_timeout_id = (SCH_TimeoutID)0;
  close_client_socket(inst);
  return;
}

static int transmit_packet(NTP_Mode my_mode, int interleaved, int my_poll,
                           int version, int auth_mode, uint32_t key_id,
                           NTP_int64 *remote_ntp_rx,
                           NTP_int64 *remote_ntp_tx,
                           NTP_Local_Timestamp *local_rx,
                           NTP_Local_Timestamp *local_tx,
                           NTP_int64 *local_ntp_rx, NTP_int64 *local_ntp_tx,
                           NTP_Remote_Address *where_to,
                           NTP_Local_Address *from)
{
  int __retres;
  NTP_Packet message;
  int auth_len;
  int max_auth_len;
  int length;
  int ret;
  int precision;
  struct timespec local_receive;
  struct timespec local_transmit;
  double smooth_offset_0;
  double local_transmit_err;
  NTP_int64 ts_fuzz;
  int are_we_synchronised_0;
  int our_stratum_0;
  int smooth_time;
  NTP_Leap leap_status;
  uint32_t our_ref_id_0;
  struct timespec our_ref_time_0;
  double our_root_delay_0;
  double our_root_dispersion_0;
  if (version > 4) version = 4;
  if (interleaved) 
    if (! remote_ntp_rx) interleaved = 0;
    else 
      if (! local_tx) interleaved = 0;
      else {
        int tmp;
        tmp = UTI_IsZeroTimespec(& local_tx->ts);
        if (tmp) interleaved = 0;
      }
  smooth_time = 0;
  smooth_offset_0 = 0.0;
  if (my_mode == (unsigned int)MODE_CLIENT) {
    precision = 32;
    our_ref_id_0 = (uint32_t)0;
    our_stratum_0 = (int)our_ref_id_0;
    leap_status = (NTP_Leap)our_stratum_0;
    our_root_dispersion_0 = 0.0;
    our_root_delay_0 = our_root_dispersion_0;
    UTI_ZeroTimespec(& our_ref_time_0);
  }
  else {
    int tmp_3;
    long tmp_4;
    SCH_GetLastEventTime(& local_transmit,(double *)0,(struct timespec *)0);
    REF_GetReferenceParams(& local_transmit,& are_we_synchronised_0,
                           & leap_status,& our_stratum_0,& our_ref_id_0,
                           & our_ref_time_0,& our_root_delay_0,
                           & our_root_dispersion_0);
    tmp_3 = SMT_IsEnabled();
    if (tmp_3) 
      if (my_mode == (unsigned int)MODE_SERVER) goto _LOR;
      else 
        if (my_mode == (unsigned int)MODE_BROADCAST) {
          _LOR:
          {
            double tmp_0;
            double tmp_1;
            REF_LeapMode tmp_2;
            smooth_offset_0 = SMT_GetOffset(& local_transmit);
            tmp_0 = fabs(smooth_offset_0);
            tmp_1 = LCL_GetSysPrecisionAsQuantum();
            smooth_time = tmp_0 > tmp_1;
            tmp_2 = REF_GetLeapMode();
            if (tmp_2 == (unsigned int)REF_LeapModeSlew) 
              if (leap_status == (unsigned int)LEAP_InsertSecond) leap_status = LEAP_Normal;
              else 
                if (leap_status == (unsigned int)LEAP_DeleteSecond) leap_status = LEAP_Normal;
          }
        }
    tmp_4 = random();
    precision = (int)(tmp_4 % (long)10 - (long)30);
  }
  if (smooth_time) {
    int tmp_5;
    tmp_5 = UTI_IsZeroTimespec(& local_rx->ts);
    if (tmp_5) goto _LAND;
    else {
      our_ref_id_0 = (uint32_t)0x7F7F01FFUL;
      UTI_AddDoubleToTimespec(& our_ref_time_0,smooth_offset_0,
                              & our_ref_time_0);
      UTI_AddDoubleToTimespec(& local_rx->ts,smooth_offset_0,& local_receive);
    }
  }
  else _LAND: local_receive = local_rx->ts;
  message.lvm = (uint8_t)((((leap_status << 6) & (unsigned int)0xc0) | (unsigned int)(
                           (version << 3) & 0x38)) | (my_mode & (unsigned int)0x07));
  if (our_stratum_0 < 16) message.stratum = (uint8_t)our_stratum_0;
  else message.stratum = (uint8_t)0;
  message.poll = (int8_t)my_poll;
  message.precision = (int8_t)precision;
  message.root_delay = UTI_DoubleToNtp32(our_root_delay_0);
  message.root_dispersion = UTI_DoubleToNtp32(our_root_dispersion_0);
  message.reference_id = htonl(our_ref_id_0);
  UTI_TimespecToNtp64(& our_ref_time_0,& message.reference_ts,(NTP_int64 *)0);
  if (my_mode != (unsigned int)MODE_CLIENT) goto _LOR_0;
  else 
    if (interleaved) {
      _LOR_0:
      {
        if (interleaved) message.originate_ts = *remote_ntp_rx;
        else message.originate_ts = *remote_ntp_tx;
        while (1) {
          int tmp_6;
          UTI_GetNtp64Fuzz(& ts_fuzz,precision);
          UTI_TimespecToNtp64(& local_receive,& message.receive_ts,& ts_fuzz);
          tmp_6 = UTI_IsZeroNtp64(& message.receive_ts);
          if (tmp_6) break;
          else {
            int tmp_7;
            tmp_7 = UTI_IsEqualAnyNtp64(& message.receive_ts,
                                        & message.originate_ts,local_ntp_rx,
                                        (NTP_int64 *)0);
            if (! tmp_7) break;
          }
        }
      }
    }
    else {
      UTI_ZeroNtp64(& message.originate_ts);
      UTI_ZeroNtp64(& message.receive_ts);
    }
  while (1) {
    int tmp_14;
    UTI_GetNtp64Fuzz(& ts_fuzz,precision);
    {
      double *p = & local_transmit_err;
      local_transmit = current_time;
      if (p) *p = 0.0;
    }
    if (smooth_time) UTI_AddDoubleToTimespec(& local_transmit,
                                             smooth_offset_0,
                                             & local_transmit);
    length = 48;
    if (auth_mode == AUTH_SYMMETRIC) goto _LOR_1;
    else 
      if (auth_mode == AUTH_MSSNTP) {
        _LOR_1:
        {
          int tmp_10;
          struct timespec *tmp_11;
          if (auth_mode == AUTH_SYMMETRIC) tmp_10 = KEY_GetAuthDelay(key_id);
          else tmp_10 = NSD_GetAuthDelay(key_id);
          local_transmit.tv_nsec += (long)tmp_10;
          UTI_NormaliseTimespec(& local_transmit);
          if (interleaved) tmp_11 = & local_tx->ts;
          else tmp_11 = & local_transmit;
          UTI_TimespecToNtp64(tmp_11,& message.transmit_ts,& ts_fuzz);
          if (auth_mode == AUTH_SYMMETRIC) {
            if (version == 4) max_auth_len = (4 + 20) - 4;
            else max_auth_len = (int)sizeof(message.auth_data);
            auth_len = KEY_GenerateAuth(key_id,
                                        (unsigned char const *)(& message),
                                        48,
                                        (unsigned char *)(& message.auth_data),
                                        max_auth_len);
            if (! auth_len) {
              __retres = 0;
              goto return_label;
            }
            message.auth_keyid = htonl(key_id);
            length = (int)((unsigned long)length + (sizeof(message.auth_keyid) + (unsigned long)auth_len));
          }
          else 
            if (auth_mode == AUTH_MSSNTP) {
              int tmp_12;
              tmp_12 = NSD_SignAndSendPacket(key_id,& message,where_to,from,
                                             length);
              __retres = tmp_12;
              goto return_label;
            }
        }
      }
      else {
        struct timespec *tmp_13;
        if (interleaved) tmp_13 = & local_tx->ts;
        else tmp_13 = & local_transmit;
        UTI_TimespecToNtp64(tmp_13,& message.transmit_ts,& ts_fuzz);
      }
    tmp_14 = UTI_IsZeroNtp64(& message.transmit_ts);
    if (tmp_14) break;
    else {
      int tmp_15;
      tmp_15 = UTI_IsEqualAnyNtp64(& message.transmit_ts,
                                   & message.receive_ts,
                                   & message.originate_ts,local_ntp_tx);
      if (! tmp_15) break;
    }
  }
  memcpy((void *)(& req_buffer),(void const *)(& message),(size_t)length);
  req_length = length;
  ret = 1;
  if (local_tx) {
    local_tx->ts = local_transmit;
    local_tx->err = local_transmit_err;
    local_tx->source = NTP_TS_DAEMON;
  }
  if (local_ntp_rx) *local_ntp_rx = message.receive_ts;
  if (local_ntp_tx) *local_ntp_tx = message.transmit_ts;
  __retres = ret;
  return_label: return __retres;
}

static void transmit_timeout(void *arg)
{
  NTP_Local_Address local_addr;
  int interleaved;
  int initial;
  int sent;
  int tmp_1;
  int tmp_3;
  NTP_Local_Timestamp *tmp_4;
  NTP_int64 *tmp_5;
  NTP_int64 *tmp_6;
  double tmp_10;
  NCR_Instance inst = (NCR_Instance)arg;
  inst->tx_timeout_id = (SCH_TimeoutID)0;
  switch (inst->opmode) {
    case MD_BURST_WAS_ONLINE: ;
    if (inst->burst_total_samples_to_go <= 1) inst->opmode = MD_ONLINE;
    break;
    case MD_BURST_WAS_OFFLINE: ;
    if (inst->burst_total_samples_to_go <= 0) take_offline(inst);
    break;
    case MD_ONLINE: ;
    if (inst->auto_burst) 
      if (inst->local_poll > inst->minpoll) {
        int tmp;
        if (1 << (inst->local_poll - inst->minpoll) < 4) tmp = 1 << (
                                                               inst->local_poll - inst->minpoll);
        else tmp = 4;
        ;
        NCR_InitiateSampleBurst(inst,1,tmp);
      }
    break;
    default: break;
  }
  if (inst->opmode == (unsigned int)MD_OFFLINE) goto return_label;
  if (inst->mode == (unsigned int)MODE_CLIENT) {
    close_client_socket(inst);
    __FC_assert((inst->local_addr.sock_fd == -2) != 0,"ntp_core.c",1181,
                "inst->local_addr.sock_fd == INVALID_SOCK_FD");
    if ((int)inst->remote_addr.ip_addr.family != 0) inst->local_addr.sock_fd = 101;
    else inst->local_addr.sock_fd = 0;
  }
  local_addr.ip_addr.family = (uint16_t)0;
  local_addr.if_index = -1;
  local_addr.sock_fd = inst->local_addr.sock_fd;
  if (inst->interleaved) 
    if (inst->mode == (unsigned int)MODE_CLIENT) {
      if (inst->tx_count < (unsigned int)4) tmp_1 = 1; else goto _LAND;
    }
    else {
      _LAND: ;
      if (inst->mode == (unsigned int)MODE_ACTIVE) 
        if (inst->prev_tx_count == (unsigned int)1) 
          if (inst->tx_count == (unsigned int)0) tmp_1 = 1; else tmp_1 = 0;
        else tmp_1 = 0;
      else tmp_1 = 0;
    }
  else tmp_1 = 0;
  interleaved = tmp_1;
  if (inst->mode == (unsigned int)MODE_ACTIVE) 
    if (! inst->valid_rx) {
      int tmp_2;
      tmp_2 = UTI_IsZeroNtp64(& inst->init_remote_ntp_tx);
      if (tmp_2) tmp_3 = 0; else tmp_3 = 1;
    }
    else tmp_3 = 0;
  else tmp_3 = 0;
  initial = tmp_3;
  inst->valid_rx = 0;
  inst->updated_init_timestamps = 0;
  if (initial) inst->valid_timestamps = 0;
  if (inst->presend_minpoll <= inst->local_poll) {
    if (! inst->presend_done) {
      if (! inst->burst_total_samples_to_go) 
        if (interleaved) inst->presend_done = 2; else inst->presend_done = 1;
      else goto _LAND_1;
    }
    else goto _LAND_1;
  }
  else {
    _LAND_1: ;
    if (inst->presend_done > 0) (inst->presend_done) --;
  }
  ;
  ;
  ;
  ;
  if (initial) tmp_4 = & inst->init_local_rx; else tmp_4 = & inst->local_rx;
  if (initial) tmp_5 = & inst->init_remote_ntp_tx;
  else tmp_5 = & inst->remote_ntp_tx;
  if (initial) tmp_6 = (NTP_int64 *)0; else tmp_6 = & inst->remote_ntp_rx;
  ;
  ;
  ;
  ;
  ;
  ;
  sent = transmit_packet(inst->mode,interleaved,inst->local_poll,
                         inst->version,(int)inst->auth_mode,
                         inst->auth_key_id,tmp_6,tmp_5,tmp_4,
                         & inst->local_tx,& inst->local_ntp_rx,
                         & inst->local_ntp_tx,& inst->remote_addr,
                         & local_addr);
  (inst->tx_count) ++;
  if (sent) (inst->report.total_tx_count) ++;
  if (inst->tx_count >= (unsigned int)2) 
    if (sent) {
      double tmp_8;
      int tmp_7;
      tmp_7 = SRC_IsSyncPeer(inst->source);
      if (tmp_7) tmp_8 = 0.1; else tmp_8 = 0.25;
      ;
      adjust_poll(inst,tmp_8);
    }
  if (! sent) 
    if (inst->auto_offline) NCR_SetConnectivity(inst,SRC_OFFLINE);
  switch (inst->opmode) {
    case MD_BURST_WAS_ONLINE:
    if (! sent) {
      int tmp_9;
      tmp_9 = SRC_IsReachable(inst->source);
      if (! tmp_9) break;
    }
    case MD_BURST_WAS_OFFLINE: (inst->burst_total_samples_to_go) --;
    break;
    case MD_OFFLINE: ;
    goto return_label;
    default: break;
  }
  tmp_10 = get_transmit_delay(inst,1,0.0);
  ;
  restart_timeout(inst,tmp_10);
  if (inst->mode == (unsigned int)MODE_CLIENT) inst->rx_timeout_id = (SCH_TimeoutID)102;
  return_label: return;
}

static int check_packet_format(NTP_Packet *message, int length)
{
  int __retres;
  int version;
  version = ((int)message->lvm >> 3) & 0x7;
  if (version < 1) goto _LOR;
  else 
    if (version > 4) {
      _LOR: {
              __retres = 0;
              goto return_label;
            }
    }
  if (length < 48) goto _LOR_0;
  else 
    if ((unsigned int)length % (unsigned int)4) {
      _LOR_0: {
                __retres = 0;
                goto return_label;
              }
    }
  __retres = 1;
  return_label: return __retres;
}

static int is_zero_data(unsigned char *data, int length)
{
  int __retres;
  int i;
  i = 0;
  while (i < length) {
    if (*(data + i)) {
      __retres = 0;
      goto return_label;
    }
    i ++;
  }
  __retres = 1;
  return_label: return __retres;
}

static int check_packet_auth(NTP_Packet *pkt, int length,
                             AuthenticationMode *auth_mode, uint32_t *key_id)
{
  int __retres;
  int i;
  int version;
  int remainder_0;
  int ext_length;
  int max_mac_length;
  unsigned char *data;
  uint32_t id;
  version = ((int)pkt->lvm >> 3) & 0x7;
  i = 48;
  data = (unsigned char *)pkt;
  while (1) {
    remainder_0 = length - i;
    if (version == 4) 
      if (remainder_0 <= 4 + 20) max_mac_length = 4 + 20;
      else max_mac_length = 4 + 64;
    else max_mac_length = 4 + 64;
    if (remainder_0 >= 4 + 16) 
      if (remainder_0 <= max_mac_length) {
        int tmp;
        id = ntohl(*((uint32_t *)(data + i)));
        tmp = KEY_CheckAuth(id,(unsigned char const *)pkt,i,
                            (unsigned char const *)((data + i) + 4),
                            remainder_0 - 4,max_mac_length - 4);
        if (tmp) {
          *auth_mode = AUTH_SYMMETRIC;
          *key_id = id;
          if (version == 4) 
            if (48 + remainder_0 == length) 
              if (remainder_0 > 4 + 20) pkt->lvm = (uint8_t)(((((((int)pkt->lvm >> 6) & 0x3) << 6) & 0xc0) | (
                                                              (3 << 3) & 0x38)) | (
                                                             ((int)pkt->lvm & 0x7) & 0x07));
          __retres = 1;
          goto return_label;
        }
      }
    if (version == 4) 
      if (remainder_0 >= 16) {
        uint16_t tmp_0;
        tmp_0 = ntohs(*((uint16_t *)((data + i) + 2)));
        ext_length = (int)tmp_0;
        if (ext_length >= 16) 
          if (ext_length <= remainder_0) 
            if (ext_length % 4 == 0) {
              i += ext_length;
              continue;
            }
      }
    break;
  }
  if (remainder_0 >= 4 + 16) {
    *auth_mode = AUTH_SYMMETRIC;
    *key_id = ntohl(*((uint32_t *)(data + i)));
    if (version == 3) 
      if (*key_id) 
        if (remainder_0 == 20) {
          int tmp_2;
          tmp_2 = is_zero_data((data + i) + 4,remainder_0 - 4);
          if (tmp_2) *auth_mode = AUTH_MSSNTP; else goto _LAND;
        }
        else {
          _LAND: ;
          if (remainder_0 == 72) {
            int tmp_1;
            tmp_1 = is_zero_data((data + i) + 8,remainder_0 - 8);
            if (tmp_1) *auth_mode = AUTH_MSSNTP_EXT;
          }
        }
  }
  else {
    *auth_mode = AUTH_NONE;
    *key_id = (uint32_t)0;
  }
  __retres = 0;
  return_label: return __retres;
}

static int check_delay_ratio(NCR_Instance inst, SST_Stats stats,
                             struct timespec *sample_time, double delay)
{
  int __retres;
  double last_sample_ago;
  double predicted_offset;
  double min_delay;
  double skew;
  double std_dev;
  double max_delay;
  double tmp_0;
  if (inst->max_delay_ratio < 1.0) {
    __retres = 1;
    goto return_label;
  }
  else {
    int tmp;
    tmp = SST_GetDelayTestData(stats,sample_time,& last_sample_ago,
                               & predicted_offset,& min_delay,& skew,
                               & std_dev);
    if (! tmp) {
      __retres = 1;
      goto return_label;
    }
  }
  tmp_0 = LCL_GetMaxClockError();
  max_delay = min_delay * inst->max_delay_ratio + last_sample_ago * (
                                                  skew + tmp_0);
  if (delay <= max_delay) {
    __retres = 1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static int check_delay_dev_ratio(NCR_Instance inst, SST_Stats stats,
                                 struct timespec *sample_time, double offset,
                                 double delay)
{
  int __retres;
  double last_sample_ago;
  double predicted_offset;
  double min_delay;
  double skew;
  double std_dev;
  double delta;
  double max_delta;
  double error_in_estimate;
  int tmp;
  double tmp_0;
  double tmp_1;
  tmp = SST_GetDelayTestData(stats,sample_time,& last_sample_ago,
                             & predicted_offset,& min_delay,& skew,& std_dev);
  if (! tmp) {
    __retres = 1;
    goto return_label;
  }
  tmp_0 = LCL_GetMaxClockError();
  max_delta = std_dev * inst->max_delay_dev_ratio + last_sample_ago * (
                                                    skew + tmp_0);
  delta = (delay - min_delay) / 2.0;
  if (delta <= max_delta) {
    __retres = 1;
    goto return_label;
  }
  error_in_estimate = offset + predicted_offset;
  tmp_1 = fabs(error_in_estimate);
  ;
  if (tmp_1 - delta > max_delta) {
    __retres = 1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static void process_sample(NCR_Instance inst, NTP_Sample *sample)
{
  double estimated_offset;
  double error_in_estimate;
  double filtered_sample_ago;
  NTP_Sample filtered_sample;
  int filtered_samples;
  SST_Stats tmp_1;
  double tmp_2;
  if (inst->filter) {
    int tmp;
    double tmp_0;
    SPF_AccumulateSample(inst->filter,sample);
    filtered_samples = SPF_GetNumberOfSamples(inst->filter);
    tmp = SPF_GetFilteredSample(inst->filter,& filtered_sample);
    if (! tmp) goto return_label;
    filtered_sample_ago = UTI_DiffTimespecsToDouble(& sample->time,
                                                    & filtered_sample.time);
    tmp_0 = UTI_Log2ToDouble(inst->local_poll);
    ;
    if (filtered_sample_ago > (double)((8 / 2) * filtered_samples) * tmp_0) 
      goto return_label;
    sample = & filtered_sample;
  }
  ;
  tmp_1 = SRC_GetSourcestats(inst->source);
  estimated_offset = SST_PredictOffset(tmp_1,& sample->time);
  error_in_estimate = fabs(- sample->offset - estimated_offset);
  SRC_AccumulateSample(inst->source,sample);
  SRC_SelectSource(inst->source);
  tmp_2 = get_poll_adj(inst,error_in_estimate,
                       sample->peer_dispersion + 0.5 * sample->peer_delay);
  ;
  adjust_poll(inst,tmp_2);
  return_label: return;
}

static int receive_packet(NCR_Instance inst, NTP_Local_Address *local_addr,
                          NTP_Local_Timestamp *rx_ts, NTP_Packet *message,
                          int length)
{
  NTP_Sample sample;
  SST_Stats stats;
  int pkt_leap;
  int pkt_version;
  uint32_t pkt_refid;
  uint32_t pkt_key_id;
  double pkt_root_delay;
  double pkt_root_dispersion;
  AuthenticationMode pkt_auth_mode;
  double skew;
  double source_freq_lo;
  double source_freq_hi;
  int test1;
  int test2n;
  int test2i;
  int test2;
  int test3;
  int test5;
  int test6;
  int test7;
  int interleaved_packet;
  int valid_packet;
  int synced_packet;
  int testA;
  int testB;
  int testC;
  int testD;
  int good_packet;
  int kod_rate;
  NTP_Local_Timestamp local_receive;
  NTP_Local_Timestamp local_transmit;
  double remote_interval;
  double local_interval;
  double response_time;
  double delay_time;
  double precision;
  int updated_timestamps;
  int tmp_1;
  int tmp;
  int tmp_3;
  int tmp_2;
  int tmp_5;
  int tmp_6;
  int tmp_7;
  int tmp_11;
  int tmp_8;
  int tmp_13;
  int tmp_14;
  int tmp_15;
  int tmp_16;
  int tmp_34;
  stats = SRC_GetSourcestats(inst->source);
  (inst->report.total_rx_count) ++;
  pkt_leap = ((int)message->lvm >> 6) & 0x3;
  pkt_version = ((int)message->lvm >> 3) & 0x7;
  pkt_refid = ntohl(message->reference_id);
  pkt_root_delay = UTI_Ntp32ToDouble(message->root_delay);
  pkt_root_dispersion = UTI_Ntp32ToDouble(message->root_dispersion);
  tmp = UTI_CompareNtp64(& message->receive_ts,& inst->remote_ntp_rx);
  if (tmp) tmp_1 = 1;
  else {
    int tmp_0;
    tmp_0 = UTI_CompareNtp64(& message->transmit_ts,& inst->remote_ntp_tx);
    if (tmp_0) tmp_1 = 1; else tmp_1 = 0;
  }
  test1 = tmp_1;
  tmp_2 = UTI_CompareNtp64(& message->originate_ts,& inst->local_ntp_tx);
  if (tmp_2) tmp_3 = 0; else tmp_3 = 1;
  test2n = tmp_3;
  if (inst->interleaved) {
    int tmp_4;
    tmp_4 = UTI_CompareNtp64(& message->originate_ts,& inst->local_ntp_rx);
    if (tmp_4) tmp_5 = 0; else tmp_5 = 1;
  }
  else tmp_5 = 0;
  test2i = tmp_5;
  if (test2n) tmp_6 = 1;
  else 
    if (test2i) tmp_6 = 1; else tmp_6 = 0;
  test2 = tmp_6;
  if (! test2n) 
    if (test2i) tmp_7 = 1; else tmp_7 = 0;
  else tmp_7 = 0;
  interleaved_packet = tmp_7;
  tmp_8 = UTI_IsZeroNtp64(& message->originate_ts);
  if (tmp_8) tmp_11 = 0;
  else {
    int tmp_9;
    tmp_9 = UTI_IsZeroNtp64(& message->receive_ts);
    if (tmp_9) tmp_11 = 0;
    else {
      int tmp_10;
      tmp_10 = UTI_IsZeroNtp64(& message->transmit_ts);
      if (tmp_10) tmp_11 = 0; else tmp_11 = 1;
    }
  }
  test3 = tmp_11;
  if (inst->auth_mode == (unsigned int)AUTH_NONE) tmp_13 = 1;
  else {
    int tmp_12;
    tmp_12 = check_packet_auth(message,length,& pkt_auth_mode,& pkt_key_id);
    if (tmp_12) 
      if (pkt_auth_mode == inst->auth_mode) 
        if (pkt_key_id == inst->auth_key_id) tmp_13 = 1; else tmp_13 = 0;
      else tmp_13 = 0;
    else tmp_13 = 0;
  }
  test5 = tmp_13;
  if (pkt_leap != LEAP_Unsynchronised) 
    if ((int)message->stratum < 16) 
      if ((int)message->stratum != 0) tmp_14 = 1; else tmp_14 = 0;
    else tmp_14 = 0;
  else tmp_14 = 0;
  test6 = tmp_14;
  test7 = pkt_root_delay / 2.0 + pkt_root_dispersion < 16.0;
  if (test1) 
    if (test2) 
      if (test3) 
        if (test5) tmp_15 = 1; else tmp_15 = 0;
      else tmp_15 = 0;
    else tmp_15 = 0;
  else tmp_15 = 0;
  valid_packet = tmp_15;
  if (valid_packet) 
    if (test6) 
      if (test7) tmp_16 = 1; else tmp_16 = 0;
    else tmp_16 = 0;
  else tmp_16 = 0;
  synced_packet = tmp_16;
  kod_rate = 0;
  if (test1) 
    if (test2) 
      if (test5) 
        if (pkt_leap == LEAP_Unsynchronised) 
          if ((int)message->stratum == 0) 
            if ((unsigned long)pkt_refid == 0x52415445UL) kod_rate = 1;
  if (synced_packet) {
    if (! interleaved_packet) goto _LOR;
    else 
      if (inst->valid_timestamps) {
        _LOR:
        {
          struct timespec remote_receive;
          struct timespec remote_transmit;
          struct timespec remote_request_receive;
          struct timespec local_average;
          struct timespec remote_average;
          struct timespec prev_remote_transmit;
          double prev_remote_poll_interval;
          double tmp_20;
          double tmp_21;
          double tmp_22;
          double tmp_25;
          double tmp_23;
          double tmp_26;
          int tmp_27;
          int tmp_30;
          int tmp_33;
          if (interleaved_packet) {
            int tmp_17;
            tmp_17 = UTI_IsZeroTimespec(& inst->prev_local_tx.ts);
            if (tmp_17) {
              _LAND:
              {
                UTI_Ntp64ToTimespec(& message->receive_ts,& remote_receive);
                UTI_Ntp64ToTimespec(& inst->remote_ntp_rx,
                                    & remote_request_receive);
                local_transmit = inst->local_tx;
              }
            }
            else {
              double tmp_18;
              double tmp_19;
              tmp_18 = UTI_DiffTimespecsToDouble(& inst->local_tx.ts,
                                                 & inst->local_rx.ts);
              tmp_19 = UTI_DiffTimespecsToDouble(& inst->local_rx.ts,
                                                 & inst->prev_local_tx.ts);
              if (0.1 * tmp_18 > tmp_19) {
                UTI_Ntp64ToTimespec(& inst->remote_ntp_rx,& remote_receive);
                remote_request_receive = remote_receive;
                local_transmit = inst->prev_local_tx;
              }
              else goto _LAND;
            }
            UTI_Ntp64ToTimespec(& message->transmit_ts,& remote_transmit);
            UTI_Ntp64ToTimespec(& inst->remote_ntp_tx,& prev_remote_transmit);
            local_receive = inst->local_rx;
          }
          else {
            UTI_Ntp64ToTimespec(& message->receive_ts,& remote_receive);
            UTI_Ntp64ToTimespec(& message->transmit_ts,& remote_transmit);
            UTI_ZeroTimespec(& prev_remote_transmit);
            remote_request_receive = remote_receive;
            local_receive = *rx_ts;
            local_transmit = inst->local_tx;
          }
          UTI_AverageDiffTimespecs(& remote_receive,& remote_transmit,
                                   & remote_average,& remote_interval);
          UTI_AverageDiffTimespecs(& local_transmit.ts,& local_receive.ts,
                                   & local_average,& local_interval);
          tmp_20 = UTI_DiffTimespecsToDouble(& remote_transmit,
                                             & remote_request_receive);
          response_time = fabs(tmp_20);
          tmp_21 = LCL_GetSysPrecisionAsQuantum();
          tmp_22 = UTI_Log2ToDouble((int)message->precision);
          precision = tmp_21 + tmp_22;
          sample.peer_delay = fabs(local_interval - remote_interval);
          if (sample.peer_delay < precision) sample.peer_delay = precision;
          sample.offset = UTI_DiffTimespecsToDouble(& remote_average,
                                                    & local_average);
          sample.offset += inst->offset_correction;
          sample.time = local_average;
          SST_GetFrequencyRange(stats,& source_freq_lo,& source_freq_hi);
          skew = (source_freq_hi - source_freq_lo) / 2.0;
          if (local_transmit.err > local_receive.err) tmp_23 = local_transmit.err;
          else tmp_23 = local_receive.err;
          ;
          if (precision > tmp_23) tmp_25 = precision;
          else {
            double tmp_24;
            if (local_transmit.err > local_receive.err) tmp_24 = local_transmit.err;
            else tmp_24 = local_receive.err;
            tmp_25 = tmp_24;
          }
          tmp_26 = fabs(local_interval);
          sample.peer_dispersion = tmp_25 + skew * tmp_26;
          if (inst->remote_poll < inst->prev_local_poll) tmp_27 = inst->remote_poll;
          else tmp_27 = inst->prev_local_poll;
          prev_remote_poll_interval = UTI_Log2ToDouble(tmp_27);
          if (sample.peer_delay - sample.peer_dispersion <= inst->max_delay) 
            if (precision <= inst->max_delay) 
              if (inst->mode == (unsigned int)MODE_CLIENT) {
                if (response_time > 4.0) tmp_30 = 0; else goto _LAND_0;
              }
              else {
                _LAND_0: ;
                if (inst->mode == (unsigned int)MODE_ACTIVE) 
                  if (interleaved_packet) 
                    if (sample.peer_delay > 0.5 * prev_remote_poll_interval) 
                      tmp_30 = 0;
                    else {
                      int tmp_28;
                      tmp_28 = UTI_CompareNtp64(& message->receive_ts,
                                                & message->transmit_ts);
                      if (tmp_28 <= 0) tmp_30 = 0;
                      else 
                        if (inst->remote_poll <= inst->prev_local_poll) {
                          double tmp_29;
                          tmp_29 = UTI_DiffTimespecsToDouble(& remote_transmit,
                                                             & prev_remote_transmit);
                          ;
                          if (tmp_29 > 1.5 * prev_remote_poll_interval) 
                            tmp_30 = 0;
                          else tmp_30 = 1;
                        }
                        else tmp_30 = 1;
                    }
                  else tmp_30 = 1;
                else tmp_30 = 1;
              }
            else tmp_30 = 0;
          else tmp_30 = 0;
          testA = tmp_30;
          testB = check_delay_ratio(inst,stats,& sample.time,
                                    sample.peer_delay);
          testC = check_delay_dev_ratio(inst,stats,& sample.time,
                                        sample.offset,sample.peer_delay);
          if ((int)message->stratum <= 1) tmp_33 = 1;
          else {
            REF_Mode tmp_31;
            tmp_31 = REF_GetMode();
            if (tmp_31 != (unsigned int)REF_ModeNormal) tmp_33 = 1;
            else {
              uint32_t tmp_32;
              tmp_32 = UTI_IPToRefid(& local_addr->ip_addr);
              ;
              if (pkt_refid != tmp_32) tmp_33 = 1; else tmp_33 = 0;
            }
          }
          testD = tmp_33;
        }
      }
      else goto _LAND_1;
  }
  else {
    _LAND_1:
    {
      response_time = 0.0;
      local_interval = response_time;
      remote_interval = local_interval;
      sample.peer_dispersion = 0.0;
      sample.peer_delay = sample.peer_dispersion;
      sample.offset = sample.peer_delay;
      sample.time = rx_ts->ts;
      local_receive = *rx_ts;
      local_transmit = inst->local_tx;
      testD = 0;
      testC = testD;
      testB = testC;
      testA = testB;
    }
  }
  if (testA) 
    if (testB) 
      if (testC) 
        if (testD) tmp_34 = 1; else tmp_34 = 0;
      else tmp_34 = 0;
    else tmp_34 = 0;
  else tmp_34 = 0;
  good_packet = tmp_34;
  sample.root_delay = pkt_root_delay + sample.peer_delay;
  sample.root_dispersion = pkt_root_dispersion + sample.peer_dispersion;
  if ((int)message->stratum > inst->min_stratum) sample.stratum = (int)message->stratum;
  else sample.stratum = inst->min_stratum;
  sample.leap = (NTP_Leap)pkt_leap;
  if (inst->mode == (unsigned int)MODE_CLIENT) {
    if (valid_packet) {
      if (! inst->valid_rx) goto _LOR_2; else goto _LAND_9;
    }
    else goto _LAND_9;
  }
  else {
    _LAND_9: ;
    if (inst->mode == (unsigned int)MODE_ACTIVE) {
      if (valid_packet) {
        if (! inst->valid_rx) goto _LOR_2;
        else {
          int tmp_37;
          tmp_37 = UTI_CompareNtp64(& inst->remote_ntp_tx,
                                    & message->transmit_ts);
          if (tmp_37 < 0) {
            _LOR_2:
            {
              inst->remote_ntp_rx = message->receive_ts;
              inst->remote_ntp_tx = message->transmit_ts;
              inst->local_rx = *rx_ts;
              inst->valid_timestamps = synced_packet;
              UTI_ZeroNtp64(& inst->init_remote_ntp_tx);
              zero_local_timestamp(& inst->init_local_rx);
              inst->updated_init_timestamps = 0;
              updated_timestamps = 2;
              if (interleaved_packet) inst->prev_local_tx = inst->local_tx;
              else zero_local_timestamp(& inst->prev_local_tx);
            }
          }
          else goto _LAND_7;
        }
      }
      else goto _LAND_7;
    }
    else {
      _LAND_7: ;
      if (inst->mode == (unsigned int)MODE_ACTIVE) {
        if (test1) {
          int tmp_35;
          tmp_35 = UTI_IsZeroNtp64(& message->transmit_ts);
          if (tmp_35) goto _LAND_5;
          else 
            if (test5) {
              if (! inst->updated_init_timestamps) goto _LOR_0;
              else {
                int tmp_36;
                tmp_36 = UTI_CompareNtp64(& inst->init_remote_ntp_tx,
                                          & message->transmit_ts);
                if (tmp_36 < 0) {
                  _LOR_0:
                  {
                    inst->init_remote_ntp_tx = message->transmit_ts;
                    inst->init_local_rx = *rx_ts;
                    inst->updated_init_timestamps = 1;
                    updated_timestamps = 1;
                  }
                }
                else goto _LAND_5;
              }
            }
            else goto _LAND_5;
        }
        else goto _LAND_5;
      }
      else _LAND_5: updated_timestamps = 0;
    }
  }
  if (inst->valid_rx) {
    test3 = 0;
    test2 = test3;
    good_packet = 0;
    synced_packet = good_packet;
    valid_packet = synced_packet;
  }
  else 
    if (valid_packet) {
      if (inst->presend_done) {
        testA = 0;
        good_packet = 0;
      }
      inst->valid_rx = 1;
    }
  if ((unsigned long)((unsigned int)local_receive.source) >= sizeof(tss_chars)) 
    __FC_assert(0 != 0,"ntp_core.c",1798,"0");
  else 
    if ((unsigned long)((unsigned int)local_transmit.source) >= sizeof(tss_chars)) 
      __FC_assert(0 != 0,"ntp_core.c",1798,"0");
  if (valid_packet) {
    inst->remote_poll = (int)message->poll;
    if ((int)message->stratum != 0) inst->remote_stratum = (int)message->stratum;
    else inst->remote_stratum = 16;
    inst->prev_local_poll = inst->local_poll;
    inst->prev_tx_count = inst->tx_count;
    inst->tx_count = (unsigned int)0;
    if (good_packet) {
      process_sample(inst,& sample);
      switch (inst->opmode) {
        case MD_BURST_WAS_ONLINE: case MD_BURST_WAS_OFFLINE:
        (inst->burst_good_samples_to_go) --;
        if (inst->burst_good_samples_to_go <= 0) 
          if (inst->opmode == (unsigned int)MD_BURST_WAS_ONLINE) inst->opmode = MD_ONLINE;
          else take_offline(inst);
        break;
        default: break;
      }
    }
    else adjust_poll(inst,0.1);
    close_client_socket(inst);
    inst->local_addr.ip_addr = local_addr->ip_addr;
    inst->local_addr.if_index = local_addr->if_index;
    if (inst->opmode != (unsigned int)MD_OFFLINE) {
      double tmp_44;
      tmp_44 = UTI_DiffTimespecsToDouble(& inst->local_rx.ts,
                                         & inst->local_tx.ts);
      ;
      delay_time = get_transmit_delay(inst,0,tmp_44);
      if (kod_rate) {
        char *tmp_45;
        double tmp_46;
        tmp_45 = UTI_IPToString(& inst->remote_addr.ip_addr);
        {
          char *__va_arg0 = tmp_45;
          void *__va_args[1] = {& __va_arg0};
          LOG_Message(LOGS_WARN,"Received KoD RATE from %s",
                      (void * const *)(__va_args));
        }
        tmp_46 = UTI_Log2ToDouble(inst->local_poll);
        delay_time += (double)4 * tmp_46;
        if (inst->opmode == (unsigned int)MD_BURST_WAS_OFFLINE) goto _LOR_3;
        else 
          if (inst->opmode == (unsigned int)MD_BURST_WAS_ONLINE) _LOR_3:
                                                                 inst->burst_good_samples_to_go = 0;
      }
      __FC_assert(inst->tx_timeout_id != (SCH_TimeoutID)0,"ntp_core.c",1883,
                  "inst->tx_timeout_id");
      restart_timeout(inst,delay_time);
    }
    inst->report.remote_addr = inst->remote_addr.ip_addr;
    inst->report.local_addr = inst->local_addr.ip_addr;
    inst->report.remote_port = inst->remote_addr.port;
    inst->report.leap = (uint8_t)pkt_leap;
    inst->report.version = (uint8_t)pkt_version;
    inst->report.mode = (uint8_t)((int)message->lvm & 0x7);
    inst->report.stratum = message->stratum;
    inst->report.poll = message->poll;
    inst->report.precision = message->precision;
    inst->report.root_delay = pkt_root_delay;
    inst->report.root_dispersion = pkt_root_dispersion;
    inst->report.ref_id = pkt_refid;
    UTI_Ntp64ToTimespec(& message->reference_ts,& inst->report.ref_time);
    inst->report.offset = sample.offset;
    inst->report.peer_delay = sample.peer_delay;
    inst->report.peer_dispersion = sample.peer_dispersion;
    inst->report.response_time = response_time;
    inst->report.jitter_asymmetry = SST_GetJitterAsymmetry(stats);
    inst->report.tests = (uint16_t)((((((((((((((((((test1 << 1) | test2) << 1) | test3) << 1) | test5) << 1) | test6) << 1) | test7) << 1) | testA) << 1) | testB) << 1) | testC) << 1) | testD);
    inst->report.interleaved = interleaved_packet;
    inst->report.authenticated = inst->auth_mode != (unsigned int)AUTH_NONE;
    inst->report.tx_tss_char = tss_chars[local_transmit.source];
    inst->report.rx_tss_char = tss_chars[local_receive.source];
    (inst->report.total_valid_count) ++;
  }
  if (logfileid_1 != -1) 
    if (log_raw_measurements) goto _LOR_4;
    else 
      if (synced_packet) {
        _LOR_4:
        {
          int tmp_47;
          char *tmp_48;
          char *tmp_49;
          ;
          ;
          if (interleaved_packet) tmp_47 = 'I'; else tmp_47 = 'B';
          ;
          ;
          ;
          ;
          ;
          ;
          ;
          ;
          ;
          ;
          ;
          ;
          ;
          ;
          ;
          ;
          ;
          ;
          ;
          ;
          ;
          ;
          tmp_48 = UTI_IPToString(& inst->remote_addr.ip_addr);
          tmp_49 = UTI_TimeToLogForm(sample.time.tv_sec);
          ;
          {
            char *__va_arg0_98 = tmp_49;
            char *__va_arg1 = tmp_48;
            int __va_arg2 = (int)leap_chars[pkt_leap];
            int __va_arg3 = (int)message->stratum;
            int __va_arg4 = test1;
            int __va_arg5 = test2;
            int __va_arg6 = test3;
            int __va_arg7 = test5;
            int __va_arg8 = test6;
            int __va_arg9 = test7;
            int __va_arg10 = testA;
            int __va_arg11 = testB;
            int __va_arg12 = testC;
            int __va_arg13 = testD;
            int __va_arg14 = inst->local_poll;
            int __va_arg15 = (int)message->poll;
            double __va_arg16 = inst->poll_score;
            double __va_arg17 = sample.offset;
            double __va_arg18 = sample.peer_delay;
            double __va_arg19 = sample.peer_dispersion;
            double __va_arg20 = pkt_root_delay;
            double __va_arg21 = pkt_root_dispersion;
            uint32_t __va_arg22 = pkt_refid;
            int __va_arg23 = (int)message->lvm & 0x7;
            int __va_arg24 = tmp_47;
            int __va_arg25 = (int)tss_chars[local_transmit.source];
            int __va_arg26 = (int)tss_chars[local_receive.source];
            void *__va_args_126[27] =
              {& __va_arg0_98,
               & __va_arg1,
               & __va_arg2,
               & __va_arg3,
               & __va_arg4,
               & __va_arg5,
               & __va_arg6,
               & __va_arg7,
               & __va_arg8,
               & __va_arg9,
               & __va_arg10,
               & __va_arg11,
               & __va_arg12,
               & __va_arg13,
               & __va_arg14,
               & __va_arg15,
               & __va_arg16,
               & __va_arg17,
               & __va_arg18,
               & __va_arg19,
               & __va_arg20,
               & __va_arg21,
               & __va_arg22,
               & __va_arg23,
               & __va_arg24,
               & __va_arg25,
               & __va_arg26};
            LOG_FileWrite(logfileid_1,
                          "%s %-15s %1c %2d %1d%1d%1d %1d%1d%1d %1d%1d%1d%d  %2d %2d %4.2f %10.3e %10.3e %10.3e %10.3e %10.3e %08X %1d%1c %1c %1c",
                          (void * const *)(__va_args_126));
          }
        }
      }
  return good_packet;
}

int NCR_ProcessRxKnown(NCR_Instance inst, NTP_Local_Address *local_addr,
                       NTP_Local_Timestamp *rx_ts, NTP_Packet *message,
                       int length)
{
  int __retres;
  int pkt_mode;
  int proc_packet;
  int proc_as_unknown;
  int tmp;
  tmp = check_packet_format(message,length);
  if (! tmp) {
    __retres = 0;
    goto return_label;
  }
  pkt_mode = (int)message->lvm & 0x7;
  proc_packet = 0;
  proc_as_unknown = 0;
  switch (pkt_mode) {
    case MODE_ACTIVE: ;
    switch (inst->mode) {
      case MODE_ACTIVE: proc_packet = 1;
      break;
      case MODE_PASSIVE: break;
      case MODE_CLIENT: proc_as_unknown = 1;
      break;
      default: break;
    }
    break;
    case MODE_PASSIVE: ;
    switch (inst->mode) {
      case MODE_ACTIVE: proc_packet = 1;
      break;
      case MODE_PASSIVE: break;
      default: break;
    }
    break;
    case MODE_CLIENT: proc_as_unknown = 1;
    break;
    case MODE_SERVER: ;
    switch (inst->mode) {
      case MODE_CLIENT: proc_packet = 1;
      break;
      default: break;
    }
    break;
    case MODE_BROADCAST: break;
    default: break;
  }
  if (proc_packet) {
    int tmp_0;
    if (local_addr->sock_fd != inst->local_addr.sock_fd) {
      __retres = 0;
      goto return_label;
    }
    if (inst->opmode == (unsigned int)MD_OFFLINE) goto _LOR;
    else 
      if (inst->tx_suspended) {
        _LOR: {
                __retres = 0;
                goto return_label;
              }
      }
    tmp_0 = receive_packet(inst,local_addr,rx_ts,message,length);
    __retres = tmp_0;
    goto return_label;
  }
  else 
    if (proc_as_unknown) {
      NCR_ProcessRxUnknown(& inst->remote_addr,local_addr,rx_ts,message,
                           length);
      __retres = 0;
      goto return_label;
    }
    else {
      __retres = 0;
      goto return_label;
    }
  return_label: return __retres;
}

void NCR_ProcessRxUnknown(NTP_Remote_Address *remote_addr,
                          NTP_Local_Address *local_addr,
                          NTP_Local_Timestamp *rx_ts, NTP_Packet *message,
                          int length)
{
  NTP_Mode pkt_mode;
  NTP_Mode my_mode;
  NTP_int64 *local_ntp_rx;
  NTP_int64 *local_ntp_tx;
  NTP_Local_Timestamp local_tx;
  NTP_Local_Timestamp *tx_ts;
  int pkt_version;
  int valid_auth;
  int log_index;
  int interleaved;
  int poll;
  AuthenticationMode auth_mode;
  uint32_t key_id;
  int tmp;
  int tmp_1;
  if (! (local_addr->sock_fd == 100)) goto return_label;
  tmp = check_packet_format(message,length);
  if (! tmp) goto return_label;
  tmp_1 = ADF_IsAllowed(access_auth_table,& remote_addr->ip_addr);
  if (! tmp_1) goto return_label;
  pkt_mode = (NTP_Mode)((int)message->lvm & 0x7);
  pkt_version = ((int)message->lvm >> 3) & 0x7;
  switch (pkt_mode) {
    case MODE_ACTIVE: my_mode = MODE_PASSIVE;
    break;
    case MODE_CLIENT: my_mode = MODE_SERVER;
    break;
    case MODE_UNDEFINED: ;
    if (pkt_version == 1) 
      if ((int)remote_addr->port != 123) {
        my_mode = MODE_SERVER;
        break;
      }
    default: ;
    goto return_label;
  }
  log_index = CLG_LogNTPAccess(& remote_addr->ip_addr,& rx_ts->ts);
  if (log_index >= 0) {
    int tmp_2;
    tmp_2 = CLG_LimitNTPResponseRate(log_index);
    if (tmp_2) goto return_label;
  }
  valid_auth = check_packet_auth(message,length,& auth_mode,& key_id);
  if (! valid_auth) 
    switch (auth_mode) {
      case AUTH_NONE: break;
      case AUTH_MSSNTP: break;
      default: ;
      goto return_label;
    }
  local_ntp_tx = (NTP_int64 *)0;
  local_ntp_rx = local_ntp_tx;
  tx_ts = (NTP_Local_Timestamp *)0;
  interleaved = 0;
  if (log_index >= 0) {
    int tmp_6;
    int tmp_3;
    CLG_GetNtpTimestamps(log_index,& local_ntp_rx,& local_ntp_tx);
    tmp_3 = UTI_IsZeroNtp64(local_ntp_rx);
    if (tmp_3) tmp_6 = 0;
    else {
      int tmp_4;
      tmp_4 = UTI_CompareNtp64(& message->originate_ts,local_ntp_rx);
      if (tmp_4) tmp_6 = 0;
      else {
        int tmp_5;
        tmp_5 = UTI_CompareNtp64(& message->receive_ts,
                                 & message->transmit_ts);
        if (tmp_5) tmp_6 = 1; else tmp_6 = 0;
      }
    }
    interleaved = tmp_6;
    if (interleaved) {
      UTI_Ntp64ToTimespec(local_ntp_tx,& local_tx.ts);
      tx_ts = & local_tx;
    }
    else {
      UTI_ZeroNtp64(local_ntp_tx);
      local_ntp_tx = (NTP_int64 *)0;
    }
  }
  poll = CLG_GetNtpMinPoll();
  if (poll > (int)message->poll) poll = poll; else poll = (int)message->poll;
  transmit_packet(my_mode,interleaved,poll,pkt_version,(int)auth_mode,key_id,
                  & message->receive_ts,& message->transmit_ts,rx_ts,tx_ts,
                  local_ntp_rx,(NTP_int64 *)0,remote_addr,local_addr);
  if (tx_ts) UTI_TimespecToNtp64(& tx_ts->ts,local_ntp_tx,(NTP_int64 *)0);
  return_label: return;
}

static void update_tx_timestamp(NTP_Local_Timestamp *tx_ts,
                                NTP_Local_Timestamp *new_tx_ts,
                                NTP_int64 *local_ntp_rx,
                                NTP_int64 *local_ntp_tx, NTP_Packet *message)
{
  double delay;
  int tmp;
  tmp = UTI_IsZeroTimespec(& tx_ts->ts);
  if (tmp) goto return_label;
  if (local_ntp_rx) {
    int tmp_0;
    tmp_0 = UTI_CompareNtp64(& message->receive_ts,local_ntp_rx);
    if (tmp_0) goto _LOR; else goto _LAND;
  }
  else {
    _LAND: ;
    if (local_ntp_tx) {
      int tmp_1;
      tmp_1 = UTI_CompareNtp64(& message->transmit_ts,local_ntp_tx);
      if (tmp_1) _LOR: goto return_label;
    }
  }
  delay = UTI_DiffTimespecsToDouble(& new_tx_ts->ts,& tx_ts->ts);
  if (delay < 0.0) goto _LOR_0;
  else 
    if (delay > 1.0) _LOR_0: goto return_label;
  *tx_ts = *new_tx_ts;
  return_label: return;
}

void NCR_ProcessTxKnown(NCR_Instance inst, NTP_Local_Address *local_addr,
                        NTP_Local_Timestamp *tx_ts, NTP_Packet *message,
                        int length)
{
  NTP_Mode pkt_mode;
  int tmp;
  tmp = check_packet_format(message,length);
  if (! tmp) goto return_label;
  pkt_mode = (NTP_Mode)((int)message->lvm & 0x7);
  if (pkt_mode != (unsigned int)MODE_CLIENT) 
    if (pkt_mode != (unsigned int)MODE_ACTIVE) {
      NCR_ProcessTxUnknown(& inst->remote_addr,local_addr,tx_ts,message,
                           length);
      goto return_label;
    }
  update_tx_timestamp(& inst->local_tx,tx_ts,& inst->local_ntp_rx,
                      & inst->local_ntp_tx,message);
  return_label: return;
}

void NCR_ProcessTxUnknown(NTP_Remote_Address *remote_addr,
                          NTP_Local_Address *local_addr,
                          NTP_Local_Timestamp *tx_ts, NTP_Packet *message,
                          int length)
{
  NTP_int64 *local_ntp_rx;
  NTP_int64 *local_ntp_tx;
  NTP_Local_Timestamp local_tx;
  int log_index;
  int tmp;
  int tmp_1;
  tmp = check_packet_format(message,length);
  if (! tmp) goto return_label;
  if (((int)message->lvm & 0x7) == MODE_BROADCAST) goto return_label;
  log_index = CLG_GetClientIndex(& remote_addr->ip_addr);
  if (log_index < 0) goto return_label;
  tmp_1 = SMT_IsEnabled();
  if (tmp_1) 
    if (((int)message->lvm & 0x7) == MODE_SERVER) {
      double tmp_0;
      ;
      tmp_0 = SMT_GetOffset(& tx_ts->ts);
      ;
      UTI_AddDoubleToTimespec(& tx_ts->ts,tmp_0,& tx_ts->ts);
    }
  CLG_GetNtpTimestamps(log_index,& local_ntp_rx,& local_ntp_tx);
  UTI_Ntp64ToTimespec(local_ntp_tx,& local_tx.ts);
  update_tx_timestamp(& local_tx,tx_ts,local_ntp_rx,(NTP_int64 *)0,message);
  UTI_TimespecToNtp64(& local_tx.ts,local_ntp_tx,(NTP_int64 *)0);
  return_label: return;
}

void NCR_SlewTimes(NCR_Instance inst, struct timespec *when, double dfreq,
                   double doffset)
{
  double delta;
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  tmp = UTI_IsZeroTimespec(& inst->local_rx.ts);
  if (! tmp) UTI_AdjustTimespec(& inst->local_rx.ts,when,& inst->local_rx.ts,
                                & delta,dfreq,doffset);
  tmp_0 = UTI_IsZeroTimespec(& inst->local_tx.ts);
  if (! tmp_0) UTI_AdjustTimespec(& inst->local_tx.ts,when,
                                  & inst->local_tx.ts,& delta,dfreq,doffset);
  tmp_1 = UTI_IsZeroTimespec(& inst->prev_local_tx.ts);
  if (! tmp_1) UTI_AdjustTimespec(& inst->prev_local_tx.ts,when,
                                  & inst->prev_local_tx.ts,& delta,dfreq,
                                  doffset);
  tmp_2 = UTI_IsZeroTimespec(& inst->init_local_rx.ts);
  if (! tmp_2) UTI_AdjustTimespec(& inst->init_local_rx.ts,when,
                                  & inst->init_local_rx.ts,& delta,dfreq,
                                  doffset);
  if (inst->filter) SPF_SlewSamples(inst->filter,when,dfreq,doffset);
  return;
}

void NCR_SetConnectivity(NCR_Instance inst, SRC_Connectivity connectivity)
{
  char *s;
  s = UTI_IPToString(& inst->remote_addr.ip_addr);
  if (connectivity == (unsigned int)SRC_MAYBE_ONLINE) {
    int tmp;
    tmp = NIO_IsServerConnectable(& inst->remote_addr);
    if (tmp) connectivity = SRC_ONLINE; else connectivity = SRC_OFFLINE;
  }
  switch (connectivity) {
    case SRC_ONLINE: ;
    switch (inst->opmode) {
      case MD_ONLINE: break;
      case MD_OFFLINE:
      {
        char *__va_arg0 = s;
        void *__va_args[1] = {& __va_arg0};
        LOG_Message(LOGS_INFO,"Source %s online",(void * const *)(__va_args));
      }
      inst->opmode = MD_ONLINE;
      NCR_ResetInstance(inst);
      start_initial_timeout(inst);
      break;
      case MD_BURST_WAS_ONLINE: break;
      case MD_BURST_WAS_OFFLINE: inst->opmode = MD_BURST_WAS_ONLINE;
      {
        char *__va_arg0_8 = s;
        void *__va_args_10[1] = {& __va_arg0_8};
        LOG_Message(LOGS_INFO,"Source %s online",
                    (void * const *)(__va_args_10));
      }
      break;
      default: __FC_assert(0 != 0,"ntp_core.c",2344,"0");
    }
    break;
    case SRC_OFFLINE: ;
    switch (inst->opmode) {
      case MD_ONLINE:
      {
        char *__va_arg0_12 = s;
        void *__va_args_14[1] = {& __va_arg0_12};
        LOG_Message(LOGS_INFO,"Source %s offline",
                    (void * const *)(__va_args_14));
      }
      take_offline(inst);
      break;
      case MD_OFFLINE: break;
      case MD_BURST_WAS_ONLINE: inst->opmode = MD_BURST_WAS_OFFLINE;
      {
        char *__va_arg0_16 = s;
        void *__va_args_18[1] = {& __va_arg0_16};
        LOG_Message(LOGS_INFO,"Source %s offline",
                    (void * const *)(__va_args_18));
      }
      break;
      case MD_BURST_WAS_OFFLINE: break;
      default: __FC_assert(0 != 0,"ntp_core.c",2362,"0");
    }
    break;
    default: __FC_assert(0 != 0,"ntp_core.c",2366,"0");
  }
  return;
}

void NCR_ModifyMinpoll(NCR_Instance inst, int new_minpoll)
{
  char *tmp;
  if (new_minpoll < -6) goto return_label;
  else 
    if (new_minpoll > 24) goto return_label;
  inst->minpoll = new_minpoll;
  ;
  tmp = UTI_IPToString(& inst->remote_addr.ip_addr);
  {
    char *__va_arg0 = tmp;
    int __va_arg1 = new_minpoll;
    void *__va_args[2] = {& __va_arg0, & __va_arg1};
    LOG_Message(LOGS_INFO,"Source %s new minpoll %d",
                (void * const *)(__va_args));
  }
  if (inst->maxpoll < inst->minpoll) NCR_ModifyMaxpoll(inst,inst->minpoll);
  return_label: return;
}

void NCR_ModifyMaxpoll(NCR_Instance inst, int new_maxpoll)
{
  char *tmp;
  if (new_maxpoll < -6) goto return_label;
  else 
    if (new_maxpoll > 24) goto return_label;
  inst->maxpoll = new_maxpoll;
  ;
  tmp = UTI_IPToString(& inst->remote_addr.ip_addr);
  {
    char *__va_arg0 = tmp;
    int __va_arg1 = new_maxpoll;
    void *__va_args[2] = {& __va_arg0, & __va_arg1};
    LOG_Message(LOGS_INFO,"Source %s new maxpoll %d",
                (void * const *)(__va_args));
  }
  if (inst->minpoll > inst->maxpoll) NCR_ModifyMinpoll(inst,inst->maxpoll);
  return_label: return;
}

void NCR_ModifyMaxdelay(NCR_Instance inst, double new_max_delay)
{
  double tmp;
  char *tmp_1;
  if (new_max_delay < 1.0e3) tmp = new_max_delay; else tmp = 1.0e3;
  if (0.0 > tmp) inst->max_delay = 0.0;
  else {
    double tmp_0;
    if (new_max_delay < 1.0e3) tmp_0 = new_max_delay; else tmp_0 = 1.0e3;
    inst->max_delay = tmp_0;
  }
  ;
  tmp_1 = UTI_IPToString(& inst->remote_addr.ip_addr);
  {
    char *__va_arg0 = tmp_1;
    double __va_arg1 = inst->max_delay;
    void *__va_args[2] = {& __va_arg0, & __va_arg1};
    LOG_Message(LOGS_INFO,"Source %s new maxdelay %f",
                (void * const *)(__va_args));
  }
  return;
}

void NCR_ModifyMaxdelayratio(NCR_Instance inst, double new_max_delay_ratio)
{
  double tmp;
  char *tmp_1;
  if (new_max_delay_ratio < 1.0e6) tmp = new_max_delay_ratio;
  else tmp = 1.0e6;
  if (0.0 > tmp) inst->max_delay_ratio = 0.0;
  else {
    double tmp_0;
    if (new_max_delay_ratio < 1.0e6) tmp_0 = new_max_delay_ratio;
    else tmp_0 = 1.0e6;
    inst->max_delay_ratio = tmp_0;
  }
  ;
  tmp_1 = UTI_IPToString(& inst->remote_addr.ip_addr);
  {
    char *__va_arg0 = tmp_1;
    double __va_arg1 = inst->max_delay_ratio;
    void *__va_args[2] = {& __va_arg0, & __va_arg1};
    LOG_Message(LOGS_INFO,"Source %s new maxdelayratio %f",
                (void * const *)(__va_args));
  }
  return;
}

void NCR_ModifyMaxdelaydevratio(NCR_Instance inst,
                                double new_max_delay_dev_ratio)
{
  double tmp;
  char *tmp_1;
  if (new_max_delay_dev_ratio < 1.0e6) tmp = new_max_delay_dev_ratio;
  else tmp = 1.0e6;
  if (0.0 > tmp) inst->max_delay_dev_ratio = 0.0;
  else {
    double tmp_0;
    if (new_max_delay_dev_ratio < 1.0e6) tmp_0 = new_max_delay_dev_ratio;
    else tmp_0 = 1.0e6;
    inst->max_delay_dev_ratio = tmp_0;
  }
  ;
  tmp_1 = UTI_IPToString(& inst->remote_addr.ip_addr);
  {
    char *__va_arg0 = tmp_1;
    double __va_arg1 = inst->max_delay_dev_ratio;
    void *__va_args[2] = {& __va_arg0, & __va_arg1};
    LOG_Message(LOGS_INFO,"Source %s new maxdelaydevratio %f",
                (void * const *)(__va_args));
  }
  return;
}

void NCR_ModifyMinstratum(NCR_Instance inst, int new_min_stratum)
{
  char *tmp;
  inst->min_stratum = new_min_stratum;
  ;
  tmp = UTI_IPToString(& inst->remote_addr.ip_addr);
  {
    char *__va_arg0 = tmp;
    int __va_arg1 = new_min_stratum;
    void *__va_args[2] = {& __va_arg0, & __va_arg1};
    LOG_Message(LOGS_INFO,"Source %s new minstratum %d",
                (void * const *)(__va_args));
  }
  return;
}

void NCR_ModifyPolltarget(NCR_Instance inst, int new_poll_target)
{
  char *tmp;
  inst->poll_target = new_poll_target;
  ;
  tmp = UTI_IPToString(& inst->remote_addr.ip_addr);
  {
    char *__va_arg0 = tmp;
    int __va_arg1 = new_poll_target;
    void *__va_args[2] = {& __va_arg0, & __va_arg1};
    LOG_Message(LOGS_INFO,"Source %s new polltarget %d",
                (void * const *)(__va_args));
  }
  return;
}

void NCR_InitiateSampleBurst(NCR_Instance inst, int n_good_samples,
                             int n_total_samples)
{
  if (inst->mode == (unsigned int)MODE_CLIENT) 
    switch (inst->opmode) {
      case MD_BURST_WAS_OFFLINE: case MD_BURST_WAS_ONLINE: break;
      case MD_ONLINE: case MD_OFFLINE:
      if (inst->opmode == (unsigned int)MD_ONLINE) inst->opmode = MD_BURST_WAS_ONLINE;
      else inst->opmode = MD_BURST_WAS_OFFLINE;
      inst->burst_good_samples_to_go = n_good_samples;
      inst->burst_total_samples_to_go = n_total_samples;
      start_initial_timeout(inst);
      break;
      default: __FC_assert(0 != 0,"ntp_core.c",2475,"0");
      break;
    }
  return;
}

void NCR_ReportSource(NCR_Instance inst, RPT_SourceReport *report,
                      struct timespec *now)
{
  report->poll = get_transmit_poll(inst);
  switch (inst->mode) {
    case MODE_CLIENT: report->mode = RPT_NTP_CLIENT;
    break;
    case MODE_ACTIVE: report->mode = RPT_NTP_PEER;
    break;
    default: __FC_assert(0 != 0,"ntp_core.c",2497,"0");
  }
  return;
}

void NCR_GetNTPReport(NCR_Instance inst, RPT_NTPReport *report)
{
  *report = inst->report;
  return;
}

int NCR_AddAccessRestriction(IPAddr *ip_addr, int subnet_bits, int allow,
                             int all)
{
  int __retres;
  ADF_Status status;
  if (allow) 
    if (all) status = ADF_AllowAll(access_auth_table,ip_addr,subnet_bits);
    else status = ADF_Allow(access_auth_table,ip_addr,subnet_bits);
  else 
    if (all) status = ADF_DenyAll(access_auth_table,ip_addr,subnet_bits);
    else status = ADF_Deny(access_auth_table,ip_addr,subnet_bits);
  if (status != (unsigned int)ADF_SUCCESS) {
    __retres = 0;
    goto return_label;
  }
  if (allow) {
    NTP_Remote_Address remote_addr;
    if (server_sock_fd4_0 == -2) {
      int tmp;
      tmp = ADF_IsAnyAllowed(access_auth_table,1);
      if (tmp) {
        remote_addr.ip_addr.family = (uint16_t)1;
        if ((int)remote_addr.ip_addr.family != 0) server_sock_fd4_0 = 100;
        else server_sock_fd4_0 = 0;
      }
    }
    if (server_sock_fd6 == -2) {
      int tmp_0;
      tmp_0 = ADF_IsAnyAllowed(access_auth_table,2);
      if (tmp_0) {
        remote_addr.ip_addr.family = (uint16_t)2;
        if ((int)remote_addr.ip_addr.family != 0) server_sock_fd6 = 100;
        else server_sock_fd6 = 0;
      }
    }
  }
  else {
    if (server_sock_fd4_0 != -2) {
      int tmp_1;
      tmp_1 = ADF_IsAnyAllowed(access_auth_table,1);
      if (! tmp_1) {
        __FC_assert((server_sock_fd4_0 == 100) != 0,"ntp_core.c",2550,
                    "server_sock_fd4 == 100");
        server_sock_fd4_0 = -2;
      }
    }
    if (server_sock_fd6 != -2) {
      int tmp_2;
      tmp_2 = ADF_IsAnyAllowed(access_auth_table,2);
      if (! tmp_2) {
        __FC_assert((server_sock_fd6 == 100) != 0,"ntp_core.c",2555,
                    "server_sock_fd6 == 100");
        server_sock_fd6 = -2;
      }
    }
  }
  __retres = 1;
  return_label: return __retres;
}

int NCR_CheckAccessRestriction(IPAddr *ip_addr)
{
  int tmp;
  tmp = ADF_IsAllowed(access_auth_table,ip_addr);
  return tmp;
}

void NCR_IncrementActivityCounters(NCR_Instance inst, int *online,
                                   int *offline, int *burst_online,
                                   int *burst_offline)
{
  switch (inst->opmode) {
    case MD_BURST_WAS_OFFLINE: (*burst_offline) ++;
    break;
    case MD_BURST_WAS_ONLINE: (*burst_online) ++;
    break;
    case MD_ONLINE: (*online) ++;
    break;
    case MD_OFFLINE: (*offline) ++;
    break;
    default: __FC_assert(0 != 0,"ntp_core.c",2591,"0");
    break;
  }
  return;
}

NTP_Remote_Address *NCR_GetRemoteAddress(NCR_Instance inst)
{
  NTP_Remote_Address *__retres;
  __retres = & inst->remote_addr;
  return __retres;
}

uint32_t NCR_GetLocalRefid(NCR_Instance inst)
{
  uint32_t tmp;
  tmp = UTI_IPToRefid(& inst->local_addr.ip_addr);
  return tmp;
}

int NCR_IsSyncPeer(NCR_Instance inst)
{
  int tmp;
  tmp = SRC_IsSyncPeer(inst->source);
  return tmp;
}

static void broadcast_timeout(void *arg)
{
  BroadcastDestination *destination;
  NTP_int64 orig_ts;
  NTP_Local_Timestamp recv_ts;
  int poll;
  double tmp;
  double tmp_0;
  double tmp_1;
  destination = (BroadcastDestination *)ARR_GetElement(broadcasts_0,
                                                       (unsigned int)((long)arg));
  tmp = log((double)destination->interval);
  tmp_0 = log(2.0);
  poll = (int)(tmp / tmp_0 + 0.5);
  UTI_ZeroNtp64(& orig_ts);
  zero_local_timestamp(& recv_ts);
  transmit_packet(MODE_BROADCAST,0,poll,4,0,(uint32_t)0,& orig_ts,& orig_ts,
                  & recv_ts,(NTP_Local_Timestamp *)0,(NTP_int64 *)0,
                  (NTP_int64 *)0,& destination->addr,
                  & destination->local_addr);
  ;
  tmp_1 = get_separation(poll);
  ;
  add_timeout_in_class((double)destination->interval,tmp_1,0.02,
                       SCH_NtpBroadcastClass,& broadcast_timeout,arg);
  return;
}

void NCR_AddBroadcastDestination(IPAddr *addr, unsigned short port,
                                 int interval)
{
  BroadcastDestination *destination;
  int tmp_0;
  unsigned int tmp_2;
  destination = (BroadcastDestination *)ARR_GetNewElement(broadcasts_0);
  destination->addr.ip_addr = *addr;
  destination->addr.port = port;
  destination->local_addr.ip_addr.family = (uint16_t)0;
  destination->local_addr.if_index = -1;
  if ((int)destination->addr.ip_addr.family != 0) destination->local_addr.sock_fd = 100;
  else destination->local_addr.sock_fd = 0;
  if (interval < 1 << 24) tmp_0 = interval; else tmp_0 = 1 << 24;
  if (1 > tmp_0) destination->interval = 1;
  else {
    int tmp_1;
    if (interval < 1 << 24) tmp_1 = interval; else tmp_1 = 1 << 24;
    destination->interval = tmp_1;
  }
  tmp_2 = ARR_GetSize(broadcasts_0);
  ;
  add_timeout_in_class((double)destination->interval,0.2,0.02,
                       SCH_NtpBroadcastClass,& broadcast_timeout,
                       (void *)((long)(tmp_2 - (unsigned int)1)));
  return;
}

static void advance_time(double x)
{
  UTI_AddDoubleToTimespec(& current_time,x,& current_time);
  return;
}

static uint32_t get_random_key_id(void)
{
  uint32_t id;
  while (1) {
    int tmp_0;
    {
      long tmp;
      tmp = random();
      id = (uint32_t)(tmp % (long)6 + (long)2);
    }
    tmp_0 = KEY_KeyKnown(id);
    if (tmp_0) break;
  }
  return id;
}

static void send_request(NCR_Instance inst)
{
  NTP_Local_Address local_addr;
  NTP_Local_Timestamp local_ts;
  uint32_t prev_tx_count;
  long tmp;
  prev_tx_count = inst->report.total_tx_count;
  transmit_timeout((void *)inst);
  if (! (! inst->valid_rx)) {
    TST_Fail(88);
    exit(1);
  }
  if (! (prev_tx_count + (uint32_t)1 == inst->report.total_tx_count)) {
    TST_Fail(89);
    exit(1);
  }
  advance_time(1e-5);
  tmp = random();
  if (tmp % (long)2) {
    local_addr.ip_addr.family = (uint16_t)0;
    local_addr.if_index = -1;
    local_addr.sock_fd = 101;
    local_ts.ts = current_time;
    local_ts.err = 0.0;
    local_ts.source = NTP_TS_KERNEL;
    NCR_ProcessTxKnown(inst,& local_addr,& local_ts,& req_buffer.ntp_pkt,
                       req_length);
  }
  return;
}

static void process_request(NTP_Remote_Address *remote_addr)
{
  NTP_Local_Address local_addr;
  NTP_Local_Timestamp local_ts;
  long tmp;
  local_addr.ip_addr.family = (uint16_t)0;
  local_addr.if_index = -1;
  local_addr.sock_fd = 100;
  local_ts.ts = current_time;
  local_ts.err = 0.0;
  local_ts.source = NTP_TS_KERNEL;
  res_length = 0;
  NCR_ProcessRxUnknown(remote_addr,& local_addr,& local_ts,
                       & req_buffer.ntp_pkt,req_length);
  res_length = req_length;
  res_buffer = req_buffer;
  advance_time(1e-5);
  tmp = random();
  if (tmp % (long)2) {
    local_ts.ts = current_time;
    NCR_ProcessTxUnknown(remote_addr,& local_addr,& local_ts,
                         & res_buffer.ntp_pkt,res_length);
  }
  return;
}

static void send_response(int interleaved, int authenticated,
                          int allow_update, int valid_ts, int valid_auth)
{
  NTP_Packet *req;
  NTP_Packet *res;
  int tmp;
  double tmp_0;
  double tmp_1;
  double tmp_2;
  int auth_len = 0;
  req = & req_buffer.ntp_pkt;
  res = & res_buffer.ntp_pkt;
  if (! (req_length >= 48)) {
    TST_Fail(142);
    exit(1);
  }
  if (((int)req->lvm & 0x7) == MODE_CLIENT) tmp = MODE_SERVER;
  else tmp = MODE_ACTIVE;
  res->lvm = (uint8_t)((((LEAP_Normal << 6) & 0xc0) | (((((int)req->lvm >> 3) & 0x7) << 3) & 0x38)) | (
                       tmp & 0x07));
  res->stratum = (uint8_t)1;
  res->poll = req->poll;
  res->precision = (int8_t)(-20);
  res->root_delay = UTI_DoubleToNtp32(0.1);
  res->root_dispersion = UTI_DoubleToNtp32(0.1);
  res->reference_id = (NTP_int32)0;
  UTI_ZeroNtp64(& res->reference_ts);
  if (interleaved) res->originate_ts = req->receive_ts;
  else res->originate_ts = req->transmit_ts;
  tmp_0 = TST_GetRandomDouble(1e-4,1e-2);
  advance_time(tmp_0);
  UTI_TimespecToNtp64(& current_time,& res->receive_ts,(NTP_int64 *)0);
  tmp_1 = TST_GetRandomDouble(- 1e-4,1e-3);
  advance_time(tmp_1);
  UTI_TimespecToNtp64(& current_time,& res->transmit_ts,(NTP_int64 *)0);
  tmp_2 = TST_GetRandomDouble(1e-4,1e-2);
  advance_time(tmp_2);
  if (! valid_ts) {
    long tmp_3;
    int tmp_4;
    tmp_3 = random();
    if (allow_update) tmp_4 = 4; else tmp_4 = 5;
    switch (tmp_3 % (long)tmp_4) {
      long tmp_5;
      long tmp_6;
      case (long)0:
      { /* sequence */
        tmp_5 = random();
        res->originate_ts.hi = (uint32_t)tmp_5;
      }
      break;
      case (long)1:
      { /* sequence */
        tmp_6 = random();
        res->originate_ts.lo = (uint32_t)tmp_6;
      }
      break;
      case (long)2: UTI_ZeroNtp64(& res->originate_ts);
      break;
      case (long)3: UTI_ZeroNtp64(& res->receive_ts);
      break;
      case (long)4: UTI_ZeroNtp64(& res->transmit_ts);
      break;
      default: __FC_assert(0 != 0,"test/unit/ntp_core.c",179,"0");
    }
  }
  if (authenticated) {
    uint32_t tmp_9;
    int tmp_12;
    uint32_t tmp_11;
    if (req->auth_keyid) res->auth_keyid = req->auth_keyid;
    else {
      uint32_t tmp_8;
      uint32_t tmp_7;
      tmp_7 = get_random_key_id();
      tmp_8 = htonl(tmp_7);
      res->auth_keyid = tmp_8;
    }
    tmp_9 = ntohl(res->auth_keyid);
    auth_len = KEY_GetAuthLength(tmp_9);
    __FC_assert(auth_len != 0,"test/unit/ntp_core.c",186,"auth_len");
    if ((((int)res->lvm >> 3) & 0x7) == 4) {
      long tmp_10;
      tmp_10 = random();
      if (tmp_10 % (long)2) 
        if (auth_len < (4 + 20) - 4) auth_len = auth_len;
        else auth_len = (4 + 20) - 4;
    }
    ;
    ;
    ;
    tmp_11 = ntohl(res->auth_keyid);
    tmp_12 = KEY_GenerateAuth(tmp_11,(unsigned char const *)res,48,
                              res->auth_data,auth_len);
    ;
    if (tmp_12 != auth_len) __FC_assert(0 != 0,"test/unit/ntp_core.c",192,
                                        "0");
    res_length = (48 + 4) + auth_len;
  }
  else res_length = 48;
  if (! valid_auth) 
    if (authenticated) {
      long tmp_13;
      __FC_assert(auth_len != 0,"test/unit/ntp_core.c",199,"auth_len");
      tmp_13 = random();
      switch (tmp_13 % (long)4) {
        uint32_t tmp_14;
        uint32_t tmp_15;
        int tmp_17;
        uint32_t tmp_16;
        long tmp_18;
        long tmp_19;
        case (long)0:
        {
          tmp_14 = ntohl(res->auth_keyid);
          res->auth_keyid = htonl(tmp_14 + (uint32_t)1);
        }
        break;
        case (long)1:
        {
          tmp_15 = ntohl(res->auth_keyid);
          res->auth_keyid = htonl(tmp_15 ^ (unsigned int)1);
        }
        ;
        ;
        ;
        tmp_16 = ntohl(res->auth_keyid);
        tmp_17 = KEY_GenerateAuth(tmp_16,(unsigned char const *)res,48,
                                  res->auth_data,auth_len);
        ;
        if (tmp_17 != auth_len) __FC_assert(0 != 0,"test/unit/ntp_core.c",
                                            209,"0");
        break;
        case (long)2:
        { /* sequence */
          tmp_18 = random();
          res->auth_data[tmp_18 % (long)auth_len] = (uint8_t)((int)res->auth_data[
                                                              tmp_18 % (long)auth_len] + 1);
        }
        break;
        case (long)3:
        { /* sequence */
          tmp_19 = random();
          res_length = (int)(48L + (long)4 * (tmp_19 % (long)((4 + auth_len) / 4)));
        }
        if ((((int)res->lvm >> 3) & 0x7) == 4) 
          if (res_length == 48 + (4 + 20)) res_length -= 4;
        break;
        default: __FC_assert(0 != 0,"test/unit/ntp_core.c",221,"0");
      }
    }
  return;
}

static void process_response(NCR_Instance inst, int good, int valid,
                             int updated_sync, int updated_init)
{
  NTP_Local_Address local_addr;
  NTP_Local_Timestamp local_ts;
  NTP_Packet *res;
  uint32_t prev_rx_count;
  uint32_t prev_valid_count;
  struct timespec prev_rx_ts;
  struct timespec prev_init_rx_ts;
  int prev_open_socket;
  int ret;
  res = & res_buffer.ntp_pkt;
  local_addr.ip_addr.family = (uint16_t)0;
  local_addr.if_index = -1;
  if (((int)res->lvm & 0x7) != MODE_SERVER) local_addr.sock_fd = 100;
  else local_addr.sock_fd = 101;
  local_ts.ts = current_time;
  local_ts.err = 0.0;
  local_ts.source = NTP_TS_KERNEL;
  prev_rx_count = inst->report.total_rx_count;
  prev_valid_count = inst->report.total_valid_count;
  prev_rx_ts = inst->local_rx.ts;
  prev_init_rx_ts = inst->init_local_rx.ts;
  prev_open_socket = inst->local_addr.sock_fd != -2;
  ret = NCR_ProcessRxKnown(inst,& local_addr,& local_ts,res,res_length);
  if (good > 0) {
    if (! ret) {
      TST_Fail(254);
      exit(1);
    }
  }
  else 
    if (! good) 
      if (! (! ret)) {
        TST_Fail(256);
        exit(1);
      }
  if (prev_open_socket) {
    if (! (prev_rx_count + (uint32_t)1 == inst->report.total_rx_count)) {
      TST_Fail(259);
      exit(1);
    }
  }
  else 
    if (! (prev_rx_count == inst->report.total_rx_count)) {
      TST_Fail(261);
      exit(1);
    }
  if (valid) {
    if (! (prev_valid_count + (uint32_t)1 == inst->report.total_valid_count)) {
      TST_Fail(264);
      exit(1);
    }
  }
  else 
    if (! (prev_valid_count == inst->report.total_valid_count)) {
      TST_Fail(266);
      exit(1);
    }
  if (updated_sync) {
    int tmp;
    tmp = UTI_CompareTimespecs(& inst->local_rx.ts,& prev_rx_ts);
    if (! tmp) {
      TST_Fail(269);
      exit(1);
    }
  }
  else {
    int tmp_0;
    tmp_0 = UTI_CompareTimespecs(& inst->local_rx.ts,& prev_rx_ts);
    if (tmp_0) {
      TST_Fail(271);
      exit(1);
    }
  }
  if (updated_init > 0) {
    int tmp_1;
    tmp_1 = UTI_CompareTimespecs(& inst->init_local_rx.ts,& prev_init_rx_ts);
    if (! tmp_1) {
      TST_Fail(274);
      exit(1);
    }
  }
  else 
    if (! updated_init) {
      int tmp_2;
      tmp_2 = UTI_CompareTimespecs(& inst->init_local_rx.ts,
                                   & prev_init_rx_ts);
      if (tmp_2) {
        TST_Fail(276);
        exit(1);
      }
    }
  if (valid) {
    {
      int tmp_3;
      tmp_3 = UTI_IsZeroTimespec(& inst->init_local_rx.ts);
      if (! tmp_3) {
        TST_Fail(279);
        exit(1);
      }
    }
    {
      int tmp_4;
      tmp_4 = UTI_IsZeroNtp64(& inst->init_remote_ntp_tx);
      if (! tmp_4) {
        TST_Fail(280);
        exit(1);
      }
    }
  }
  return;
}

static void process_replay(NCR_Instance inst,
                           NTP_Receive_Buffer *packet_queue,
                           int queue_length, int updated_init)
{
  while (1) {
    int tmp_0;
    {
      long tmp;
      tmp = random();
      res_buffer = *(packet_queue + tmp % (long)queue_length);
    }
    tmp_0 = UTI_CompareNtp64(& res_buffer.ntp_pkt.transmit_ts,
                             & inst->remote_ntp_tx);
    if (tmp_0) break;
  }
  process_response(inst,0,0,0,updated_init);
  advance_time(1e-6);
  return;
}

void test_unit(void)
{
  int i;
  int j;
  int k;
  int interleaved;
  int authenticated;
  int valid;
  int updated;
  int has_updated;
  CPS_NTP_Source source;
  NTP_Remote_Address remote_addr;
  NCR_Instance inst1;
  NCR_Instance inst2;
  NTP_Receive_Buffer packet_queue[10];
  char source_line[31] =
    {(char)'1',
     (char)'2',
     (char)'7',
     (char)'.',
     (char)'0',
     (char)'.',
     (char)'0',
     (char)'.',
     (char)'1',
     (char)' ',
     (char)'m',
     (char)'a',
     (char)'x',
     (char)'d',
     (char)'e',
     (char)'l',
     (char)'a',
     (char)'y',
     (char)'d',
     (char)'e',
     (char)'v',
     (char)'r',
     (char)'a',
     (char)'t',
     (char)'i',
     (char)'o',
     (char)' ',
     (char)'1',
     (char)'e',
     (char)'6',
     (char)'\000'};
  char conf[4][100] =
    {{(char)'a', (char)'l', (char)'l', (char)'o', (char)'w', (char)'\000'},
     {(char)'p',
      (char)'o',
      (char)'r',
      (char)'t',
      (char)' ',
      (char)'0',
      (char)'\000'},
     {(char)'l', (char)'o', (char)'c', (char)'a', (char)'l', (char)'\000'},
     {(char)'k',
      (char)'e',
      (char)'y',
      (char)'f',
      (char)'i',
      (char)'l',
      (char)'e',
      (char)' ',
      (char)'n',
      (char)'t',
      (char)'p',
      (char)'_',
      (char)'c',
      (char)'o',
      (char)'r',
      (char)'e',
      (char)'.',
      (char)'k',
      (char)'e',
      (char)'y',
      (char)'s',
      (char)'\000'}};
  CNF_Initialise(0,0);
  i = 0;
  /*@ loop unroll 4; */
  while ((unsigned long)i < sizeof(conf) / sizeof(conf[0])) {
    CNF_ParseLine((char const *)0,i + 1,conf[i]);
    i ++;
  }
  LCL_Initialise();
  TST_RegisterDummyDrivers();
  SCH_Initialise();
  SRC_Initialise();
  NIO_Initialise(0);
  NCR_Initialise();
  REF_Initialise();
  TST_SuspendLogging();
  KEY_Initialise();
  TST_ResumeLogging();
  CNF_SetupAccessRestrictions();
  CPS_ParseNTPSourceAdd(source_line,& source);
  i = 0;
  /*@ loop unroll 3; */
  while (i < 3) {
    {
      long tmp;
      long tmp_0;
      long tmp_1;
      double tmp_2;
      int tmp_4;
      long tmp_3;
      int tmp_14;
      long tmp_13;
      tmp = random();
      if (tmp % (long)2) source.params.interleaved = 1;
      tmp_0 = random();
      if (tmp_0 % (long)2) source.params.authkey = get_random_key_id();
      tmp_1 = random();
      source.params.version = (int)(tmp_1 % (long)4 + (long)1);
      UTI_ZeroTimespec(& current_time);
      tmp_2 = TST_GetRandomDouble(1.0,1e9);
      advance_time(tmp_2);
      TST_GetRandomAddress(& remote_addr.ip_addr,0,-1);
      remote_addr.port = (unsigned short)123;
      tmp_3 = random();
      if (tmp_3 % (long)2) tmp_4 = NTP_SERVER; else tmp_4 = NTP_PEER;
      inst1 = NCR_GetInstance(& remote_addr,(NTP_Source_Type)tmp_4,
                              & source.params);
      NCR_StartInstance(inst1);
      has_updated = 0;
      j = 0;
      /*@ loop unroll 5; */
      while (j < 5) {
        {
          int tmp_6;
          long tmp_5;
          long tmp_7;
          int tmp_8;
          int tmp_9;
          int tmp_10;
          int tmp_11;
          int tmp_12;
          tmp_5 = random();
          if (tmp_5 % (long)2) 
            if (inst1->mode != (unsigned int)MODE_CLIENT) tmp_6 = 1;
            else 
              if (inst1->tx_count < (unsigned int)4) tmp_6 = 1;
              else tmp_6 = 0;
          else tmp_6 = 0;
          interleaved = tmp_6;
          tmp_7 = random();
          authenticated = (int)(tmp_7 % (long)2);
          if (! interleaved) goto _LOR;
          else 
            if (source.params.interleaved) 
              if (has_updated) 
                _LOR:
                if (! source.params.authkey) tmp_8 = 1;
                else 
                  if (authenticated) tmp_8 = 1; else tmp_8 = 0;
              else tmp_8 = 0;
            else tmp_8 = 0;
          valid = tmp_8;
          if (valid) goto _LOR_0;
          else 
            if (inst1->mode == (unsigned int)MODE_ACTIVE) 
              _LOR_0:
              if (! source.params.authkey) tmp_9 = 1;
              else 
                if (authenticated) tmp_9 = 1; else tmp_9 = 0;
            else tmp_9 = 0;
          updated = tmp_9;
          if (has_updated) tmp_10 = 1;
          else 
            if (updated) tmp_10 = 1; else tmp_10 = 0;
          has_updated = tmp_10;
          if (inst1->mode == (unsigned int)MODE_CLIENT) updated = 0;
          send_request(inst1);
          send_response(interleaved,authenticated,1,0,1);
          process_response(inst1,0,0,0,updated);
          if (source.params.authkey) {
            send_response(interleaved,authenticated,1,1,0);
            process_response(inst1,0,0,0,0);
          }
          send_response(interleaved,authenticated,1,1,1);
          process_response(inst1,-1,valid,valid,updated);
          process_response(inst1,0,0,0,0);
          advance_time(- 1.0);
          send_response(interleaved,authenticated,1,1,1);
          if (updated) 
            if (valid) tmp_11 = 1; else tmp_11 = 0;
          else tmp_11 = 0;
          ;
          process_response(inst1,0,0,0,tmp_11);
          advance_time(1.0);
          send_response(interleaved,authenticated,1,1,1);
          ;
          if (valid) 
            if (updated) tmp_12 = 1; else tmp_12 = 0;
          else tmp_12 = 0;
          ;
          process_response(inst1,0,0,tmp_12,updated);
        }
        j ++;
      }
      NCR_DestroyInstance(inst1);
      tmp_13 = random();
      if (tmp_13 % (long)2) tmp_14 = NTP_SERVER; else tmp_14 = NTP_PEER;
      inst1 = NCR_GetInstance(& remote_addr,(NTP_Source_Type)tmp_14,
                              & source.params);
      NCR_StartInstance(inst1);
      j = 0;
      /*@ loop unroll 2; */
      while (j < 2) {
        send_request(inst1);
        process_request(& remote_addr);
        process_response(inst1,1,1,1,0);
        advance_time((double)(1 << inst1->local_poll));
        j ++;
      }
      NCR_DestroyInstance(inst1);
      inst1 = NCR_GetInstance(& remote_addr,NTP_PEER,& source.params);
      NCR_StartInstance(inst1);
      inst2 = NCR_GetInstance(& remote_addr,NTP_PEER,& source.params);
      NCR_StartInstance(inst2);
      req_length = 0;
      res_length = req_length;
      j = 0;
      /*@ loop unroll 4; */
      while (j < 4) {
        {
          int tmp_15;
          send_request(inst1);
          res_buffer = req_buffer;
          if (! res_length) tmp_15 = 1;
          else 
            if (res_length == req_length) tmp_15 = 1; else tmp_15 = 0;
          __FC_assert(tmp_15 != 0,"test/unit/ntp_core.c",446,
                      "!res_length || res_length == req_length");
          res_length = req_length;
          if (! (inst1->valid_timestamps == (j > 0))) {
            TST_Fail(449);
            exit(1);
          }
          process_response(inst2,j > source.params.interleaved,j > 0,j > 0,1);
          packet_queue[(j * 2) % 10] = res_buffer;
          k = 0;
          /*@ loop unroll 5; */
          while (k < j % 4 + 1) {
            {
              int tmp_16;
              int tmp_17;
              int tmp_18;
              if (k) tmp_16 = -1; else tmp_16 = 1;
              if (j * 2 + 1 < 10) tmp_17 = j * 2 + 1; else tmp_17 = 10;
              ;
              process_replay(inst1,packet_queue,tmp_17,tmp_16);
              if (j * 2 + 1 < 10) tmp_18 = j * 2 + 1; else tmp_18 = 10;
              ;
              process_replay(inst2,packet_queue,tmp_18,-1);
            }
            k ++;
          }
          advance_time((double)(1 << (source.params.minpoll - 1)));
          send_request(inst2);
          res_buffer = req_buffer;
          __FC_assert((res_length == req_length) != 0,"test/unit/ntp_core.c",
                      468,"res_length == req_length");
          if (! (inst2->valid_timestamps == (j > 0))) {
            TST_Fail(470);
            exit(1);
          }
          process_response(inst1,1,1,1,1);
          packet_queue[(j * 2 + 1) % 10] = res_buffer;
          k = 0;
          /*@ loop unroll 5; */
          while (k < j % 4 + 1) {
            {
              int tmp_19;
              int tmp_20;
              int tmp_21;
              if (k) tmp_19 = -1; else tmp_19 = 1;
              if (j * 2 + 2 < 10) tmp_20 = j * 2 + 2; else tmp_20 = 10;
              ;
              process_replay(inst1,packet_queue,tmp_20,tmp_19);
              if (j * 2 + 2 < 10) tmp_21 = j * 2 + 2; else tmp_21 = 10;
              ;
              process_replay(inst2,packet_queue,tmp_21,-1);
            }
            k ++;
          }
          advance_time((double)(1 << (source.params.minpoll - 1)));
        }
        j ++;
      }
      NCR_DestroyInstance(inst1);
      NCR_DestroyInstance(inst2);
    }
    i ++;
  }
  KEY_Finalise();
  REF_Finalise();
  NCR_Finalise();
  NIO_Finalise();
  SRC_Finalise();
  SCH_Finalise();
  LCL_Finalise();
  CNF_Finalise();
  HSH_Finalise();
  return;
}


