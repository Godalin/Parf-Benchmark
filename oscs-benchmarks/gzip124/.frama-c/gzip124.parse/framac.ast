/* Generated by Frama-C */
#include "__fc_builtin.h"
#include "ctype.h"
#include "dirent.h"
#include "errno.h"
#include "fcntl.h"
#include "signal.h"
#include "stdarg.h"
#include "stddef.h"
#include "stdio.h"
#include "stdlib.c"
#include "stdlib.h"
#include "string.h"
#include "strings.h"
#include "sys/stat.h"
#include "sys/types.h"
#include "time.h"
#include "unistd.h"
typedef void *voidp;
typedef unsigned char uch;
typedef unsigned short ush;
typedef unsigned long ulg;
typedef int file_t;
struct option {
   char const *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
typedef struct dirent dir_type;
typedef ush Pos;
typedef unsigned int IPos;
struct config {
   ush good_length ;
   ush max_lazy ;
   ush nice_length ;
   ush max_chain ;
};
typedef struct config config;
union __anonunion_fc_1 {
   ush freq ;
   ush code ;
};
union __anonunion_dl_2 {
   ush dad ;
   ush len ;
};
struct ct_data {
   union __anonunion_fc_1 fc ;
   union __anonunion_dl_2 dl ;
};
typedef struct ct_data ct_data;
struct tree_desc {
   ct_data *dyn_tree ;
   ct_data *static_tree ;
   int *extra_bits ;
   int extra_base ;
   int elems ;
   int max_length ;
   int max_code ;
};
typedef struct tree_desc tree_desc;
union __anonunion_v_1 {
   ush n ;
   struct huft *t ;
};
struct huft {
   uch e ;
   uch b ;
   union __anonunion_v_1 v ;
};
typedef unsigned char char_type;
typedef long code_int;
typedef unsigned long cmp_code_int;
enum __anonenum_ordering_1 {
    REQUIRE_ORDER = 0,
    PERMUTE = 1,
    RETURN_IN_ORDER = 2
};
static char *license_msg[15] =
  {(char *)"   Copyright (C) 1992-1993 Jean-loup Gailly",
   (char *)"   This program is free software; you can redistribute it and/or modify",
   (char *)"   it under the terms of the GNU General Public License as published by",
   (char *)"   the Free Software Foundation; either version 2, or (at your option)",
   (char *)"   any later version.",
   (char *)"",
   (char *)"   This program is distributed in the hope that it will be useful,",
   (char *)"   but WITHOUT ANY WARRANTY; without even the implied warranty of",
   (char *)"   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
   (char *)"   GNU General Public License for more details.",
   (char *)"",
   (char *)"   You should have received a copy of the GNU General Public License",
   (char *)"   along with this program; if not, write to the Free Software",
   (char *)"   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.",
   (char *)0};
int method;

uch inbuf[0x8000 + 64];
uch outbuf[16384 + 2048];
ush d_buf[0x8000];
uch window[2L * (long)0x8000];
ush prev[1L << 16];
unsigned int insize;
unsigned int inptr;
unsigned int outcnt;
long bytes_in;
long bytes_out;
long header_bytes;

int ifd;
int ofd;
char ifname[1024];
char ofname[1024];
char *progname;
long time_stamp;
long ifile_size;
int decrypt;

int exit_code;

int verbose;

int quiet;

int level;

int test;

int to_stdout;

int save_orig_name;
int zip(int in, int out) __attribute__((__FC_OLDSTYLEPROTO__));

int file_read(char *buf, unsigned int size) __attribute__((__FC_OLDSTYLEPROTO__));

int unzip(int in, int out) __attribute__((__FC_OLDSTYLEPROTO__));

int check_zipfile(int in) __attribute__((__FC_OLDSTYLEPROTO__));

int unpack(int in, int out) __attribute__((__FC_OLDSTYLEPROTO__));

int unlzh(int in, int out) __attribute__((__FC_OLDSTYLEPROTO__));

void abort_gzip(void);

void lm_init(int pack_level, ush *flags_0) __attribute__((__FC_OLDSTYLEPROTO__));

ulg deflate(void);

void ct_init(ush *attr, int *methodp) __attribute__((__FC_OLDSTYLEPROTO__));

int ct_tally(int dist, int lc) __attribute__((__FC_OLDSTYLEPROTO__));

ulg flush_block(char *buf, ulg stored_len, int eof) __attribute__((__FC_OLDSTYLEPROTO__));

void bi_init(file_t zipfile) __attribute__((__FC_OLDSTYLEPROTO__));

void send_bits(int value, int length) __attribute__((__FC_OLDSTYLEPROTO__));

unsigned int bi_reverse(unsigned int code, int len) __attribute__((__FC_OLDSTYLEPROTO__));

void bi_windup(void);

void copy_block(char *buf, unsigned int len, int header) __attribute__((
__FC_OLDSTYLEPROTO__));

int (*read_buf)(char *buf, unsigned int size);

int copy(int in, int out) __attribute__((__FC_OLDSTYLEPROTO__));

ulg updcrc(uch *s, unsigned int n) __attribute__((__FC_OLDSTYLEPROTO__));

void clear_bufs(void);

int fill_inbuf(int eof_ok) __attribute__((__FC_OLDSTYLEPROTO__));

void flush_outbuf(void);

void flush_window(void);

void write_buf(int fd, voidp buf, unsigned int cnt) __attribute__((__FC_OLDSTYLEPROTO__));

char *strlwr(char *s) __attribute__((__FC_OLDSTYLEPROTO__));

char *basename(char *fname) __attribute__((__FC_OLDSTYLEPROTO__));

void make_simple_name(char *name) __attribute__((__FC_OLDSTYLEPROTO__));

char *add_envopt(int *argcp, char ***argvp, char *env_0) __attribute__((
__FC_OLDSTYLEPROTO__));

void error(char *m) __attribute__((__FC_OLDSTYLEPROTO__));

void warn(char *a, char *b) __attribute__((__FC_OLDSTYLEPROTO__));

void read_error(void);

void write_error(void);

void display_ratio(long num, long den, FILE *file) __attribute__((__FC_OLDSTYLEPROTO__));

voidp xmalloc(unsigned int size) __attribute__((__FC_OLDSTYLEPROTO__));

int inflate(void);

int maxbits;

int block_mode;

int lzw(int in, int out) __attribute__((__FC_OLDSTYLEPROTO__));

int unlzw(int in, int out) __attribute__((__FC_OLDSTYLEPROTO__));

int getopt_long(int argc, char * const *argv, char const *options,
                struct option const *long_options, int *opt_index) __attribute__((
__FC_OLDSTYLEPROTO__));

int _getopt_internal(int argc, char * const *argv, char const *optstring,
                     struct option const *longopts_0, int *longind,
                     int long_only) __attribute__((__FC_OLDSTYLEPROTO__));

int ascii = 0;
int to_stdout = 0;
int decompress = 0;
int force = 0;
int no_name = -1;
int no_time = -1;
int recursive = 0;
int list = 0;
int verbose = 0;
int quiet = 0;
int do_lzw = 0;
int test = 0;
int foreground;
int maxbits = 16;
int method = 8;
int level = 6;
int exit_code = 0;
int last_member;
int part_nb;
char *env;
char **args = (char **)0;
char z_suffix[30 + 1];
int z_len;
long total_in = (long)0;
long total_out = (long)0;
int remove_ofname = 0;
struct stat istat;
struct option longopts[24] =
  {{.name = "ascii", .has_arg = 0, .flag = (int *)0, .val = 'a'},
   {.name = "to-stdout", .has_arg = 0, .flag = (int *)0, .val = 'c'},
   {.name = "stdout", .has_arg = 0, .flag = (int *)0, .val = 'c'},
   {.name = "decompress", .has_arg = 0, .flag = (int *)0, .val = 'd'},
   {.name = "uncompress", .has_arg = 0, .flag = (int *)0, .val = 'd'},
   {.name = "force", .has_arg = 0, .flag = (int *)0, .val = 'f'},
   {.name = "help", .has_arg = 0, .flag = (int *)0, .val = 'h'},
   {.name = "list", .has_arg = 0, .flag = (int *)0, .val = 'l'},
   {.name = "license", .has_arg = 0, .flag = (int *)0, .val = 'L'},
   {.name = "no-name", .has_arg = 0, .flag = (int *)0, .val = 'n'},
   {.name = "name", .has_arg = 0, .flag = (int *)0, .val = 'N'},
   {.name = "quiet", .has_arg = 0, .flag = (int *)0, .val = 'q'},
   {.name = "silent", .has_arg = 0, .flag = (int *)0, .val = 'q'},
   {.name = "recursive", .has_arg = 0, .flag = (int *)0, .val = 'r'},
   {.name = "suffix", .has_arg = 1, .flag = (int *)0, .val = 'S'},
   {.name = "test", .has_arg = 0, .flag = (int *)0, .val = 't'},
   {.name = "no-time", .has_arg = 0, .flag = (int *)0, .val = 'T'},
   {.name = "verbose", .has_arg = 0, .flag = (int *)0, .val = 'v'},
   {.name = "version", .has_arg = 0, .flag = (int *)0, .val = 'V'},
   {.name = "fast", .has_arg = 0, .flag = (int *)0, .val = '1'},
   {.name = "best", .has_arg = 0, .flag = (int *)0, .val = '9'},
   {.name = "lzw", .has_arg = 0, .flag = (int *)0, .val = 'Z'},
   {.name = "bits", .has_arg = 1, .flag = (int *)0, .val = 'b'},
   {.name = (char const *)0, .has_arg = 0, .flag = (int *)0, .val = 0}};
static void usage(void);

static void help(void);

static void license(void);

static void version(void);

static void treat_stdin(void);

static void treat_file(char *iname) __attribute__((__FC_OLDSTYLEPROTO__));

static int create_outfile(void);

static int do_stat(char *name, struct stat *sbuf) __attribute__((__FC_OLDSTYLEPROTO__));

static char *get_suffix(char *name) __attribute__((__FC_OLDSTYLEPROTO__));

static int get_istat(char *iname, struct stat *sbuf) __attribute__((__FC_OLDSTYLEPROTO__));

static int make_ofname(void);

static int same_file(struct stat *stat1, struct stat *stat2) __attribute__((
__FC_OLDSTYLEPROTO__));

static int name_too_long(char *name, struct stat *statb) __attribute__((
__FC_OLDSTYLEPROTO__));

static void shorten_name(char *name) __attribute__((__FC_OLDSTYLEPROTO__));

static int get_method(int in) __attribute__((__FC_OLDSTYLEPROTO__));

static void do_list(int ifd_0, int method_0) __attribute__((__FC_OLDSTYLEPROTO__));

static int check_ofname(void);

static void copy_stat(struct stat *ifstat) __attribute__((__FC_OLDSTYLEPROTO__));

static void do_exit(int exitcode) __attribute__((__FC_OLDSTYLEPROTO__));

int main(int argc, char **argv) __attribute__((__FC_OLDSTYLEPROTO__));

int (*work)(int infile, int outfile) = & zip;
static void treat_dir(char *dir) __attribute__((__FC_OLDSTYLEPROTO__));

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(param2);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param2 + (0 ..))),
            (indirect: *(param1 + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param2 + (0 ..)),
            *(param1 + (0 ..)), *(param0 + (0 ..));
 */
int fprintf_va_1(FILE * restrict stream, char const * restrict format,
                 char *param0, char *param1, char *param2);

static void usage(void)
{
  fprintf(__fc_stderr,
          "usage: %s [-%scdfhlLnN%stvV19] [-S suffix] [file ...]\n",progname,
          (char *)"",(char *)"r"); /* fprintf_va_1 */
  return;
}

static char *help_help_msg[18] =
  {(char *)" -c --stdout      write on standard output, keep original files unchanged",
   (char *)" -d --decompress  decompress",
   (char *)" -f --force       force overwrite of output file and compress links",
   (char *)" -h --help        give this help",
   (char *)" -l --list        list compressed file contents",
   (char *)" -L --license     display software license",
   (char *)" -n --no-name     do not save or restore the original name and time stamp",
   (char *)" -N --name        save or restore the original name and time stamp",
   (char *)" -q --quiet       suppress all warnings",
   (char *)" -r --recursive   operate recursively on directories",
   (char *)" -S .suf  --suffix .suf     use suffix .suf on compressed files",
   (char *)" -t --test        test compressed file integrity",
   (char *)" -v --verbose     verbose mode",
   (char *)" -V --version     display version number",
   (char *)" -1 --fast        compress faster",
   (char *)" -9 --best        compress better",
   (char *)" file...          files to (de)compress. If none given, use standard input.",
   (char *)0};
/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(param2);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param2 + (0 ..))),
            (indirect: *(param1 + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param2 + (0 ..)),
            *(param1 + (0 ..)), *(param0 + (0 ..));
 */
int fprintf_va_2(FILE * restrict stream, char const * restrict format,
                 char *param0, char *param1, char *param2);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_3(FILE * restrict stream, char const * restrict format,
                 char *param0);

static void help(void)
{
  char **p = help_help_msg;
  fprintf(__fc_stderr,"%s %s (%s)\n",progname,(char *)"1.2.4",
          (char *)"18 Aug 93"); /* fprintf_va_2 */
  usage();
  while (*p) {
    char **tmp;
    tmp = p;
    p ++;
    ;
    ;
    fprintf(__fc_stderr,"%s\n",*tmp); /* fprintf_va_3 */
  }
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(param2);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param2 + (0 ..))),
            (indirect: *(param1 + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param2 + (0 ..)),
            *(param1 + (0 ..)), *(param0 + (0 ..));
 */
int fprintf_va_4(FILE * restrict stream, char const * restrict format,
                 char *param0, char *param1, char *param2);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_5(FILE * restrict stream, char const * restrict format,
                 char *param0);

static void license(void)
{
  char **p = license_msg;
  fprintf(__fc_stderr,"%s %s (%s)\n",progname,(char *)"1.2.4",
          (char *)"18 Aug 93"); /* fprintf_va_4 */
  while (*p) {
    char **tmp;
    tmp = p;
    p ++;
    ;
    ;
    fprintf(__fc_stderr,"%s\n",*tmp); /* fprintf_va_5 */
  }
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(param2);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param2 + (0 ..))),
            (indirect: *(param1 + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param2 + (0 ..)),
            *(param1 + (0 ..)), *(param0 + (0 ..));
 */
int fprintf_va_6(FILE * restrict stream, char const * restrict format,
                 char *param0, char *param1, char *param2);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_7(FILE * restrict stream, char const * restrict format,
                 char *param0, char *param1);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_8(FILE * restrict stream, char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_9(FILE * restrict stream, char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_10(FILE * restrict stream, char const * restrict format);

static void version(void)
{
  fprintf(__fc_stderr,"%s %s (%s)\n",progname,(char *)"1.2.4",
          (char *)"18 Aug 93"); /* fprintf_va_6 */
  fprintf(__fc_stderr,"Compilation options:\n%s %s ",(char *)"DIRENT",
          (char *)"NO_UTIME"); /* fprintf_va_7 */
  fprintf(__fc_stderr,"STDC_HEADERS "); /* fprintf_va_8 */
  fprintf(__fc_stderr,"HAVE_UNISTD_H "); /* fprintf_va_9 */
  fprintf(__fc_stderr,"\n"); /* fprintf_va_10 */
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_11(FILE * restrict stream, char const * restrict format,
                  char *param0);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_12(FILE * restrict stream, char const * restrict format,
                  char *param0);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_13(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1);

int main(int argc, char **argv) __attribute__((__FC_OLDSTYLEPROTO__));
int main(int argc, char **argv)
{
  int file_count;
  int proglen;
  int optc;
  size_t tmp;
  void (*tmp_1)(int );
  void (*tmp_2)(int );
  void (*tmp_3)(int );
  int tmp_6;
  size_t tmp_8;
  progname = basename(*(argv + 0));
  tmp = strlen((char const *)progname);
  proglen = (int)tmp;
  if (proglen > 4) {
    int tmp_0;
    tmp_0 = strcmp((char const *)((progname + proglen) - 4),".exe");
    if (tmp_0 == 0) *(progname + (proglen - 4)) = (char)'\000';
  }
  env = add_envopt(& argc,& argv,(char *)"GZIP");
  if (env != (char *)0) args = argv;
  tmp_1 = signal(2,SIG_IGN);
  foreground = tmp_1 != SIG_IGN;
  if (foreground) signal(2,(void (*)(int ))(& abort_gzip));
  tmp_2 = signal(15,SIG_IGN);
  if (tmp_2 != SIG_IGN) signal(15,(void (*)(int ))(& abort_gzip));
  tmp_3 = signal(1,SIG_IGN);
  if (tmp_3 != SIG_IGN) signal(1,(void (*)(int ))(& abort_gzip));
  tmp_6 = strncmp((char const *)progname,"un",(size_t)2);
  if (tmp_6 == 0) goto _LOR_0;
  else {
    int tmp_7;
    tmp_7 = strncmp((char const *)progname,"gun",(size_t)3);
    if (tmp_7 == 0) _LOR_0: decompress = 1;
    else {
      int tmp_4;
      tmp_4 = strcmp((char const *)(progname + 1),"cat");
      if (tmp_4 == 0) goto _LOR;
      else {
        int tmp_5;
        tmp_5 = strcmp((char const *)progname,"gzcat");
        if (tmp_5 == 0) {
          _LOR: {
                  to_stdout = 1;
                  decompress = to_stdout;
                }
        }
      }
    }
  }
  strncpy(z_suffix,".gz",sizeof(z_suffix) - (unsigned int)1);
  tmp_8 = strlen((char const *)(z_suffix));
  z_len = (int)tmp_8;
  while (1) {
    optc = getopt_long(argc,(char * const *)argv,
                       "ab:cdfhH?lLmMnNqrS:tvVZ123456789",
                       (struct option const *)(longopts),(int *)0);
    if (! (optc != -1)) break;
    switch (optc) {
      size_t tmp_9;
      case 'a': ascii = 1;
      break;
      case 'b': maxbits = atoi((char const *)optarg);
      break;
      case 'c': to_stdout = 1;
      break;
      case 'd': decompress = 1;
      break;
      case 'f': force ++;
      break;
      case 'h': case 'H': case '?': help();
      do_exit(0);
      break;
      case 'l':
      { /* sequence */
        to_stdout = 1;
        decompress = to_stdout;
        list = decompress;
      }
      break;
      case 'L': license();
      do_exit(0);
      break;
      case 'm': no_time = 1;
      break;
      case 'M': no_time = 0;
      break;
      case 'n': { /* sequence */
                  no_time = 1;
                  no_name = no_time;
                }
      break;
      case 'N': { /* sequence */
                  no_time = 0;
                  no_name = no_time;
                }
      break;
      case 'q': quiet = 1;
      verbose = 0;
      break;
      case 'r': recursive = 1;
      break;
      case 'S':
      { /* sequence */
        tmp_9 = strlen((char const *)optarg);
        z_len = (int)tmp_9;
      }
      strcpy(z_suffix,(char const *)optarg);
      break;
      case 't':
      { /* sequence */
        to_stdout = 1;
        decompress = to_stdout;
        test = decompress;
      }
      break;
      case 'v': verbose ++;
      quiet = 0;
      break;
      case 'V': version();
      do_exit(0);
      break;
      case 'Z':
      fprintf(__fc_stderr,"%s: -Z not supported in this version\n",progname); /* fprintf_va_11 */
      usage();
      do_exit(1);
      break;
      case '1': case '2': case '3': case '4': case '5': case '6': case '7':
      case '8': case '9':
      level = optc - '0';
      break;
      default: usage();
      do_exit(1);
    }
  }
  if (no_time < 0) no_time = decompress;
  if (no_name < 0) no_name = decompress;
  file_count = argc - optind;
  if (ascii) 
    if (! quiet) fprintf(__fc_stderr,
                         "%s: option --ascii ignored on this system\n",
                         progname); /* fprintf_va_12 */
  if (z_len == 0) {
    if (! decompress) goto _LOR_1; else goto _LAND;
  }
  else {
    _LAND: ;
    if (z_len > 30) {
      _LOR_1:
      {
        fprintf(__fc_stderr,"%s: incorrect suffix \'%s\'\n",progname,optarg); /* fprintf_va_13 */
        do_exit(1);
      }
    }
  }
  if (do_lzw) 
    if (! decompress) work = & lzw;
  if (file_count != 0) {
    if (to_stdout) 
      if (! test) 
        if (! list) 
          if (! decompress) goto _LOR_2;
          else 
            if (! ascii) _LOR_2: ;
    while (optind < argc) {
      int tmp_10;
      tmp_10 = optind;
      optind ++;
      ;
      treat_file(*(argv + tmp_10));
    }
  }
  else treat_stdin();
  if (list) 
    if (! quiet) 
      if (file_count > 1) do_list(-1,-1);
  do_exit(exit_code);
  return exit_code;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(param2);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param2 + (0 ..))),
            (indirect: *(param1 + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param2 + (0 ..)),
            *(param1 + (0 ..)), *(param0 + (0 ..));
 */
int fprintf_va_14(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1, char *param2);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_15(FILE * restrict stream, char const * restrict format,
                  char *param0);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_16(FILE * restrict stream, char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_17(FILE * restrict stream, char const * restrict format);

static void treat_stdin(void)
{
  if (! force) 
    if (! list) {
      int tmp_3;
      int tmp_2;
      FILE *tmp_1;
      if (decompress) tmp_1 = __fc_stdin; else tmp_1 = __fc_stdout;
      tmp_2 = fileno(tmp_1);
      tmp_3 = isatty(tmp_2);
      if (tmp_3) {
        char const *tmp;
        char const *tmp_0;
        if (decompress) tmp = "de"; else tmp = "";
        if (decompress) tmp_0 = "read from"; else tmp_0 = "written to";
        ;
        ;
        fprintf(__fc_stderr,
                "%s: compressed data not %s a terminal. Use -f to force %scompression.\n",
                progname,(char *)tmp_0,(char *)tmp); /* fprintf_va_14 */
        fprintf(__fc_stderr,"For help, type: %s -h\n",progname); /* fprintf_va_15 */
        do_exit(1);
      }
    }
  if (decompress) goto _LOR;
  else 
    if (! ascii) _LOR: ;
  if (! test) 
    if (! list) 
      if (! decompress) goto _LOR_0;
      else 
        if (! ascii) _LOR_0: ;
  strcpy(ifname,"stdin");
  strcpy(ofname,"stdout");
  time_stamp = (long)0;
  if (list) goto _LOR_1;
  else 
    if (! no_time) {
      _LOR_1:
      {
        int tmp_5;
        int tmp_4;
        tmp_4 = fileno(__fc_stdin);
        tmp_5 = fstat(tmp_4,& istat);
        if (tmp_5 != 0) error((char *)"fstat(stdin)");
        time_stamp = istat.st_mtime;
      }
    }
  ifile_size = -1L;
  clear_bufs();
  to_stdout = 1;
  part_nb = 0;
  if (decompress) {
    method = get_method(ifd);
    if (method < 0) do_exit(exit_code);
  }
  if (list) {
    do_list(ifd,method);
    goto return_label;
  }
  while (1) {
    int tmp_8;
    int tmp_6;
    int tmp_7;
    tmp_6 = fileno(__fc_stdout);
    tmp_7 = fileno(__fc_stdin);
    tmp_8 = (*work)(tmp_7,tmp_6);
    if (tmp_8 != 0) goto return_label;
    if (! decompress) break;
    else 
      if (last_member) break;
      else 
        if (inptr == insize) break;
    method = get_method(ifd);
    if (method < 0) goto return_label;
    bytes_out = (long)0;
  }
  if (verbose) 
    if (test) fprintf(__fc_stderr," OK\n"); /* fprintf_va_16 */
    else 
      if (! decompress) {
        display_ratio(bytes_in - (bytes_out - header_bytes),bytes_in,
                      __fc_stderr);
        fprintf(__fc_stderr,"\n"); /* fprintf_va_17 */
      }
  return_label: return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_18(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_19(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param3),
            (indirect: param2), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param3, param2,
            *(param1 + (0 ..)), *(param0 + (0 ..));
 */
int fprintf_va_20(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1, int param2, int param3);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_21(FILE * restrict stream, char const * restrict format,
                  char *param0);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(param2);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param2 + (0 ..))),
            (indirect: *(param1 + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param2 + (0 ..)),
            *(param1 + (0 ..)), *(param0 + (0 ..));
 */
int fprintf_va_22(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1, char *param2);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_23(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_24(FILE * restrict stream, char const * restrict format);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_25(FILE * restrict stream, char const * restrict format,
                  char *param0);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_26(FILE * restrict stream, char const * restrict format);

static void treat_file(char *iname) __attribute__((__FC_OLDSTYLEPROTO__));
static void treat_file(char *iname)
{
  int tmp;
  int tmp_0;
  int tmp_3;
  tmp = strcmp((char const *)iname,"-");
  if (tmp == 0) {
    int cflag = to_stdout;
    treat_stdin();
    to_stdout = cflag;
    goto return_label;
  }
  tmp_0 = get_istat(iname,& istat);
  if (tmp_0 != 0) goto return_label;
  if ((istat.st_mode & (unsigned int)0170000) == (unsigned int)0040000) {
    if (recursive) {
      struct stat st;
      st = istat;
    }
    else {
      if (! quiet) fprintf(__fc_stderr,"%s: %s is a directory -- ignored\n",
                           progname,ifname); /* fprintf_va_18 */
      if (exit_code == 0) exit_code = 2;
    }
    goto return_label;
  }
  if (! ((istat.st_mode & (unsigned int)0170000) == (unsigned int)0100000)) {
    if (! quiet) fprintf(__fc_stderr,
                         "%s: %s is not a directory or a regular file - ignored\n",
                         progname,ifname); /* fprintf_va_19 */
    if (exit_code == 0) exit_code = 2;
    goto return_label;
  }
  if (istat.st_nlink > (nlink_t)1) 
    if (! to_stdout) 
      if (! force) {
        if (! quiet) {
          int tmp_1;
          if (istat.st_nlink > (nlink_t)2) tmp_1 = 's'; else tmp_1 = ' ';
          ;
          ;
          ;
          fprintf(__fc_stderr,"%s: %s has %d other link%c -- unchanged\n",
                  progname,ifname,(int)istat.st_nlink - 1,tmp_1); /* fprintf_va_20 */
        }
        if (exit_code == 0) exit_code = 2;
        goto return_label;
      }
  ifile_size = istat.st_size;
  if (no_time) 
    if (! list) time_stamp = (long)0; else time_stamp = istat.st_mtime;
  else time_stamp = istat.st_mtime;
  if (to_stdout) {
    if (! list) {
      if (! test) strcpy(ofname,"stdout"); else goto _LAND_0;
    }
    else goto _LAND_0;
  }
  else {
    int tmp_2;
    _LAND_0: tmp_2 = make_ofname();
    if (tmp_2 != 0) goto return_label;
  }
  if (ascii) 
    if (! decompress) tmp_3 = 0; else tmp_3 = 0 | 0;
  else tmp_3 = 0 | 0;
  ifd = open((char const *)(ifname),tmp_3,(mode_t)(00400 | 00200)); /* __va_open_mode_t */
  if (ifd == -1) {
    fprintf(__fc_stderr,"%s: ",progname); /* fprintf_va_21 */
    perror((char const *)(ifname));
    exit_code = 1;
    goto return_label;
  }
  clear_bufs();
  part_nb = 0;
  if (decompress) {
    method = get_method(ifd);
    if (method < 0) {
      close(ifd);
      goto return_label;
    }
  }
  if (list) {
    do_list(ifd,method);
    close(ifd);
    goto return_label;
  }
  if (to_stdout) ofd = fileno(__fc_stdout);
  else {
    int tmp_4;
    tmp_4 = create_outfile();
    if (tmp_4 != 0) goto return_label;
    if (! decompress) 
      if (save_orig_name) 
        if (! verbose) 
          if (! quiet) fprintf(__fc_stderr,"%s: %s compressed to %s\n",
                               progname,ifname,ofname); /* fprintf_va_22 */
  }
  if (! save_orig_name) save_orig_name = ! no_name;
  if (verbose) {
    char const *tmp_8;
    size_t tmp_5;
    tmp_5 = strlen((char const *)(ifname));
    if ((int)tmp_5 >= 15) tmp_8 = "";
    else {
      char const *tmp_7;
      size_t tmp_6;
      tmp_6 = strlen((char const *)(ifname));
      if ((int)tmp_6 >= 7) tmp_7 = "\t"; else tmp_7 = "\t\t";
      tmp_8 = tmp_7;
    }
    ;
    fprintf(__fc_stderr,"%s:\t%s",ifname,(char *)tmp_8); /* fprintf_va_23 */
  }
  while (1) {
    int tmp_9;
    tmp_9 = (*work)(ifd,ofd);
    if (tmp_9 != 0) {
      method = -1;
      break;
    }
    if (! decompress) break;
    else 
      if (last_member) break;
      else 
        if (inptr == insize) break;
    method = get_method(ifd);
    if (method < 0) break;
    bytes_out = (long)0;
  }
  close(ifd);
  if (! to_stdout) {
    int tmp_10;
    tmp_10 = close(ofd);
    if (tmp_10) write_error();
  }
  if (method == -1) {
    if (! to_stdout) unlink((char const *)(ofname));
    goto return_label;
  }
  if (verbose) {
    if (test) fprintf(__fc_stderr," OK"); /* fprintf_va_24 */
    else 
      if (decompress) display_ratio(bytes_out - (bytes_in - header_bytes),
                                    bytes_out,__fc_stderr);
      else display_ratio(bytes_in - (bytes_out - header_bytes),bytes_in,
                         __fc_stderr);
    if (! test) 
      if (! to_stdout) fprintf(__fc_stderr," -- replaced with %s",ofname); /* fprintf_va_25 */
    fprintf(__fc_stderr,"\n"); /* fprintf_va_26 */
  }
  if (! to_stdout) copy_stat(& istat);
  return_label: return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_27(FILE * restrict stream, char const * restrict format,
                  char *param0);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_28(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1);

static int create_outfile(void)
{
  int __retres;
  struct stat ostat;
  int flags_0 = ((1 | 0x40) | 0x80) | 0;
  if (ascii) 
    if (decompress) flags_0 &= ~ 0;
  while (1) {
    int tmp;
    int tmp_0;
    int tmp_1;
    tmp = check_ofname();
    if (tmp != 0) {
      close(ifd);
      __retres = 1;
      goto return_label;
    }
    remove_ofname = 1;
    ofd = open((char const *)(ofname),flags_0,(mode_t)(00400 | 00200)); /* __va_open_mode_t */
    if (ofd == -1) {
      perror((char const *)(ofname));
      close(ifd);
      exit_code = 1;
      __retres = 1;
      goto return_label;
    }
    tmp_0 = fstat(ofd,& ostat);
    if (tmp_0 != 0) {
      fprintf(__fc_stderr,"%s: ",progname); /* fprintf_va_27 */
      perror((char const *)(ofname));
      close(ifd);
      close(ofd);
      unlink((char const *)(ofname));
      exit_code = 1;
      __retres = 1;
      goto return_label;
    }
    tmp_1 = name_too_long(ofname,& ostat);
    if (! tmp_1) {
      __retres = 0;
      goto return_label;
    }
    if (decompress) {
      if (! quiet) fprintf(__fc_stderr,"%s: %s: warning, name truncated\n",
                           progname,ofname); /* fprintf_va_28 */
      if (exit_code == 0) exit_code = 2;
      __retres = 0;
      goto return_label;
    }
    close(ofd);
    unlink((char const *)(ofname));
    shorten_name(ofname);
  }
  return_label: return __retres;
}

static int do_stat(char *name, struct stat *sbuf) __attribute__((__FC_OLDSTYLEPROTO__));
static int do_stat(char *name, struct stat *sbuf)
{
  int __retres;
  int tmp_0;
  __fc_errno = 0;
  if (! to_stdout) 
    if (! force) {
      int tmp;
      tmp = lstat((char const *)name,sbuf);
      __retres = tmp;
      goto return_label;
    }
  tmp_0 = stat((char const *)name,sbuf);
  __retres = tmp_0;
  return_label: return __retres;
}

static char *get_suffix_known_suffixes[9] =
  {z_suffix,
   (char *)".gz",
   (char *)".z",
   (char *)".taz",
   (char *)".tgz",
   (char *)"-gz",
   (char *)"-z",
   (char *)"_z",
   (char *)0};
static char *get_suffix(char *name) __attribute__((__FC_OLDSTYLEPROTO__));
static char *get_suffix(char *name)
{
  char *__retres;
  int nlen;
  int slen;
  char suffix[30 + 3];
  int tmp;
  size_t tmp_0;
  size_t tmp_1;
  char **suf = get_suffix_known_suffixes;
  tmp = strcmp((char const *)(z_suffix),"z");
  if (tmp == 0) suf ++;
  tmp_0 = strlen((char const *)name);
  nlen = (int)tmp_0;
  if (nlen <= 30 + 2) strcpy(suffix,(char const *)name);
  else strcpy(suffix,(char const *)(((name + nlen) - 30) - 2));
  strlwr(suffix);
  tmp_1 = strlen((char const *)(suffix));
  slen = (int)tmp_1;
  while (1) {
    {
      size_t tmp_2;
      tmp_2 = strlen((char const *)*suf);
      int s = (int)tmp_2;
      if (slen > s) 
        if ((int)suffix[(slen - s) - 1] != '/') {
          int tmp_3;
          tmp_3 = strcmp((char const *)(& suffix[slen] - s),
                         (char const *)*suf);
          if (tmp_3 == 0) {
            __retres = (name + nlen) - s;
            goto return_label;
          }
        }
    }
    suf ++;
    ;
    if (! (*suf != (char *)0)) break;
  }
  __retres = (char *)0;
  return_label: return __retres;
}

static char *get_istat_suffixes[6] =
  {z_suffix,
   (char *)".gz",
   (char *)".z",
   (char *)"-z",
   (char *)".Z",
   (char *)0};
static int get_istat(char *iname, struct stat *sbuf) __attribute__((__FC_OLDSTYLEPROTO__));
static int get_istat(char *iname, struct stat *sbuf)
{
  int __retres;
  int ilen;
  char *s;
  int tmp;
  size_t tmp_0;
  int tmp_1;
  char **suf = get_istat_suffixes;
  strcpy(ifname,(char const *)iname);
  tmp = do_stat(ifname,sbuf);
  if (tmp == 0) {
    __retres = 0;
    goto return_label;
  }
  if (! decompress) goto _LOR;
  else 
    if (__fc_errno != 2) {
      _LOR:
      {
        perror((char const *)(ifname));
        exit_code = 1;
        __retres = 1;
        goto return_label;
      }
    }
  s = get_suffix(ifname);
  if (s != (char *)0) {
    perror((char const *)(ifname));
    exit_code = 1;
    __retres = 1;
    goto return_label;
  }
  tmp_0 = strlen((char const *)(ifname));
  ilen = (int)tmp_0;
  tmp_1 = strcmp((char const *)(z_suffix),".gz");
  if (tmp_1 == 0) suf ++;
  while (1) {
    {
      int tmp_2;
      s = *suf;
      strcat(ifname,(char const *)s);
      tmp_2 = do_stat(ifname,sbuf);
      if (tmp_2 == 0) {
        __retres = 0;
        goto return_label;
      }
      ifname[ilen] = (char)'\000';
    }
    suf ++;
    ;
    if (! (*suf != (char *)0)) break;
  }
  strcat(ifname,(char const *)(z_suffix));
  perror((char const *)(ifname));
  exit_code = 1;
  __retres = 1;
  return_label: return __retres;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_29(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(param2);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param2 + (0 ..))),
            (indirect: *(param1 + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param2 + (0 ..)),
            *(param1 + (0 ..)), *(param0 + (0 ..));
 */
int fprintf_va_30(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1, char *param2);

static int make_ofname(void)
{
  int __retres;
  char *suff;
  strcpy(ofname,(char const *)(ifname));
  suff = get_suffix(ofname);
  if (decompress) {
    int tmp;
    if (suff == (char *)0) {
      if (! recursive) 
        if (list) {
          __retres = 0;
          goto return_label;
        }
        else 
          if (test) {
            __retres = 0;
            goto return_label;
          }
      if (verbose) goto _LOR;
      else 
        if (! recursive) 
          if (! quiet) {
            _LOR:
            {
              if (! quiet) fprintf(__fc_stderr,
                                   "%s: %s: unknown suffix -- ignored\n",
                                   progname,ifname); /* fprintf_va_29 */
              if (exit_code == 0) exit_code = 2;
            }
          }
      __retres = 2;
      goto return_label;
    }
    strlwr(suff);
    tmp = strcmp((char const *)suff,".tgz");
    if (tmp == 0) goto _LOR_0;
    else {
      int tmp_0;
      tmp_0 = strcmp((char const *)suff,".taz");
      if (tmp_0 == 0) _LOR_0: strcpy(suff,".tar"); else *suff = (char)'\000';
    }
  }
  else 
    if (suff != (char *)0) {
      if (verbose) goto _LOR_1;
      else 
        if (! recursive) 
          if (! quiet) _LOR_1:
                       fprintf(__fc_stderr,
                               "%s: %s already has %s suffix -- unchanged\n",
                               progname,ifname,suff); /* fprintf_va_30 */
      if (exit_code == 0) exit_code = 2;
      __retres = 2;
      goto return_label;
    }
    else {
      save_orig_name = 0;
      strcat(ofname,(char const *)(z_suffix));
    }
  __retres = 0;
  return_label: return __retres;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param2),
            (indirect: *(param1 + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param2, *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_31(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1, int param2);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_32(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_33(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param2),
            (indirect: *(param1 + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param2, *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_34(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1, unsigned int param2);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param2),
            (indirect: *(param1 + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param2, *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_35(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1, unsigned int param2);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param2),
            (indirect: *(param1 + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param2, *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_36(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1, unsigned int param2);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_37(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_38(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1);

static int get_method(int in) __attribute__((__FC_OLDSTYLEPROTO__));
static int get_method(int in)
{
  int __retres;
  uch flags_0;
  char magic[2];
  ulg stamp;
  int tmp_61;
  if (force) {
    if (to_stdout) {
      int tmp_1;
      int tmp_4;
      if (inptr < insize) {
        unsigned int tmp;
        tmp = inptr;
        inptr ++;
        tmp_1 = (int)inbuf[tmp];
      }
      else tmp_1 = fill_inbuf(1);
      magic[0] = (char)tmp_1;
      if (inptr < insize) {
        unsigned int tmp_2;
        tmp_2 = inptr;
        inptr ++;
        tmp_4 = (int)inbuf[tmp_2];
      }
      else tmp_4 = fill_inbuf(1);
      magic[1] = (char)tmp_4;
    }
    else goto _LAND;
  }
  else {
    _LAND:
    {
      int tmp_7;
      int tmp_10;
      if (inptr < insize) {
        unsigned int tmp_5;
        tmp_5 = inptr;
        inptr ++;
        tmp_7 = (int)inbuf[tmp_5];
      }
      else tmp_7 = fill_inbuf(0);
      magic[0] = (char)tmp_7;
      if (inptr < insize) {
        unsigned int tmp_8;
        tmp_8 = inptr;
        inptr ++;
        tmp_10 = (int)inbuf[tmp_8];
      }
      else tmp_10 = fill_inbuf(0);
      magic[1] = (char)tmp_10;
    }
  }
  method = -1;
  part_nb ++;
  header_bytes = (long)0;
  last_member = 0;
  tmp_61 = memcmp((void const *)(magic),(void const *)"\037\213",(size_t)2);
  if (tmp_61 == 0) goto _LOR_0;
  else {
    int tmp_62;
    tmp_62 = memcmp((void const *)(magic),(void const *)"\037\236",(size_t)2);
    if (tmp_62 == 0) {
      _LOR_0:
      {
        int tmp_13;
        int tmp_16;
        int tmp_19;
        int tmp_22;
        int tmp_25;
        int tmp_28;
        if (inptr < insize) {
          unsigned int tmp_11;
          tmp_11 = inptr;
          inptr ++;
          tmp_13 = (int)inbuf[tmp_11];
        }
        else tmp_13 = fill_inbuf(0);
        method = tmp_13;
        if (method != 8) {
          fprintf(__fc_stderr,
                  "%s: %s: unknown method %d -- get newer version of gzip\n",
                  progname,ifname,method); /* fprintf_va_31 */
          exit_code = 1;
          __retres = -1;
          goto return_label;
        }
        work = & unzip;
        if (inptr < insize) {
          unsigned int tmp_14;
          tmp_14 = inptr;
          inptr ++;
          tmp_16 = (int)inbuf[tmp_14];
        }
        else tmp_16 = fill_inbuf(0);
        flags_0 = (uch)tmp_16;
        if (((int)flags_0 & 0x20) != 0) {
          fprintf(__fc_stderr,
                  "%s: %s is encrypted -- get newer version of gzip\n",
                  progname,ifname); /* fprintf_va_32 */
          exit_code = 1;
          __retres = -1;
          goto return_label;
        }
        if (((int)flags_0 & 0x02) != 0) {
          fprintf(__fc_stderr,
                  "%s: %s is a a multi-part gzip file -- get newer version of gzip\n",
                  progname,ifname); /* fprintf_va_33 */
          exit_code = 1;
          if (force <= 1) {
            __retres = -1;
            goto return_label;
          }
        }
        if (((int)flags_0 & 0xC0) != 0) {
          fprintf(__fc_stderr,
                  "%s: %s has flags 0x%x -- get newer version of gzip\n",
                  progname,ifname,(unsigned int)((int)flags_0)); /* fprintf_va_34 */
          exit_code = 1;
          if (force <= 1) {
            __retres = -1;
            goto return_label;
          }
        }
        if (inptr < insize) {
          unsigned int tmp_17;
          tmp_17 = inptr;
          inptr ++;
          tmp_19 = (int)inbuf[tmp_17];
        }
        else tmp_19 = fill_inbuf(0);
        stamp = (ulg)tmp_19;
        if (inptr < insize) {
          unsigned int tmp_20;
          tmp_20 = inptr;
          inptr ++;
          tmp_22 = (int)inbuf[tmp_20];
        }
        else tmp_22 = fill_inbuf(0);
        stamp |= (ulg)tmp_22 << 8;
        if (inptr < insize) {
          unsigned int tmp_23;
          tmp_23 = inptr;
          inptr ++;
          tmp_25 = (int)inbuf[tmp_23];
        }
        else tmp_25 = fill_inbuf(0);
        stamp |= (ulg)tmp_25 << 16;
        if (inptr < insize) {
          unsigned int tmp_26;
          tmp_26 = inptr;
          inptr ++;
          tmp_28 = (int)inbuf[tmp_26];
        }
        else tmp_28 = fill_inbuf(0);
        stamp |= (ulg)tmp_28 << 24;
        if (stamp != (ulg)0) 
          if (! no_time) time_stamp = (long)stamp;
        if (inptr < insize) {
          unsigned int tmp_29;
          tmp_29 = inptr;
          inptr ++;
          uch tmp_30 = inbuf[tmp_29];
        }
        else fill_inbuf(0);
        if (inptr < insize) {
          unsigned int tmp_30_0;
          tmp_30_0 = inptr;
          inptr ++;
          uch tmp_32 = inbuf[tmp_30_0];
        }
        else fill_inbuf(0);
        if (((int)flags_0 & 0x02) != 0) {
          int tmp_33;
          int tmp_36;
          if (inptr < insize) {
            unsigned int tmp_31;
            tmp_31 = inptr;
            inptr ++;
            tmp_33 = (int)inbuf[tmp_31];
          }
          else tmp_33 = fill_inbuf(0);
          unsigned int part = (unsigned int)tmp_33;
          if (inptr < insize) {
            unsigned int tmp_34;
            tmp_34 = inptr;
            inptr ++;
            tmp_36 = (int)inbuf[tmp_34];
          }
          else tmp_36 = fill_inbuf(0);
          part |= (unsigned int)tmp_36 << 8;
          if (verbose) fprintf(__fc_stderr,"%s: %s: part number %u\n",
                               progname,ifname,part); /* fprintf_va_35 */
        }
        if (((int)flags_0 & 0x04) != 0) {
          int tmp_39;
          int tmp_42;
          if (inptr < insize) {
            unsigned int tmp_37;
            tmp_37 = inptr;
            inptr ++;
            tmp_39 = (int)inbuf[tmp_37];
          }
          else tmp_39 = fill_inbuf(0);
          unsigned int len = (unsigned int)tmp_39;
          if (inptr < insize) {
            unsigned int tmp_40;
            tmp_40 = inptr;
            inptr ++;
            tmp_42 = (int)inbuf[tmp_40];
          }
          else tmp_42 = fill_inbuf(0);
          len |= (unsigned int)tmp_42 << 8;
          if (verbose) fprintf(__fc_stderr,
                               "%s: %s: extra field of %u bytes ignored\n",
                               progname,ifname,len); /* fprintf_va_36 */
          while (1) {
            unsigned int tmp_44_0;
            tmp_44_0 = len;
            len --;
            ;
            if (! tmp_44_0) break;
            if (inptr < insize) {
              unsigned int tmp_43;
              tmp_43 = inptr;
              inptr ++;
              uch tmp_44 = inbuf[tmp_43];
            }
            else fill_inbuf(0);
          }
        }
        if (((int)flags_0 & 0x08) != 0) 
          if (no_name) goto _LOR;
          else 
            if (to_stdout) {
              if (! list) goto _LOR; else goto _LAND_0;
            }
            else {
              _LAND_0: ;
              if (part_nb > 1) {
                _LOR:
                {
                  char c;
                  while (1) {
                    if (inptr < insize) {
                      unsigned int tmp_45;
                      tmp_45 = inptr;
                      inptr ++;
                      c = (char)inbuf[tmp_45];
                    }
                    else {
                      int tmp_46;
                      tmp_46 = fill_inbuf(0);
                      c = (char)tmp_46;
                    }
                    if (! ((int)c != 0)) break;
                  }
                }
              }
              else {
                char *p = basename(ofname);
                char *base = p;
                while (1) {
                  int tmp_50;
                  char *tmp_51;
                  if (inptr < insize) {
                    unsigned int tmp_48;
                    tmp_48 = inptr;
                    inptr ++;
                    tmp_50 = (int)inbuf[tmp_48];
                  }
                  else tmp_50 = fill_inbuf(0);
                  *p = (char)tmp_50;
                  tmp_51 = p;
                  p ++;
                  ;
                  if ((int)*tmp_51 == '\000') break;
                  if (p >= & ofname[sizeof(ofname)]) error((char *)"corrupted input -- file name too large");
                }
                if (! list) 
                  if (base) list = 0;
              }
            }
        if (((int)flags_0 & 0x10) != 0) 
          while (1) {
            int tmp_54;
            if (inptr < insize) {
              unsigned int tmp_52;
              tmp_52 = inptr;
              inptr ++;
              tmp_54 = (int)inbuf[tmp_52];
            }
            else tmp_54 = fill_inbuf(0);
            if (! (tmp_54 != 0)) break;
          }
        if (part_nb == 1) header_bytes = (long)(inptr + (unsigned int)2 * sizeof(long));
      }
    }
    else {
      int tmp_59;
      tmp_59 = memcmp((void const *)(magic),(void const *)"PK\003\004",
                      (size_t)2);
      if (tmp_59 == 0) {
        if (inptr == (unsigned int)2) {
          int tmp_60;
          tmp_60 = memcmp((void const *)(inbuf),(void const *)"PK\003\004",
                          (size_t)4);
          if (tmp_60 == 0) {
            int tmp_55;
            inptr = (unsigned int)0;
            work = & unzip;
            tmp_55 = check_zipfile(in);
            if (tmp_55 != 0) {
              __retres = -1;
              goto return_label;
            }
            last_member = 1;
          }
          else goto _LAND_2;
        }
        else goto _LAND_2;
      }
      else {
        int tmp_58;
        _LAND_2:
        tmp_58 = memcmp((void const *)(magic),(void const *)"\037\036",
                        (size_t)2);
        if (tmp_58 == 0) {
          work = & unpack;
          method = 2;
        }
        else {
          int tmp_57;
          tmp_57 = memcmp((void const *)(magic),(void const *)"\037\235",
                          (size_t)2);
          if (tmp_57 == 0) {
            work = & unlzw;
            method = 1;
            last_member = 1;
          }
          else {
            int tmp_56;
            tmp_56 = memcmp((void const *)(magic),(void const *)"\037\240",
                            (size_t)2);
            if (tmp_56 == 0) {
              work = & unlzh;
              method = 3;
              last_member = 1;
            }
            else 
              if (force) 
                if (to_stdout) 
                  if (! list) {
                    method = 0;
                    work = & copy;
                    inptr = (unsigned int)0;
                    last_member = 1;
                  }
          }
        }
      }
    }
  }
  if (method >= 0) {
    __retres = method;
    goto return_label;
  }
  if (part_nb == 1) {
    fprintf(__fc_stderr,"\n%s: %s: not in gzip format\n",progname,ifname); /* fprintf_va_37 */
    exit_code = 1;
    __retres = -1;
    goto return_label;
  }
  else {
    if (! quiet) fprintf(__fc_stderr,
                         "\n%s: %s: decompression OK, trailing garbage ignored\n",
                         progname,ifname); /* fprintf_va_38 */
    if (exit_code == 0) exit_code = 2;
    __retres = -2;
    goto return_label;
  }
  return_label: return __retres;
}

static int do_list_first_time = 1;
static char *do_list_methods[9] =
  {(char *)"store",
   (char *)"compr",
   (char *)"pack ",
   (char *)"lzh  ",
   (char *)"",
   (char *)"",
   (char *)"",
   (char *)"",
   (char *)"defla"};
/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_1(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_2(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, param0;
 */
int printf_va_3(char const * restrict format, unsigned long param0,
                unsigned long param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, param0;
 */
int printf_va_4(char const * restrict format, long param0, long param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_5(char const * restrict format);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param2);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param2 + (0 ..))),
            (indirect: param1), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param2 + (0 ..)), param1, *(param0 + (0 ..));
 */
int printf_va_6(char const * restrict format, char *param0,
                unsigned long param1, char *param2);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, param0;
 */
int printf_va_7(char const * restrict format, long param0, long param1);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_8(char const * restrict format, char *param0);

static void do_list(int ifd_0, int method_0) __attribute__((__FC_OLDSTYLEPROTO__));
static void do_list(int ifd_0, int method_0)
{
  ulg crc_0;
  char *date;
  char *tmp_1;
  if (do_list_first_time) {
    if (method_0 >= 0) {
      do_list_first_time = 0;
      if (verbose) printf("method  crc     date  time  "); /* printf_va_1 */
      if (! quiet) printf("compressed  uncompr. ratio uncompressed_name\n"); /* printf_va_2 */
    }
    else goto _LAND;
  }
  else {
    _LAND: ;
    if (method_0 < 0) {
      if (total_in <= (long)0) goto return_label;
      else 
        if (total_out <= (long)0) goto return_label;
      if (verbose) printf("                            %9lu %9lu ",
                          (unsigned long)total_in,(unsigned long)total_out); /* printf_va_3 */
      else 
        if (! quiet) printf("%9ld %9ld ",total_in,total_out); /* printf_va_4 */
      display_ratio(total_out - (total_in - header_bytes),total_out,
                    __fc_stdout);
      printf(" (totals)\n"); /* printf_va_5 */
      goto return_label;
    }
  }
  crc_0 = (ulg)(~ 0);
  bytes_out = -1L;
  bytes_in = ifile_size;
  if (method_0 == 8) 
    if (! last_member) {
      bytes_in = lseek(ifd_0,(off_t)(-8),2);
      if (bytes_in != -1L) {
        uch buf[8];
        ssize_t tmp_0;
        bytes_in += 8L;
        tmp_0 = read(ifd_0,(void *)(buf),sizeof(buf));
        if ((unsigned int)tmp_0 != sizeof(buf)) read_error();
        crc_0 = (ulg)((int)((ush)buf[0]) | ((int)((ush)buf[1]) << 8)) | (
                (ulg)((int)((ush)*(& buf[2] + 0)) | ((int)((ush)*(& buf[2] + 1)) << 8)) << 16);
        bytes_out = (long)((ulg)((int)((ush)*(& buf[4] + 0)) | ((int)((ush)*(
                                                                & buf[4] + 1)) << 8)) | (
                           (ulg)((int)((ush)*((& buf[4] + 2) + 0)) | (
                                 (int)((ush)*((& buf[4] + 2) + 1)) << 8)) << 16));
      }
    }
  tmp_1 = ctime((time_t const *)(& time_stamp));
  date = tmp_1 + 4;
  *(date + 12) = (char)'\000';
  if (verbose) printf("%5s %08lx %11s ",do_list_methods[method_0],crc_0,date); /* printf_va_6 */
  printf("%9ld %9ld ",bytes_in,bytes_out); /* printf_va_7 */
  if (bytes_in == -1L) {
    total_in = -1L;
    header_bytes = (long)0;
    bytes_out = header_bytes;
    bytes_in = bytes_out;
  }
  else 
    if (total_in >= (long)0) total_in += bytes_in;
  if (bytes_out == -1L) {
    total_out = -1L;
    header_bytes = (long)0;
    bytes_out = header_bytes;
    bytes_in = bytes_out;
  }
  else 
    if (total_out >= (long)0) total_out += bytes_out;
  display_ratio(bytes_out - (bytes_in - header_bytes),bytes_out,__fc_stdout);
  printf(" %s\n",ofname); /* printf_va_8 */
  return_label: return;
}

static int same_file(struct stat *stat1, struct stat *stat2) __attribute__((
__FC_OLDSTYLEPROTO__));
static int same_file(struct stat *stat1, struct stat *stat2)
{
  int tmp;
  if (stat1->st_ino == stat2->st_ino) 
    if (stat1->st_dev == stat2->st_dev) tmp = 1; else tmp = 0;
  else tmp = 0;
  return tmp;
}

static int name_too_long(char *name, struct stat *statb) __attribute__((
__FC_OLDSTYLEPROTO__));
static int name_too_long(char *name, struct stat *statb)
{
  size_t tmp;
  struct stat tstat;
  int res;
  int tmp_2;
  int tmp_0;
  tmp = strlen((char const *)name);
  int s = (int)tmp;
  char c = *(name + (s - 1));
  tstat = *statb;
  *(name + (s - 1)) = (char)'\000';
  tmp_0 = stat((char const *)name,& tstat);
  if (tmp_0 == 0) {
    int tmp_1;
    tmp_1 = same_file(statb,& tstat);
    if (tmp_1) tmp_2 = 1; else tmp_2 = 0;
  }
  else tmp_2 = 0;
  res = tmp_2;
  *(name + (s - 1)) = c;
  return res;
}

static void shorten_name(char *name) __attribute__((__FC_OLDSTYLEPROTO__));
static void shorten_name(char *name)
{
  int len;
  int plen;
  char *p;
  size_t tmp;
  char *trunc = (char *)0;
  int min_part = 3;
  tmp = strlen((char const *)name);
  len = (int)tmp;
  if (decompress) {
    if (len <= 1) error((char *)"name too short");
    *(name + (len - 1)) = (char)'\000';
    goto return_label;
  }
  p = get_suffix(name);
  if (p == (char *)0) error((char *)"can\'t recover suffix\n");
  *p = (char)'\000';
  save_orig_name = 1;
  if (len > 4) {
    int tmp_0;
    tmp_0 = strcmp((char const *)(p - 4),".tar");
    if (tmp_0 == 0) {
      strcpy(p - 4,".tgz");
      goto return_label;
    }
  }
  while (1) {
    p = strrchr((char const *)name,'/');
    if (p) p ++; else p = name;
    while (*p) {
      size_t tmp_1;
      tmp_1 = strcspn((char const *)p,".");
      plen = (int)tmp_1;
      p += plen;
      if (plen > min_part) trunc = p - 1;
      if (*p) p ++;
    }
    if (trunc == (char *)0) {
      min_part --;
      if (! (min_part != 0)) break;
    }
    else break;
  }
  if (trunc != (char *)0) {
    while (1) {
      char *tmp_2;
      *(trunc + 0) = *(trunc + 1);
      tmp_2 = trunc;
      trunc ++;
      ;
      if (! *tmp_2) break;
    }
    trunc --;
  }
  else {
    trunc = strrchr((char const *)name,(int)*("." + 0));
    if (trunc == (char *)0) error((char *)"internal error in shorten_name");
    if ((int)*(trunc + 1) == '\000') trunc --;
  }
  strcpy(trunc,(char const *)(z_suffix));
  return_label: return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(param2);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param2 + (0 ..))),
            (indirect: *(param1 + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param2 + (0 ..)),
            *(param1 + (0 ..)), *(param0 + (0 ..));
 */
int fprintf_va_39(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1, char *param2);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(param2);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param2 + (0 ..))),
            (indirect: *(param1 + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param2 + (0 ..)),
            *(param1 + (0 ..)), *(param0 + (0 ..));
 */
int fprintf_va_40(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1, char *param2);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_41(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_42(FILE * restrict stream, char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_43(FILE * restrict stream, char const * restrict format);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_44(FILE * restrict stream, char const * restrict format,
                  char *param0);

static int check_ofname(void)
{
  int __retres;
  struct stat ostat;
  int tmp_4;
  int tmp_9;
  __fc_errno = 0;
  while (1) {
    int tmp;
    tmp = stat((char const *)(ofname),& ostat);
    if (! (tmp != 0)) break;
    if (__fc_errno != 36) {
      __retres = 0;
      goto return_label;
    }
    shorten_name(ofname);
  }
  if (! decompress) {
    int tmp_1;
    tmp_1 = name_too_long(ofname,& ostat);
    if (tmp_1) {
      int tmp_0;
      shorten_name(ofname);
      tmp_0 = stat((char const *)(ofname),& ostat);
      if (tmp_0 != 0) {
        __retres = 0;
        goto return_label;
      }
    }
  }
  tmp_4 = same_file(& istat,& ostat);
  if (tmp_4) {
    int tmp_3;
    tmp_3 = strcmp((char const *)(ifname),(char const *)(ofname));
    if (tmp_3 == 0) {
      char const *tmp_2;
      if (decompress) tmp_2 = "de"; else tmp_2 = "";
      ;
      ;
      fprintf(__fc_stderr,"%s: %s: cannot %scompress onto itself\n",progname,
              ifname,(char *)tmp_2); /* fprintf_va_39 */
    }
    else fprintf(__fc_stderr,"%s: %s and %s are the same file\n",progname,
                 ifname,ofname); /* fprintf_va_40 */
    exit_code = 1;
    __retres = 1;
    goto return_label;
  }
  if (! force) {
    char response[80];
    int tmp_8;
    int tmp_7;
    strcpy(response,"n");
    fprintf(__fc_stderr,"%s: %s already exists;",progname,ofname); /* fprintf_va_41 */
    if (foreground) {
      int tmp_6;
      int tmp_5;
      tmp_5 = fileno(__fc_stdin);
      tmp_6 = isatty(tmp_5);
      if (tmp_6) {
        fprintf(__fc_stderr," do you wish to overwrite (y or n)? "); /* fprintf_va_42 */
        fflush(__fc_stderr);
        fgets(response,(int)(sizeof(response) - (unsigned int)1),__fc_stdin);
      }
    }
    tmp_7 = isupper((int)response[0]);
    if (tmp_7) tmp_8 = ((int)response[0] - 'A') + 'a';
    else tmp_8 = (int)response[0];
    if (tmp_8 != 'y') {
      fprintf(__fc_stderr,"\tnot overwritten\n"); /* fprintf_va_43 */
      if (exit_code == 0) exit_code = 2;
      __retres = 1;
      goto return_label;
    }
  }
  chmod((char const *)(ofname),(mode_t)0777);
  tmp_9 = unlink((char const *)(ofname));
  if (tmp_9) {
    fprintf(__fc_stderr,"%s: ",progname); /* fprintf_va_44 */
    perror((char const *)(ofname));
    exit_code = 1;
    __retres = 1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_45(FILE * restrict stream, char const * restrict format,
                  char *param0);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_46(FILE * restrict stream, char const * restrict format,
                  char *param0);

static void copy_stat(struct stat *ifstat) __attribute__((__FC_OLDSTYLEPROTO__));
static void copy_stat(struct stat *ifstat)
{
  int tmp;
  int tmp_0;
  tmp = chmod((char const *)(ofname),ifstat->st_mode & (unsigned int)07777);
  if (tmp) {
    if (! quiet) fprintf(__fc_stderr,"%s: ",progname); /* fprintf_va_45 */
    if (exit_code == 0) exit_code = 2;
    if (! quiet) perror((char const *)(ofname));
  }
  chown((char const *)(ofname),ifstat->st_uid,ifstat->st_gid);
  remove_ofname = 0;
  chmod((char const *)(ifname),(mode_t)0777);
  tmp_0 = unlink((char const *)(ifname));
  if (tmp_0) {
    if (! quiet) fprintf(__fc_stderr,"%s: ",progname); /* fprintf_va_46 */
    if (exit_code == 0) exit_code = 2;
    if (! quiet) perror((char const *)(ifname));
  }
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_47(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(param2);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param2 + (0 ..))),
            (indirect: *(param1 + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param2 + (0 ..)),
            *(param1 + (0 ..)), *(param0 + (0 ..));
 */
int fprintf_va_48(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1, char *param2);

static void treat_dir(char *dir) __attribute__((__FC_OLDSTYLEPROTO__));
static void treat_dir(char *dir)
{
  dir_type *dp;
  DIR *dirp;
  char nbuf[1024];
  int len;
  dirp = opendir((char const *)dir);
  if (dirp == (DIR *)0) {
    fprintf(__fc_stderr,"%s: %s unreadable\n",progname,dir); /* fprintf_va_47 */
    exit_code = 1;
    goto return_label;
  }
  while (1) {
    dp = readdir(dirp);
    if (! (dp != (dir_type *)0)) break;
    {
      int tmp;
      size_t tmp_1;
      size_t tmp_3;
      tmp = strcmp((char const *)(dp->d_name),".");
      if (tmp == 0) goto _LOR;
      else {
        int tmp_0;
        tmp_0 = strcmp((char const *)(dp->d_name),"..");
        if (tmp_0 == 0) _LOR: continue;
      }
      tmp_1 = strlen((char const *)dir);
      len = (int)tmp_1;
      tmp_3 = strlen((char const *)(dp->d_name));
      ;
      if ((len + (int)tmp_3) + 1 < 1024 - 1) {
        strcpy(nbuf,(char const *)dir);
        if (len != 0) {
          int tmp_2;
          tmp_2 = len;
          len ++;
          nbuf[tmp_2] = (char)'/';
        }
        strcpy(& nbuf[len],(char const *)(dp->d_name));
        treat_file(nbuf);
      }
      else {
        fprintf(__fc_stderr,"%s: %s/%s: pathname too long\n",progname,dir,
                dp->d_name); /* fprintf_va_48 */
        exit_code = 1;
      }
    }
  }
  closedir(dirp);
  return_label: return;
}

static int do_exit_in_exit = 0;
static void do_exit(int exitcode) __attribute__((__FC_OLDSTYLEPROTO__));
static void do_exit(int exitcode)
{
  if (do_exit_in_exit) exit(exitcode);
  do_exit_in_exit = 1;
  if (env != (char *)0) {
    free((void *)env);
    env = (char *)0;
  }
  if (args != (char **)0) {
    free((void *)args);
    args = (char **)0;
  }
  exit(exitcode);
  return;
}

void abort_gzip(void)
{
  if (remove_ofname) {
    close(ofd);
    unlink((char const *)(ofname));
  }
  do_exit(1);
  return;
}

long header_bytes;
static ulg crc;
int zip(int in, int out) __attribute__((__FC_OLDSTYLEPROTO__));
int zip(int in, int out)
{
  int __retres;
  uch flags_0 = (uch)0;
  ush attr = (ush)0;
  ush deflate_flags = (ush)0;
  ifd = in;
  ofd = out;
  outcnt = (unsigned int)0;
  method = 8;
  {
    unsigned int tmp;
    tmp = outcnt;
    outcnt ++;
    outbuf[tmp] = (uch)*("\037\213" + 0);
    if (outcnt == (unsigned int)16384) flush_outbuf();
  }
  {
    unsigned int tmp_0;
    tmp_0 = outcnt;
    outcnt ++;
    outbuf[tmp_0] = (uch)*("\037\213" + 1);
    if (outcnt == (unsigned int)16384) flush_outbuf();
  }
  {
    unsigned int tmp_1;
    tmp_1 = outcnt;
    outcnt ++;
    outbuf[tmp_1] = (uch)8;
    if (outcnt == (unsigned int)16384) flush_outbuf();
  }
  if (save_orig_name) flags_0 = (uch)((int)flags_0 | 0x08);
  {
    unsigned int tmp_2;
    tmp_2 = outcnt;
    outcnt ++;
    outbuf[tmp_2] = flags_0;
    if (outcnt == (unsigned int)16384) flush_outbuf();
  }
  if (outcnt < (unsigned int)(16384 - 2)) {
    unsigned int tmp_3;
    unsigned int tmp_4;
    tmp_3 = outcnt;
    outcnt ++;
    outbuf[tmp_3] = (uch)((time_stamp & (long)0xffff) & (long)0xff);
    tmp_4 = outcnt;
    outcnt ++;
    outbuf[tmp_4] = (uch)((int)((ush)(time_stamp & (long)0xffff)) >> 8);
  }
  else {
    {
      unsigned int tmp_5;
      tmp_5 = outcnt;
      outcnt ++;
      outbuf[tmp_5] = (uch)((time_stamp & (long)0xffff) & (long)0xff);
      if (outcnt == (unsigned int)16384) flush_outbuf();
    }
    {
      unsigned int tmp_6;
      tmp_6 = outcnt;
      outcnt ++;
      outbuf[tmp_6] = (uch)((int)((ush)(time_stamp & (long)0xffff)) >> 8);
      if (outcnt == (unsigned int)16384) flush_outbuf();
    }
  }
  if (outcnt < (unsigned int)(16384 - 2)) {
    unsigned int tmp_7;
    unsigned int tmp_8;
    tmp_7 = outcnt;
    outcnt ++;
    outbuf[tmp_7] = (uch)(((ulg)time_stamp >> 16) & (unsigned long)0xff);
    tmp_8 = outcnt;
    outcnt ++;
    outbuf[tmp_8] = (uch)((int)((ush)((ulg)time_stamp >> 16)) >> 8);
  }
  else {
    {
      unsigned int tmp_9;
      tmp_9 = outcnt;
      outcnt ++;
      outbuf[tmp_9] = (uch)(((ulg)time_stamp >> 16) & (unsigned long)0xff);
      if (outcnt == (unsigned int)16384) flush_outbuf();
    }
    {
      unsigned int tmp_10;
      tmp_10 = outcnt;
      outcnt ++;
      outbuf[tmp_10] = (uch)((int)((ush)((ulg)time_stamp >> 16)) >> 8);
      if (outcnt == (unsigned int)16384) flush_outbuf();
    }
  }
  crc = updcrc((uch *)0,(unsigned int)0);
  bi_init(out);
  ct_init(& attr,& method);
  lm_init(level,& deflate_flags);
  {
    unsigned int tmp_11;
    tmp_11 = outcnt;
    outcnt ++;
    outbuf[tmp_11] = (uch)deflate_flags;
    if (outcnt == (unsigned int)16384) flush_outbuf();
  }
  {
    unsigned int tmp_12;
    tmp_12 = outcnt;
    outcnt ++;
    outbuf[tmp_12] = (uch)0x03;
    if (outcnt == (unsigned int)16384) flush_outbuf();
  }
  if (save_orig_name) {
    char *p = basename(ifname);
    while (1) {
      char *tmp_15;
      {
        unsigned int tmp_14;
        tmp_14 = outcnt;
        outcnt ++;
        outbuf[tmp_14] = (uch)*p;
        if (outcnt == (unsigned int)16384) flush_outbuf();
      }
      tmp_15 = p;
      p ++;
      ;
      if (! *tmp_15) break;
    }
  }
  header_bytes = (long)outcnt;
  deflate();
  if (outcnt < (unsigned int)(16384 - 2)) {
    unsigned int tmp_16;
    unsigned int tmp_17;
    tmp_16 = outcnt;
    outcnt ++;
    outbuf[tmp_16] = (uch)((crc & (unsigned long)0xffff) & (unsigned long)0xff);
    tmp_17 = outcnt;
    outcnt ++;
    outbuf[tmp_17] = (uch)((int)((ush)(crc & (unsigned long)0xffff)) >> 8);
  }
  else {
    {
      unsigned int tmp_18;
      tmp_18 = outcnt;
      outcnt ++;
      outbuf[tmp_18] = (uch)((crc & (unsigned long)0xffff) & (unsigned long)0xff);
      if (outcnt == (unsigned int)16384) flush_outbuf();
    }
    {
      unsigned int tmp_19;
      tmp_19 = outcnt;
      outcnt ++;
      outbuf[tmp_19] = (uch)((int)((ush)(crc & (unsigned long)0xffff)) >> 8);
      if (outcnt == (unsigned int)16384) flush_outbuf();
    }
  }
  if (outcnt < (unsigned int)(16384 - 2)) {
    unsigned int tmp_20;
    unsigned int tmp_21;
    tmp_20 = outcnt;
    outcnt ++;
    outbuf[tmp_20] = (uch)((crc >> 16) & (unsigned long)0xff);
    tmp_21 = outcnt;
    outcnt ++;
    outbuf[tmp_21] = (uch)((int)((ush)(crc >> 16)) >> 8);
  }
  else {
    {
      unsigned int tmp_22;
      tmp_22 = outcnt;
      outcnt ++;
      outbuf[tmp_22] = (uch)((crc >> 16) & (unsigned long)0xff);
      if (outcnt == (unsigned int)16384) flush_outbuf();
    }
    {
      unsigned int tmp_23;
      tmp_23 = outcnt;
      outcnt ++;
      outbuf[tmp_23] = (uch)((int)((ush)(crc >> 16)) >> 8);
      if (outcnt == (unsigned int)16384) flush_outbuf();
    }
  }
  if (outcnt < (unsigned int)(16384 - 2)) {
    unsigned int tmp_24;
    unsigned int tmp_25;
    tmp_24 = outcnt;
    outcnt ++;
    outbuf[tmp_24] = (uch)((bytes_in & (long)0xffff) & (long)0xff);
    tmp_25 = outcnt;
    outcnt ++;
    outbuf[tmp_25] = (uch)((int)((ush)(bytes_in & (long)0xffff)) >> 8);
  }
  else {
    {
      unsigned int tmp_26;
      tmp_26 = outcnt;
      outcnt ++;
      outbuf[tmp_26] = (uch)((bytes_in & (long)0xffff) & (long)0xff);
      if (outcnt == (unsigned int)16384) flush_outbuf();
    }
    {
      unsigned int tmp_27;
      tmp_27 = outcnt;
      outcnt ++;
      outbuf[tmp_27] = (uch)((int)((ush)(bytes_in & (long)0xffff)) >> 8);
      if (outcnt == (unsigned int)16384) flush_outbuf();
    }
  }
  if (outcnt < (unsigned int)(16384 - 2)) {
    unsigned int tmp_28;
    unsigned int tmp_29;
    tmp_28 = outcnt;
    outcnt ++;
    outbuf[tmp_28] = (uch)(((ulg)bytes_in >> 16) & (unsigned long)0xff);
    tmp_29 = outcnt;
    outcnt ++;
    outbuf[tmp_29] = (uch)((int)((ush)((ulg)bytes_in >> 16)) >> 8);
  }
  else {
    {
      unsigned int tmp_30;
      tmp_30 = outcnt;
      outcnt ++;
      outbuf[tmp_30] = (uch)(((ulg)bytes_in >> 16) & (unsigned long)0xff);
      if (outcnt == (unsigned int)16384) flush_outbuf();
    }
    {
      unsigned int tmp_31;
      tmp_31 = outcnt;
      outcnt ++;
      outbuf[tmp_31] = (uch)((int)((ush)((ulg)bytes_in >> 16)) >> 8);
      if (outcnt == (unsigned int)16384) flush_outbuf();
    }
  }
  header_bytes = (long)((unsigned long)header_bytes + (unsigned long)(
                        (unsigned int)2 * sizeof(long)));
  flush_outbuf();
  __retres = 0;
  return __retres;
}

int file_read(char *buf, unsigned int size) __attribute__((__FC_OLDSTYLEPROTO__));
int file_read(char *buf, unsigned int size)
{
  int __retres;
  unsigned int len;
  ssize_t tmp;
  tmp = read(ifd,(void *)buf,size);
  len = (unsigned int)tmp;
  if (len == (unsigned int)(-1)) {
    __retres = (int)len;
    goto return_label;
  }
  else 
    if (len == (unsigned int)0) {
      __retres = (int)len;
      goto return_label;
    }
  crc = updcrc((uch *)buf,len);
  bytes_in = (long)((ulg)bytes_in + (ulg)len);
  __retres = (int)len;
  return_label: return __retres;
}

ulg window_size = (ulg)2 * (ulg)0x8000;
long block_start;
static unsigned int ins_h;
unsigned int prev_length;
unsigned int strstart;
unsigned int match_start;
static int eofile;
static unsigned int lookahead;
unsigned int max_chain_length;
static unsigned int max_lazy_match;
static int compr_level;
unsigned int good_match;
int nice_match;
static config configuration_table[10] =
  {{.good_length = (ush)0,
    .max_lazy = (ush)0,
    .nice_length = (ush)0,
    .max_chain = (ush)0},
   {.good_length = (ush)4,
    .max_lazy = (ush)4,
    .nice_length = (ush)8,
    .max_chain = (ush)4},
   {.good_length = (ush)4,
    .max_lazy = (ush)5,
    .nice_length = (ush)16,
    .max_chain = (ush)8},
   {.good_length = (ush)4,
    .max_lazy = (ush)6,
    .nice_length = (ush)32,
    .max_chain = (ush)32},
   {.good_length = (ush)4,
    .max_lazy = (ush)4,
    .nice_length = (ush)16,
    .max_chain = (ush)16},
   {.good_length = (ush)8,
    .max_lazy = (ush)16,
    .nice_length = (ush)32,
    .max_chain = (ush)32},
   {.good_length = (ush)8,
    .max_lazy = (ush)16,
    .nice_length = (ush)128,
    .max_chain = (ush)128},
   {.good_length = (ush)8,
    .max_lazy = (ush)32,
    .nice_length = (ush)128,
    .max_chain = (ush)256},
   {.good_length = (ush)32,
    .max_lazy = (ush)128,
    .nice_length = (ush)258,
    .max_chain = (ush)1024},
   {.good_length = (ush)32,
    .max_lazy = (ush)258,
    .nice_length = (ush)258,
    .max_chain = (ush)4096}};
static void fill_window(void);

static ulg deflate_fast(void);

int longest_match(IPos cur_match) __attribute__((__FC_OLDSTYLEPROTO__));

void lm_init(int pack_level, ush *flags_0) __attribute__((__FC_OLDSTYLEPROTO__));
void lm_init(int pack_level, ush *flags_0)
{
  register unsigned int j_0;
  int tmp_0;
  unsigned int tmp;
  if (pack_level < 1) error((char *)"bad pack level");
  else 
    if (pack_level > 9) error((char *)"bad pack level");
  compr_level = pack_level;
  memset((voidp)(& prev[0x8000]),0,
         (unsigned int)(1 << 15) * sizeof(prev[0x8000]));
  max_lazy_match = (unsigned int)configuration_table[pack_level].max_lazy;
  good_match = (unsigned int)configuration_table[pack_level].good_length;
  nice_match = (int)configuration_table[pack_level].nice_length;
  max_chain_length = (unsigned int)configuration_table[pack_level].max_chain;
  if (pack_level == 1) *flags_0 = (ush)((int)*flags_0 | 4);
  else 
    if (pack_level == 9) *flags_0 = (ush)((int)*flags_0 | 2);
  strstart = (unsigned int)0;
  block_start = 0L;
  if (sizeof(int) <= (unsigned int)2) tmp = (unsigned int)0x8000;
  else tmp = (unsigned int)(2 * 0x8000);
  tmp_0 = (*read_buf)((char *)(window),tmp);
  lookahead = (unsigned int)tmp_0;
  if (lookahead == (unsigned int)0) goto _LOR;
  else 
    if (lookahead == (unsigned int)(-1)) {
      _LOR: {
              eofile = 1;
              lookahead = (unsigned int)0;
              goto return_label;
            }
    }
  eofile = 0;
  while (1) {
    if (lookahead < (unsigned int)((258 + 3) + 1)) {
      if (! (! eofile)) break;
    }
    else break;
    fill_window();
  }
  ins_h = (unsigned int)0;
  j_0 = (unsigned int)0;
  while (j_0 < (unsigned int)(3 - 1)) {
    ins_h = ((ins_h << ((15 + 3) - 1) / 3) ^ (unsigned int)window[j_0]) & (
            (unsigned int)(1 << 15) - (unsigned int)1);
    j_0 ++;
  }
  return_label: return;
}

int longest_match(IPos cur_match) __attribute__((__FC_OLDSTYLEPROTO__));
int longest_match(IPos cur_match)
{
  register uch *match;
  register int len;
  unsigned int tmp;
  unsigned int chain_length = max_chain_length;
  register uch *scan = & window[strstart];
  int best_len = (int)prev_length;
  if (strstart > (IPos)(0x8000 - ((258 + 3) + 1))) tmp = strstart - (IPos)(
                                                         0x8000 - ((258 + 3) + 1));
  else tmp = (unsigned int)0;
  IPos limit = tmp;
  register uch *strend = & window[strstart] + 258;
  register uch scan_end1 = *(scan + (best_len - 1));
  register uch scan_end = *(scan + best_len);
  if (prev_length >= good_match) chain_length >>= 2;
  while (1) {
    match = & window[cur_match];
    if ((int)*(match + best_len) != (int)scan_end) goto __Cont;
    else 
      if ((int)*(match + (best_len - 1)) != (int)scan_end1) goto __Cont;
      else 
        if ((int)*match != (int)*scan) goto __Cont;
        else {
          match ++;
          ;
          if ((int)*match != (int)*(scan + 1)) goto __Cont;
        }
    scan += 2;
    match ++;
    while (1) {
      scan ++;
      match ++;
      ;
      if ((int)*scan == (int)*match) {
        scan ++;
        match ++;
        ;
        if ((int)*scan == (int)*match) {
          scan ++;
          match ++;
          ;
          if ((int)*scan == (int)*match) {
            scan ++;
            match ++;
            ;
            if ((int)*scan == (int)*match) {
              scan ++;
              match ++;
              ;
              if ((int)*scan == (int)*match) {
                scan ++;
                match ++;
                ;
                if ((int)*scan == (int)*match) {
                  scan ++;
                  match ++;
                  ;
                  if ((int)*scan == (int)*match) {
                    scan ++;
                    match ++;
                    ;
                    if ((int)*scan == (int)*match) {
                      if (! (scan < strend)) break;
                    }
                    else break;
                  }
                  else break;
                }
                else break;
              }
              else break;
            }
            else break;
          }
          else break;
        }
        else break;
      }
      else break;
    }
    len = 258 - (strend - scan);
    scan = strend - 258;
    if (len > best_len) {
      match_start = cur_match;
      best_len = len;
      if (len >= nice_match) break;
      scan_end1 = *(scan + (best_len - 1));
      scan_end = *(scan + best_len);
    }
    __Cont:
    { /* sequence */
      cur_match = (IPos)prev[cur_match & (unsigned int)(0x8000 - 1)];
      ;
    }
    if (cur_match > limit) {
      chain_length --;
      if (! (chain_length != (unsigned int)0)) break;
    }
    else break;
  }
  return best_len;
}

static void fill_window(void)
{
  register unsigned int n;
  register unsigned int m;
  unsigned int more =
    (unsigned int)((window_size - (ulg)lookahead) - (ulg)strstart);
  if (more == (unsigned int)(-1)) more --;
  else 
    if (strstart >= (unsigned int)(0x8000 + (0x8000 - ((258 + 3) + 1)))) {
      memcpy((void *)(window),(void const *)((char *)(window) + 0x8000),
             (unsigned int)0x8000);
      match_start -= (unsigned int)0x8000;
      strstart -= (unsigned int)0x8000;
      block_start -= (long)0x8000;
      n = (unsigned int)0;
      while (n < (unsigned int)(1 << 15)) {
        {
          unsigned int tmp;
          m = (unsigned int)*(& prev[0x8000] + n);
          if (m >= (unsigned int)0x8000) tmp = m - (unsigned int)0x8000;
          else tmp = (unsigned int)0;
          *(& prev[0x8000] + n) = (Pos)tmp;
        }
        n ++;
      }
      n = (unsigned int)0;
      while (n < (unsigned int)0x8000) {
        {
          unsigned int tmp_0;
          m = (unsigned int)prev[n];
          if (m >= (unsigned int)0x8000) tmp_0 = m - (unsigned int)0x8000;
          else tmp_0 = (unsigned int)0;
          prev[n] = (Pos)tmp_0;
        }
        n ++;
      }
      more += (unsigned int)0x8000;
    }
  if (! eofile) {
    int tmp_1;
    tmp_1 = (*read_buf)(((char *)(window) + strstart) + lookahead,more);
    n = (unsigned int)tmp_1;
    if (n == (unsigned int)0) goto _LOR;
    else 
      if (n == (unsigned int)(-1)) _LOR: eofile = 1; else lookahead += n;
  }
  return;
}

static ulg deflate_fast(void)
{
  IPos hash_head;
  int flush;
  ulg tmp_2;
  char *tmp_1;
  unsigned int match_length = (unsigned int)0;
  prev_length = (unsigned int)(3 - 1);
  while (lookahead != (unsigned int)0) {
    ins_h = ((ins_h << ((15 + 3) - 1) / 3) ^ (unsigned int)window[(strstart + (unsigned int)3) - (unsigned int)1]) & (
            (unsigned int)(1 << 15) - (unsigned int)1);
    hash_head = (IPos)*(& prev[0x8000] + ins_h);
    prev[strstart & (unsigned int)(0x8000 - 1)] = (ush)hash_head;
    *(& prev[0x8000] + ins_h) = (ush)strstart;
    if (hash_head != (IPos)0) 
      if (strstart - hash_head <= (unsigned int)(0x8000 - ((258 + 3) + 1))) {
        int tmp;
        tmp = longest_match(hash_head);
        match_length = (unsigned int)tmp;
        if (match_length > lookahead) match_length = lookahead;
      }
    if (match_length >= (unsigned int)3) {
      flush = ct_tally((int)(strstart - match_start),
                       (int)(match_length - (unsigned int)3));
      lookahead -= match_length;
      if (match_length <= max_lazy_match) {
        match_length --;
        while (1) {
          strstart ++;
          ins_h = ((ins_h << ((15 + 3) - 1) / 3) ^ (unsigned int)window[
                   (strstart + (unsigned int)3) - (unsigned int)1]) & (
                  (unsigned int)(1 << 15) - (unsigned int)1);
          hash_head = (IPos)*(& prev[0x8000] + ins_h);
          prev[strstart & (unsigned int)(0x8000 - 1)] = (ush)hash_head;
          *(& prev[0x8000] + ins_h) = (ush)strstart;
          match_length --;
          if (! (match_length != (unsigned int)0)) break;
        }
        strstart ++;
      }
      else {
        strstart += match_length;
        match_length = (unsigned int)0;
        ins_h = (unsigned int)window[strstart];
        ins_h = ((ins_h << ((15 + 3) - 1) / 3) ^ (unsigned int)window[
                 strstart + (unsigned int)1]) & ((unsigned int)(1 << 15) - (unsigned int)1);
      }
    }
    else {
      flush = ct_tally(0,(int)window[strstart]);
      lookahead --;
      strstart ++;
    }
    if (flush) {
      char *tmp_0;
      ;
      if (block_start >= 0L) tmp_0 = (char *)(& window[(unsigned int)block_start]);
      else tmp_0 = (char *)0;
      flush_block(tmp_0,(ulg)((long)strstart - block_start),0);
      block_start = (long)strstart;
    }
    while (1) {
      if (lookahead < (unsigned int)((258 + 3) + 1)) {
        if (! (! eofile)) break;
      }
      else break;
      fill_window();
    }
  }
  ;
  if (block_start >= 0L) tmp_1 = (char *)(& window[(unsigned int)block_start]);
  else tmp_1 = (char *)0;
  tmp_2 = flush_block(tmp_1,(ulg)((long)strstart - block_start),1);
  return tmp_2;
}

ulg deflate(void)
{
  ulg __retres;
  IPos hash_head;
  IPos prev_match;
  int flush;
  ulg tmp_5;
  char *tmp_4;
  int match_available = 0;
  register unsigned int match_length = (unsigned int)(3 - 1);
  if (compr_level <= 3) {
    ulg tmp;
    tmp = deflate_fast();
    __retres = tmp;
    goto return_label;
  }
  while (lookahead != (unsigned int)0) {
    ins_h = ((ins_h << ((15 + 3) - 1) / 3) ^ (unsigned int)window[(strstart + (unsigned int)3) - (unsigned int)1]) & (
            (unsigned int)(1 << 15) - (unsigned int)1);
    hash_head = (IPos)*(& prev[0x8000] + ins_h);
    prev[strstart & (unsigned int)(0x8000 - 1)] = (ush)hash_head;
    *(& prev[0x8000] + ins_h) = (ush)strstart;
    prev_length = match_length;
    prev_match = match_start;
    match_length = (unsigned int)(3 - 1);
    if (hash_head != (IPos)0) 
      if (prev_length < max_lazy_match) 
        if (strstart - hash_head <= (unsigned int)(0x8000 - ((258 + 3) + 1))) {
          int tmp_0;
          tmp_0 = longest_match(hash_head);
          match_length = (unsigned int)tmp_0;
          if (match_length > lookahead) match_length = lookahead;
          if (match_length == (unsigned int)3) 
            if (strstart - match_start > (unsigned int)4096) match_length --;
        }
    if (prev_length >= (unsigned int)3) {
      if (match_length <= prev_length) {
        flush = ct_tally((int)((strstart - (unsigned int)1) - prev_match),
                         (int)(prev_length - (unsigned int)3));
        lookahead -= prev_length - (unsigned int)1;
        prev_length -= (unsigned int)2;
        while (1) {
          strstart ++;
          ins_h = ((ins_h << ((15 + 3) - 1) / 3) ^ (unsigned int)window[
                   (strstart + (unsigned int)3) - (unsigned int)1]) & (
                  (unsigned int)(1 << 15) - (unsigned int)1);
          hash_head = (IPos)*(& prev[0x8000] + ins_h);
          prev[strstart & (unsigned int)(0x8000 - 1)] = (ush)hash_head;
          *(& prev[0x8000] + ins_h) = (ush)strstart;
          prev_length --;
          if (! (prev_length != (unsigned int)0)) break;
        }
        match_available = 0;
        match_length = (unsigned int)(3 - 1);
        strstart ++;
        if (flush) {
          char *tmp_1;
          ;
          if (block_start >= 0L) tmp_1 = (char *)(& window[(unsigned int)block_start]);
          else tmp_1 = (char *)0;
          flush_block(tmp_1,(ulg)((long)strstart - block_start),0);
          block_start = (long)strstart;
        }
      }
      else goto _LAND;
    }
    else {
      _LAND: ;
      if (match_available) {
        int tmp_3;
        tmp_3 = ct_tally(0,(int)window[strstart - (unsigned int)1]);
        if (tmp_3) {
          char *tmp_2;
          ;
          if (block_start >= 0L) tmp_2 = (char *)(& window[(unsigned int)block_start]);
          else tmp_2 = (char *)0;
          flush_block(tmp_2,(ulg)((long)strstart - block_start),0);
          block_start = (long)strstart;
        }
        strstart ++;
        lookahead --;
      }
      else {
        match_available = 1;
        strstart ++;
        lookahead --;
      }
    }
    while (1) {
      if (lookahead < (unsigned int)((258 + 3) + 1)) {
        if (! (! eofile)) break;
      }
      else break;
      fill_window();
    }
  }
  if (match_available) ct_tally(0,(int)window[strstart - (unsigned int)1]);
  ;
  if (block_start >= 0L) tmp_4 = (char *)(& window[(unsigned int)block_start]);
  else tmp_4 = (char *)0;
  tmp_5 = flush_block(tmp_4,(ulg)((long)strstart - block_start),1);
  __retres = tmp_5;
  return_label: return __retres;
}

static int extra_lbits[29] =
  {0,
   0,
   0,
   0,
   0,
   0,
   0,
   0,
   1,
   1,
   1,
   1,
   2,
   2,
   2,
   2,
   3,
   3,
   3,
   3,
   4,
   4,
   4,
   4,
   5,
   5,
   5,
   5,
   0};
static int extra_dbits[30] =
  {0,
   0,
   0,
   0,
   1,
   1,
   2,
   2,
   3,
   3,
   4,
   4,
   5,
   5,
   6,
   6,
   7,
   7,
   8,
   8,
   9,
   9,
   10,
   10,
   11,
   11,
   12,
   12,
   13,
   13};
static int extra_blbits[19] =
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7};
static ct_data dyn_ltree[2 * ((256 + 1) + 29) + 1];
static ct_data dyn_dtree[2 * 30 + 1];
static ct_data static_ltree[((256 + 1) + 29) + 2];
static ct_data static_dtree[30];
static ct_data bl_tree[2 * 19 + 1];
static tree_desc l_desc =
  {.dyn_tree = dyn_ltree,
   .static_tree = static_ltree,
   .extra_bits = extra_lbits,
   .extra_base = 256 + 1,
   .elems = (256 + 1) + 29,
   .max_length = 15,
   .max_code = 0};
static tree_desc d_desc =
  {.dyn_tree = dyn_dtree,
   .static_tree = static_dtree,
   .extra_bits = extra_dbits,
   .extra_base = 0,
   .elems = 30,
   .max_length = 15,
   .max_code = 0};
static tree_desc bl_desc =
  {.dyn_tree = bl_tree,
   .static_tree = (ct_data *)0,
   .extra_bits = extra_blbits,
   .extra_base = 0,
   .elems = 19,
   .max_length = 7,
   .max_code = 0};
static ush bl_count[15 + 1];
static uch bl_order[19] =
  {(uch)16,
   (uch)17,
   (uch)18,
   (uch)0,
   (uch)8,
   (uch)7,
   (uch)9,
   (uch)6,
   (uch)10,
   (uch)5,
   (uch)11,
   (uch)4,
   (uch)12,
   (uch)3,
   (uch)13,
   (uch)2,
   (uch)14,
   (uch)1,
   (uch)15};
static int heap[2 * ((256 + 1) + 29) + 1];
static int heap_len;
static int heap_max;
static uch depth[2 * ((256 + 1) + 29) + 1];
static uch length_code[(258 - 3) + 1];
static uch dist_code[512];
static int base_length[29];
static int base_dist[30];
static uch flag_buf[0x8000 / 8];
static unsigned int last_lit;
static unsigned int last_dist;
static unsigned int last_flags;
static uch flags;
static uch flag_bit;
static ulg opt_len;
static ulg static_len;
static ulg compressed_len;
static ulg input_len;
ush *file_type;
int *file_method;
static void init_block(void);

static void pqdownheap(ct_data *tree, int k) __attribute__((__FC_OLDSTYLEPROTO__));

static void gen_bitlen(tree_desc *desc) __attribute__((__FC_OLDSTYLEPROTO__));

static void gen_codes(ct_data *tree, int max_code) __attribute__((__FC_OLDSTYLEPROTO__));

static void build_tree(tree_desc *desc) __attribute__((__FC_OLDSTYLEPROTO__));

static void scan_tree(ct_data *tree, int max_code) __attribute__((__FC_OLDSTYLEPROTO__));

static void send_tree(ct_data *tree, int max_code) __attribute__((__FC_OLDSTYLEPROTO__));

static int build_bl_tree(void);

static void send_all_trees(int lcodes, int dcodes, int blcodes) __attribute__((
__FC_OLDSTYLEPROTO__));

static void compress_block(ct_data *ltree, ct_data *dtree) __attribute__((
__FC_OLDSTYLEPROTO__));

static void set_file_type(void);

void ct_init(ush *attr, int *methodp) __attribute__((__FC_OLDSTYLEPROTO__));
void ct_init(ush *attr, int *methodp)
{
  int n;
  int bits;
  int length;
  int code;
  int dist;
  file_type = attr;
  file_method = methodp;
  input_len = (ulg)0L;
  compressed_len = input_len;
  if ((int)static_dtree[0].dl.len != 0) goto return_label;
  length = 0;
  code = 0;
  while (code < 29 - 1) {
    base_length[code] = length;
    n = 0;
    while (n < 1 << extra_lbits[code]) {
      {
        int tmp;
        tmp = length;
        length ++;
        length_code[tmp] = (uch)code;
      }
      n ++;
    }
    code ++;
  }
  length_code[length - 1] = (uch)code;
  dist = 0;
  code = 0;
  while (code < 16) {
    base_dist[code] = dist;
    n = 0;
    while (n < 1 << extra_dbits[code]) {
      {
        int tmp_0;
        tmp_0 = dist;
        dist ++;
        dist_code[tmp_0] = (uch)code;
      }
      n ++;
    }
    code ++;
  }
  dist >>= 7;
  while (code < 30) {
    base_dist[code] = dist << 7;
    n = 0;
    while (n < 1 << (extra_dbits[code] - 7)) {
      {
        int tmp_1;
        tmp_1 = dist;
        dist ++;
        dist_code[256 + tmp_1] = (uch)code;
      }
      n ++;
    }
    code ++;
  }
  bits = 0;
  while (bits <= 15) {
    bl_count[bits] = (ush)0;
    bits ++;
  }
  n = 0;
  while (n <= 143) {
    int tmp_2;
    tmp_2 = n;
    n ++;
    static_ltree[tmp_2].dl.len = (ush)8;
    bl_count[8] = (ush)((int)bl_count[8] + 1);
  }
  while (n <= 255) {
    int tmp_3;
    tmp_3 = n;
    n ++;
    static_ltree[tmp_3].dl.len = (ush)9;
    bl_count[9] = (ush)((int)bl_count[9] + 1);
  }
  while (n <= 279) {
    int tmp_4;
    tmp_4 = n;
    n ++;
    static_ltree[tmp_4].dl.len = (ush)7;
    bl_count[7] = (ush)((int)bl_count[7] + 1);
  }
  while (n <= 287) {
    int tmp_5;
    tmp_5 = n;
    n ++;
    static_ltree[tmp_5].dl.len = (ush)8;
    bl_count[8] = (ush)((int)bl_count[8] + 1);
  }
  gen_codes(static_ltree,((256 + 1) + 29) + 1);
  n = 0;
  while (n < 30) {
    {
      unsigned int tmp_6;
      static_dtree[n].dl.len = (ush)5;
      tmp_6 = bi_reverse((unsigned int)n,5);
      static_dtree[n].fc.code = (ush)tmp_6;
    }
    n ++;
  }
  init_block();
  return_label: return;
}

static void init_block(void)
{
  int n;
  n = 0;
  while (n < (256 + 1) + 29) {
    dyn_ltree[n].fc.freq = (ush)0;
    n ++;
  }
  n = 0;
  while (n < 30) {
    dyn_dtree[n].fc.freq = (ush)0;
    n ++;
  }
  n = 0;
  while (n < 19) {
    bl_tree[n].fc.freq = (ush)0;
    n ++;
  }
  dyn_ltree[256].fc.freq = (ush)1;
  static_len = (ulg)0L;
  opt_len = static_len;
  last_flags = (unsigned int)0;
  last_dist = last_flags;
  last_lit = last_dist;
  flags = (uch)0;
  flag_bit = (uch)1;
  return;
}

static void pqdownheap(ct_data *tree, int k) __attribute__((__FC_OLDSTYLEPROTO__));
static void pqdownheap(ct_data *tree, int k)
{
  int v = heap[k];
  int j_0 = k << 1;
  while (j_0 <= heap_len) {
    if (j_0 < heap_len) 
      if ((int)(tree + heap[j_0 + 1])->fc.freq < (int)(tree + heap[j_0])->fc.freq) 
        j_0 ++;
      else 
        if ((int)(tree + heap[j_0 + 1])->fc.freq == (int)(tree + heap[j_0])->fc.freq) 
          if ((int)depth[heap[j_0 + 1]] <= (int)depth[heap[j_0]]) j_0 ++;
    if ((int)(tree + v)->fc.freq < (int)(tree + heap[j_0])->fc.freq) 
      break;
    else 
      if ((int)(tree + v)->fc.freq == (int)(tree + heap[j_0])->fc.freq) 
        if ((int)depth[v] <= (int)depth[heap[j_0]]) break;
    heap[k] = heap[j_0];
    k = j_0;
    j_0 <<= 1;
  }
  heap[k] = v;
  return;
}

static void gen_bitlen(tree_desc *desc) __attribute__((__FC_OLDSTYLEPROTO__));
static void gen_bitlen(tree_desc *desc)
{
  int h;
  int n;
  int m;
  int bits;
  int xbits;
  ush f;
  ct_data *tree = desc->dyn_tree;
  int *extra = desc->extra_bits;
  int base = desc->extra_base;
  int max_code = desc->max_code;
  int max_length = desc->max_length;
  ct_data *stree = desc->static_tree;
  int overflow = 0;
  bits = 0;
  while (bits <= 15) {
    bl_count[bits] = (ush)0;
    bits ++;
  }
  (tree + heap[heap_max])->dl.len = (ush)0;
  h = heap_max + 1;
  while (h < 2 * ((256 + 1) + 29) + 1) {
    n = heap[h];
    bits = (int)(tree + (tree + n)->dl.dad)->dl.len + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow ++;
    }
    (tree + n)->dl.len = (ush)bits;
    if (n > max_code) goto __Cont;
    bl_count[bits] = (ush)((int)bl_count[bits] + 1);
    xbits = 0;
    if (n >= base) xbits = *(extra + (n - base));
    f = (tree + n)->fc.freq;
    opt_len += (ulg)f * (ulg)(bits + xbits);
    if (stree) static_len += (ulg)f * (ulg)((int)(stree + n)->dl.len + xbits);
    __Cont: h ++;
  }
  if (overflow == 0) goto return_label;
  while (1) {
    bits = max_length - 1;
    while ((int)bl_count[bits] == 0) bits --;
    bl_count[bits] = (ush)((int)bl_count[bits] - 1);
    bl_count[bits + 1] = (ush)((int)bl_count[bits + 1] + 2);
    bl_count[max_length] = (ush)((int)bl_count[max_length] - 1);
    overflow -= 2;
    if (! (overflow > 0)) break;
  }
  bits = max_length;
  while (bits != 0) {
    n = (int)bl_count[bits];
    while (n != 0) {
      h --;
      m = heap[h];
      if (m > max_code) continue;
      if ((unsigned int)(tree + m)->dl.len != (unsigned int)bits) {
        opt_len += (ulg)(((long)bits - (long)(tree + m)->dl.len) * (long)(
                         tree + m)->fc.freq);
        (tree + m)->dl.len = (ush)bits;
      }
      n --;
    }
    bits --;
  }
  return_label: return;
}

static void gen_codes(ct_data *tree, int max_code) __attribute__((__FC_OLDSTYLEPROTO__));
static void gen_codes(ct_data *tree, int max_code)
{
  ush next_code[15 + 1];
  int bits;
  int n;
  ush code = (ush)0;
  bits = 1;
  while (bits <= 15) {
    code = (ush)(((int)code + (int)bl_count[bits - 1]) << 1);
    next_code[bits] = code;
    bits ++;
  }
  n = 0;
  while (n <= max_code) {
    {
      unsigned int tmp_0;
      ush tmp;
      int len = (int)(tree + n)->dl.len;
      if (len == 0) goto __Cont;
      ;
      tmp = next_code[len];
      next_code[len] = (ush)((int)next_code[len] + 1);
      ;
      tmp_0 = bi_reverse((unsigned int)tmp,len);
      (tree + n)->fc.code = (ush)tmp_0;
    }
    __Cont: n ++;
  }
  return;
}

static void build_tree(tree_desc *desc) __attribute__((__FC_OLDSTYLEPROTO__));
static void build_tree(tree_desc *desc)
{
  int n;
  int m;
  ct_data *tree = desc->dyn_tree;
  ct_data *stree = desc->static_tree;
  int elems = desc->elems;
  int max_code = -1;
  int node = elems;
  heap_len = 0;
  heap_max = 2 * ((256 + 1) + 29) + 1;
  n = 0;
  while (n < elems) {
    if ((int)(tree + n)->fc.freq != 0) {
      heap_len ++;
      max_code = n;
      heap[heap_len] = max_code;
      depth[n] = (uch)0;
    }
    else (tree + n)->dl.len = (ush)0;
    n ++;
  }
  while (heap_len < 2) {
    int tmp;
    heap_len ++;
    if (max_code < 2) {
      max_code ++;
      tmp = max_code;
    }
    else tmp = 0;
    heap[heap_len] = tmp;
    int new = tmp;
    (tree + new)->fc.freq = (ush)1;
    depth[new] = (uch)0;
    opt_len --;
    if (stree) static_len -= (ulg)(stree + new)->dl.len;
  }
  desc->max_code = max_code;
  n = heap_len / 2;
  while (n >= 1) {
    pqdownheap(tree,n);
    n --;
  }
  while (1) {
    {
      int tmp_1;
      ush tmp_2;
      int tmp_3;
      {
        int tmp_0;
        n = heap[1];
        tmp_0 = heap_len;
        heap_len --;
        heap[1] = heap[tmp_0];
        pqdownheap(tree,1);
      }
      m = heap[1];
      heap_max --;
      heap[heap_max] = n;
      heap_max --;
      heap[heap_max] = m;
      (tree + node)->fc.freq = (ush)((int)(tree + n)->fc.freq + (int)(
                                     tree + m)->fc.freq);
      if ((int)depth[n] >= (int)depth[m]) tmp_1 = (int)depth[n];
      else tmp_1 = (int)depth[m];
      depth[node] = (uch)(tmp_1 + 1);
      tmp_2 = (ush)node;
      (tree + m)->dl.dad = tmp_2;
      (tree + n)->dl.dad = tmp_2;
      tmp_3 = node;
      node ++;
      heap[1] = tmp_3;
      pqdownheap(tree,1);
    }
    if (! (heap_len >= 2)) break;
  }
  heap_max --;
  heap[heap_max] = heap[1];
  gen_bitlen(desc);
  gen_codes(tree,max_code);
  return;
}

static void scan_tree(ct_data *tree, int max_code) __attribute__((__FC_OLDSTYLEPROTO__));
static void scan_tree(ct_data *tree, int max_code)
{
  int n;
  int curlen;
  int prevlen = -1;
  int nextlen = (int)(tree + 0)->dl.len;
  int count = 0;
  int max_count = 7;
  int min_count = 4;
  if (nextlen == 0) {
    max_count = 138;
    min_count = 3;
  }
  (tree + (max_code + 1))->dl.len = (ush)0xffff;
  n = 0;
  while (n <= max_code) {
    curlen = nextlen;
    nextlen = (int)(tree + (n + 1))->dl.len;
    count ++;
    ;
    if (count < max_count) {
      if (curlen == nextlen) goto __Cont; else goto _LAND;
    }
    else {
      _LAND: ;
      if (count < min_count) bl_tree[curlen].fc.freq = (ush)((int)bl_tree[curlen].fc.freq + count);
      else 
        if (curlen != 0) {
          if (curlen != prevlen) bl_tree[curlen].fc.freq = (ush)((int)bl_tree[curlen].fc.freq + 1);
          bl_tree[16].fc.freq = (ush)((int)bl_tree[16].fc.freq + 1);
        }
        else 
          if (count <= 10) bl_tree[17].fc.freq = (ush)((int)bl_tree[17].fc.freq + 1);
          else bl_tree[18].fc.freq = (ush)((int)bl_tree[18].fc.freq + 1);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen == 0) {
      max_count = 138;
      min_count = 3;
    }
    else 
      if (curlen == nextlen) {
        max_count = 6;
        min_count = 3;
      }
      else {
        max_count = 7;
        min_count = 4;
      }
    __Cont: n ++;
  }
  return;
}

static void send_tree(ct_data *tree, int max_code) __attribute__((__FC_OLDSTYLEPROTO__));
static void send_tree(ct_data *tree, int max_code)
{
  int n;
  int curlen;
  int prevlen = -1;
  int nextlen = (int)(tree + 0)->dl.len;
  int count = 0;
  int max_count = 7;
  int min_count = 4;
  if (nextlen == 0) {
    max_count = 138;
    min_count = 3;
  }
  n = 0;
  while (n <= max_code) {
    curlen = nextlen;
    nextlen = (int)(tree + (n + 1))->dl.len;
    count ++;
    ;
    if (count < max_count) {
      if (curlen == nextlen) goto __Cont; else goto _LAND;
    }
    else {
      _LAND: ;
      if (count < min_count) 
        while (1) {
          send_bits((int)bl_tree[curlen].fc.code,(int)bl_tree[curlen].dl.len);
          count --;
          if (! (count != 0)) break;
        }
      else 
        if (curlen != 0) {
          if (curlen != prevlen) {
            send_bits((int)bl_tree[curlen].fc.code,
                      (int)bl_tree[curlen].dl.len);
            count --;
          }
          send_bits((int)bl_tree[16].fc.code,(int)bl_tree[16].dl.len);
          send_bits(count - 3,2);
        }
        else 
          if (count <= 10) {
            send_bits((int)bl_tree[17].fc.code,(int)bl_tree[17].dl.len);
            send_bits(count - 3,3);
          }
          else {
            send_bits((int)bl_tree[18].fc.code,(int)bl_tree[18].dl.len);
            send_bits(count - 11,7);
          }
    }
    count = 0;
    prevlen = curlen;
    if (nextlen == 0) {
      max_count = 138;
      min_count = 3;
    }
    else 
      if (curlen == nextlen) {
        max_count = 6;
        min_count = 3;
      }
      else {
        max_count = 7;
        min_count = 4;
      }
    __Cont: n ++;
  }
  return;
}

static int build_bl_tree(void)
{
  int max_blindex;
  scan_tree(dyn_ltree,l_desc.max_code);
  scan_tree(dyn_dtree,d_desc.max_code);
  build_tree(& bl_desc);
  max_blindex = 19 - 1;
  while (max_blindex >= 3) {
    if ((int)bl_tree[bl_order[max_blindex]].dl.len != 0) break;
    max_blindex --;
  }
  opt_len += (ulg)(((3 * (max_blindex + 1) + 5) + 5) + 4);
  return max_blindex;
}

static void send_all_trees(int lcodes, int dcodes, int blcodes) __attribute__((
__FC_OLDSTYLEPROTO__));
static void send_all_trees(int lcodes, int dcodes, int blcodes)
{
  int rank;
  send_bits(lcodes - 257,5);
  send_bits(dcodes - 1,5);
  send_bits(blcodes - 4,4);
  rank = 0;
  while (rank < blcodes) {
    send_bits((int)bl_tree[bl_order[rank]].dl.len,3);
    rank ++;
  }
  send_tree(dyn_ltree,lcodes - 1);
  send_tree(dyn_dtree,dcodes - 1);
  return;
}

ulg flush_block(char *buf, ulg stored_len, int eof) __attribute__((__FC_OLDSTYLEPROTO__));
ulg flush_block(char *buf, ulg stored_len, int eof)
{
  ulg __retres;
  ulg opt_lenb;
  ulg static_lenb;
  int max_blindex;
  flag_buf[last_flags] = flags;
  if ((int)*file_type == (int)((ush)0xffff)) set_file_type();
  build_tree(& l_desc);
  build_tree(& d_desc);
  max_blindex = build_bl_tree();
  opt_lenb = ((opt_len + (ulg)3) + (ulg)7) >> 3;
  static_lenb = ((static_len + (ulg)3) + (ulg)7) >> 3;
  input_len += stored_len;
  if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
  if (stored_len <= opt_lenb) {
    if (eof) {
      if (compressed_len == (ulg)0L) goto _LAND_2; else goto _LAND_2;
    }
    else goto _LAND_2;
  }
  else {
    _LAND_2: ;
    if (stored_len + (ulg)4 <= opt_lenb) {
      if (buf != (char *)0) {
        send_bits((0 << 1) + eof,3);
        compressed_len = ((compressed_len + (ulg)3) + (ulg)7) & (unsigned long)(~ 7L);
        compressed_len += (stored_len + (ulg)4) << 3;
        copy_block(buf,(unsigned int)stored_len,1);
      }
      else goto _LAND;
    }
    else {
      _LAND: ;
      if (static_lenb == opt_lenb) {
        send_bits((1 << 1) + eof,3);
        compress_block(static_ltree,static_dtree);
        compressed_len += (ulg)3 + static_len;
      }
      else {
        send_bits((2 << 1) + eof,3);
        send_all_trees(l_desc.max_code + 1,d_desc.max_code + 1,
                       max_blindex + 1);
        compress_block(dyn_ltree,dyn_dtree);
        compressed_len += (ulg)3 + opt_len;
      }
    }
  }
  init_block();
  if (eof) {
    bi_windup();
    compressed_len += (ulg)7;
  }
  __retres = compressed_len >> 3;
  return __retres;
}

int ct_tally(int dist, int lc) __attribute__((__FC_OLDSTYLEPROTO__));
int ct_tally(int dist, int lc)
{
  int __retres;
  unsigned int tmp;
  int tmp_3;
  tmp = last_lit;
  last_lit ++;
  inbuf[tmp] = (uch)lc;
  if (dist == 0) dyn_ltree[lc].fc.freq = (ush)((int)dyn_ltree[lc].fc.freq + 1);
  else {
    int tmp_0;
    unsigned int tmp_1;
    dist --;
    dyn_ltree[((int)length_code[lc] + 256) + 1].fc.freq = (ush)((int)dyn_ltree[
                                                                ((int)length_code[lc] + 256) + 1].fc.freq + 1);
    if (dist < 256) tmp_0 = (int)dist_code[dist];
    else tmp_0 = (int)dist_code[256 + (dist >> 7)];
    dyn_dtree[tmp_0].fc.freq = (ush)((int)dyn_dtree[tmp_0].fc.freq + 1);
    tmp_1 = last_dist;
    last_dist ++;
    d_buf[tmp_1] = (ush)dist;
    flags = (uch)((int)flags | (int)flag_bit);
  }
  flag_bit = (uch)((int)flag_bit << 1);
  if ((last_lit & (unsigned int)7) == (unsigned int)0) {
    unsigned int tmp_2;
    tmp_2 = last_flags;
    last_flags ++;
    flag_buf[tmp_2] = flags;
    flags = (uch)0;
    flag_bit = (uch)1;
  }
  if (level > 2) 
    if ((last_lit & (unsigned int)0xfff) == (unsigned int)0) {
      int dcode;
      ulg out_length = (ulg)last_lit * (ulg)8L;
      ulg in_length = (ulg)strstart - (ulg)block_start;
      dcode = 0;
      while (dcode < 30) {
        out_length += (ulg)dyn_dtree[dcode].fc.freq * (ulg)(5L + (long)extra_dbits[dcode]);
        dcode ++;
      }
      out_length >>= 3;
      if (last_dist < last_lit / (unsigned int)2) 
        if (out_length < in_length / (ulg)2) {
          __retres = 1;
          goto return_label;
        }
    }
  if (last_lit == (unsigned int)(0x8000 - 1)) tmp_3 = 1;
  else 
    if (last_dist == (unsigned int)0x8000) tmp_3 = 1; else tmp_3 = 0;
  __retres = tmp_3;
  return_label: return __retres;
}

static void compress_block(ct_data *ltree, ct_data *dtree) __attribute__((
__FC_OLDSTYLEPROTO__));
static void compress_block(ct_data *ltree, ct_data *dtree)
{
  unsigned int dist;
  int lc;
  unsigned int code;
  int extra;
  unsigned int lx = (unsigned int)0;
  unsigned int dx = (unsigned int)0;
  unsigned int fx = (unsigned int)0;
  uch flag = (uch)0;
  if (last_lit != (unsigned int)0) 
    while (1) {
      {
        unsigned int tmp_0;
        if ((lx & (unsigned int)7) == (unsigned int)0) {
          unsigned int tmp;
          tmp = fx;
          fx ++;
          flag = flag_buf[tmp];
        }
        tmp_0 = lx;
        lx ++;
        lc = (int)inbuf[tmp_0];
        if (((int)flag & 1) == 0) send_bits((int)(ltree + lc)->fc.code,
                                            (int)(ltree + lc)->dl.len);
        else {
          unsigned int tmp_1;
          code = (unsigned int)length_code[lc];
          send_bits((int)(ltree + ((code + (unsigned int)256) + (unsigned int)1))->fc.code,
                    (int)(ltree + ((code + (unsigned int)256) + (unsigned int)1))->dl.len);
          extra = extra_lbits[code];
          if (extra != 0) {
            lc -= base_length[code];
            send_bits(lc,extra);
          }
          tmp_1 = dx;
          dx ++;
          dist = (unsigned int)d_buf[tmp_1];
          if (dist < (unsigned int)256) code = (unsigned int)dist_code[dist];
          else code = (unsigned int)dist_code[(unsigned int)256 + (dist >> 7)];
          send_bits((int)(dtree + code)->fc.code,(int)(dtree + code)->dl.len);
          extra = extra_dbits[code];
          if (extra != 0) {
            dist -= (unsigned int)base_dist[code];
            send_bits((int)dist,extra);
          }
        }
        flag = (uch)((int)flag >> 1);
      }
      if (! (lx < last_lit)) break;
    }
  send_bits((int)(ltree + 256)->fc.code,(int)(ltree + 256)->dl.len);
  return;
}

static void set_file_type(void)
{
  int n = 0;
  unsigned int ascii_freq = (unsigned int)0;
  unsigned int bin_freq = (unsigned int)0;
  while (n < 7) {
    int tmp;
    tmp = n;
    n ++;
    bin_freq += (unsigned int)dyn_ltree[tmp].fc.freq;
  }
  while (n < 128) {
    int tmp_0;
    tmp_0 = n;
    n ++;
    ascii_freq += (unsigned int)dyn_ltree[tmp_0].fc.freq;
  }
  while (n < 256) {
    int tmp_1;
    tmp_1 = n;
    n ++;
    bin_freq += (unsigned int)dyn_ltree[tmp_1].fc.freq;
  }
  if (bin_freq > ascii_freq >> 2) *file_type = (ush)0;
  else *file_type = (ush)1;
  if ((int)*file_type == 0) ;
  return;
}

int (*read_buf)(char *buf, unsigned int size);
static file_t zfile;
static unsigned short bi_buf;
static int bi_valid;
void bi_init(file_t zipfile) __attribute__((__FC_OLDSTYLEPROTO__));
void bi_init(file_t zipfile)
{
  zfile = zipfile;
  bi_buf = (unsigned short)0;
  bi_valid = 0;
  if (zfile != -1) read_buf = & file_read;
  return;
}

void send_bits(int value, int length) __attribute__((__FC_OLDSTYLEPROTO__));
void send_bits(int value, int length)
{
  if (bi_valid > (int)((unsigned int)(8 * 2) * sizeof(char)) - length) {
    bi_buf = (unsigned short)((int)bi_buf | (value << bi_valid));
    if (outcnt < (unsigned int)(16384 - 2)) {
      unsigned int tmp;
      unsigned int tmp_0;
      tmp = outcnt;
      outcnt ++;
      outbuf[tmp] = (uch)((int)bi_buf & 0xff);
      tmp_0 = outcnt;
      outcnt ++;
      outbuf[tmp_0] = (uch)((int)bi_buf >> 8);
    }
    else {
      {
        unsigned int tmp_1;
        tmp_1 = outcnt;
        outcnt ++;
        outbuf[tmp_1] = (uch)((int)bi_buf & 0xff);
        if (outcnt == (unsigned int)16384) flush_outbuf();
      }
      {
        unsigned int tmp_2;
        tmp_2 = outcnt;
        outcnt ++;
        outbuf[tmp_2] = (uch)((int)bi_buf >> 8);
        if (outcnt == (unsigned int)16384) flush_outbuf();
      }
    }
    bi_buf = (unsigned short)((int)((ush)value) >> ((unsigned int)(8 * 2) * sizeof(char) - (unsigned int)bi_valid));
    bi_valid = (int)((unsigned int)bi_valid + ((unsigned int)length - 
                                               (unsigned int)(8 * 2) * sizeof(char)));
  }
  else {
    bi_buf = (unsigned short)((int)bi_buf | (value << bi_valid));
    bi_valid += length;
  }
  return;
}

unsigned int bi_reverse(unsigned int code, int len) __attribute__((__FC_OLDSTYLEPROTO__));
unsigned int bi_reverse(unsigned int code, int len)
{
  unsigned int __retres;
  register unsigned int res = (unsigned int)0;
  while (1) {
    res |= code & (unsigned int)1;
    code >>= 1;
    res <<= 1;
    len --;
    if (! (len > 0)) break;
  }
  __retres = res >> 1;
  return __retres;
}

void bi_windup(void)
{
  if (bi_valid > 8) 
    if (outcnt < (unsigned int)(16384 - 2)) {
      unsigned int tmp;
      unsigned int tmp_0;
      tmp = outcnt;
      outcnt ++;
      outbuf[tmp] = (uch)((int)bi_buf & 0xff);
      tmp_0 = outcnt;
      outcnt ++;
      outbuf[tmp_0] = (uch)((int)bi_buf >> 8);
    }
    else {
      {
        unsigned int tmp_1;
        tmp_1 = outcnt;
        outcnt ++;
        outbuf[tmp_1] = (uch)((int)bi_buf & 0xff);
        if (outcnt == (unsigned int)16384) flush_outbuf();
      }
      {
        unsigned int tmp_2;
        tmp_2 = outcnt;
        outcnt ++;
        outbuf[tmp_2] = (uch)((int)bi_buf >> 8);
        if (outcnt == (unsigned int)16384) flush_outbuf();
      }
    }
  else 
    if (bi_valid > 0) {
      {
        unsigned int tmp_3;
        tmp_3 = outcnt;
        outcnt ++;
        outbuf[tmp_3] = (uch)bi_buf;
        if (outcnt == (unsigned int)16384) flush_outbuf();
      }
    }
  bi_buf = (unsigned short)0;
  bi_valid = 0;
  return;
}

void copy_block(char *buf, unsigned int len, int header) __attribute__((
__FC_OLDSTYLEPROTO__));
void copy_block(char *buf, unsigned int len, int header)
{
  bi_windup();
  if (header) {
    if (outcnt < (unsigned int)(16384 - 2)) {
      unsigned int tmp;
      unsigned int tmp_0;
      tmp = outcnt;
      outcnt ++;
      outbuf[tmp] = (uch)((int)((ush)len) & 0xff);
      tmp_0 = outcnt;
      outcnt ++;
      outbuf[tmp_0] = (uch)((int)((ush)len) >> 8);
    }
    else {
      {
        unsigned int tmp_1;
        tmp_1 = outcnt;
        outcnt ++;
        outbuf[tmp_1] = (uch)((int)((ush)len) & 0xff);
        if (outcnt == (unsigned int)16384) flush_outbuf();
      }
      {
        unsigned int tmp_2;
        tmp_2 = outcnt;
        outcnt ++;
        outbuf[tmp_2] = (uch)((int)((ush)len) >> 8);
        if (outcnt == (unsigned int)16384) flush_outbuf();
      }
    }
    if (outcnt < (unsigned int)(16384 - 2)) {
      unsigned int tmp_3;
      unsigned int tmp_4;
      tmp_3 = outcnt;
      outcnt ++;
      outbuf[tmp_3] = (uch)((int)((ush)(~ len)) & 0xff);
      tmp_4 = outcnt;
      outcnt ++;
      outbuf[tmp_4] = (uch)((int)((ush)(~ len)) >> 8);
    }
    else {
      {
        unsigned int tmp_5;
        tmp_5 = outcnt;
        outcnt ++;
        outbuf[tmp_5] = (uch)((int)((ush)(~ len)) & 0xff);
        if (outcnt == (unsigned int)16384) flush_outbuf();
      }
      {
        unsigned int tmp_6;
        tmp_6 = outcnt;
        outcnt ++;
        outbuf[tmp_6] = (uch)((int)((ush)(~ len)) >> 8);
        if (outcnt == (unsigned int)16384) flush_outbuf();
      }
    }
  }
  while (1) {
    unsigned int tmp_9;
    tmp_9 = len;
    len --;
    ;
    if (! tmp_9) break;
    {
      unsigned int tmp_7;
      char *tmp_8;
      tmp_7 = outcnt;
      outcnt ++;
      tmp_8 = buf;
      buf ++;
      outbuf[tmp_7] = (uch)*tmp_8;
      if (outcnt == (unsigned int)16384) flush_outbuf();
    }
  }
  return;
}

int decrypt;
char *key;
int pkzip = 0;
int ext_header = 0;
/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_49(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_50(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_51(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1);

int check_zipfile(int in) __attribute__((__FC_OLDSTYLEPROTO__));
int check_zipfile(int in)
{
  int __retres;
  uch *h = & inbuf[inptr];
  ifd = in;
  inptr += (unsigned int)((30 + ((int)((ush)*((h + 26) + 0)) | ((int)((ush)*(
                                                                (h + 26) + 1)) << 8))) + (
                          (int)((ush)*((h + 28) + 0)) | ((int)((ush)*(
                                                         (h + 28) + 1)) << 8)));
  if (inptr > insize) goto _LOR;
  else 
    if (((ulg)((int)((ush)*(h + 0)) | ((int)((ush)*(h + 1)) << 8)) | (
         (ulg)((int)((ush)*((h + 2) + 0)) | ((int)((ush)*((h + 2) + 1)) << 8)) << 16)) != (unsigned long)0x04034b50L) {
      _LOR:
      {
        fprintf(__fc_stderr,"\n%s: %s: not a valid zip file\n",progname,
                ifname); /* fprintf_va_49 */
        exit_code = 1;
        __retres = 1;
        goto return_label;
      }
    }
  method = (int)*(h + 8);
  if (method != 0) 
    if (method != 8) {
      fprintf(__fc_stderr,
              "\n%s: %s: first entry not deflated or stored -- use unzip\n",
              progname,ifname); /* fprintf_va_50 */
      exit_code = 1;
      __retres = 1;
      goto return_label;
    }
  decrypt = (int)*(h + 6) & 1;
  if (decrypt != 0) {
    fprintf(__fc_stderr,"\n%s: %s: encrypted file -- use unzip\n",progname,
            ifname); /* fprintf_va_51 */
    exit_code = 1;
    __retres = 1;
    goto return_label;
  }
  ext_header = ((int)*(h + 6) & 8) != 0;
  pkzip = 1;
  __retres = 0;
  return_label: return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param1, param0;
 */
int fprintf_va_52(FILE * restrict stream, char const * restrict format,
                  long param0, long param1);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_53(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_54(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1);

int unzip(int in, int out) __attribute__((__FC_OLDSTYLEPROTO__));
int unzip(int in, int out)
{
  int __retres;
  int n;
  uch buf[16];
  ulg tmp_12;
  ulg orig_crc = (ulg)0;
  ulg orig_len_0 = (ulg)0;
  ifd = in;
  ofd = out;
  updcrc((uch *)0,(unsigned int)0);
  if (pkzip) 
    if (! ext_header) {
      orig_crc = (ulg)((int)((ush)*(& inbuf[14] + 0)) | ((int)((ush)*(
                                                         & inbuf[14] + 1)) << 8)) | (
                 (ulg)((int)((ush)*((& inbuf[14] + 2) + 0)) | ((int)((ush)*(
                                                               (& inbuf[14] + 2) + 1)) << 8)) << 16);
      orig_len_0 = (ulg)((int)((ush)*(& inbuf[22] + 0)) | ((int)((ush)*(
                                                           & inbuf[22] + 1)) << 8)) | (
                   (ulg)((int)((ush)*((& inbuf[22] + 2) + 0)) | ((int)((ush)*(
                                                                 (& inbuf[22] + 2) + 1)) << 8)) << 16);
    }
  if (method == 8) {
    int res = inflate();
    if (res == 3) error((char *)"out of memory");
    else 
      if (res != 0) error((char *)"invalid compressed data--format violated");
  }
  else 
    if (pkzip) {
      if (method == 0) {
        int tmp_0;
        register ulg n_0 =
          (ulg)((int)((ush)*(& inbuf[22] + 0)) | ((int)((ush)*(& inbuf[22] + 1)) << 8)) | (
          (ulg)((int)((ush)*((& inbuf[22] + 2) + 0)) | ((int)((ush)*(
                                                        (& inbuf[22] + 2) + 1)) << 8)) << 16);
        if (decrypt) tmp_0 = 12; else tmp_0 = 0;
        ;
        if (n_0 != ((ulg)((int)((ush)*(& inbuf[18] + 0)) | ((int)((ush)*(
                                                            & inbuf[18] + 1)) << 8)) | (
                    (ulg)((int)((ush)*((& inbuf[18] + 2) + 0)) | ((int)((ush)*(
                                                                  (& inbuf[18] + 2) + 1)) << 8)) << 16)) - (unsigned long)tmp_0) {
          fprintf(__fc_stderr,"len %ld, siz %ld\n",(long)n_0,
                  (long)((ulg)((int)((ush)*(& inbuf[18] + 0)) | ((int)((ush)*(
                                                                 & inbuf[18] + 1)) << 8)) | (
                         (ulg)((int)((ush)*((& inbuf[18] + 2) + 0)) | (
                               (int)((ush)*((& inbuf[18] + 2) + 1)) << 8)) << 16))); /* fprintf_va_52 */
          error((char *)"invalid compressed data--length mismatch");
        }
        while (1) {
          ulg tmp_5;
          tmp_5 = n_0;
          n_0 --;
          ;
          if (! tmp_5) break;
          {
            int tmp_3;
            if (inptr < insize) {
              unsigned int tmp_1;
              tmp_1 = inptr;
              inptr ++;
              tmp_3 = (int)inbuf[tmp_1];
            }
            else tmp_3 = fill_inbuf(0);
            uch c = (uch)tmp_3;
            {
              unsigned int tmp_4;
              tmp_4 = outcnt;
              outcnt ++;
              window[tmp_4] = c;
              if (outcnt == (unsigned int)0x8000) flush_window();
            }
          }
        }
        flush_window();
      }
      else goto _LAND;
    }
    else _LAND: error((char *)"internal error, invalid method");
  if (! pkzip) {
    n = 0;
    while (n < 8) {
      {
        int tmp_8;
        if (inptr < insize) {
          unsigned int tmp_6;
          tmp_6 = inptr;
          inptr ++;
          tmp_8 = (int)inbuf[tmp_6];
        }
        else tmp_8 = fill_inbuf(0);
        buf[n] = (uch)tmp_8;
      }
      n ++;
    }
    orig_crc = (ulg)((int)((ush)buf[0]) | ((int)((ush)buf[1]) << 8)) | (
               (ulg)((int)((ush)*(& buf[2] + 0)) | ((int)((ush)*(& buf[2] + 1)) << 8)) << 16);
    orig_len_0 = (ulg)((int)((ush)*(& buf[4] + 0)) | ((int)((ush)*(& buf[4] + 1)) << 8)) | (
                 (ulg)((int)((ush)*((& buf[4] + 2) + 0)) | ((int)((ush)*(
                                                            (& buf[4] + 2) + 1)) << 8)) << 16);
  }
  else 
    if (ext_header) {
      n = 0;
      while (n < 16) {
        {
          int tmp_11;
          if (inptr < insize) {
            unsigned int tmp_9;
            tmp_9 = inptr;
            inptr ++;
            tmp_11 = (int)inbuf[tmp_9];
          }
          else tmp_11 = fill_inbuf(0);
          buf[n] = (uch)tmp_11;
        }
        n ++;
      }
      orig_crc = (ulg)((int)((ush)*(& buf[4] + 0)) | ((int)((ush)*(& buf[4] + 1)) << 8)) | (
                 (ulg)((int)((ush)*((& buf[4] + 2) + 0)) | ((int)((ush)*(
                                                            (& buf[4] + 2) + 1)) << 8)) << 16);
      orig_len_0 = (ulg)((int)((ush)*(& buf[12] + 0)) | ((int)((ush)*(
                                                         & buf[12] + 1)) << 8)) | (
                   (ulg)((int)((ush)*((& buf[12] + 2) + 0)) | ((int)((ush)*(
                                                               (& buf[12] + 2) + 1)) << 8)) << 16);
    }
  tmp_12 = updcrc(outbuf,(unsigned int)0);
  ;
  if (orig_crc != tmp_12) error((char *)"invalid compressed data--crc error");
  if (orig_len_0 != (ulg)bytes_out) error((char *)"invalid compressed data--length error");
  if (pkzip) 
    if (inptr + (unsigned int)4 < insize) 
      if (((ulg)((int)((ush)*(& inbuf[inptr] + 0)) | ((int)((ush)*(& inbuf[inptr] + 1)) << 8)) | (
           (ulg)((int)((ush)*((& inbuf[inptr] + 2) + 0)) | ((int)((ush)*(
                                                            (& inbuf[inptr] + 2) + 1)) << 8)) << 16)) == (unsigned long)0x04034b50L) 
        if (to_stdout) {
          if (! quiet) fprintf(__fc_stderr,
                               "%s: %s has more than one entry--rest ignored\n",
                               progname,ifname); /* fprintf_va_53 */
          if (exit_code == 0) exit_code = 2;
        }
        else {
          fprintf(__fc_stderr,
                  "%s: %s has more than one entry -- unchanged\n",progname,
                  ifname); /* fprintf_va_54 */
          exit_code = 1;
          pkzip = 0;
          ext_header = pkzip;
          __retres = 1;
          goto return_label;
        }
  pkzip = 0;
  ext_header = pkzip;
  __retres = 0;
  return_label: return __retres;
}

int huft_build(unsigned int *b, unsigned int n, unsigned int s, ush *d,
               ush *e, struct huft **t, int *m) __attribute__((__FC_OLDSTYLEPROTO__));

int huft_free(struct huft *t) __attribute__((__FC_OLDSTYLEPROTO__));

int inflate_codes(struct huft *tl, struct huft *td, int bl, int bd) __attribute__((
__FC_OLDSTYLEPROTO__));

int inflate_stored(void);

int inflate_fixed(void);

int inflate_dynamic(void);

int inflate_block(int *e) __attribute__((__FC_OLDSTYLEPROTO__));

static unsigned int border[19] =
  {(unsigned int)16,
   (unsigned int)17,
   (unsigned int)18,
   (unsigned int)0,
   (unsigned int)8,
   (unsigned int)7,
   (unsigned int)9,
   (unsigned int)6,
   (unsigned int)10,
   (unsigned int)5,
   (unsigned int)11,
   (unsigned int)4,
   (unsigned int)12,
   (unsigned int)3,
   (unsigned int)13,
   (unsigned int)2,
   (unsigned int)14,
   (unsigned int)1,
   (unsigned int)15};
static ush cplens[31] =
  {(ush)3,
   (ush)4,
   (ush)5,
   (ush)6,
   (ush)7,
   (ush)8,
   (ush)9,
   (ush)10,
   (ush)11,
   (ush)13,
   (ush)15,
   (ush)17,
   (ush)19,
   (ush)23,
   (ush)27,
   (ush)31,
   (ush)35,
   (ush)43,
   (ush)51,
   (ush)59,
   (ush)67,
   (ush)83,
   (ush)99,
   (ush)115,
   (ush)131,
   (ush)163,
   (ush)195,
   (ush)227,
   (ush)258,
   (ush)0,
   (ush)0};
static ush cplext[31] =
  {(ush)0,
   (ush)0,
   (ush)0,
   (ush)0,
   (ush)0,
   (ush)0,
   (ush)0,
   (ush)0,
   (ush)1,
   (ush)1,
   (ush)1,
   (ush)1,
   (ush)2,
   (ush)2,
   (ush)2,
   (ush)2,
   (ush)3,
   (ush)3,
   (ush)3,
   (ush)3,
   (ush)4,
   (ush)4,
   (ush)4,
   (ush)4,
   (ush)5,
   (ush)5,
   (ush)5,
   (ush)5,
   (ush)0,
   (ush)99,
   (ush)99};
static ush cpdist[30] =
  {(ush)1,
   (ush)2,
   (ush)3,
   (ush)4,
   (ush)5,
   (ush)7,
   (ush)9,
   (ush)13,
   (ush)17,
   (ush)25,
   (ush)33,
   (ush)49,
   (ush)65,
   (ush)97,
   (ush)129,
   (ush)193,
   (ush)257,
   (ush)385,
   (ush)513,
   (ush)769,
   (ush)1025,
   (ush)1537,
   (ush)2049,
   (ush)3073,
   (ush)4097,
   (ush)6145,
   (ush)8193,
   (ush)12289,
   (ush)16385,
   (ush)24577};
static ush cpdext[30] =
  {(ush)0,
   (ush)0,
   (ush)0,
   (ush)0,
   (ush)1,
   (ush)1,
   (ush)2,
   (ush)2,
   (ush)3,
   (ush)3,
   (ush)4,
   (ush)4,
   (ush)5,
   (ush)5,
   (ush)6,
   (ush)6,
   (ush)7,
   (ush)7,
   (ush)8,
   (ush)8,
   (ush)9,
   (ush)9,
   (ush)10,
   (ush)10,
   (ush)11,
   (ush)11,
   (ush)12,
   (ush)12,
   (ush)13,
   (ush)13};
ulg bb;
unsigned int bk;
ush mask_bits[17] =
  {(ush)0x0000,
   (ush)0x0001,
   (ush)0x0003,
   (ush)0x0007,
   (ush)0x000f,
   (ush)0x001f,
   (ush)0x003f,
   (ush)0x007f,
   (ush)0x00ff,
   (ush)0x01ff,
   (ush)0x03ff,
   (ush)0x07ff,
   (ush)0x0fff,
   (ush)0x1fff,
   (ush)0x3fff,
   (ush)0x7fff,
   (ush)0xffff};
int lbits = 9;
int dbits = 6;
unsigned int hufts;
int huft_build(unsigned int *b, unsigned int n, unsigned int s, ush *d,
               ush *e, struct huft **t, int *m) __attribute__((__FC_OLDSTYLEPROTO__));
int huft_build(unsigned int *b, unsigned int n, unsigned int s, ush *d,
               ush *e, struct huft **t, int *m)
{
  int __retres;
  unsigned int a;
  unsigned int c[16 + 1];
  unsigned int f;
  int g;
  int h;
  register unsigned int i;
  register unsigned int j_0;
  register int k;
  int l;
  register unsigned int *p;
  register struct huft *q;
  struct huft r;
  struct huft *u[16];
  unsigned int v[288];
  register int w;
  unsigned int x[16 + 1];
  unsigned int *xp;
  int y;
  unsigned int z;
  int tmp_7;
  memset((voidp)(c),0,sizeof(c));
  p = b;
  i = n;
  while (1) {
    (c[*p]) ++;
    p ++;
    i --;
    if (! i) break;
  }
  if (c[0] == n) {
    *t = (struct huft *)0;
    *m = 0;
    __retres = 0;
    goto return_label;
  }
  l = *m;
  j_0 = (unsigned int)1;
  while (j_0 <= (unsigned int)16) {
    if (c[j_0]) break;
    j_0 ++;
  }
  k = (int)j_0;
  if ((unsigned int)l < j_0) l = (int)j_0;
  i = (unsigned int)16;
  while (i) {
    if (c[i]) break;
    i --;
  }
  g = (int)i;
  if ((unsigned int)l > i) l = (int)i;
  *m = l;
  y = 1 << j_0;
  while (j_0 < i) {
    y = (int)((unsigned int)y - c[j_0]);
    if (y < 0) {
      __retres = 2;
      goto return_label;
    }
    j_0 ++;
    y <<= 1;
  }
  y = (int)((unsigned int)y - c[i]);
  if (y < 0) {
    __retres = 2;
    goto return_label;
  }
  c[i] += (unsigned int)y;
  j_0 = (unsigned int)0;
  x[1] = j_0;
  p = & c[1];
  xp = & x[2];
  while (1) {
    i --;
    if (! i) break;
    {
      unsigned int *tmp;
      unsigned int *tmp_0;
      tmp = xp;
      xp ++;
      tmp_0 = p;
      p ++;
      j_0 += *tmp_0;
      *tmp = j_0;
    }
  }
  p = b;
  i = (unsigned int)0;
  while (1) {
    {
      unsigned int *tmp_2;
      tmp_2 = p;
      p ++;
      j_0 = *tmp_2;
      if (j_0 != (unsigned int)0) {
        unsigned int tmp_1;
        tmp_1 = x[j_0];
        (x[j_0]) ++;
        v[tmp_1] = i;
      }
    }
    i ++;
    ;
    if (! (i < n)) break;
  }
  i = (unsigned int)0;
  x[0] = i;
  p = v;
  h = -1;
  w = - l;
  u[0] = (struct huft *)0;
  q = (struct huft *)0;
  z = (unsigned int)0;
  while (k <= g) {
    a = c[k];
    while (1) {
      unsigned int tmp_6;
      tmp_6 = a;
      a --;
      ;
      if (! tmp_6) break;
      while (k > w + l) {
        h ++;
        w += l;
        z = (unsigned int)(g - w);
        ;
        if (z > (unsigned int)l) z = (unsigned int)l; else z = z;
        j_0 = (unsigned int)(k - w);
        f = (unsigned int)(1 << j_0);
        ;
        if (f > a + (unsigned int)1) {
          f -= a + (unsigned int)1;
          xp = & c[k];
          while (1) {
            j_0 ++;
            ;
            if (! (j_0 < z)) break;
            f <<= 1;
            xp ++;
            ;
            if (f <= *xp) break;
            f -= *xp;
          }
        }
        z = (unsigned int)(1 << j_0);
        q = (struct huft *)malloc((z + (unsigned int)1) * sizeof(struct huft));
        if (q == (struct huft *)0) {
          if (h) huft_free(u[0]);
          __retres = 3;
          goto return_label;
        }
        hufts += z + (unsigned int)1;
        *t = q + 1;
        t = & q->v.t;
        *t = (struct huft *)0;
        q ++;
        u[h] = q;
        if (h) {
          x[h] = i;
          r.b = (uch)l;
          r.e = (uch)((unsigned int)16 + j_0);
          r.v.t = q;
          j_0 = i >> (w - l);
          *(u[h - 1] + j_0) = r;
        }
      }
      r.b = (uch)(k - w);
      if (p >= & v[n]) r.e = (uch)99;
      else 
        if (*p < s) {
          int tmp_4;
          if (*p < (unsigned int)256) tmp_4 = 16; else tmp_4 = 15;
          r.e = (uch)tmp_4;
          r.v.n = (ush)*p;
          p ++;
        }
        else {
          unsigned int *tmp_5;
          r.e = (uch)*(e + (*p - s));
          tmp_5 = p;
          p ++;
          r.v.n = *(d + (*tmp_5 - s));
        }
      f = (unsigned int)(1 << (k - w));
      j_0 = i >> w;
      while (j_0 < z) {
        *(q + j_0) = r;
        j_0 += f;
      }
      j_0 = (unsigned int)(1 << (k - 1));
      while (i & j_0) {
        i ^= j_0;
        j_0 >>= 1;
      }
      i ^= j_0;
      while ((i & (unsigned int)((1 << w) - 1)) != x[h]) {
        h --;
        w -= l;
      }
    }
    k ++;
  }
  if (y != 0) 
    if (g != 1) tmp_7 = 1; else tmp_7 = 0;
  else tmp_7 = 0;
  __retres = tmp_7;
  return_label: return __retres;
}

int huft_free(struct huft *t) __attribute__((__FC_OLDSTYLEPROTO__));
int huft_free(struct huft *t)
{
  int __retres;
  register struct huft *p;
  register struct huft *q;
  p = t;
  while (p != (struct huft *)0) {
    p --;
    q = p->v.t;
    free((void *)p);
    p = q;
  }
  __retres = 0;
  return __retres;
}

int inflate_codes(struct huft *tl, struct huft *td, int bl, int bd) __attribute__((
__FC_OLDSTYLEPROTO__));
int inflate_codes(struct huft *tl, struct huft *td, int bl, int bd)
{
  int __retres;
  register unsigned int e;
  unsigned int n;
  unsigned int d;
  unsigned int w;
  struct huft *t;
  unsigned int ml;
  unsigned int md;
  register ulg b;
  register unsigned int k;
  b = bb;
  k = bk;
  w = outcnt;
  ml = (unsigned int)mask_bits[bl];
  md = (unsigned int)mask_bits[bd];
  while (1) {
    while (k < (unsigned int)bl) {
      int tmp_1;
      if (inptr < insize) {
        unsigned int tmp;
        tmp = inptr;
        inptr ++;
        tmp_1 = (int)inbuf[tmp];
      }
      else tmp_1 = fill_inbuf(0);
      b |= (ulg)((uch)tmp_1) << k;
      k += (unsigned int)8;
    }
    t = tl + ((unsigned int)b & ml);
    e = (unsigned int)t->e;
    if (e > (unsigned int)16) 
      while (1) {
        if (e == (unsigned int)99) {
          __retres = 1;
          goto return_label;
        }
        b >>= (int)t->b;
        k -= (unsigned int)t->b;
        e -= (unsigned int)16;
        while (k < e) {
          int tmp_4;
          if (inptr < insize) {
            unsigned int tmp_2;
            tmp_2 = inptr;
            inptr ++;
            tmp_4 = (int)inbuf[tmp_2];
          }
          else tmp_4 = fill_inbuf(0);
          b |= (ulg)((uch)tmp_4) << k;
          k += (unsigned int)8;
        }
        t = t->v.t + ((unsigned int)b & (unsigned int)mask_bits[e]);
        e = (unsigned int)t->e;
        if (! (e > (unsigned int)16)) break;
      }
    b >>= (int)t->b;
    k -= (unsigned int)t->b;
    if (e == (unsigned int)16) {
      unsigned int tmp_5;
      tmp_5 = w;
      w ++;
      window[tmp_5] = (uch)t->v.n;
      if (w == (unsigned int)0x8000) {
        outcnt = w;
        flush_window();
        w = (unsigned int)0;
      }
    }
    else {
      if (e == (unsigned int)15) break;
      while (k < e) {
        int tmp_8;
        if (inptr < insize) {
          unsigned int tmp_6;
          tmp_6 = inptr;
          inptr ++;
          tmp_8 = (int)inbuf[tmp_6];
        }
        else tmp_8 = fill_inbuf(0);
        b |= (ulg)((uch)tmp_8) << k;
        k += (unsigned int)8;
      }
      n = (unsigned int)t->v.n + ((unsigned int)b & (unsigned int)mask_bits[e]);
      b >>= e;
      k -= e;
      while (k < (unsigned int)bd) {
        int tmp_11;
        if (inptr < insize) {
          unsigned int tmp_9;
          tmp_9 = inptr;
          inptr ++;
          tmp_11 = (int)inbuf[tmp_9];
        }
        else tmp_11 = fill_inbuf(0);
        b |= (ulg)((uch)tmp_11) << k;
        k += (unsigned int)8;
      }
      t = td + ((unsigned int)b & md);
      e = (unsigned int)t->e;
      if (e > (unsigned int)16) 
        while (1) {
          if (e == (unsigned int)99) {
            __retres = 1;
            goto return_label;
          }
          b >>= (int)t->b;
          k -= (unsigned int)t->b;
          e -= (unsigned int)16;
          while (k < e) {
            int tmp_14;
            if (inptr < insize) {
              unsigned int tmp_12;
              tmp_12 = inptr;
              inptr ++;
              tmp_14 = (int)inbuf[tmp_12];
            }
            else tmp_14 = fill_inbuf(0);
            b |= (ulg)((uch)tmp_14) << k;
            k += (unsigned int)8;
          }
          t = t->v.t + ((unsigned int)b & (unsigned int)mask_bits[e]);
          e = (unsigned int)t->e;
          if (! (e > (unsigned int)16)) break;
        }
      b >>= (int)t->b;
      k -= (unsigned int)t->b;
      while (k < e) {
        int tmp_17;
        if (inptr < insize) {
          unsigned int tmp_15;
          tmp_15 = inptr;
          inptr ++;
          tmp_17 = (int)inbuf[tmp_15];
        }
        else tmp_17 = fill_inbuf(0);
        b |= (ulg)((uch)tmp_17) << k;
        k += (unsigned int)8;
      }
      d = (w - (unsigned int)t->v.n) - ((unsigned int)b & (unsigned int)mask_bits[e]);
      b >>= e;
      k -= e;
      while (1) {
        {
          unsigned int tmp_18;
          d &= (unsigned int)(0x8000 - 1);
          ;
          if (d > w) tmp_18 = d; else tmp_18 = w;
          e = (unsigned int)0x8000 - tmp_18;
          if (e > n) e = n; else e = e;
          n -= e;
          if (w - d >= e) {
            memcpy((void *)(& window[w]),(void const *)(& window[d]),e);
            w += e;
            d += e;
          }
          else 
            while (1) {
              {
                unsigned int tmp_19;
                unsigned int tmp_20;
                tmp_19 = w;
                w ++;
                tmp_20 = d;
                d ++;
                window[tmp_19] = window[tmp_20];
              }
              e --;
              if (! e) break;
            }
          if (w == (unsigned int)0x8000) {
            outcnt = w;
            flush_window();
            w = (unsigned int)0;
          }
        }
        if (! n) break;
      }
    }
  }
  outcnt = w;
  bb = b;
  bk = k;
  __retres = 0;
  return_label: return __retres;
}

int inflate_stored(void)
{
  int __retres;
  unsigned int n;
  unsigned int w;
  register ulg b;
  register unsigned int k;
  b = bb;
  k = bk;
  w = outcnt;
  n = k & (unsigned int)7;
  b >>= n;
  k -= n;
  while (k < (unsigned int)16) {
    int tmp_1;
    if (inptr < insize) {
      unsigned int tmp;
      tmp = inptr;
      inptr ++;
      tmp_1 = (int)inbuf[tmp];
    }
    else tmp_1 = fill_inbuf(0);
    b |= (ulg)((uch)tmp_1) << k;
    k += (unsigned int)8;
  }
  n = (unsigned int)b & (unsigned int)0xffff;
  b >>= 16;
  k -= (unsigned int)16;
  while (k < (unsigned int)16) {
    int tmp_4;
    if (inptr < insize) {
      unsigned int tmp_2;
      tmp_2 = inptr;
      inptr ++;
      tmp_4 = (int)inbuf[tmp_2];
    }
    else tmp_4 = fill_inbuf(0);
    b |= (ulg)((uch)tmp_4) << k;
    k += (unsigned int)8;
  }
  if (n != (unsigned int)(~ b & (unsigned long)0xffff)) {
    __retres = 1;
    goto return_label;
  }
  b >>= 16;
  k -= (unsigned int)16;
  while (1) {
    unsigned int tmp_9;
    tmp_9 = n;
    n --;
    ;
    if (! tmp_9) break;
    {
      unsigned int tmp_8;
      while (k < (unsigned int)8) {
        int tmp_7;
        if (inptr < insize) {
          unsigned int tmp_5;
          tmp_5 = inptr;
          inptr ++;
          tmp_7 = (int)inbuf[tmp_5];
        }
        else tmp_7 = fill_inbuf(0);
        b |= (ulg)((uch)tmp_7) << k;
        k += (unsigned int)8;
      }
      tmp_8 = w;
      w ++;
      window[tmp_8] = (uch)b;
      if (w == (unsigned int)0x8000) {
        outcnt = w;
        flush_window();
        w = (unsigned int)0;
      }
      b >>= 8;
      k -= (unsigned int)8;
    }
  }
  outcnt = w;
  bb = b;
  bk = k;
  __retres = 0;
  return_label: return __retres;
}

int inflate_fixed(void)
{
  int __retres;
  int i;
  struct huft *tl;
  struct huft *td;
  int bl;
  int bd;
  unsigned int l[288];
  int tmp;
  i = 0;
  while (i < 144) {
    l[i] = (unsigned int)8;
    i ++;
  }
  while (i < 256) {
    l[i] = (unsigned int)9;
    i ++;
  }
  while (i < 280) {
    l[i] = (unsigned int)7;
    i ++;
  }
  while (i < 288) {
    l[i] = (unsigned int)8;
    i ++;
  }
  bl = 7;
  i = huft_build(l,(unsigned int)288,(unsigned int)257,cplens,cplext,& tl,
                 & bl);
  if (i != 0) {
    __retres = i;
    goto return_label;
  }
  i = 0;
  while (i < 30) {
    l[i] = (unsigned int)5;
    i ++;
  }
  bd = 5;
  i = huft_build(l,(unsigned int)30,(unsigned int)0,cpdist,cpdext,& td,& bd);
  if (i > 1) {
    huft_free(tl);
    __retres = i;
    goto return_label;
  }
  tmp = inflate_codes(tl,td,bl,bd);
  if (tmp) {
    __retres = 1;
    goto return_label;
  }
  huft_free(tl);
  huft_free(td);
  __retres = 0;
  return_label: return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_55(FILE * restrict stream, char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_56(FILE * restrict stream, char const * restrict format);

int inflate_dynamic(void)
{
  int __retres;
  int i;
  unsigned int j_0;
  unsigned int l;
  unsigned int m;
  unsigned int n;
  struct huft *tl;
  struct huft *td;
  int bl;
  int bd;
  unsigned int nb;
  unsigned int nl;
  unsigned int nd;
  unsigned int ll[286 + 30];
  register ulg b;
  register unsigned int k;
  int tmp_30;
  b = bb;
  k = bk;
  while (k < (unsigned int)5) {
    int tmp_1;
    if (inptr < insize) {
      unsigned int tmp;
      tmp = inptr;
      inptr ++;
      tmp_1 = (int)inbuf[tmp];
    }
    else tmp_1 = fill_inbuf(0);
    b |= (ulg)((uch)tmp_1) << k;
    k += (unsigned int)8;
  }
  nl = (unsigned int)257 + ((unsigned int)b & (unsigned int)0x1f);
  b >>= 5;
  k -= (unsigned int)5;
  while (k < (unsigned int)5) {
    int tmp_4;
    if (inptr < insize) {
      unsigned int tmp_2;
      tmp_2 = inptr;
      inptr ++;
      tmp_4 = (int)inbuf[tmp_2];
    }
    else tmp_4 = fill_inbuf(0);
    b |= (ulg)((uch)tmp_4) << k;
    k += (unsigned int)8;
  }
  nd = (unsigned int)1 + ((unsigned int)b & (unsigned int)0x1f);
  b >>= 5;
  k -= (unsigned int)5;
  while (k < (unsigned int)4) {
    int tmp_7;
    if (inptr < insize) {
      unsigned int tmp_5;
      tmp_5 = inptr;
      inptr ++;
      tmp_7 = (int)inbuf[tmp_5];
    }
    else tmp_7 = fill_inbuf(0);
    b |= (ulg)((uch)tmp_7) << k;
    k += (unsigned int)8;
  }
  nb = (unsigned int)4 + ((unsigned int)b & (unsigned int)0xf);
  b >>= 4;
  k -= (unsigned int)4;
  if (nl > (unsigned int)286) {
    __retres = 1;
    goto return_label;
  }
  else 
    if (nd > (unsigned int)30) {
      __retres = 1;
      goto return_label;
    }
  j_0 = (unsigned int)0;
  while (j_0 < nb) {
    while (k < (unsigned int)3) {
      int tmp_10;
      if (inptr < insize) {
        unsigned int tmp_8;
        tmp_8 = inptr;
        inptr ++;
        tmp_10 = (int)inbuf[tmp_8];
      }
      else tmp_10 = fill_inbuf(0);
      b |= (ulg)((uch)tmp_10) << k;
      k += (unsigned int)8;
    }
    ll[border[j_0]] = (unsigned int)b & (unsigned int)7;
    b >>= 3;
    k -= (unsigned int)3;
    j_0 ++;
  }
  while (j_0 < (unsigned int)19) {
    ll[border[j_0]] = (unsigned int)0;
    j_0 ++;
  }
  bl = 7;
  i = huft_build(ll,(unsigned int)19,(unsigned int)19,(ush *)0,(ush *)0,& tl,
                 & bl);
  if (i != 0) {
    if (i == 1) huft_free(tl);
    __retres = i;
    goto return_label;
  }
  n = nl + nd;
  m = (unsigned int)mask_bits[bl];
  l = (unsigned int)0;
  i = (int)l;
  while ((unsigned int)i < n) {
    while (k < (unsigned int)bl) {
      int tmp_13;
      if (inptr < insize) {
        unsigned int tmp_11;
        tmp_11 = inptr;
        inptr ++;
        tmp_13 = (int)inbuf[tmp_11];
      }
      else tmp_13 = fill_inbuf(0);
      b |= (ulg)((uch)tmp_13) << k;
      k += (unsigned int)8;
    }
    td = tl + ((unsigned int)b & m);
    j_0 = (unsigned int)td->b;
    b >>= j_0;
    k -= j_0;
    j_0 = (unsigned int)td->v.n;
    if (j_0 < (unsigned int)16) {
      int tmp_14;
      tmp_14 = i;
      i ++;
      l = j_0;
      ll[tmp_14] = l;
    }
    else 
      if (j_0 == (unsigned int)16) {
        while (k < (unsigned int)2) {
          int tmp_17;
          if (inptr < insize) {
            unsigned int tmp_15;
            tmp_15 = inptr;
            inptr ++;
            tmp_17 = (int)inbuf[tmp_15];
          }
          else tmp_17 = fill_inbuf(0);
          b |= (ulg)((uch)tmp_17) << k;
          k += (unsigned int)8;
        }
        j_0 = (unsigned int)3 + ((unsigned int)b & (unsigned int)3);
        b >>= 2;
        k -= (unsigned int)2;
        if ((unsigned int)i + j_0 > n) {
          __retres = 1;
          goto return_label;
        }
        while (1) {
          unsigned int tmp_19;
          int tmp_18;
          tmp_19 = j_0;
          j_0 --;
          ;
          if (! tmp_19) break;
          tmp_18 = i;
          i ++;
          ll[tmp_18] = l;
        }
      }
      else 
        if (j_0 == (unsigned int)17) {
          while (k < (unsigned int)3) {
            int tmp_22;
            if (inptr < insize) {
              unsigned int tmp_20;
              tmp_20 = inptr;
              inptr ++;
              tmp_22 = (int)inbuf[tmp_20];
            }
            else tmp_22 = fill_inbuf(0);
            b |= (ulg)((uch)tmp_22) << k;
            k += (unsigned int)8;
          }
          j_0 = (unsigned int)3 + ((unsigned int)b & (unsigned int)7);
          b >>= 3;
          k -= (unsigned int)3;
          if ((unsigned int)i + j_0 > n) {
            __retres = 1;
            goto return_label;
          }
          while (1) {
            unsigned int tmp_24;
            int tmp_23;
            tmp_24 = j_0;
            j_0 --;
            ;
            if (! tmp_24) break;
            tmp_23 = i;
            i ++;
            ll[tmp_23] = (unsigned int)0;
          }
          l = (unsigned int)0;
        }
        else {
          while (k < (unsigned int)7) {
            int tmp_27;
            if (inptr < insize) {
              unsigned int tmp_25;
              tmp_25 = inptr;
              inptr ++;
              tmp_27 = (int)inbuf[tmp_25];
            }
            else tmp_27 = fill_inbuf(0);
            b |= (ulg)((uch)tmp_27) << k;
            k += (unsigned int)8;
          }
          j_0 = (unsigned int)11 + ((unsigned int)b & (unsigned int)0x7f);
          b >>= 7;
          k -= (unsigned int)7;
          if ((unsigned int)i + j_0 > n) {
            __retres = 1;
            goto return_label;
          }
          while (1) {
            unsigned int tmp_29;
            int tmp_28;
            tmp_29 = j_0;
            j_0 --;
            ;
            if (! tmp_29) break;
            tmp_28 = i;
            i ++;
            ll[tmp_28] = (unsigned int)0;
          }
          l = (unsigned int)0;
        }
  }
  huft_free(tl);
  bb = b;
  bk = k;
  bl = lbits;
  i = huft_build(ll,nl,(unsigned int)257,cplens,cplext,& tl,& bl);
  if (i != 0) {
    if (i == 1) {
      fprintf(__fc_stderr," incomplete literal tree\n"); /* fprintf_va_55 */
      huft_free(tl);
    }
    __retres = i;
    goto return_label;
  }
  bd = dbits;
  i = huft_build(& ll[nl],nd,(unsigned int)0,cpdist,cpdext,& td,& bd);
  if (i != 0) {
    if (i == 1) {
      fprintf(__fc_stderr," incomplete distance tree\n"); /* fprintf_va_56 */
      huft_free(td);
    }
    huft_free(tl);
    __retres = i;
    goto return_label;
  }
  tmp_30 = inflate_codes(tl,td,bl,bd);
  if (tmp_30) {
    __retres = 1;
    goto return_label;
  }
  huft_free(tl);
  huft_free(td);
  __retres = 0;
  return_label: return __retres;
}

int inflate_block(int *e) __attribute__((__FC_OLDSTYLEPROTO__));
int inflate_block(int *e)
{
  int __retres;
  unsigned int t;
  register ulg b;
  register unsigned int k;
  b = bb;
  k = bk;
  while (k < (unsigned int)1) {
    int tmp_1;
    if (inptr < insize) {
      unsigned int tmp;
      tmp = inptr;
      inptr ++;
      tmp_1 = (int)inbuf[tmp];
    }
    else tmp_1 = fill_inbuf(0);
    b |= (ulg)((uch)tmp_1) << k;
    k += (unsigned int)8;
  }
  *e = (int)b & 1;
  b >>= 1;
  k -= (unsigned int)1;
  while (k < (unsigned int)2) {
    int tmp_4;
    if (inptr < insize) {
      unsigned int tmp_2;
      tmp_2 = inptr;
      inptr ++;
      tmp_4 = (int)inbuf[tmp_2];
    }
    else tmp_4 = fill_inbuf(0);
    b |= (ulg)((uch)tmp_4) << k;
    k += (unsigned int)8;
  }
  t = (unsigned int)b & (unsigned int)3;
  b >>= 2;
  k -= (unsigned int)2;
  bb = b;
  bk = k;
  if (t == (unsigned int)2) {
    int tmp_5;
    tmp_5 = inflate_dynamic();
    __retres = tmp_5;
    goto return_label;
  }
  if (t == (unsigned int)0) {
    int tmp_6;
    tmp_6 = inflate_stored();
    __retres = tmp_6;
    goto return_label;
  }
  if (t == (unsigned int)1) {
    int tmp_7;
    tmp_7 = inflate_fixed();
    __retres = tmp_7;
    goto return_label;
  }
  __retres = 2;
  return_label: return __retres;
}

int inflate(void)
{
  int __retres;
  int e;
  int r;
  unsigned int h;
  outcnt = (unsigned int)0;
  bk = (unsigned int)0;
  bb = (ulg)0;
  h = (unsigned int)0;
  while (1) {
    hufts = (unsigned int)0;
    r = inflate_block(& e);
    if (r != 0) {
      __retres = r;
      goto return_label;
    }
    if (hufts > h) h = hufts;
    if (! (! e)) break;
  }
  while (bk >= (unsigned int)8) {
    bk -= (unsigned int)8;
    inptr --;
  }
  outcnt = outcnt;
  flush_window();
  __retres = 0;
  return_label: return __retres;
}

ulg crc_32_tab[256];

int copy(int in, int out) __attribute__((__FC_OLDSTYLEPROTO__));
int copy(int in, int out)
{
  int __retres;
  __fc_errno = 0;
  while (1) {
    if (insize != (unsigned int)0) {
      if (! ((int)insize != -1)) break;
    }
    else break;
    {
      ssize_t tmp;
      write_buf(out,(voidp)(inbuf),insize);
      bytes_out = (long)((unsigned long)bytes_out + (unsigned long)insize);
      tmp = read(in,(void *)(inbuf),(size_t)0x8000);
      insize = (unsigned int)tmp;
    }
  }
  if ((int)insize == -1) 
    if (__fc_errno != 0) read_error();
  bytes_in = bytes_out;
  __retres = 0;
  return __retres;
}

static ulg updcrc_crc = 0xffffffffL;
ulg updcrc(uch *s, unsigned int n) __attribute__((__FC_OLDSTYLEPROTO__));
ulg updcrc(uch *s, unsigned int n)
{
  ulg __retres;
  register ulg c;
  if (s == (uch *)0) c = 0xffffffffL;
  else {
    c = updcrc_crc;
    if (n) 
      while (1) {
        {
          uch *tmp;
          tmp = s;
          s ++;
          c = crc_32_tab[((int)c ^ (int)*tmp) & 0xff] ^ (c >> 8);
        }
        n --;
        if (! n) break;
      }
  }
  updcrc_crc = c;
  __retres = c ^ 0xffffffffL;
  return __retres;
}

void clear_bufs(void)
{
  outcnt = (unsigned int)0;
  inptr = (unsigned int)0;
  insize = inptr;
  bytes_out = 0L;
  bytes_in = bytes_out;
  return;
}

int fill_inbuf(int eof_ok) __attribute__((__FC_OLDSTYLEPROTO__));
int fill_inbuf(int eof_ok)
{
  int __retres;
  int len;
  insize = (unsigned int)0;
  __fc_errno = 0;
  while (1) {
    len = read(ifd,(void *)((char *)(inbuf) + insize),
               (unsigned int)0x8000 - insize);
    if (len == 0) break;
    else 
      if (len == -1) break;
    insize += (unsigned int)len;
    if (! (insize < (unsigned int)0x8000)) break;
  }
  if (insize == (unsigned int)0) {
    if (eof_ok) {
      __retres = -1;
      goto return_label;
    }
    read_error();
  }
  bytes_in = (long)((ulg)bytes_in + (ulg)insize);
  inptr = (unsigned int)1;
  __retres = (int)inbuf[0];
  return_label: return __retres;
}

void flush_outbuf(void)
{
  if (outcnt == (unsigned int)0) goto return_label;
  write_buf(ofd,(voidp)(outbuf),outcnt);
  bytes_out = (long)((ulg)bytes_out + (ulg)outcnt);
  outcnt = (unsigned int)0;
  return_label: return;
}

void flush_window(void)
{
  if (outcnt == (unsigned int)0) goto return_label;
  updcrc(window,outcnt);
  if (! test) write_buf(ofd,(voidp)(window),outcnt);
  bytes_out = (long)((ulg)bytes_out + (ulg)outcnt);
  outcnt = (unsigned int)0;
  return_label: return;
}

void write_buf(int fd, voidp buf, unsigned int cnt) __attribute__((__FC_OLDSTYLEPROTO__));
void write_buf(int fd, voidp buf, unsigned int cnt)
{
  unsigned int n;
  while (1) {
    ssize_t tmp;
    tmp = write(fd,(void const *)buf,cnt);
    n = (unsigned int)tmp;
    ;
    if (! (n != cnt)) break;
    if (n == (unsigned int)(-1)) write_error();
    cnt -= n;
    buf = (voidp)((char *)buf + n);
  }
  return;
}

char *strlwr(char *s) __attribute__((__FC_OLDSTYLEPROTO__));
char *strlwr(char *s)
{
  char *t;
  t = s;
  while (*t) {
    int tmp;
    tmp = isupper((int)*t);
    if (tmp) *t = (char)(((int)*t - 'A') + 'a'); else *t = *t;
    t ++;
  }
  return s;
}

char *basename(char *fname) __attribute__((__FC_OLDSTYLEPROTO__));
char *basename(char *fname)
{
  char *p;
  p = strrchr((char const *)fname,'/');
  if (p != (char *)0) fname = p + 1;
  if ('A' == 'a') strlwr(fname);
  return fname;
}

void make_simple_name(char *name) __attribute__((__FC_OLDSTYLEPROTO__));
void make_simple_name(char *name)
{
  char *p = strrchr((char const *)name,'.');
  if (p == (char *)0) goto return_label;
  if (p == name) p ++;
  while (1) {
    p --;
    ;
    if ((int)*p == '.') *p = (char)'_';
    if (! (p != name)) break;
  }
  return_label: return;
}

char *add_envopt(int *argcp, char ***argvp, char *env_0) __attribute__((
__FC_OLDSTYLEPROTO__));
char *add_envopt(int *argcp, char ***argvp, char *env_0)
{
  char *__retres;
  char *p;
  char **oargv;
  char **nargv;
  voidp tmp_1;
  size_t tmp_0;
  int tmp_6;
  char **tmp_7;
  char **tmp_8;
  int oargc = *argcp;
  int nargc = 0;
  env_0 = getenv((char const *)env_0);
  if (env_0 == (char *)0) {
    __retres = (char *)0;
    goto return_label;
  }
  tmp_0 = strlen((char const *)env_0);
  tmp_1 = xmalloc(tmp_0 + (size_t)1);
  p = (char *)tmp_1;
  env_0 = strcpy(p,(char const *)env_0);
  p = env_0;
  while (*p) {
    {
      size_t tmp_2;
      size_t tmp_3;
      tmp_2 = strspn((char const *)p," \t");
      p += tmp_2;
      if ((int)*p == '\000') break;
      tmp_3 = strcspn((char const *)p," \t");
      p += tmp_3;
      if (*p) {
        char *tmp_4;
        tmp_4 = p;
        p ++;
        *tmp_4 = (char)'\000';
      }
    }
    nargc ++;
  }
  if (nargc == 0) {
    free((void *)env_0);
    __retres = (char *)0;
    goto return_label;
  }
  *argcp += nargc;
  nargv = (char **)calloc((size_t)(*argcp + 1),sizeof(char *));
  if (nargv == (char **)0) error((char *)"out of memory");
  oargv = *argvp;
  *argvp = nargv;
  tmp_6 = oargc;
  oargc --;
  ;
  if (tmp_6 < 0) error((char *)"argc<=0");
  tmp_7 = nargv;
  nargv ++;
  tmp_8 = oargv;
  oargv ++;
  *tmp_7 = *tmp_8;
  p = env_0;
  while (nargc > 0) {
    {
      size_t tmp_9;
      char **tmp_10;
      tmp_9 = strspn((char const *)p," \t");
      p += tmp_9;
      tmp_10 = nargv;
      nargv ++;
      *tmp_10 = p;
      while (1) {
        char *tmp_11;
        tmp_11 = p;
        p ++;
        ;
        if (! *tmp_11) break;
      }
    }
    nargc --;
  }
  while (1) {
    int tmp_14;
    char **tmp_12;
    char **tmp_13;
    tmp_14 = oargc;
    oargc --;
    ;
    if (! tmp_14) break;
    tmp_12 = nargv;
    nargv ++;
    tmp_13 = oargv;
    oargv ++;
    *tmp_12 = *tmp_13;
  }
  *nargv = (char *)0;
  __retres = env_0;
  return_label: return __retres;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(param2);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param2 + (0 ..))),
            (indirect: *(param1 + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param2 + (0 ..)),
            *(param1 + (0 ..)), *(param0 + (0 ..));
 */
int fprintf_va_57(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1, char *param2);

void error(char *m) __attribute__((__FC_OLDSTYLEPROTO__));
void error(char *m)
{
  fprintf(__fc_stderr,"\n%s: %s: %s\n",progname,ifname,m); /* fprintf_va_57 */
  abort_gzip();
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(param2);
    requires valid_read_string(param3);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param3 + (0 ..))),
            (indirect: *(param2 + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param3 + (0 ..)),
            *(param2 + (0 ..)), *(param1 + (0 ..)), *(param0 + (0 ..));
 */
int fprintf_va_58(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1, char *param2, char *param3);

void warn(char *a, char *b) __attribute__((__FC_OLDSTYLEPROTO__));
void warn(char *a, char *b)
{
  if (! quiet) fprintf(__fc_stderr,"%s: %s: warning: %s%s\n",progname,ifname,
                       a,b); /* fprintf_va_58 */
  if (exit_code == 0) exit_code = 2;
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_59(FILE * restrict stream, char const * restrict format,
                  char *param0);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_60(FILE * restrict stream, char const * restrict format,
                  char *param0);

void read_error(void)
{
  fprintf(__fc_stderr,"\n%s: ",progname); /* fprintf_va_59 */
  if (__fc_errno != 0) perror((char const *)(ifname));
  else fprintf(__fc_stderr,"%s: unexpected end of file\n",ifname); /* fprintf_va_60 */
  abort_gzip();
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_61(FILE * restrict stream, char const * restrict format,
                  char *param0);

void write_error(void)
{
  fprintf(__fc_stderr,"\n%s: ",progname); /* fprintf_va_61 */
  perror((char const *)(ofname));
  abort_gzip();
  return;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param1, param0;
 */
int fprintf_va_62(FILE * restrict stream, char const * restrict format,
                  long param0, long param1);

void display_ratio(long num, long den, FILE *file) __attribute__((__FC_OLDSTYLEPROTO__));
void display_ratio(long num, long den, FILE *file)
{
  long ratio;
  if (den == (long)0) ratio = (long)0;
  else 
    if (den < 2147483L) ratio = (1000L * num) / den;
    else ratio = num / (den / 1000L);
  if (ratio < (long)0) {
    putc('-',file);
    ratio = - ratio;
  }
  else putc(' ',file);
  fprintf(file,"%2ld.%1ld%%",ratio / 10L,ratio % 10L); /* fprintf_va_62 */
  return;
}

voidp xmalloc(unsigned int size) __attribute__((__FC_OLDSTYLEPROTO__));
voidp xmalloc(unsigned int size)
{
  voidp cp = malloc(size);
  if (cp == (void *)0) error((char *)"out of memory");
  return cp;
}

ulg crc_32_tab[256] =
  {(ulg)0x00000000L,
   (ulg)0x77073096L,
   0xee0e612cL,
   0x990951baL,
   (ulg)0x076dc419L,
   (ulg)0x706af48fL,
   0xe963a535L,
   0x9e6495a3L,
   (ulg)0x0edb8832L,
   (ulg)0x79dcb8a4L,
   0xe0d5e91eL,
   0x97d2d988L,
   (ulg)0x09b64c2bL,
   (ulg)0x7eb17cbdL,
   0xe7b82d07L,
   0x90bf1d91L,
   (ulg)0x1db71064L,
   (ulg)0x6ab020f2L,
   0xf3b97148L,
   0x84be41deL,
   (ulg)0x1adad47dL,
   (ulg)0x6ddde4ebL,
   0xf4d4b551L,
   0x83d385c7L,
   (ulg)0x136c9856L,
   (ulg)0x646ba8c0L,
   0xfd62f97aL,
   0x8a65c9ecL,
   (ulg)0x14015c4fL,
   (ulg)0x63066cd9L,
   0xfa0f3d63L,
   0x8d080df5L,
   (ulg)0x3b6e20c8L,
   (ulg)0x4c69105eL,
   0xd56041e4L,
   0xa2677172L,
   (ulg)0x3c03e4d1L,
   (ulg)0x4b04d447L,
   0xd20d85fdL,
   0xa50ab56bL,
   (ulg)0x35b5a8faL,
   (ulg)0x42b2986cL,
   0xdbbbc9d6L,
   0xacbcf940L,
   (ulg)0x32d86ce3L,
   (ulg)0x45df5c75L,
   0xdcd60dcfL,
   0xabd13d59L,
   (ulg)0x26d930acL,
   (ulg)0x51de003aL,
   0xc8d75180L,
   0xbfd06116L,
   (ulg)0x21b4f4b5L,
   (ulg)0x56b3c423L,
   0xcfba9599L,
   0xb8bda50fL,
   (ulg)0x2802b89eL,
   (ulg)0x5f058808L,
   0xc60cd9b2L,
   0xb10be924L,
   (ulg)0x2f6f7c87L,
   (ulg)0x58684c11L,
   0xc1611dabL,
   0xb6662d3dL,
   (ulg)0x76dc4190L,
   (ulg)0x01db7106L,
   0x98d220bcL,
   0xefd5102aL,
   (ulg)0x71b18589L,
   (ulg)0x06b6b51fL,
   0x9fbfe4a5L,
   0xe8b8d433L,
   (ulg)0x7807c9a2L,
   (ulg)0x0f00f934L,
   0x9609a88eL,
   0xe10e9818L,
   (ulg)0x7f6a0dbbL,
   (ulg)0x086d3d2dL,
   0x91646c97L,
   0xe6635c01L,
   (ulg)0x6b6b51f4L,
   (ulg)0x1c6c6162L,
   0x856530d8L,
   0xf262004eL,
   (ulg)0x6c0695edL,
   (ulg)0x1b01a57bL,
   0x8208f4c1L,
   0xf50fc457L,
   (ulg)0x65b0d9c6L,
   (ulg)0x12b7e950L,
   0x8bbeb8eaL,
   0xfcb9887cL,
   (ulg)0x62dd1ddfL,
   (ulg)0x15da2d49L,
   0x8cd37cf3L,
   0xfbd44c65L,
   (ulg)0x4db26158L,
   (ulg)0x3ab551ceL,
   0xa3bc0074L,
   0xd4bb30e2L,
   (ulg)0x4adfa541L,
   (ulg)0x3dd895d7L,
   0xa4d1c46dL,
   0xd3d6f4fbL,
   (ulg)0x4369e96aL,
   (ulg)0x346ed9fcL,
   0xad678846L,
   0xda60b8d0L,
   (ulg)0x44042d73L,
   (ulg)0x33031de5L,
   0xaa0a4c5fL,
   0xdd0d7cc9L,
   (ulg)0x5005713cL,
   (ulg)0x270241aaL,
   0xbe0b1010L,
   0xc90c2086L,
   (ulg)0x5768b525L,
   (ulg)0x206f85b3L,
   0xb966d409L,
   0xce61e49fL,
   (ulg)0x5edef90eL,
   (ulg)0x29d9c998L,
   0xb0d09822L,
   0xc7d7a8b4L,
   (ulg)0x59b33d17L,
   (ulg)0x2eb40d81L,
   0xb7bd5c3bL,
   0xc0ba6cadL,
   0xedb88320L,
   0x9abfb3b6L,
   (ulg)0x03b6e20cL,
   (ulg)0x74b1d29aL,
   0xead54739L,
   0x9dd277afL,
   (ulg)0x04db2615L,
   (ulg)0x73dc1683L,
   0xe3630b12L,
   0x94643b84L,
   (ulg)0x0d6d6a3eL,
   (ulg)0x7a6a5aa8L,
   0xe40ecf0bL,
   0x9309ff9dL,
   (ulg)0x0a00ae27L,
   (ulg)0x7d079eb1L,
   0xf00f9344L,
   0x8708a3d2L,
   (ulg)0x1e01f268L,
   (ulg)0x6906c2feL,
   0xf762575dL,
   0x806567cbL,
   (ulg)0x196c3671L,
   (ulg)0x6e6b06e7L,
   0xfed41b76L,
   0x89d32be0L,
   (ulg)0x10da7a5aL,
   (ulg)0x67dd4accL,
   0xf9b9df6fL,
   0x8ebeeff9L,
   (ulg)0x17b7be43L,
   (ulg)0x60b08ed5L,
   0xd6d6a3e8L,
   0xa1d1937eL,
   (ulg)0x38d8c2c4L,
   (ulg)0x4fdff252L,
   0xd1bb67f1L,
   0xa6bc5767L,
   (ulg)0x3fb506ddL,
   (ulg)0x48b2364bL,
   0xd80d2bdaL,
   0xaf0a1b4cL,
   (ulg)0x36034af6L,
   (ulg)0x41047a60L,
   0xdf60efc3L,
   0xa867df55L,
   (ulg)0x316e8eefL,
   (ulg)0x4669be79L,
   0xcb61b38cL,
   0xbc66831aL,
   (ulg)0x256fd2a0L,
   (ulg)0x5268e236L,
   0xcc0c7795L,
   0xbb0b4703L,
   (ulg)0x220216b9L,
   (ulg)0x5505262fL,
   0xc5ba3bbeL,
   0xb2bd0b28L,
   (ulg)0x2bb45a92L,
   (ulg)0x5cb36a04L,
   0xc2d7ffa7L,
   0xb5d0cf31L,
   (ulg)0x2cd99e8bL,
   (ulg)0x5bdeae1dL,
   0x9b64c2b0L,
   0xec63f226L,
   (ulg)0x756aa39cL,
   (ulg)0x026d930aL,
   0x9c0906a9L,
   0xeb0e363fL,
   (ulg)0x72076785L,
   (ulg)0x05005713L,
   0x95bf4a82L,
   0xe2b87a14L,
   (ulg)0x7bb12baeL,
   (ulg)0x0cb61b38L,
   0x92d28e9bL,
   0xe5d5be0dL,
   (ulg)0x7cdcefb7L,
   (ulg)0x0bdbdf21L,
   0x86d3d2d4L,
   0xf1d4e242L,
   (ulg)0x68ddb3f8L,
   (ulg)0x1fda836eL,
   0x81be16cdL,
   0xf6b9265bL,
   (ulg)0x6fb077e1L,
   (ulg)0x18b74777L,
   0x88085ae6L,
   0xff0f6a70L,
   (ulg)0x66063bcaL,
   (ulg)0x11010b5cL,
   0x8f659effL,
   0xf862ae69L,
   (ulg)0x616bffd3L,
   (ulg)0x166ccf45L,
   0xa00ae278L,
   0xd70dd2eeL,
   (ulg)0x4e048354L,
   (ulg)0x3903b3c2L,
   0xa7672661L,
   0xd06016f7L,
   (ulg)0x4969474dL,
   (ulg)0x3e6e77dbL,
   0xaed16a4aL,
   0xd9d65adcL,
   (ulg)0x40df0b66L,
   (ulg)0x37d83bf0L,
   0xa9bcae53L,
   0xdebb9ec5L,
   (ulg)0x47b2cf7fL,
   (ulg)0x30b5ffe9L,
   0xbdbdf21cL,
   0xcabac28aL,
   (ulg)0x53b39330L,
   (ulg)0x24b4a3a6L,
   0xbad03605L,
   0xcdd70693L,
   (ulg)0x54de5729L,
   (ulg)0x23d967bfL,
   0xb3667a2eL,
   0xc4614ab8L,
   (ulg)0x5d681b02L,
   (ulg)0x2a6f2b94L,
   0xb40bbe37L,
   0xc30c8ea1L,
   (ulg)0x5a05df1bL,
   (ulg)0x2d02ef8dL};
static int msg_done = 0;
/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_63(FILE * restrict stream, char const * restrict format);

int lzw(int in, int out) __attribute__((__FC_OLDSTYLEPROTO__));
int lzw(int in, int out)
{
  int __retres;
  if (msg_done) {
    __retres = 1;
    goto return_label;
  }
  msg_done = 1;
  fprintf(__fc_stderr,"output in compress .Z format not supported\n"); /* fprintf_va_63 */
  if (in != out) exit_code = 1;
  __retres = 1;
  return_label: return __retres;
}

int block_mode = 0x80;
/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param2),
            (indirect: *(param1 + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param2, *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_64(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1, unsigned int param2);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param3),
            (indirect: param2), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param3, param2,
            *(param1 + (0 ..)), *(param0 + (0 ..));
 */
int fprintf_va_65(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1, int param2, int param3);

int unlzw(int in, int out) __attribute__((__FC_OLDSTYLEPROTO__));
int unlzw(int in, int out)
{
  int __retres;
  register char_type *stackp;
  code_int code;
  int finchar;
  code_int oldcode;
  code_int incode;
  long inbits;
  long posbits;
  int outpos;
  unsigned int bitmask;
  code_int free_ent;
  code_int maxcode;
  code_int maxmaxcode;
  int n_bits;
  int rsize;
  if (inptr < insize) {
    unsigned int tmp;
    tmp = inptr;
    inptr ++;
    maxbits = (int)inbuf[tmp];
  }
  else maxbits = fill_inbuf(0);
  block_mode = maxbits & 0x80;
  if ((maxbits & 0x60) != 0) {
    if (! quiet) fprintf(__fc_stderr,
                         "\n%s: %s: warning, unknown flags 0x%x\n",progname,
                         ifname,(unsigned int)(maxbits & 0x60)); /* fprintf_va_64 */
    if (exit_code == 0) exit_code = 2;
  }
  maxbits &= 0x1f;
  maxmaxcode = 1L << maxbits;
  if (maxbits > 16) {
    fprintf(__fc_stderr,
            "\n%s: %s: compressed with %d bits, can only handle %d bits\n",
            progname,ifname,maxbits,16); /* fprintf_va_65 */
    exit_code = 1;
    __retres = 1;
    goto return_label;
  }
  rsize = (int)insize;
  n_bits = 9;
  maxcode = (1L << n_bits) - (long)1;
  bitmask = (unsigned int)((1 << n_bits) - 1);
  oldcode = (code_int)(-1);
  finchar = 0;
  outpos = 0;
  posbits = (long)(inptr << 3);
  if (block_mode) free_ent = (code_int)(256 + 1);
  else free_ent = (code_int)256;
  memset((voidp)(prev),0,(size_t)256);
  code = (code_int)255;
  while (code >= (code_int)0) {
    window[code] = (char_type)code;
    code --;
  }
  while (1) {
    {
      register int i;
      int e;
      int o;
      resetbuf:
      { /* sequence */
        o = (int)(posbits >> 3);
        e = (int)(insize - (unsigned int)o);
      }
      i = 0;
      while (i < e) {
        inbuf[i] = inbuf[i + o];
        i ++;
      }
      insize = (unsigned int)e;
      posbits = (long)0;
      if (insize < (unsigned int)64) {
        rsize = read(in,(void *)((char *)(inbuf) + insize),(size_t)0x8000);
        if (rsize == -1) read_error();
        insize += (unsigned int)rsize;
        bytes_in = (long)((ulg)bytes_in + (ulg)rsize);
      }
      if (rsize != 0) inbits = (long)(((unsigned long)((long)insize) - (unsigned long)(
                                       insize % (unsigned int)n_bits)) << 3);
      else inbits = ((long)insize << 3) - (long)(n_bits - 1);
      while (inbits > posbits) {
        if (free_ent > maxcode) {
          posbits = (posbits - (long)1) + ((long)(n_bits << 3) - ((posbits - (long)1) + (long)(
                                                                  n_bits << 3)) % (long)(
                                                                 n_bits << 3));
          n_bits ++;
          if (n_bits == maxbits) maxcode = maxmaxcode;
          else maxcode = (1L << n_bits) - (long)1;
          bitmask = (unsigned int)((1 << n_bits) - 1);
          goto resetbuf;
        }
        {
          register char_type *p = & inbuf[posbits >> 3];
          code = (code_int)((unsigned long)((((long)*(p + 0) | ((long)*(
                                                                p + 1) << 8)) | (
                                             (long)*(p + 2) << 16)) >> (
                                            posbits & (long)0x7)) & (unsigned long)bitmask);
          posbits += (long)n_bits;
        }
        if (oldcode == (code_int)(-1)) {
          int tmp_1;
          if (code >= (code_int)256) error((char *)"corrupt input.");
          tmp_1 = outpos;
          outpos ++;
          oldcode = code;
          finchar = (int)oldcode;
          outbuf[tmp_1] = (char_type)finchar;
          continue;
        }
        if (code == (code_int)256) 
          if (block_mode) {
            memset((voidp)(prev),0,(size_t)256);
            free_ent = (code_int)((256 + 1) - 1);
            posbits = (posbits - (long)1) + ((long)(n_bits << 3) - ((
                                                                    posbits - (long)1) + (long)(
                                                                    n_bits << 3)) % (long)(
                                                                   n_bits << 3));
            n_bits = 9;
            maxcode = (1L << n_bits) - (long)1;
            bitmask = (unsigned int)((1 << n_bits) - 1);
            goto resetbuf;
          }
        incode = code;
        stackp = (char_type *)(& d_buf[0x8000 - 1]);
        if (code >= free_ent) {
          if (code > free_ent) {
            char const *tmp_2;
            if (! test) 
              if (outpos > 0) {
                write_buf(out,(voidp)(outbuf),(unsigned int)outpos);
                bytes_out = (long)((ulg)bytes_out + (ulg)outpos);
              }
            if (to_stdout) tmp_2 = "corrupt input.";
            else tmp_2 = "corrupt input. Use zcat to recover some data.";
            error((char *)tmp_2);
          }
          stackp --;
          *stackp = (char_type)finchar;
          code = oldcode;
        }
        while ((cmp_code_int)code >= (cmp_code_int)256) {
          stackp --;
          *stackp = window[code];
          code = (code_int)prev[code];
        }
        stackp --;
        finchar = (int)window[code];
        *stackp = (char_type)finchar;
        {
          register int i_0;
          i_0 = (char_type *)(& d_buf[0x8000 - 1]) - stackp;
          ;
          if (outpos + i_0 >= 16384) 
            while (1) {
              if (i_0 > 16384 - outpos) i_0 = 16384 - outpos;
              if (i_0 > 0) {
                memcpy((void *)(& outbuf[outpos]),(void const *)stackp,
                       (size_t)i_0);
                outpos += i_0;
              }
              if (outpos >= 16384) {
                if (! test) {
                  write_buf(out,(voidp)(outbuf),(unsigned int)outpos);
                  bytes_out = (long)((ulg)bytes_out + (ulg)outpos);
                }
                outpos = 0;
              }
              stackp += i_0;
              i_0 = (char_type *)(& d_buf[0x8000 - 1]) - stackp;
              if (! (i_0 > 0)) break;
            }
          else {
            memcpy((void *)(& outbuf[outpos]),(void const *)stackp,
                   (size_t)i_0);
            outpos += i_0;
          }
        }
        code = free_ent;
        ;
        if (code < maxmaxcode) {
          prev[code] = (unsigned short)oldcode;
          window[code] = (char_type)finchar;
          free_ent = code + (code_int)1;
        }
        oldcode = incode;
      }
    }
    if (! (rsize != 0)) break;
  }
  if (! test) 
    if (outpos > 0) {
      write_buf(out,(voidp)(outbuf),(unsigned int)outpos);
      bytes_out = (long)((ulg)bytes_out + (ulg)outpos);
    }
  __retres = 0;
  return_label: return __retres;
}

static ulg orig_len;
static int max_len;
static uch literal[256];
static int lit_base[25 + 1];
static int leaves[25 + 1];
static int parents[25 + 1];
static int peek_bits;
static ulg bitbuf;
static int valid;
static void read_tree(void);

static void build_tree_0(void);

static void read_tree(void)
{
  int len;
  int base;
  int n;
  int tmp_4;
  orig_len = (ulg)0;
  n = 1;
  while (n <= 4) {
    int tmp_1;
    if (inptr < insize) {
      unsigned int tmp;
      tmp = inptr;
      inptr ++;
      tmp_1 = (int)inbuf[tmp];
    }
    else tmp_1 = fill_inbuf(0);
    orig_len = (orig_len << 8) | (ulg)tmp_1;
    n ++;
  }
  if (inptr < insize) {
    unsigned int tmp_2;
    tmp_2 = inptr;
    inptr ++;
    tmp_4 = (int)inbuf[tmp_2];
  }
  else tmp_4 = fill_inbuf(0);
  max_len = tmp_4;
  if (max_len > 25) error((char *)"invalid compressed data -- Huffman code > 32 bits");
  n = 0;
  len = 1;
  while (len <= max_len) {
    {
      int tmp_7;
      if (inptr < insize) {
        unsigned int tmp_5;
        tmp_5 = inptr;
        inptr ++;
        tmp_7 = (int)inbuf[tmp_5];
      }
      else tmp_7 = fill_inbuf(0);
      leaves[len] = tmp_7;
      n += leaves[len];
    }
    len ++;
  }
  if (n > 256) error((char *)"too many leaves in Huffman tree");
  (leaves[max_len]) ++;
  base = 0;
  len = 1;
  while (len <= max_len) {
    lit_base[len] = base;
    n = leaves[len];
    while (n > 0) {
      {
        int tmp_8;
        int tmp_11;
        tmp_8 = base;
        base ++;
        if (inptr < insize) {
          unsigned int tmp_9;
          tmp_9 = inptr;
          inptr ++;
          tmp_11 = (int)inbuf[tmp_9];
        }
        else tmp_11 = fill_inbuf(0);
        literal[tmp_8] = (uch)tmp_11;
      }
      n --;
    }
    len ++;
  }
  (leaves[max_len]) ++;
  return;
}

static void build_tree_0(void)
{
  int len;
  uch *prefixp;
  int nodes = 0;
  len = max_len;
  while (len >= 1) {
    nodes >>= 1;
    parents[len] = nodes;
    lit_base[len] -= nodes;
    nodes += leaves[len];
    len --;
  }
  if (max_len <= 12) peek_bits = max_len; else peek_bits = 12;
  prefixp = & outbuf[1 << peek_bits];
  len = 1;
  while (len <= peek_bits) {
    {
      int prefixes = leaves[len] << (peek_bits - len);
      while (1) {
        int tmp;
        tmp = prefixes;
        prefixes --;
        ;
        if (! tmp) break;
        prefixp --;
        *prefixp = (uch)len;
      }
    }
    len ++;
  }
  while (prefixp > outbuf) {
    prefixp --;
    *prefixp = (uch)0;
  }
  return;
}

int unpack(int in, int out) __attribute__((__FC_OLDSTYLEPROTO__));
int unpack(int in, int out)
{
  int __retres;
  int len;
  unsigned int eob;
  register unsigned int peek;
  unsigned int peek_mask;
  ifd = in;
  ofd = out;
  read_tree();
  build_tree_0();
  valid = 0;
  bitbuf = (ulg)0;
  peek_mask = (unsigned int)((1 << peek_bits) - 1);
  eob = (unsigned int)(leaves[max_len] - 1);
  while (1) {
    while (valid < peek_bits) {
      int tmp_1;
      if (inptr < insize) {
        unsigned int tmp;
        tmp = inptr;
        inptr ++;
        tmp_1 = (int)inbuf[tmp];
      }
      else tmp_1 = fill_inbuf(0);
      bitbuf = (bitbuf << 8) | (ulg)tmp_1;
      valid += 8;
    }
    peek = (unsigned int)((bitbuf >> (valid - peek_bits)) & (unsigned long)peek_mask);
    len = (int)outbuf[peek];
    if (len > 0) peek >>= peek_bits - len;
    else {
      ulg mask = (ulg)peek_mask;
      len = peek_bits;
      while (1) {
        len ++;
        mask = (mask << 1) + (ulg)1;
        while (valid < len) {
          int tmp_4;
          if (inptr < insize) {
            unsigned int tmp_2;
            tmp_2 = inptr;
            inptr ++;
            tmp_4 = (int)inbuf[tmp_2];
          }
          else tmp_4 = fill_inbuf(0);
          bitbuf = (bitbuf << 8) | (ulg)tmp_4;
          valid += 8;
        }
        peek = (unsigned int)((bitbuf >> (valid - len)) & mask);
        if (! (peek < (unsigned int)parents[len])) break;
      }
    }
    if (peek == eob) 
      if (len == max_len) break;
    {
      unsigned int tmp_5;
      tmp_5 = outcnt;
      outcnt ++;
      window[tmp_5] = literal[peek + (unsigned int)lit_base[len]];
      if (outcnt == (unsigned int)0x8000) flush_window();
    }
    valid -= len;
  }
  flush_window();
  if (orig_len != (ulg)bytes_out) error((char *)"invalid compressed data--length error");
  __retres = 0;
  return __retres;
}

static unsigned int decode(unsigned int count, uch *buffer) __attribute__((
__FC_OLDSTYLEPROTO__));

static void decode_start(void);

static void huf_decode_start(void);

static unsigned int decode_c(void);

static unsigned int decode_p(void);

static void read_pt_len(int nn, int nbit, int i_special) __attribute__((
__FC_OLDSTYLEPROTO__));

static void read_c_len(void);

static void fillbuf(int n) __attribute__((__FC_OLDSTYLEPROTO__));

static unsigned int getbits(int n) __attribute__((__FC_OLDSTYLEPROTO__));

static void init_getbits(void);

static void make_table(int nchar, uch *bitlen, int tablebits, ush *table) __attribute__((
__FC_OLDSTYLEPROTO__));

static uch pt_len[16 + 3];
static unsigned int blocksize;
static ush pt_table[256];
static ush bitbuf_0;
static unsigned int subbitbuf;
static int bitcount;
static void fillbuf(int n) __attribute__((__FC_OLDSTYLEPROTO__));
static void fillbuf(int n)
{
  bitbuf_0 = (ush)((int)bitbuf_0 << n);
  while (n > bitcount) {
    int tmp_1;
    n -= bitcount;
    bitbuf_0 = (ush)((unsigned int)bitbuf_0 | (subbitbuf << n));
    if (inptr < insize) {
      unsigned int tmp;
      tmp = inptr;
      inptr ++;
      tmp_1 = (int)inbuf[tmp];
    }
    else tmp_1 = fill_inbuf(1);
    subbitbuf = (unsigned int)tmp_1;
    if ((int)subbitbuf == -1) subbitbuf = (unsigned int)0;
    bitcount = 8;
  }
  bitcount -= n;
  bitbuf_0 = (ush)((unsigned int)bitbuf_0 | (subbitbuf >> bitcount));
  return;
}

static unsigned int getbits(int n) __attribute__((__FC_OLDSTYLEPROTO__));
static unsigned int getbits(int n)
{
  unsigned int x;
  x = (unsigned int)((int)bitbuf_0 >> ((unsigned int)(8 * 2) * sizeof(char) - (unsigned int)n));
  fillbuf(n);
  return x;
}

static void init_getbits(void)
{
  bitbuf_0 = (ush)0;
  subbitbuf = (unsigned int)0;
  bitcount = 0;
  fillbuf((int)((unsigned int)(8 * 2) * sizeof(char)));
  return;
}

static void make_table(int nchar, uch *bitlen, int tablebits, ush *table) __attribute__((
__FC_OLDSTYLEPROTO__));
static void make_table(int nchar, uch *bitlen, int tablebits, ush *table)
{
  ush count[17];
  ush weight[17];
  ush start[18];
  ush *p;
  unsigned int i;
  unsigned int k;
  unsigned int len;
  unsigned int ch;
  unsigned int jutbits;
  unsigned int avail;
  unsigned int nextcode;
  unsigned int mask;
  i = (unsigned int)1;
  while (i <= (unsigned int)16) {
    count[i] = (ush)0;
    i ++;
  }
  i = (unsigned int)0;
  while (i < (unsigned int)nchar) {
    count[*(bitlen + i)] = (ush)((int)count[*(bitlen + i)] + 1);
    i ++;
  }
  start[1] = (ush)0;
  i = (unsigned int)1;
  while (i <= (unsigned int)16) {
    start[i + (unsigned int)1] = (ush)((int)start[i] + ((int)count[i] << (
                                                        (unsigned int)16 - i)));
    i ++;
  }
  if (((int)start[17] & 0xffff) != 0) error((char *)"Bad table\n");
  jutbits = (unsigned int)(16 - tablebits);
  i = (unsigned int)1;
  while (i <= (unsigned int)tablebits) {
    start[i] = (ush)((int)start[i] >> jutbits);
    weight[i] = (ush)((unsigned int)1 << ((unsigned int)tablebits - i));
    i ++;
  }
  while (i <= (unsigned int)16) {
    weight[i] = (ush)((unsigned int)1 << ((unsigned int)16 - i));
    i ++;
  }
  i = (unsigned int)((int)start[tablebits + 1] >> jutbits);
  if (i != (unsigned int)0) {
    k = (unsigned int)(1 << tablebits);
    while (i != k) {
      unsigned int tmp;
      tmp = i;
      i ++;
      *(table + tmp) = (ush)0;
    }
  }
  avail = (unsigned int)nchar;
  mask = (unsigned int)1 << (15 - tablebits);
  ch = (unsigned int)0;
  while (ch < (unsigned int)nchar) {
    len = (unsigned int)*(bitlen + ch);
    if (len == (unsigned int)0) goto __Cont;
    nextcode = (unsigned int)((int)start[len] + (int)weight[len]);
    if (len <= (unsigned int)tablebits) {
      i = (unsigned int)start[len];
      while (i < nextcode) {
        *(table + i) = (ush)ch;
        i ++;
      }
    }
    else {
      k = (unsigned int)start[len];
      p = table + (k >> jutbits);
      i = len - (unsigned int)tablebits;
      while (i != (unsigned int)0) {
        if ((int)*p == 0) {
          ush tmp_0;
          unsigned int tmp_1;
          tmp_0 = (ush)0;
          prev[avail] = tmp_0;
          *(& prev[0x8000] + avail) = tmp_0;
          tmp_1 = avail;
          avail ++;
          *p = (ush)tmp_1;
        }
        if (k & mask) p = & prev[0x8000] + *p; else p = & prev[*p];
        k <<= 1;
        i --;
      }
      *p = (ush)ch;
    }
    start[len] = (ush)nextcode;
    __Cont: ch ++;
  }
  return;
}

static void read_pt_len(int nn, int nbit, int i_special) __attribute__((
__FC_OLDSTYLEPROTO__));
static void read_pt_len(int nn, int nbit, int i_special)
{
  int i;
  int c;
  int n;
  unsigned int mask;
  unsigned int tmp;
  tmp = getbits(nbit);
  n = (int)tmp;
  if (n == 0) {
    unsigned int tmp_0;
    tmp_0 = getbits(nbit);
    c = (int)tmp_0;
    i = 0;
    while (i < nn) {
      pt_len[i] = (uch)0;
      i ++;
    }
    i = 0;
    while (i < 256) {
      pt_table[i] = (ush)c;
      i ++;
    }
  }
  else {
    i = 0;
    while (i < n) {
      int tmp_1;
      int tmp_2;
      c = (int)bitbuf_0 >> ((unsigned int)(8 * 2) * sizeof(char) - (unsigned int)3);
      if (c == 7) {
        mask = (unsigned int)1 << (((unsigned int)(8 * 2) * sizeof(char) - (unsigned int)1) - (unsigned int)3);
        while (mask & (unsigned int)bitbuf_0) {
          mask >>= 1;
          c ++;
        }
      }
      if (c < 7) tmp_1 = 3; else tmp_1 = c - 3;
      fillbuf(tmp_1);
      tmp_2 = i;
      i ++;
      pt_len[tmp_2] = (uch)c;
      if (i == i_special) {
        unsigned int tmp_3;
        tmp_3 = getbits(2);
        c = (int)tmp_3;
        while (1) {
          int tmp_4;
          c --;
          if (! (c >= 0)) break;
          tmp_4 = i;
          i ++;
          pt_len[tmp_4] = (uch)0;
        }
      }
    }
    while (i < nn) {
      int tmp_5;
      tmp_5 = i;
      i ++;
      pt_len[tmp_5] = (uch)0;
    }
    make_table(nn,pt_len,8,pt_table);
  }
  return;
}

static void read_c_len(void)
{
  int i;
  int c;
  int n;
  unsigned int mask;
  unsigned int tmp;
  tmp = getbits(9);
  n = (int)tmp;
  if (n == 0) {
    unsigned int tmp_0;
    tmp_0 = getbits(9);
    c = (int)tmp_0;
    i = 0;
    while ((unsigned int)i < ((255U + (unsigned int)256) + (unsigned int)2) - (unsigned int)3) {
      outbuf[i] = (uch)0;
      i ++;
    }
    i = 0;
    while (i < 4096) {
      d_buf[i] = (ush)c;
      i ++;
    }
  }
  else {
    i = 0;
    while (i < n) {
      c = (int)pt_table[(int)bitbuf_0 >> ((unsigned int)(8 * 2) * sizeof(char) - (unsigned int)8)];
      if (c >= 16 + 3) {
        mask = (unsigned int)1 << (((unsigned int)(8 * 2) * sizeof(char) - (unsigned int)1) - (unsigned int)8);
        while (1) {
          if ((unsigned int)bitbuf_0 & mask) c = (int)*(& prev[0x8000] + c);
          else c = (int)prev[c];
          mask >>= 1;
          if (! (c >= 16 + 3)) break;
        }
      }
      fillbuf((int)pt_len[c]);
      if (c <= 2) {
        if (c == 0) c = 1;
        else 
          if (c == 1) {
            unsigned int tmp_1;
            tmp_1 = getbits(4);
            c = (int)(tmp_1 + (unsigned int)3);
          }
          else {
            unsigned int tmp_2;
            tmp_2 = getbits(9);
            c = (int)(tmp_2 + (unsigned int)20);
          }
        while (1) {
          int tmp_3;
          c --;
          if (! (c >= 0)) break;
          tmp_3 = i;
          i ++;
          outbuf[tmp_3] = (uch)0;
        }
      }
      else {
        int tmp_4;
        tmp_4 = i;
        i ++;
        outbuf[tmp_4] = (uch)(c - 2);
      }
    }
    while ((unsigned int)i < ((255U + (unsigned int)256) + (unsigned int)2) - (unsigned int)3) {
      int tmp_5;
      tmp_5 = i;
      i ++;
      outbuf[tmp_5] = (uch)0;
    }
    make_table((int)(((255U + (unsigned int)256) + (unsigned int)2) - (unsigned int)3),
               outbuf,12,d_buf);
  }
  return;
}

static unsigned int decode_c(void)
{
  unsigned int __retres;
  unsigned int j_0;
  unsigned int mask;
  if (blocksize == (unsigned int)0) {
    blocksize = getbits(16);
    if (blocksize == (unsigned int)0) {
      __retres = ((255U + (unsigned int)256) + (unsigned int)2) - (unsigned int)3;
      goto return_label;
    }
    read_pt_len(16 + 3,5,3);
    read_c_len();
    read_pt_len(13 + 1,4,-1);
  }
  blocksize --;
  j_0 = (unsigned int)d_buf[(int)bitbuf_0 >> ((unsigned int)(8 * 2) * sizeof(char) - (unsigned int)12)];
  if (j_0 >= ((255U + (unsigned int)256) + (unsigned int)2) - (unsigned int)3) {
    mask = (unsigned int)1 << (((unsigned int)(8 * 2) * sizeof(char) - (unsigned int)1) - (unsigned int)12);
    while (1) {
      if ((unsigned int)bitbuf_0 & mask) j_0 = (unsigned int)*(& prev[0x8000] + j_0);
      else j_0 = (unsigned int)prev[j_0];
      mask >>= 1;
      if (! (j_0 >= ((255U + (unsigned int)256) + (unsigned int)2) - (unsigned int)3)) 
        break;
    }
  }
  fillbuf((int)outbuf[j_0]);
  __retres = j_0;
  return_label: return __retres;
}

static unsigned int decode_p(void)
{
  unsigned int j_0;
  unsigned int mask;
  j_0 = (unsigned int)pt_table[(int)bitbuf_0 >> ((unsigned int)(8 * 2) * sizeof(char) - (unsigned int)8)];
  if (j_0 >= (unsigned int)(13 + 1)) {
    mask = (unsigned int)1 << (((unsigned int)(8 * 2) * sizeof(char) - (unsigned int)1) - (unsigned int)8);
    while (1) {
      if ((unsigned int)bitbuf_0 & mask) j_0 = (unsigned int)*(& prev[0x8000] + j_0);
      else j_0 = (unsigned int)prev[j_0];
      mask >>= 1;
      if (! (j_0 >= (unsigned int)(13 + 1))) break;
    }
  }
  fillbuf((int)pt_len[j_0]);
  if (j_0 != (unsigned int)0) {
    unsigned int tmp;
    tmp = getbits((int)(j_0 - (unsigned int)1));
    j_0 = ((unsigned int)1 << (j_0 - (unsigned int)1)) + tmp;
  }
  return j_0;
}

static void huf_decode_start(void)
{
  init_getbits();
  blocksize = (unsigned int)0;
  return;
}

static int j;
static int done;
static void decode_start(void)
{
  huf_decode_start();
  j = 0;
  done = 0;
  return;
}

static unsigned int decode_i;
static unsigned int decode(unsigned int count, uch *buffer) __attribute__((
__FC_OLDSTYLEPROTO__));
static unsigned int decode(unsigned int count, uch *buffer)
{
  unsigned int __retres;
  unsigned int r;
  unsigned int c;
  r = (unsigned int)0;
  while (1) {
    j --;
    if (! (j >= 0)) break;
    *(buffer + r) = *(buffer + decode_i);
    decode_i = (decode_i + (unsigned int)1) & (((unsigned int)1 << 13) - (unsigned int)1);
    r ++;
    ;
    if (r == count) {
      __retres = r;
      goto return_label;
    }
  }
  while (1) {
    c = decode_c();
    if (c == ((255U + (unsigned int)256) + (unsigned int)2) - (unsigned int)3) {
      done = 1;
      __retres = r;
      goto return_label;
    }
    if (c <= 255U) {
      *(buffer + r) = (uch)c;
      r ++;
      ;
      if (r == count) {
        __retres = r;
        goto return_label;
      }
    }
    else {
      unsigned int tmp;
      j = (int)(c - ((255U + (unsigned int)1) - (unsigned int)3));
      tmp = decode_p();
      decode_i = ((r - tmp) - (unsigned int)1) & (((unsigned int)1 << 13) - (unsigned int)1);
      while (1) {
        j --;
        if (! (j >= 0)) break;
        *(buffer + r) = *(buffer + decode_i);
        decode_i = (decode_i + (unsigned int)1) & (((unsigned int)1 << 13) - (unsigned int)1);
        r ++;
        ;
        if (r == count) {
          __retres = r;
          goto return_label;
        }
      }
    }
  }
  return_label: return __retres;
}

int unlzh(int in, int out) __attribute__((__FC_OLDSTYLEPROTO__));
int unlzh(int in, int out)
{
  int __retres;
  unsigned int n;
  ifd = in;
  ofd = out;
  decode_start();
  while (! done) {
    n = decode((unsigned int)1 << 13,window);
    if (! test) 
      if (n > (unsigned int)0) write_buf(out,(voidp)(window),n);
  }
  __retres = 0;
  return __retres;
}

static char *nextchar;
static enum __anonenum_ordering_1 ordering;
static int my_strlen(char const *str)
{
  int n = 0;
  while (1) {
    char const *tmp;
    tmp = str;
    str ++;
    ;
    if (! *tmp) break;
    n ++;
  }
  return n;
}

static char *my_index(char const *str, int chr)
{
  char *__retres;
  while (*str) {
    if ((int)*str == chr) {
      __retres = (char *)str;
      goto return_label;
    }
    str ++;
  }
  __retres = (char *)0;
  return_label: return __retres;
}

static int first_nonopt;
static int last_nonopt;
static void exchange(char **argv) __attribute__((__FC_OLDSTYLEPROTO__));

static void exchange(char **argv) __attribute__((__FC_OLDSTYLEPROTO__));
static void exchange(char **argv)
{
  char *temp;
  char **first;
  char **last;
  first = argv + first_nonopt;
  last = argv + (optind - 1);
  while (first < last) {
    temp = *first;
    *first = *last;
    *last = temp;
    first ++;
    last --;
  }
  first = argv + first_nonopt;
  first_nonopt += optind - last_nonopt;
  last = argv + (first_nonopt - 1);
  while (first < last) {
    temp = *first;
    *first = *last;
    *last = temp;
    first ++;
    last --;
  }
  first = argv + first_nonopt;
  last_nonopt = optind;
  last = argv + (last_nonopt - 1);
  while (first < last) {
    temp = *first;
    *first = *last;
    *last = temp;
    first ++;
    last --;
  }
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_66(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_67(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param2);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param2 + (0 ..))),
            (indirect: param1), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param2 + (0 ..)), param1,
            *(param0 + (0 ..));
 */
int fprintf_va_68(FILE * restrict stream, char const * restrict format,
                  char *param0, int param1, char *param2);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_69(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_70(FILE * restrict stream, char const * restrict format,
                  char *param0, char *param1);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param2);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param2 + (0 ..))),
            (indirect: param1), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param2 + (0 ..)), param1,
            *(param0 + (0 ..));
 */
int fprintf_va_71(FILE * restrict stream, char const * restrict format,
                  char *param0, int param1, char *param2);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param1, *(param0 + (0 ..));
 */
int fprintf_va_72(FILE * restrict stream, char const * restrict format,
                  char *param0, int param1);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param1, *(param0 + (0 ..));
 */
int fprintf_va_73(FILE * restrict stream, char const * restrict format,
                  char *param0, int param1);

int _getopt_internal(int argc, char * const *argv, char const *optstring,
                     struct option const *longopts_0, int *longind,
                     int long_only) __attribute__((__FC_OLDSTYLEPROTO__));
int _getopt_internal(int argc, char * const *argv, char const *optstring,
                     struct option const *longopts_0, int *longind,
                     int long_only)
{
  int __retres;
  int option_index;
  optarg = (char *)0;
  if (optind == 0) {
    optind = 1;
    last_nonopt = optind;
    first_nonopt = last_nonopt;
    nextchar = (char *)0;
    if ((int)*(optstring + 0) == '-') {
      ordering = RETURN_IN_ORDER;
      optstring ++;
    }
    else 
      if ((int)*(optstring + 0) == '+') {
        ordering = REQUIRE_ORDER;
        optstring ++;
      }
      else {
        char *tmp;
        tmp = getenv("POSIXLY_CORRECT");
        if (tmp != (char *)0) ordering = REQUIRE_ORDER;
        else ordering = PERMUTE;
      }
  }
  if (nextchar == (char *)0) goto _LOR_0;
  else 
    if ((int)*nextchar == '\000') {
      _LOR_0:
      {
        int tmp_2;
        if (ordering == (unsigned int)PERMUTE) {
          if (first_nonopt != last_nonopt) {
            if (last_nonopt != optind) exchange((char **)argv);
            else goto _LAND;
          }
          else {
            _LAND: ;
            if (last_nonopt != optind) first_nonopt = optind;
          }
          while (1) {
            if (optind < argc) {
              if (! ((int)*(*(argv + optind) + 0) != '-')) 
                if (! ((int)*(*(argv + optind) + 1) == '\000')) break;
            }
            else break;
            optind ++;
          }
          last_nonopt = optind;
        }
        if (optind != argc) {
          int tmp_0;
          tmp_0 = strcmp((char const *)*(argv + optind),"--");
          if (! tmp_0) {
            optind ++;
            if (first_nonopt != last_nonopt) {
              if (last_nonopt != optind) exchange((char **)argv);
              else goto _LAND_0;
            }
            else {
              _LAND_0: ;
              if (first_nonopt == last_nonopt) first_nonopt = optind;
            }
            last_nonopt = argc;
            optind = argc;
          }
        }
        if (optind == argc) {
          if (first_nonopt != last_nonopt) optind = first_nonopt;
          __retres = -1;
          goto return_label;
        }
        if ((int)*(*(argv + optind) + 0) != '-') goto _LOR;
        else 
          if ((int)*(*(argv + optind) + 1) == '\000') {
            _LOR:
            {
              int tmp_1;
              if (ordering == (unsigned int)REQUIRE_ORDER) {
                __retres = -1;
                goto return_label;
              }
              tmp_1 = optind;
              optind ++;
              optarg = *(argv + tmp_1);
              __retres = 1;
              goto return_label;
            }
          }
        if (longopts_0 != (struct option const *)0) 
          if ((int)*(*(argv + optind) + 1) == '-') tmp_2 = 1; else tmp_2 = 0;
        else tmp_2 = 0;
        nextchar = (*(argv + optind) + 1) + tmp_2;
      }
    }
  if (longopts_0 != (struct option const *)0) 
    if ((int)*(*(argv + optind) + 0) == '-') 
      if ((int)*(*(argv + optind) + 1) == '-') goto _LOR_2;
      else 
        if (long_only) {
          _LOR_2:
          {
            struct option const *p;
            char *s = nextchar;
            int exact = 0;
            int ambig = 0;
            struct option const *pfound = (struct option const *)0;
            int indfound = 0;
            while (1) {
              if (*s) {
                if (! ((int)*s != '=')) break;
              }
              else break;
              s ++;
            }
            p = longopts_0;
            option_index = 0;
            while (p->name) {
              int tmp_4;
              tmp_4 = strncmp(p->name,(char const *)nextchar,
                              (size_t)(s - nextchar));
              if (! tmp_4) {
                int tmp_3;
                tmp_3 = my_strlen(p->name);
                ;
                if (s - nextchar == tmp_3) {
                  pfound = p;
                  indfound = option_index;
                  exact = 1;
                  break;
                }
                else 
                  if (pfound == (struct option const *)0) {
                    pfound = p;
                    indfound = option_index;
                  }
                  else ambig = 1;
              }
              p ++;
              option_index ++;
            }
            if (ambig) 
              if (! exact) {
                int tmp_5;
                if (opterr) fprintf(__fc_stderr,
                                    "%s: option `%s\' is ambiguous\n",
                                    *(argv + 0),*(argv + optind)); /* fprintf_va_66 */
                tmp_5 = my_strlen((char const *)nextchar);
                nextchar += tmp_5;
                optind ++;
                __retres = '\000';
                goto return_label;
              }
            if (pfound != (struct option const *)0) {
              int tmp_10;
              option_index = indfound;
              optind ++;
              if (*s) 
                if (pfound->has_arg) optarg = s + 1;
                else {
                  int tmp_6;
                  if (opterr) 
                    if ((int)*(*(argv + (optind - 1)) + 1) == '-') fprintf
                                                                   (__fc_stderr,
                                                                    "%s: option `--%s\' doesn\'t allow an argument\n",
                                                                    *(
                                                                    argv + 0),
                                                                    (char *)pfound->name); /* fprintf_va_67 */
                    else fprintf(__fc_stderr,
                                 "%s: option `%c%s\' doesn\'t allow an argument\n",
                                 *(argv + 0),
                                 (int)*(*(argv + (optind - 1)) + 0),
                                 (char *)pfound->name); /* fprintf_va_68 */
                  tmp_6 = my_strlen((char const *)nextchar);
                  nextchar += tmp_6;
                  __retres = '\000';
                  goto return_label;
                }
              else 
                if (pfound->has_arg == 1) 
                  if (optind < argc) {
                    int tmp_7;
                    tmp_7 = optind;
                    optind ++;
                    optarg = *(argv + tmp_7);
                  }
                  else {
                    int tmp_8;
                    int tmp_9;
                    if (opterr) fprintf(__fc_stderr,
                                        "%s: option `%s\' requires an argument\n",
                                        *(argv + 0),*(argv + (optind - 1))); /* fprintf_va_69 */
                    tmp_8 = my_strlen((char const *)nextchar);
                    nextchar += tmp_8;
                    if ((int)*(optstring + 0) == ':') tmp_9 = ':';
                    else tmp_9 = '\000';
                    __retres = tmp_9;
                    goto return_label;
                  }
              tmp_10 = my_strlen((char const *)nextchar);
              nextchar += tmp_10;
              if (longind != (int *)0) *longind = option_index;
              if (pfound->flag) {
                *(pfound->flag) = pfound->val;
                __retres = 0;
                goto return_label;
              }
              __retres = pfound->val;
              goto return_label;
            }
            if (! long_only) goto _LOR_1;
            else 
              if ((int)*(*(argv + optind) + 1) == '-') goto _LOR_1;
              else {
                char *tmp_11;
                tmp_11 = my_index(optstring,(int)*nextchar);
                if (tmp_11 == (char *)0) {
                  _LOR_1:
                  {
                    if (opterr) 
                      if ((int)*(*(argv + optind) + 1) == '-') fprintf
                                                               (__fc_stderr,
                                                                "%s: unrecognized option `--%s\'\n",
                                                                *(argv + 0),
                                                                nextchar); /* fprintf_va_70 */
                      else fprintf(__fc_stderr,
                                   "%s: unrecognized option `%c%s\'\n",
                                   *(argv + 0),(int)*(*(argv + optind) + 0),
                                   nextchar); /* fprintf_va_71 */
                    nextchar = (char *)"";
                    optind ++;
                    __retres = '\000';
                    goto return_label;
                  }
                }
              }
          }
        }
  {
    char *tmp_12;
    tmp_12 = nextchar;
    nextchar ++;
    char c = *tmp_12;
    char *temp = my_index(optstring,(int)c);
    if ((int)*nextchar == '\000') optind ++;
    if (temp == (char *)0) goto _LOR_3;
    else 
      if ((int)c == ':') {
        _LOR_3:
        {
          if (opterr) fprintf(__fc_stderr,"%s: illegal option -- %c\n",
                              *(argv + 0),(int)c); /* fprintf_va_72 */
          optopt = (int)c;
          __retres = '\000';
          goto return_label;
        }
      }
    if ((int)*(temp + 1) == ':') 
      if ((int)*(temp + 2) == ':') {
        if ((int)*nextchar != '\000') {
          optarg = nextchar;
          optind ++;
        }
        else optarg = (char *)0;
        nextchar = (char *)0;
      }
      else {
        if ((int)*nextchar != '\000') {
          optarg = nextchar;
          optind ++;
        }
        else 
          if (optind == argc) {
            if (opterr) fprintf(__fc_stderr,
                                "%s: option requires an argument -- %c\n",
                                *(argv + 0),(int)c); /* fprintf_va_73 */
            optopt = (int)c;
            if ((int)*(optstring + 0) == ':') c = (char)':';
            else c = (char)'\000';
          }
          else {
            int tmp_14;
            tmp_14 = optind;
            optind ++;
            optarg = *(argv + tmp_14);
          }
        nextchar = (char *)0;
      }
    __retres = (int)c;
    return_label: return __retres;
  }
}

int getopt_long(int argc, char * const *argv, char const *options,
                struct option const *long_options, int *opt_index) __attribute__((
__FC_OLDSTYLEPROTO__));
int getopt_long(int argc, char * const *argv, char const *options,
                struct option const *long_options, int *opt_index)
{
  int tmp;
  tmp = _getopt_internal(argc,argv,options,long_options,opt_index,0);
  return tmp;
}

int eva_main(void)
{
  char argv0[256];
  char argv1[256];
  char argv2[256];
  char argv3[256];
  char argv4[256];
  int tmp_0;
  int argc = Frama_C_interval(0,5);
  char *argv[6] = {argv0, argv1, argv2, argv3, argv4, (char *)0};
  {
    int i = 0;
    /*@ loop unroll 5; */
    while (i < 5) {
      Frama_C_make_unknown(argv[i],(size_t)255);
      *(argv[i] + 255) = (char)0;
      i ++;
    }
  }
  tmp_0 = main(argc,argv);
  return tmp_0;
}


