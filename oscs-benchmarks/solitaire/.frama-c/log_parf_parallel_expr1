Entering directory '/Users/carolt/Abstract_Interpretation/Tools_Development/Frama-c-Plugin/src/demo_1'
Leaving directory '/Users/carolt/Abstract_Interpretation/Tools_Development/Frama-c-Plugin/src/demo_1'
[kernel] Parsing solitaire.c (with preprocessing)
mkdir: .parf_temp_files: File exists
rm: .parf_temp_files/*.sav: No such file or directory
[parf] checkout project: project "default"
[parf] init parameters: -eva-widening-delay 1 -eva-subdivide-non-linear 0 -eva-slevel 0 -eva-plevel 10 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 8 -eva-equality-through-calls none -eva-domains cvalue -eva-auto-loop-unroll 0
[parf] run eva: start
[parf] set eva options
[parf] parameters: -eva-widening-delay 1 -eva-subdivide-non-linear 0 -eva-slevel 0 -eva-plevel 10 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 8 -eva-equality-through-calls none -eva-domains cvalue -eva-auto-loop-unroll 0
[parf] @default,cvalue
[eva] Analyzing a complete application starting at main
[eva] using specification for function printf_va_3
[eva] using specification for function strcmp
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] using specification for function printf_va_4
[eva] using specification for function exit
[eva] using specification for function __FC_assert
[eva] solitaire.c:128: starting to merge loop iterations
[eva] solitaire.c:131: starting to merge loop iterations
[eva] using specification for function putchar
[eva] solitaire.c:185: Trace partitioning superposing up to 100 states
[eva] using specification for function printf_va_1
[eva] solitaire.c:213: starting to merge loop iterations
[eva] solitaire.c:107: starting to merge loop iterations
[eva] solitaire.c:111: starting to merge loop iterations
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:117: starting to merge loop iterations
[eva] solitaire.c:124: starting to merge loop iterations
[eva] solitaire.c:134: starting to merge loop iterations
[eva] solitaire.c:146: starting to merge loop iterations
[eva] solitaire.c:149: starting to merge loop iterations
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:156: starting to merge loop iterations
[eva] solitaire.c:219: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:97: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 200 states
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  4 functions analyzed (out of 6): 66% coverage.
  In these functions, 336 statements reached (out of 377): 89% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  216 alarms generated by the analysis:
     134 integer overflows
      68 invalid memory accesses
      14 others
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     5 valid     9 unknown     0 invalid     14 total
  35% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[parf] base: base00
[parf] Analysis time for this epoch: 180
[parf] sample: base00-sample00
[parf] sample: base00-sample01
[parf] sample: base00-sample02
[parf] sample: base00-sample03
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 2 -eva-subdivide-non-linear 3 -eva-slevel 9 -eva-plevel 33 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 17 -eva-equality-through-calls formals -eva-domains cvalue,equality,octagon -eva-auto-loop-unroll 10
[parf] parameters: -eva-widening-delay 2 -eva-subdivide-non-linear 6 -eva-split-return auto -eva-slevel 13 -eva-remove-redundant-alarms -eva-plevel 21 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 22 -eva-equality-through-calls none -eva-domains cvalue,gauges,octagon -eva-auto-loop-unroll 16
[parf] set eva options
[parf] parameters: -eva-widening-delay 2 -eva-subdivide-non-linear 5 -eva-slevel 12 -eva-plevel 35 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 18 -eva-equality-through-calls formals -eva-domains cvalue,gauges -eva-auto-loop-unroll 12
[parf] parameters: -eva-widening-delay 2 -eva-subdivide-non-linear 4 -eva-slevel 10 -eva-remove-redundant-alarms -eva-plevel 35 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 16 -eva-equality-through-calls formals -eva-domains cvalue,symbolic-locations -eva-auto-loop-unroll 11
[parf] @default,cvalue,symbolic-locations
[parf] @default,cvalue,gauges
[parf] @default,cvalue,equality,octagon
[parf] @default,cvalue,gauges,octagon
[eva] Splitting return states on:
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] Analyzing a complete application starting at main
[eva] using specification for function printf_va_3
[eva] using specification for function strcmp
[eva] using specification for function strcmp
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] using specification for function strcmp
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_3
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] using specification for function exit
[eva] using specification for function exit
[eva] using specification for function strcmp
[eva] using specification for function printf_va_4
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] using specification for function exit
[eva] using specification for function printf_va_4
[eva] using specification for function exit
[eva] using specification for function __FC_assert
[eva] using specification for function __FC_assert
[eva] solitaire.c:131: starting to merge loop iterations
[eva] using specification for function __FC_assert
[eva] solitaire.c:131: starting to merge loop iterations
[eva] using specification for function __FC_assert
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:107: starting to merge loop iterations
[eva] solitaire.c:107: starting to merge loop iterations
[eva] solitaire.c:111: starting to merge loop iterations
[eva] solitaire.c:111: starting to merge loop iterations
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:117: starting to merge loop iterations
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:124: starting to merge loop iterations
[eva] solitaire.c:107: starting to merge loop iterations
[eva] solitaire.c:117: starting to merge loop iterations
[eva] solitaire.c:107: starting to merge loop iterations
[eva] solitaire.c:128: starting to merge loop iterations
[eva] solitaire.c:124: starting to merge loop iterations
[eva] solitaire.c:128: starting to merge loop iterations
[eva] solitaire.c:134: starting to merge loop iterations
[eva] solitaire.c:111: starting to merge loop iterations
[eva] solitaire.c:111: starting to merge loop iterations
[eva] solitaire.c:146: starting to merge loop iterations
[eva] solitaire.c:149: starting to merge loop iterations
[eva] solitaire.c:134: starting to merge loop iterations
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:156: starting to merge loop iterations
[eva] solitaire.c:146: starting to merge loop iterations
[eva] solitaire.c:117: starting to merge loop iterations
[eva] solitaire.c:149: starting to merge loop iterations
[eva] solitaire.c:117: starting to merge loop iterations
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:156: starting to merge loop iterations
[eva] solitaire.c:124: starting to merge loop iterations
[eva] solitaire.c:124: starting to merge loop iterations
[eva] solitaire.c:219: starting to merge loop iterations
[eva] solitaire.c:128: starting to merge loop iterations
[eva] solitaire.c:128: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:97: starting to merge loop iterations
[eva] solitaire.c:134: starting to merge loop iterations
[eva] solitaire.c:100: starting to merge loop iterations
[eva] solitaire.c:219: starting to merge loop iterations
[eva] solitaire.c:134: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:146: starting to merge loop iterations
[eva] solitaire.c:146: starting to merge loop iterations
[eva] solitaire.c:97: starting to merge loop iterations
[eva] solitaire.c:149: starting to merge loop iterations
[eva] solitaire.c:149: starting to merge loop iterations
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:100: starting to merge loop iterations
[eva] solitaire.c:156: starting to merge loop iterations
[eva] solitaire.c:156: starting to merge loop iterations
[eva] solitaire.c:219: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:219: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 200 states
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:100: starting to merge loop iterations
[eva] solitaire.c:100: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 200 states
[eva] solitaire.c:219: Trace partitioning superposing up to 300 states
[eva] solitaire.c:219: Trace partitioning superposing up to 400 states
[eva] solitaire.c:219: Trace partitioning superposing up to 300 states
[eva] solitaire.c:213: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 500 states
[eva] solitaire.c:213: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 400 states
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[eva] solitaire.c:219: Trace partitioning superposing up to 500 states
[eva] solitaire.c:219: Trace partitioning superposing up to 200 states
[eva] solitaire.c:213: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 200 states
[scope:rm_asserts] removing 17 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 321 statements reached (out of 364): 88% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  184 alarms generated by the analysis:
     104 integer overflows
      66 invalid memory accesses
      14 others
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     4 valid     8 unknown     0 invalid     12 total
  33% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] solitaire.c:219: Trace partitioning superposing up to 600 states
[eva] solitaire.c:219: Trace partitioning superposing up to 700 states
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 321 statements reached (out of 364): 88% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  212 alarms generated by the analysis:
     132 integer overflows
      66 invalid memory accesses
      14 others
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     4 valid     8 unknown     0 invalid     12 total
  33% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[scope:rm_asserts] removing 5 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 321 statements reached (out of 364): 88% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  21 alarms generated by the analysis:
      19 invalid memory accesses
       2 integer overflows
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     6 valid     6 unknown     0 invalid     12 total
  50% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] solitaire.c:219: Trace partitioning superposing up to 300 states
[eva] solitaire.c:219: Trace partitioning superposing up to 400 states
[eva] solitaire.c:213: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 500 states
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 321 statements reached (out of 364): 88% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  24 alarms generated by the analysis:
      22 invalid memory accesses
       2 integer overflows
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     5 valid     7 unknown     0 invalid     12 total
  41% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] sample base00-sample00: subset of base? true
[parf] sample base00-sample01: subset of base? true
[parf] sample base00-sample03: subset of base? true
[parf] sample base00-sample02: subset of base? true
[parf] base: base01
[parf] Analysis time for this epoch: 360
[parf] sample: base01-sample00
[parf] sample: base01-sample01
[parf] sample: base01-sample02
[parf] sample: base01-sample03
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 5 -eva-subdivide-non-linear 9 -eva-split-return auto -eva-slevel 25 -eva-remove-redundant-alarms -eva-plevel 43 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 34 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon -eva-auto-loop-unroll 33
[parf] parameters: -eva-widening-delay 4 -eva-subdivide-non-linear 8 -eva-split-return auto -eva-slevel 29 -eva-remove-redundant-alarms -eva-plevel 38 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 47 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 29
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 4 -eva-subdivide-non-linear 17 -eva-split-return auto -eva-slevel 29 -eva-remove-redundant-alarms -eva-plevel 43 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 50 -eva-equality-through-calls none -eva-domains cvalue,gauges,octagon -eva-auto-loop-unroll 29
[parf] parameters: -eva-widening-delay 3 -eva-subdivide-non-linear 15 -eva-split-return auto -eva-slevel 29 -eva-remove-redundant-alarms -eva-plevel 47 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 48 -eva-equality-through-calls formals -eva-domains cvalue,gauges,octagon -eva-auto-loop-unroll 30
[parf] @default,cvalue,gauges,octagon
[parf] @default,cvalue,equality,gauges,octagon
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,gauges,octagon
[eva] Splitting return states on:
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
[eva] Splitting return states on:
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
[eva] Splitting return states on:
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
[eva] Splitting return states on:
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function strcmp
[eva] using specification for function strcmp
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] using specification for function strcmp
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] using specification for function strcmp
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] using specification for function printf_va_4
[eva] using specification for function exit
[eva] using specification for function exit
[eva] using specification for function exit
[eva] using specification for function printf_va_4
[eva] using specification for function exit
[eva] using specification for function __FC_assert
[eva] using specification for function __FC_assert
[eva] using specification for function __FC_assert
[eva] using specification for function __FC_assert
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:107: starting to merge loop iterations
[eva] solitaire.c:107: starting to merge loop iterations
[eva] solitaire.c:107: starting to merge loop iterations
[eva] solitaire.c:107: starting to merge loop iterations
[eva] solitaire.c:111: starting to merge loop iterations
[eva] solitaire.c:117: starting to merge loop iterations
[eva] solitaire.c:117: starting to merge loop iterations
[eva] solitaire.c:124: starting to merge loop iterations
[eva] solitaire.c:124: starting to merge loop iterations
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:117: starting to merge loop iterations
[eva] solitaire.c:117: starting to merge loop iterations
[eva] solitaire.c:124: starting to merge loop iterations
[eva] solitaire.c:124: starting to merge loop iterations
[eva] solitaire.c:128: starting to merge loop iterations
[eva] solitaire.c:134: starting to merge loop iterations
[eva] solitaire.c:146: starting to merge loop iterations
[eva] solitaire.c:146: starting to merge loop iterations
[eva] solitaire.c:146: starting to merge loop iterations
[eva] solitaire.c:149: starting to merge loop iterations
[eva] solitaire.c:149: starting to merge loop iterations
[eva] solitaire.c:149: starting to merge loop iterations
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:156: starting to merge loop iterations
[eva] solitaire.c:219: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:219: starting to merge loop iterations
[eva] solitaire.c:219: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:100: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:100: starting to merge loop iterations
[eva] solitaire.c:100: starting to merge loop iterations
[eva] solitaire.c:146: starting to merge loop iterations
[eva] solitaire.c:111: starting to merge loop iterations
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:111: starting to merge loop iterations
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:128: starting to merge loop iterations
[eva] solitaire.c:149: starting to merge loop iterations
[eva] solitaire.c:128: starting to merge loop iterations
[eva] solitaire.c:134: starting to merge loop iterations
[eva] solitaire.c:134: starting to merge loop iterations
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:156: starting to merge loop iterations
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:156: starting to merge loop iterations
[eva] solitaire.c:219: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:100: starting to merge loop iterations
[eva] solitaire.c:111: starting to merge loop iterations
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:128: starting to merge loop iterations
[eva] solitaire.c:134: starting to merge loop iterations
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:156: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 200 states
[eva] solitaire.c:219: Trace partitioning superposing up to 200 states
[eva] solitaire.c:213: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 200 states
[eva] solitaire.c:219: Trace partitioning superposing up to 300 states
[eva] solitaire.c:219: Trace partitioning superposing up to 300 states
[eva] solitaire.c:219: Trace partitioning superposing up to 300 states
[eva] solitaire.c:219: Trace partitioning superposing up to 400 states
[eva] solitaire.c:213: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 400 states
[eva] solitaire.c:213: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 400 states
[eva] solitaire.c:219: Trace partitioning superposing up to 500 states
[eva] solitaire.c:219: Trace partitioning superposing up to 500 states
[eva] solitaire.c:219: Trace partitioning superposing up to 200 states
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[scope:rm_asserts] removing 5 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 321 statements reached (out of 364): 88% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  21 alarms generated by the analysis:
      19 invalid memory accesses
       2 integer overflows
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     6 valid     6 unknown     0 invalid     12 total
  50% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[scope:rm_asserts] removing 5 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 321 statements reached (out of 364): 88% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  21 alarms generated by the analysis:
      19 invalid memory accesses
       2 integer overflows
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     6 valid     6 unknown     0 invalid     12 total
  50% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] solitaire.c:219: Trace partitioning superposing up to 600 states
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[scope:rm_asserts] removing 5 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 321 statements reached (out of 364): 88% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  21 alarms generated by the analysis:
      19 invalid memory accesses
       2 integer overflows
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     6 valid     6 unknown     0 invalid     12 total
  50% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] solitaire.c:219: Trace partitioning superposing up to 300 states
[eva] solitaire.c:219: Trace partitioning superposing up to 400 states
[eva] solitaire.c:213: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 500 states
[eva] solitaire.c:219: Trace partitioning superposing up to 600 states
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[scope:rm_asserts] removing 5 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 321 statements reached (out of 364): 88% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  21 alarms generated by the analysis:
      19 invalid memory accesses
       2 integer overflows
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     6 valid     6 unknown     0 invalid     12 total
  50% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] sample base01-sample01: subset of base? true
[parf] sample base01-sample00: subset of base? true
[parf] sample base01-sample02: subset of base? true
[parf] sample base01-sample03: subset of base? true
[parf] base: base02
[parf] Analysis time for this epoch: 720
[parf] sample: base02-sample00
[parf] sample: base02-sample01
[parf] sample: base02-sample02
[parf] sample: base02-sample03
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 6 -eva-subdivide-non-linear 16 -eva-split-return auto -eva-slevel 50 -eva-remove-redundant-alarms -eva-plevel 69 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 62 -eva-equality-through-calls formals -eva-domains cvalue,gauges,octagon -eva-auto-loop-unroll 58
[parf] set eva options
[parf] parameters: -eva-widening-delay 4 -eva-subdivide-non-linear 13 -eva-split-return auto -eva-slevel 54 -eva-remove-redundant-alarms -eva-plevel 75 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 69 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 60
[parf] parameters: -eva-widening-delay 9 -eva-subdivide-non-linear 18 -eva-split-return auto -eva-slevel 50 -eva-remove-redundant-alarms -eva-plevel 72 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 63 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 62
[parf] parameters: -eva-widening-delay 6 -eva-subdivide-non-linear 23 -eva-split-return auto -eva-slevel 51 -eva-remove-redundant-alarms -eva-plevel 67 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 72 -eva-equality-through-calls formals -eva-domains cvalue,gauges,octagon -eva-auto-loop-unroll 57
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,gauges,octagon
[parf] @default,cvalue,gauges,octagon
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[eva] Splitting return states on:
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
[eva] Splitting return states on:
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
[eva] Splitting return states on:
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
[eva] Splitting return states on:
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function strcmp
[eva] using specification for function strcmp
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] using specification for function strcmp
[eva] using specification for function strcmp
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] using specification for function exit
[eva] using specification for function exit
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function exit
[eva] using specification for function exit
[eva] using specification for function __FC_assert
[eva] using specification for function __FC_assert
[eva] using specification for function __FC_assert
[eva] using specification for function __FC_assert
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:107: starting to merge loop iterations
[eva] solitaire.c:107: starting to merge loop iterations
[eva] solitaire.c:107: starting to merge loop iterations
[eva] solitaire.c:107: starting to merge loop iterations
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:117: starting to merge loop iterations
[eva] solitaire.c:117: starting to merge loop iterations
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:117: starting to merge loop iterations
[eva] solitaire.c:117: starting to merge loop iterations
[eva] solitaire.c:124: starting to merge loop iterations
[eva] solitaire.c:124: starting to merge loop iterations
[eva] solitaire.c:134: starting to merge loop iterations
[eva] solitaire.c:134: starting to merge loop iterations
[eva] solitaire.c:124: starting to merge loop iterations
[eva] solitaire.c:124: starting to merge loop iterations
[eva] solitaire.c:146: starting to merge loop iterations
[eva] solitaire.c:146: starting to merge loop iterations
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:156: starting to merge loop iterations
[eva] solitaire.c:153: Trace partitioning superposing up to 100 states
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:134: starting to merge loop iterations
[eva] solitaire.c:134: starting to merge loop iterations
[eva] solitaire.c:160: Trace partitioning superposing up to 100 states
[eva] solitaire.c:146: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:219: starting to merge loop iterations
[eva] solitaire.c:100: starting to merge loop iterations
[eva] solitaire.c:146: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:219: starting to merge loop iterations
[eva] solitaire.c:111: Trace partitioning superposing up to 100 states
[eva] solitaire.c:111: starting to merge loop iterations
[eva] solitaire.c:111: Trace partitioning superposing up to 100 states
[eva] solitaire.c:111: starting to merge loop iterations
[eva] solitaire.c:156: starting to merge loop iterations
[eva] solitaire.c:153: Trace partitioning superposing up to 100 states
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:128: starting to merge loop iterations
[eva] solitaire.c:156: starting to merge loop iterations
[eva] solitaire.c:160: Trace partitioning superposing up to 100 states
[eva] solitaire.c:128: starting to merge loop iterations
[eva] solitaire.c:149: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:219: starting to merge loop iterations
[eva] solitaire.c:100: starting to merge loop iterations
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:149: starting to merge loop iterations
[eva] solitaire.c:111: Trace partitioning superposing up to 100 states
[eva] solitaire.c:111: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[scope:rm_asserts] removing 5 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 285 statements reached (out of 364): 78% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  18 alarms generated by the analysis:
      17 invalid memory accesses
       1 integer overflow
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     4 valid     6 unknown     0 invalid     10 total
  40% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] solitaire.c:128: starting to merge loop iterations
[eva] solitaire.c:117: Trace partitioning superposing up to 100 states
[eva] solitaire.c:117: Trace partitioning superposing up to 100 states
[eva] solitaire.c:149: starting to merge loop iterations
[eva] solitaire.c:156: starting to merge loop iterations
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:131: Trace partitioning superposing up to 100 states
[eva] solitaire.c:131: Trace partitioning superposing up to 100 states
[eva] solitaire.c:131: Trace partitioning superposing up to 100 states
[eva] solitaire.c:219: Trace partitioning superposing up to 200 states
[eva] solitaire.c:219: Trace partitioning superposing up to 200 states
[eva] solitaire.c:219: Trace partitioning superposing up to 200 states
[eva] solitaire.c:219: Trace partitioning superposing up to 300 states
[eva] solitaire.c:219: Trace partitioning superposing up to 300 states
[eva] solitaire.c:100: starting to merge loop iterations
[eva] solitaire.c:213: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 400 states
[eva] solitaire.c:219: Trace partitioning superposing up to 400 states
[eva] solitaire.c:213: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 500 states
[eva] solitaire.c:219: Trace partitioning superposing up to 500 states
[eva] solitaire.c:219: Trace partitioning superposing up to 600 states
[eva] solitaire.c:219: Trace partitioning superposing up to 600 states
[eva] solitaire.c:219: Trace partitioning superposing up to 300 states
[eva] solitaire.c:219: Trace partitioning superposing up to 700 states
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[scope:rm_asserts] removing 5 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 321 statements reached (out of 364): 88% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  21 alarms generated by the analysis:
      19 invalid memory accesses
       2 integer overflows
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     6 valid     6 unknown     0 invalid     12 total
  50% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] solitaire.c:213: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 700 states
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[scope:rm_asserts] removing 5 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 321 statements reached (out of 364): 88% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  21 alarms generated by the analysis:
      19 invalid memory accesses
       2 integer overflows
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     6 valid     6 unknown     0 invalid     12 total
  50% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] solitaire.c:219: Trace partitioning superposing up to 400 states
[eva] solitaire.c:219: Trace partitioning superposing up to 500 states
[eva] solitaire.c:219: Trace partitioning superposing up to 600 states
[eva] solitaire.c:219: Trace partitioning superposing up to 700 states
[eva] solitaire.c:219: Trace partitioning superposing up to 800 states
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[scope:rm_asserts] removing 5 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 321 statements reached (out of 364): 88% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  21 alarms generated by the analysis:
      19 invalid memory accesses
       2 integer overflows
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     6 valid     6 unknown     0 invalid     12 total
  50% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] sample base02-sample00: subset of base? true
[parf] sample base02-sample01: subset of base? true
[parf] sample base02-sample03: subset of base? true
[parf] sample base02-sample02: subset of base? true
[parf] base: base03
[parf] Analysis time for this epoch: 1440
[parf] sample: base03-sample00
[parf] sample: base03-sample01
[parf] sample: base03-sample02
[parf] sample: base03-sample03
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 7 -eva-subdivide-non-linear 22 -eva-split-return auto -eva-slevel 103 -eva-remove-redundant-alarms -eva-plevel 140 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 134 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 128
[parf] set eva options
[parf] parameters: -eva-widening-delay 13 -eva-subdivide-non-linear 29 -eva-split-return auto -eva-slevel 104 -eva-remove-redundant-alarms -eva-plevel 155 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 139 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 104
[parf] set eva options
[parf] parameters: -eva-widening-delay 8 -eva-subdivide-non-linear 25 -eva-split-return auto -eva-slevel 108 -eva-remove-redundant-alarms -eva-plevel 155 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 133 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 109
[parf] parameters: -eva-widening-delay 7 -eva-subdivide-non-linear 22 -eva-split-return auto -eva-slevel 96 -eva-remove-redundant-alarms -eva-plevel 135 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 130 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 126
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[eva] Splitting return states on:
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
[eva] Splitting return states on:
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
[eva] Splitting return states on:
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
[eva] Splitting return states on:
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function strcmp
[eva] using specification for function strcmp
[eva] using specification for function strcmp
[eva] using specification for function strcmp
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function exit
[eva] using specification for function exit
[eva] using specification for function exit
[eva] using specification for function exit
[eva] using specification for function __FC_assert
[eva] using specification for function __FC_assert
[eva] using specification for function __FC_assert
[eva] using specification for function __FC_assert
[eva] solitaire.c:107: starting to merge loop iterations
[eva] solitaire.c:107: Trace partitioning superposing up to 100 states
[eva] solitaire.c:107: Trace partitioning superposing up to 100 states
[eva] solitaire.c:107: Trace partitioning superposing up to 100 states
[eva] solitaire.c:107: Trace partitioning superposing up to 100 states
[eva] solitaire.c:107: starting to merge loop iterations
[eva] solitaire.c:107: starting to merge loop iterations
[eva] solitaire.c:107: starting to merge loop iterations
[eva] solitaire.c:111: starting to merge loop iterations
[eva] solitaire.c:111: starting to merge loop iterations
[eva] solitaire.c:111: starting to merge loop iterations
[eva] solitaire.c:111: starting to merge loop iterations
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:117: starting to merge loop iterations
[eva] solitaire.c:117: starting to merge loop iterations
[eva] solitaire.c:117: starting to merge loop iterations
[eva] solitaire.c:124: starting to merge loop iterations
[eva] solitaire.c:124: starting to merge loop iterations
[eva] solitaire.c:124: starting to merge loop iterations
[eva] solitaire.c:124: starting to merge loop iterations
[eva] solitaire.c:128: starting to merge loop iterations
[eva] solitaire.c:128: starting to merge loop iterations
[eva] solitaire.c:128: starting to merge loop iterations
[eva] solitaire.c:128: starting to merge loop iterations
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:134: starting to merge loop iterations
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:134: starting to merge loop iterations
[eva] solitaire.c:134: starting to merge loop iterations
[eva] solitaire.c:134: starting to merge loop iterations
[eva] solitaire.c:146: starting to merge loop iterations
[eva] solitaire.c:146: starting to merge loop iterations
[eva] solitaire.c:146: starting to merge loop iterations
[eva] solitaire.c:146: starting to merge loop iterations
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:156: starting to merge loop iterations
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:156: starting to merge loop iterations
[eva] solitaire.c:156: starting to merge loop iterations
[eva] solitaire.c:156: starting to merge loop iterations
[eva] solitaire.c:160: Trace partitioning superposing up to 200 states
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[scope:rm_asserts] removing 5 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 285 statements reached (out of 364): 78% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  18 alarms generated by the analysis:
      17 invalid memory accesses
       1 integer overflow
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     4 valid     6 unknown     0 invalid     10 total
  40% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] solitaire.c:160: Trace partitioning superposing up to 300 states
[eva] solitaire.c:160: Trace partitioning superposing up to 300 states
[eva] solitaire.c:160: Trace partitioning superposing up to 300 states
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[scope:rm_asserts] removing 5 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 285 statements reached (out of 364): 78% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  18 alarms generated by the analysis:
      17 invalid memory accesses
       1 integer overflow
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     4 valid     6 unknown     0 invalid     10 total
  40% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[scope:rm_asserts] removing 5 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 285 statements reached (out of 364): 78% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  18 alarms generated by the analysis:
      17 invalid memory accesses
       1 integer overflow
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     4 valid     6 unknown     0 invalid     10 total
  40% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[scope:rm_asserts] removing 5 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 285 statements reached (out of 364): 78% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  18 alarms generated by the analysis:
      17 invalid memory accesses
       1 integer overflow
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     4 valid     6 unknown     0 invalid     10 total
  40% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] sample base03-sample01: subset of base? true
[parf] sample base03-sample00: subset of base? true
[parf] sample base03-sample02: subset of base? true
[parf] sample base03-sample03: subset of base? true
[parf] base: base04
[parf] Analysis time for this epoch: 1741
[parf] sample: base04-sample00
[parf] sample: base04-sample01
[parf] sample: base04-sample02
[parf] sample: base04-sample03
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 16 -eva-subdivide-non-linear 48 -eva-split-return auto -eva-slevel 191 -eva-remove-redundant-alarms -eva-plevel 262 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 270 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 216
[parf] set eva options
[parf] parameters: -eva-widening-delay 11 -eva-subdivide-non-linear 48 -eva-split-return auto -eva-slevel 194 -eva-remove-redundant-alarms -eva-plevel 277 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 246 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 202
[parf] parameters: -eva-widening-delay 12 -eva-subdivide-non-linear 44 -eva-split-return auto -eva-slevel 189 -eva-remove-redundant-alarms -eva-plevel 274 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 281 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 204
[parf] parameters: -eva-widening-delay 14 -eva-subdivide-non-linear 41 -eva-split-return auto -eva-slevel 190 -eva-remove-redundant-alarms -eva-plevel 274 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 245 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 201
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[eva] Splitting return states on:
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
[eva] Splitting return states on:
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
[eva] Splitting return states on:
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
[eva] Splitting return states on:
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function strcmp
[eva] using specification for function strcmp
[eva] using specification for function strcmp
[eva] using specification for function strcmp
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function exit
[eva] using specification for function exit
[eva] using specification for function exit
[eva] using specification for function exit
[eva] using specification for function __FC_assert
[eva] using specification for function __FC_assert
[eva] using specification for function __FC_assert
[eva] using specification for function __FC_assert
[eva] solitaire.c:107: Trace partitioning superposing up to 100 states
[eva] solitaire.c:107: Trace partitioning superposing up to 100 states
[eva] solitaire.c:107: Trace partitioning superposing up to 100 states
[eva] solitaire.c:107: Trace partitioning superposing up to 100 states
[eva] solitaire.c:111: Trace partitioning superposing up to 200 states
[eva] solitaire.c:111: Trace partitioning superposing up to 200 states
[eva] solitaire.c:111: starting to merge loop iterations
[eva] solitaire.c:111: starting to merge loop iterations
[eva] solitaire.c:111: Trace partitioning superposing up to 200 states
[eva] solitaire.c:111: Trace partitioning superposing up to 200 states
[eva] solitaire.c:111: starting to merge loop iterations
[eva] solitaire.c:111: starting to merge loop iterations
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:117: starting to merge loop iterations
[eva] solitaire.c:117: Trace partitioning superposing up to 300 states
[eva] solitaire.c:117: starting to merge loop iterations
[eva] solitaire.c:117: Trace partitioning superposing up to 300 states
[eva] solitaire.c:117: starting to merge loop iterations
[eva] solitaire.c:117: Trace partitioning superposing up to 300 states
[eva] solitaire.c:117: starting to merge loop iterations
[eva] solitaire.c:117: Trace partitioning superposing up to 300 states
[eva] solitaire.c:128: starting to merge loop iterations
[eva] solitaire.c:128: starting to merge loop iterations
[eva] solitaire.c:128: starting to merge loop iterations
[eva] solitaire.c:128: starting to merge loop iterations
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:134: starting to merge loop iterations
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:134: starting to merge loop iterations
[eva] solitaire.c:134: starting to merge loop iterations
[eva] solitaire.c:134: starting to merge loop iterations
[eva] solitaire.c:149: starting to merge loop iterations
[eva] solitaire.c:149: starting to merge loop iterations
[eva] solitaire.c:151: 
  The evaluation of the expression state.spare + ((53 - nccut) + nlo)
  led to bottom without alarms:
  at this point the product of states has no possible concretization.
[eva] solitaire.c:149: starting to merge loop iterations
[eva] solitaire.c:151: 
  The evaluation of the expression state.spare + ((53 - nccut) + nlo)
  led to bottom without alarms:
  at this point the product of states has no possible concretization.
[eva] solitaire.c:151: 
  The evaluation of the expression state.spare + ((53 - nccut) + nlo)
  led to bottom without alarms:
  at this point the product of states has no possible concretization.
[eva] solitaire.c:149: starting to merge loop iterations
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:156: starting to merge loop iterations
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:151: 
  The evaluation of the expression state.spare + ((53 - nccut) + nlo)
  led to bottom without alarms:
  at this point the product of states has no possible concretization.
[eva] solitaire.c:156: starting to merge loop iterations
[eva] solitaire.c:156: starting to merge loop iterations
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:156: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:219: Trace partitioning superposing up to 200 states
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[scope:rm_asserts] removing 5 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 285 statements reached (out of 364): 78% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  18 alarms generated by the analysis:
      17 invalid memory accesses
       1 integer overflow
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     4 valid     6 unknown     0 invalid     10 total
  40% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:219: Trace partitioning superposing up to 200 states
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[scope:rm_asserts] removing 5 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 285 statements reached (out of 364): 78% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  18 alarms generated by the analysis:
      17 invalid memory accesses
       1 integer overflow
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     4 valid     6 unknown     0 invalid     10 total
  40% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:219: Trace partitioning superposing up to 200 states
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[scope:rm_asserts] removing 5 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 285 statements reached (out of 364): 78% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  18 alarms generated by the analysis:
      17 invalid memory accesses
       1 integer overflow
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     4 valid     6 unknown     0 invalid     10 total
  40% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:219: Trace partitioning superposing up to 200 states
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[scope:rm_asserts] removing 5 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 285 statements reached (out of 364): 78% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  18 alarms generated by the analysis:
      17 invalid memory accesses
       1 integer overflow
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     4 valid     6 unknown     0 invalid     10 total
  40% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] sample base04-sample01: subset of base? true
[parf] sample base04-sample00: subset of base? true
[parf] sample base04-sample02: subset of base? true
[parf] sample base04-sample03: subset of base? true
[parf] base: base05
[parf] Analysis time for this epoch: 1733
[parf] sample: base05-sample00
[parf] sample: base05-sample01
[parf] sample: base05-sample02
[parf] sample: base05-sample03
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 21 -eva-subdivide-non-linear 88 -eva-split-return auto -eva-slevel 398 -eva-remove-redundant-alarms -eva-plevel 536 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 490 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 390
[parf] set eva options
[parf] parameters: -eva-widening-delay 20 -eva-subdivide-non-linear 88 -eva-split-return auto -eva-slevel 377 -eva-remove-redundant-alarms -eva-plevel 522 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 484 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 407
[parf] set eva options
[parf] parameters: -eva-widening-delay 21 -eva-subdivide-non-linear 90 -eva-split-return auto -eva-slevel 369 -eva-remove-redundant-alarms -eva-plevel 507 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 497 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 391
[parf] parameters: -eva-widening-delay 18 -eva-subdivide-non-linear 79 -eva-split-return auto -eva-slevel 385 -eva-remove-redundant-alarms -eva-plevel 502 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 491 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 391
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[eva] Splitting return states on:
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
[eva] Splitting return states on:
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
[eva] Splitting return states on:
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
[eva] Splitting return states on:
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function strcmp
[eva] using specification for function strcmp
[eva] using specification for function strcmp
[eva] using specification for function strcmp
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function exit
[eva] using specification for function exit
[eva] using specification for function exit
[eva] using specification for function exit
[eva] using specification for function __FC_assert
[eva] using specification for function __FC_assert
[eva] using specification for function __FC_assert
[eva] using specification for function __FC_assert
[eva] solitaire.c:107: Trace partitioning superposing up to 100 states
[eva] solitaire.c:107: Trace partitioning superposing up to 100 states
[eva] solitaire.c:107: Trace partitioning superposing up to 100 states
[eva] solitaire.c:107: Trace partitioning superposing up to 100 states
[eva] solitaire.c:111: Trace partitioning superposing up to 200 states
[eva] solitaire.c:111: Trace partitioning superposing up to 200 states
[eva] solitaire.c:111: Trace partitioning superposing up to 200 states
[eva] solitaire.c:111: Trace partitioning superposing up to 200 states
[eva] solitaire.c:111: Trace partitioning superposing up to 300 states
[eva] solitaire.c:111: Trace partitioning superposing up to 300 states
[eva] solitaire.c:111: Trace partitioning superposing up to 300 states
[eva] solitaire.c:111: Trace partitioning superposing up to 300 states
[eva] solitaire.c:111: starting to merge loop iterations
[eva] solitaire.c:111: starting to merge loop iterations
[eva] solitaire.c:111: Trace partitioning superposing up to 400 states
[eva] solitaire.c:111: Trace partitioning superposing up to 400 states
[eva] solitaire.c:111: starting to merge loop iterations
[eva] solitaire.c:111: starting to merge loop iterations
[eva] solitaire.c:111: Trace partitioning superposing up to 400 states
[eva] solitaire.c:111: Trace partitioning superposing up to 400 states
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:128: starting to merge loop iterations
[eva] solitaire.c:128: starting to merge loop iterations
[eva] solitaire.c:128: starting to merge loop iterations
[eva] solitaire.c:128: starting to merge loop iterations
[eva] solitaire.c:131: Trace partitioning superposing up to 500 states
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:131: Trace partitioning superposing up to 600 states
[eva] solitaire.c:131: Trace partitioning superposing up to 500 states
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:131: Trace partitioning superposing up to 500 states
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:131: Trace partitioning superposing up to 600 states
[eva] solitaire.c:131: Trace partitioning superposing up to 600 states
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:149: starting to merge loop iterations
[eva] solitaire.c:149: starting to merge loop iterations
[eva] solitaire.c:149: starting to merge loop iterations
[eva] solitaire.c:149: starting to merge loop iterations
[eva] solitaire.c:151: 
  The evaluation of the expression state.spare + ((53 - nccut) + nlo)
  led to bottom without alarms:
  at this point the product of states has no possible concretization.
[eva] solitaire.c:151: 
  The evaluation of the expression state.spare + ((53 - nccut) + nlo)
  led to bottom without alarms:
  at this point the product of states has no possible concretization.
[eva] solitaire.c:151: 
  The evaluation of the expression state.spare + ((53 - nccut) + nlo)
  led to bottom without alarms:
  at this point the product of states has no possible concretization.
[eva] solitaire.c:151: 
  The evaluation of the expression state.spare + ((53 - nccut) + nlo)
  led to bottom without alarms:
  at this point the product of states has no possible concretization.
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:156: starting to merge loop iterations
[eva] solitaire.c:156: starting to merge loop iterations
[eva] solitaire.c:156: starting to merge loop iterations
[eva] solitaire.c:156: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:219: Trace partitioning superposing up to 200 states
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[scope:rm_asserts] removing 5 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 285 statements reached (out of 364): 78% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  18 alarms generated by the analysis:
      17 invalid memory accesses
       1 integer overflow
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     4 valid     6 unknown     0 invalid     10 total
  40% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:219: Trace partitioning superposing up to 200 states
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:219: Trace partitioning superposing up to 200 states
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:219: Trace partitioning superposing up to 200 states
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[scope:rm_asserts] removing 5 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 285 statements reached (out of 364): 78% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  18 alarms generated by the analysis:
      17 invalid memory accesses
       1 integer overflow
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     4 valid     6 unknown     0 invalid     10 total
  40% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[scope:rm_asserts] removing 5 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 285 statements reached (out of 364): 78% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  18 alarms generated by the analysis:
      17 invalid memory accesses
       1 integer overflow
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     4 valid     6 unknown     0 invalid     10 total
  40% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[scope:rm_asserts] removing 5 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 285 statements reached (out of 364): 78% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  18 alarms generated by the analysis:
      17 invalid memory accesses
       1 integer overflow
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     4 valid     6 unknown     0 invalid     10 total
  40% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] sample base05-sample00: subset of base? true
[parf] sample base05-sample01: subset of base? true
[parf] sample base05-sample03: subset of base? true
[parf] sample base05-sample02: subset of base? true
[parf] base: base06
[parf] Analysis time for this epoch: 1722
[parf] sample: base06-sample00
[parf] sample: base06-sample01
[parf] sample: base06-sample02
[parf] sample: base06-sample03
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 17 -eva-subdivide-non-linear 169 -eva-split-return auto -eva-slevel 759 -eva-remove-redundant-alarms -eva-plevel 1014 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 510 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 751
[parf] set eva options
[parf] parameters: -eva-widening-delay 21 -eva-subdivide-non-linear 144 -eva-split-return auto -eva-slevel 722 -eva-remove-redundant-alarms -eva-plevel 984 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 513 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 788
[parf] parameters: -eva-widening-delay 21 -eva-subdivide-non-linear 160 -eva-split-return auto -eva-slevel 728 -eva-remove-redundant-alarms -eva-plevel 1015 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 513 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 781
[parf] parameters: -eva-widening-delay 19 -eva-subdivide-non-linear 174 -eva-split-return auto -eva-slevel 735 -eva-remove-redundant-alarms -eva-plevel 1026 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 504 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 802
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[eva] Splitting return states on:
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
[eva] Splitting return states on:
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
[eva] Splitting return states on:
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
[eva] Splitting return states on:
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function strcmp
[eva] using specification for function strcmp
[eva] using specification for function strcmp
[eva] using specification for function strcmp
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function exit
[eva] using specification for function exit
[eva] using specification for function exit
[eva] using specification for function exit
[eva] using specification for function __FC_assert
[eva] using specification for function __FC_assert
[eva] using specification for function __FC_assert
[eva] using specification for function __FC_assert
[eva] solitaire.c:107: Trace partitioning superposing up to 100 states
[eva] solitaire.c:107: Trace partitioning superposing up to 100 states
[eva] solitaire.c:107: Trace partitioning superposing up to 100 states
[eva] solitaire.c:107: Trace partitioning superposing up to 100 states
[eva] solitaire.c:111: Trace partitioning superposing up to 200 states
[eva] solitaire.c:111: Trace partitioning superposing up to 200 states
[eva] solitaire.c:111: Trace partitioning superposing up to 200 states
[eva] solitaire.c:111: Trace partitioning superposing up to 200 states
[eva] solitaire.c:111: Trace partitioning superposing up to 300 states
[eva] solitaire.c:111: Trace partitioning superposing up to 300 states
[eva] solitaire.c:111: Trace partitioning superposing up to 300 states
[eva] solitaire.c:111: Trace partitioning superposing up to 300 states
[eva] solitaire.c:111: Trace partitioning superposing up to 400 states
[eva] solitaire.c:111: Trace partitioning superposing up to 400 states
[eva] solitaire.c:111: Trace partitioning superposing up to 400 states
[eva] solitaire.c:111: Trace partitioning superposing up to 400 states
[eva] solitaire.c:111: Trace partitioning superposing up to 500 states
[eva] solitaire.c:111: Trace partitioning superposing up to 500 states
[eva] solitaire.c:111: Trace partitioning superposing up to 500 states
[eva] solitaire.c:111: Trace partitioning superposing up to 500 states
[eva] solitaire.c:111: Trace partitioning superposing up to 600 states
[eva] solitaire.c:111: Trace partitioning superposing up to 600 states
[eva] solitaire.c:111: Trace partitioning superposing up to 600 states
[eva] solitaire.c:111: Trace partitioning superposing up to 600 states
[eva] solitaire.c:111: Trace partitioning superposing up to 700 states
[eva] solitaire.c:111: Trace partitioning superposing up to 700 states
[eva] solitaire.c:111: Trace partitioning superposing up to 700 states
[eva] solitaire.c:111: Trace partitioning superposing up to 700 states
[eva] solitaire.c:111: starting to merge loop iterations
[eva] solitaire.c:111: starting to merge loop iterations
[eva] solitaire.c:111: starting to merge loop iterations
[eva] solitaire.c:111: starting to merge loop iterations
[eva] solitaire.c:114: Trace partitioning superposing up to 1100 states
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:114: Trace partitioning superposing up to 1100 states
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:114: Trace partitioning superposing up to 1100 states
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:114: Trace partitioning superposing up to 1200 states
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:128: starting to merge loop iterations
[eva] solitaire.c:128: starting to merge loop iterations
[eva] solitaire.c:128: starting to merge loop iterations
[eva] solitaire.c:128: starting to merge loop iterations
[eva] solitaire.c:131: Trace partitioning superposing up to 1200 states
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:131: Trace partitioning superposing up to 1200 states
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:131: Trace partitioning superposing up to 1300 states
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:131: Trace partitioning superposing up to 1300 states
[eva] solitaire.c:131: Trace partitioning superposing up to 1300 states
[eva] solitaire.c:131: Trace partitioning superposing up to 1300 states
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:149: starting to merge loop iterations
[eva] solitaire.c:149: starting to merge loop iterations
[eva] solitaire.c:149: starting to merge loop iterations
[eva] solitaire.c:149: starting to merge loop iterations
[eva] solitaire.c:151: 
  The evaluation of the expression state.spare + ((53 - nccut) + nlo)
  led to bottom without alarms:
  at this point the product of states has no possible concretization.
[eva] solitaire.c:151: 
  The evaluation of the expression state.spare + ((53 - nccut) + nlo)
  led to bottom without alarms:
  at this point the product of states has no possible concretization.
[eva] solitaire.c:151: 
  The evaluation of the expression state.spare + ((53 - nccut) + nlo)
  led to bottom without alarms:
  at this point the product of states has no possible concretization.
[eva] solitaire.c:151: 
  The evaluation of the expression state.spare + ((53 - nccut) + nlo)
  led to bottom without alarms:
  at this point the product of states has no possible concretization.
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:156: starting to merge loop iterations
[eva] solitaire.c:156: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:219: Trace partitioning superposing up to 200 states
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:219: Trace partitioning superposing up to 200 states
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[scope:rm_asserts] removing 5 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 285 statements reached (out of 364): 78% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  18 alarms generated by the analysis:
      17 invalid memory accesses
       1 integer overflow
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     4 valid     6 unknown     0 invalid     10 total
  40% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] solitaire.c:219: Trace partitioning superposing up to 200 states
[scope:rm_asserts] removing 5 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 285 statements reached (out of 364): 78% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  18 alarms generated by the analysis:
      17 invalid memory accesses
       1 integer overflow
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     4 valid     6 unknown     0 invalid     10 total
  40% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[scope:rm_asserts] removing 5 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 285 statements reached (out of 364): 78% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  18 alarms generated by the analysis:
      17 invalid memory accesses
       1 integer overflow
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     4 valid     6 unknown     0 invalid     10 total
  40% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] solitaire.c:219: Trace partitioning superposing up to 200 states
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[scope:rm_asserts] removing 5 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 285 statements reached (out of 364): 78% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  18 alarms generated by the analysis:
      17 invalid memory accesses
       1 integer overflow
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     4 valid     6 unknown     0 invalid     10 total
  40% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] sample base06-sample01: subset of base? true
[parf] sample base06-sample00: subset of base? true
[parf] sample base06-sample02: subset of base? true
[parf] sample base06-sample03: subset of base? true
[parf] base: base07
[parf] Analysis time for this epoch: 1704
[parf] sample: base07-sample00
[parf] sample: base07-sample01
[parf] sample: base07-sample02
[parf] sample: base07-sample03
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 20 -eva-subdivide-non-linear 305 -eva-split-return auto -eva-slevel 1477 -eva-remove-redundant-alarms -eva-plevel 2985 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 513 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 1776
[parf] parameters: -eva-widening-delay 20 -eva-subdivide-non-linear 286 -eva-split-return auto -eva-slevel 1531 -eva-remove-redundant-alarms -eva-plevel 2985 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 492 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 1776
[parf] set eva options
[parf] parameters: -eva-widening-delay 21 -eva-subdivide-non-linear 296 -eva-split-return auto -eva-slevel 1392 -eva-remove-redundant-alarms -eva-plevel 2985 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 513 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 1776
[parf] parameters: -eva-widening-delay 21 -eva-subdivide-non-linear 288 -eva-split-return auto -eva-slevel 1421 -eva-remove-redundant-alarms -eva-plevel 2985 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 513 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 1776
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[eva] Splitting return states on:
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
[eva] Splitting return states on:
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
[eva] Splitting return states on:
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
[eva] Splitting return states on:
  \return(memchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_3
[eva] using specification for function strcmp
[eva] using specification for function strcmp
[eva] using specification for function strcmp
[eva] using specification for function strcmp
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] FRAMAC_SHARE/libc/string.h:156: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function strcmp
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_4
[eva] using specification for function exit
[eva] using specification for function exit
[eva] using specification for function exit
[eva] using specification for function exit
[eva] using specification for function __FC_assert
[eva] using specification for function __FC_assert
[eva] using specification for function __FC_assert
[eva] using specification for function __FC_assert
[eva] solitaire.c:107: Trace partitioning superposing up to 100 states
[eva] solitaire.c:107: Trace partitioning superposing up to 100 states
[eva] solitaire.c:107: Trace partitioning superposing up to 100 states
[eva] solitaire.c:107: Trace partitioning superposing up to 100 states
[eva] solitaire.c:111: Trace partitioning superposing up to 200 states
[eva] solitaire.c:111: Trace partitioning superposing up to 200 states
[eva] solitaire.c:111: Trace partitioning superposing up to 200 states
[eva] solitaire.c:111: Trace partitioning superposing up to 200 states
[eva] solitaire.c:111: Trace partitioning superposing up to 300 states
[eva] solitaire.c:111: Trace partitioning superposing up to 300 states
[eva] solitaire.c:111: Trace partitioning superposing up to 300 states
[eva] solitaire.c:111: Trace partitioning superposing up to 300 states
[eva] solitaire.c:111: Trace partitioning superposing up to 400 states
[eva] solitaire.c:111: Trace partitioning superposing up to 400 states
[eva] solitaire.c:111: Trace partitioning superposing up to 400 states
[eva] solitaire.c:111: Trace partitioning superposing up to 400 states
[eva] solitaire.c:111: Trace partitioning superposing up to 500 states
[eva] solitaire.c:111: Trace partitioning superposing up to 500 states
[eva] solitaire.c:111: Trace partitioning superposing up to 500 states
[eva] solitaire.c:111: Trace partitioning superposing up to 500 states
[eva] solitaire.c:111: Trace partitioning superposing up to 600 states
[eva] solitaire.c:111: Trace partitioning superposing up to 600 states
[eva] solitaire.c:111: Trace partitioning superposing up to 600 states
[eva] solitaire.c:111: Trace partitioning superposing up to 600 states
[eva] solitaire.c:111: Trace partitioning superposing up to 700 states
[eva] solitaire.c:111: Trace partitioning superposing up to 700 states
[eva] solitaire.c:111: Trace partitioning superposing up to 700 states
[eva] solitaire.c:111: Trace partitioning superposing up to 700 states
[eva] solitaire.c:111: Trace partitioning superposing up to 800 states
[eva] solitaire.c:111: Trace partitioning superposing up to 800 states
[eva] solitaire.c:111: Trace partitioning superposing up to 800 states
[eva] solitaire.c:111: Trace partitioning superposing up to 800 states
[eva] solitaire.c:114: Trace partitioning superposing up to 1300 states
[eva] solitaire.c:114: Trace partitioning superposing up to 1300 states
[eva] solitaire.c:114: Trace partitioning superposing up to 1300 states
[eva] solitaire.c:114: Trace partitioning superposing up to 1300 states
[eva] solitaire.c:114: Trace partitioning superposing up to 1900 states
[eva] solitaire.c:114: Trace partitioning superposing up to 1900 states
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:114: Trace partitioning superposing up to 1900 states
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:114: Trace partitioning superposing up to 1900 states
[eva] solitaire.c:114: starting to merge loop iterations
[eva] solitaire.c:114: Trace partitioning superposing up to 2000 states
[eva] solitaire.c:114: Trace partitioning superposing up to 2000 states
[eva] solitaire.c:114: Trace partitioning superposing up to 2000 states
[eva] solitaire.c:114: Trace partitioning superposing up to 2000 states
[eva] solitaire.c:117: starting to merge loop iterations
[eva] solitaire.c:117: starting to merge loop iterations
[eva] solitaire.c:117: starting to merge loop iterations
[eva] solitaire.c:117: starting to merge loop iterations
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:149: starting to merge loop iterations
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:131: starting to merge loop iterations
[eva] solitaire.c:151: 
  The evaluation of the expression state.spare + ((53 - nccut) + nlo)
  led to bottom without alarms:
  at this point the product of states has no possible concretization.
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:134: starting to merge loop iterations
[eva] solitaire.c:134: starting to merge loop iterations
[eva] solitaire.c:134: starting to merge loop iterations
[eva] solitaire.c:149: starting to merge loop iterations
[eva] solitaire.c:149: starting to merge loop iterations
[eva] solitaire.c:149: starting to merge loop iterations
[eva] solitaire.c:151: 
  The evaluation of the expression state.spare + ((53 - nccut) + nlo)
  led to bottom without alarms:
  at this point the product of states has no possible concretization.
[eva] solitaire.c:151: 
  The evaluation of the expression state.spare + ((53 - nccut) + nlo)
  led to bottom without alarms:
  at this point the product of states has no possible concretization.
[eva] solitaire.c:151: 
  The evaluation of the expression state.spare + ((53 - nccut) + nlo)
  led to bottom without alarms:
  at this point the product of states has no possible concretization.
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:153: starting to merge loop iterations
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:219: Trace partitioning superposing up to 200 states
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[scope:rm_asserts] removing 5 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 285 statements reached (out of 364): 78% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  18 alarms generated by the analysis:
      17 invalid memory accesses
       1 integer overflow
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     4 valid     6 unknown     0 invalid     10 total
  40% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:219: Trace partitioning superposing up to 200 states
[eva] solitaire.c:219: Trace partitioning superposing up to 200 states
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[scope:rm_asserts] removing 5 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 285 statements reached (out of 364): 78% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  18 alarms generated by the analysis:
      17 invalid memory accesses
       1 integer overflow
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     4 valid     6 unknown     0 invalid     10 total
  40% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[scope:rm_asserts] removing 5 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 285 statements reached (out of 364): 78% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  18 alarms generated by the analysis:
      17 invalid memory accesses
       1 integer overflow
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     4 valid     6 unknown     0 invalid     10 total
  40% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] solitaire.c:219: Trace partitioning superposing up to 100 states
[eva] solitaire.c:219: Trace partitioning superposing up to 200 states
[eva] solitaire.c:284: assertion 'Eva,mem_access' got final status invalid.
[scope:rm_asserts] removing 5 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  3 functions analyzed (out of 6): 50% coverage.
  In these functions, 285 statements reached (out of 364): 78% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  18 alarms generated by the analysis:
      17 invalid memory accesses
       1 integer overflow
  1 of them is a sure alarm (invalid status).
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions     4 valid     6 unknown     0 invalid     10 total
  40% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] sample base07-sample00: subset of base? true
[parf] sample base07-sample01: subset of base? true
[parf] sample base07-sample03: subset of base? true
[parf] sample base07-sample02: subset of base? true
[parf] Final parameters: -eva-widening-delay 10 -eva-subdivide-non-linear 220 -eva-split-return auto -eva-slevel 1392 -eva-remove-redundant-alarms -eva-plevel 2000 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 256 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 1024
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] ================================= Summary ==================================
[parf] ====== project "Initial Base 2" ======
[parf] Parameter: -eva-widening-delay 1 -eva-subdivide-non-linear 0 -eva-slevel 0 -eva-plevel 10 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 8 -eva-equality-through-calls none -eva-domains cvalue -eva-auto-loop-unroll 0
[parf] alarms:
[parf] alarm (  1): Pointer_comparison(s, sb)
[parf] alarm (  2): Memory_access(*tmp_9, read)
[parf] alarm (  3): Memory_access(*tmp_8, write)
[parf] alarm (  4): Memory_access(*(state.deck + state.a), read)
[parf] alarm (  5): Memory_access(*(state.deck + state.b), read)
[parf] alarm (  6): Memory_access(*av, read)
[parf] alarm (  7): Pointer_comparison(s, sb)
[parf] alarm (  8): Signed_overflow(state.a + 1 <= 2147483647)
[parf] alarm (  9): Signed_overflow(state.a + 1 >= -2147483648)
[parf] alarm ( 10): Memory_access(*(source + (state.a + 1)), read)
[parf] alarm ( 11): Memory_access(*(source + state.a), write)
[parf] alarm ( 12): Memory_access(*av, read)
[parf] alarm ( 13): Signed_overflow(state.a + 1 >= -2147483648)
[parf] alarm ( 14): Signed_overflow(state.a + 1 <= 2147483647)
[parf] alarm ( 15): Memory_access(*tmp_28, write)
[parf] alarm ( 16): Memory_access(*tmp_29, read)
[parf] alarm ( 17): Signed_overflow(state.a + (((53 - nccut) + nlo) - lo) <= 2147483647)
[parf] alarm ( 18): Signed_overflow(state.a + (((53 - nccut) + nlo) - lo) >= -2147483648)
[parf] alarm ( 19): Signed_overflow(53 - nccut <= 2147483647)
[parf] alarm ( 20): Signed_overflow(((53 - nccut) + nlo) - lo <= 2147483647)
[parf] alarm ( 21): Signed_overflow((53 - nccut) + nlo >= -2147483648)
[parf] alarm ( 22): Signed_overflow((53 - nccut) + nlo <= 2147483647)
[parf] alarm ( 23): Signed_overflow(53 - nccut >= -2147483648)
[parf] alarm ( 24): Signed_overflow(((53 - nccut) + nlo) - lo >= -2147483648)
[parf] alarm ( 25): Signed_overflow(state.b + 1 >= -2147483648)
[parf] alarm ( 26): Signed_overflow(state.b + 1 <= 2147483647)
[parf] alarm ( 27): Signed_overflow((53 - nccut) + nlo <= 2147483647)
[parf] alarm ( 28): Signed_overflow((53 - nccut) + nlo >= -2147483648)
[parf] alarm ( 29): Signed_overflow(((53 - nccut) + nlo) - lo <= 2147483647)
[parf] alarm ( 30): Signed_overflow(53 - nccut >= -2147483648)
[parf] alarm ( 31): Signed_overflow(state.b + (((53 - nccut) + nlo) - lo) <= 2147483647)
[parf] alarm ( 32): Signed_overflow(53 - nccut <= 2147483647)
[parf] alarm ( 33): Signed_overflow(state.b + (((53 - nccut) + nlo) - lo) >= -2147483648)
[parf] alarm ( 34): Signed_overflow(((53 - nccut) + nlo) - lo >= -2147483648)
[parf] alarm ( 35): Memory_access(*av, read)
[parf] alarm ( 36): Memory_access(*(source + 0), write)
[parf] alarm ( 37): Memory_access(*(source + 1), read)
[parf] alarm ( 38): Memory_access(*(state.deck + 0), read)
[parf] alarm ( 39): Memory_access(*(state.deck + *(state.deck + 0)), read)
[parf] alarm ( 40): Memory_access(*tmp_11, read)
[parf] alarm ( 41): Memory_access(*tmp_10, write)
[parf] alarm ( 42): Memory_access(*(av + 0), read)
[parf] alarm ( 43): Memory_access(*(av + 1), read)
[parf] alarm ( 44): Signed_overflow(nlo - nccut >= -2147483648)
[parf] alarm ( 45): Signed_overflow((nlo - nccut) - lo <= 2147483647)
[parf] alarm ( 46): Signed_overflow(nlo - nccut <= 2147483647)
[parf] alarm ( 47): Signed_overflow(state.a + ((nlo - nccut) - lo) >= -2147483648)
[parf] alarm ( 48): Signed_overflow(state.a + ((nlo - nccut) - lo) <= 2147483647)
[parf] alarm ( 49): Signed_overflow((nlo - nccut) - lo >= -2147483648)
[parf] alarm ( 50): Signed_overflow(state.b - 1 <= 2147483647)
[parf] alarm ( 51): Signed_overflow(state.b - 1 >= -2147483648)
[parf] alarm ( 52): Signed_overflow(state.b + ((nlo - nccut) - lo) <= 2147483647)
[parf] alarm ( 53): Signed_overflow(state.b + ((nlo - nccut) - lo) >= -2147483648)
[parf] alarm ( 54): Signed_overflow((nlo - nccut) - lo >= -2147483648)
[parf] alarm ( 55): Signed_overflow(nlo - nccut >= -2147483648)
[parf] alarm ( 56): Signed_overflow((nlo - nccut) - lo <= 2147483647)
[parf] alarm ( 57): Signed_overflow(nlo - nccut <= 2147483647)
[parf] alarm ( 58): Signed_overflow(nhi - nccut >= -2147483648)
[parf] alarm ( 59): Signed_overflow(nhi - nccut <= 2147483647)
[parf] alarm ( 60): Memory_access(*(source + (state.b + 1)), read)
[parf] alarm ( 61): Signed_overflow(state.b + 1 >= -2147483648)
[parf] alarm ( 62): Signed_overflow(state.b + 1 <= 2147483647)
[parf] alarm ( 63): Memory_access(*(source + state.b), write)
[parf] alarm ( 64): Signed_overflow(lo - 1 <= 2147483647)
[parf] alarm ( 65): Signed_overflow(lo - 1 >= -2147483648)
[parf] alarm ( 66): Signed_overflow(state.b + 1 >= -2147483648)
[parf] alarm ( 67): Signed_overflow(state.b + 1 <= 2147483647)
[parf] alarm ( 68): Signed_overflow(state.a + 1 >= -2147483648)
[parf] alarm ( 69): Signed_overflow(state.a + 1 <= 2147483647)
[parf] alarm ( 70): Memory_access(*(source + 0), write)
[parf] alarm ( 71): Memory_access(*(source + 1), read)
[parf] alarm ( 72): Pointer_comparison(s, sb)
[parf] alarm ( 73): Signed_overflow(output - 26 >= -2147483648)
[parf] alarm ( 74): Signed_overflow(output - 26 <= 2147483647)
[parf] alarm ( 75): Signed_overflow(cocount + (lastout == output) <= 2147483647)
[parf] alarm ( 76): Signed_overflow(state.a - 1 >= -2147483648)
[parf] alarm ( 77): Signed_overflow(state.a - 1 <= 2147483647)
[parf] alarm ( 78): Signed_overflow(state.b + 1 <= 2147483647)
[parf] alarm ( 79): Memory_access(*(source + (state.b + 1)), read)
[parf] alarm ( 80): Signed_overflow(state.b + 1 >= -2147483648)
[parf] alarm ( 81): Memory_access(*(source + state.b), write)
[parf] alarm ( 82): Memory_access(*tmp_12, write)
[parf] alarm ( 83): Memory_access(*tmp_13, read)
[parf] alarm ( 84): Signed_overflow(state.b + 1 <= 2147483647)
[parf] alarm ( 85): Signed_overflow(state.b + 1 >= -2147483648)
[parf] alarm ( 86): Signed_overflow(state.a + 1 <= 2147483647)
[parf] alarm ( 87): Signed_overflow(state.a + 1 >= -2147483648)
[parf] alarm ( 88): Memory_access(*(source + 0), write)
[parf] alarm ( 89): Memory_access(*(source + 1), read)
[parf] alarm ( 90): Memory_access(*(state.spare + 53), write)
[parf] alarm ( 91): Memory_access(*tmp_14, read)
[parf] alarm ( 92): Signed_overflow((53 - nccut) + nlo <= 2147483647)
[parf] alarm ( 93): Signed_overflow((53 - nccut) + nlo >= -2147483648)
[parf] alarm ( 94): Signed_overflow(53 - nccut >= -2147483648)
[parf] alarm ( 95): Signed_overflow(53 - nccut <= 2147483647)
[parf] alarm ( 96): Signed_overflow(nccut - nlo <= 2147483647)
[parf] alarm ( 97): Signed_overflow((nccut - nlo) + lo <= 2147483647)
[parf] alarm ( 98): Signed_overflow((nccut - nlo) + lo >= -2147483648)
[parf] alarm ( 99): Signed_overflow(nccut - nlo >= -2147483648)
[parf] alarm (100): Signed_overflow(state.a - 1 <= 2147483647)
[parf] alarm (101): Signed_overflow(state.a - 1 >= -2147483648)
[parf] alarm (102): Pointer_comparison(s, sb)
[parf] alarm (103): Memory_access(*(state.deck + i), read)
[parf] alarm (104): Memory_access(*(source + state.a), write)
[parf] alarm (105): Signed_overflow(' ' + *(state.deck + i) >= -2147483648)
[parf] alarm (106): Signed_overflow(' ' + *(state.deck + i) <= 2147483647)
[parf] alarm (107): Memory_access(*(source + state.b), write)
[parf] alarm (108): Signed_overflow(state.b + 1 >= -2147483648)
[parf] alarm (109): Signed_overflow(state.b + 1 <= 2147483647)
[parf] alarm (110): Signed_overflow(state.a + 1 <= 2147483647)
[parf] alarm (111): Signed_overflow(state.a + 1 >= -2147483648)
[parf] alarm (112): Memory_access(*tmp_15, write)
[parf] alarm (113): Memory_access(*tmp_16, read)
[parf] alarm (114): Signed_overflow(54 - hi <= 2147483647)
[parf] alarm (115): Signed_overflow(54 - hi >= -2147483648)
[parf] alarm (116): Signed_overflow(54 - lo <= 2147483647)
[parf] alarm (117): Signed_overflow(54 - lo >= -2147483648)
[parf] alarm (118): Signed_overflow(lo - 1 <= 2147483647)
[parf] alarm (119): Signed_overflow(lo - 1 >= -2147483648)
[parf] alarm (120): Memory_access(*(source + (lo - 1)), read)
[parf] alarm (121): Pointer_comparison(s, sb)
[parf] alarm (122): Pointer_comparison(s, sb)
[parf] alarm (123): Memory_access(*tmp_18, read)
[parf] alarm (124): Memory_access(*tmp_17, write)
[parf] alarm (125): Signed_overflow(53 - nccut >= -2147483648)
[parf] alarm (126): Signed_overflow(53 - nccut <= 2147483647)
[parf] alarm (127): Pointer_comparison(s, sb)
[parf] alarm (128): Memory_access(*tmp, write)
[parf] alarm (129): Memory_access(*tmp_0, read)
[parf] alarm (130): Memory_access(*key, read)
[parf] alarm (131): Memory_access(*key, read)
[parf] alarm (132): Pointer_comparison(s, sb)
[parf] alarm (133): Memory_access(*tmp_19, write)
[parf] alarm (134): Memory_access(*tmp_20, read)
[parf] alarm (135): Memory_access(*key, read)
[parf] alarm (136): Signed_overflow((53 - nccut) + nlo <= 2147483647)
[parf] alarm (137): Signed_overflow(53 - nccut <= 2147483647)
[parf] alarm (138): Signed_overflow(53 - nccut >= -2147483648)
[parf] alarm (139): Signed_overflow((53 - nccut) + nlo >= -2147483648)
[parf] alarm (140): Memory_access(*key, read)
[parf] alarm (141): Signed_overflow((nhi - nccut) - 1 >= -2147483648)
[parf] alarm (142): Signed_overflow((nhi - nccut) - 1 <= 2147483647)
[parf] alarm (143): Signed_overflow(nhi - nccut >= -2147483648)
[parf] alarm (144): Signed_overflow(nhi - nccut <= 2147483647)
[parf] alarm (145): Signed_overflow(53 - nccut >= -2147483648)
[parf] alarm (146): Signed_overflow(53 - nccut <= 2147483647)
[parf] alarm (147): Signed_overflow((53 - nccut) + nlo <= 2147483647)
[parf] alarm (148): Signed_overflow((53 - nccut) + nlo >= -2147483648)
[parf] alarm (149): Signed_overflow(nhi - nccut <= 2147483647)
[parf] alarm (150): Signed_overflow((nhi - nccut) - 1 >= -2147483648)
[parf] alarm (151): Signed_overflow(nhi - nccut >= -2147483648)
[parf] alarm (152): Signed_overflow((nhi - nccut) - 1 <= 2147483647)
[parf] alarm (153): Signed_overflow((53 - nccut) + nhi <= 2147483647)
[parf] alarm (154): Signed_overflow(53 - nccut <= 2147483647)
[parf] alarm (155): Signed_overflow((53 - nccut) + nhi >= -2147483648)
[parf] alarm (156): Signed_overflow(53 - nccut >= -2147483648)
[parf] alarm (157): Signed_overflow(nccut - nhi <= 2147483647)
[parf] alarm (158): Signed_overflow(nccut - nhi >= -2147483648)
[parf] alarm (159): Memory_access(*tmp_2, read)
[parf] alarm (160): Memory_access(*tmp_1, write)
[parf] alarm (161): Memory_access(*(state.deck + (i + kval) % 53), read)
[parf] alarm (162): Memory_access(*(state.spare + i), write)
[parf] alarm (163): Memory_access(*(state.deck + 53), read)
[parf] alarm (164): Memory_access(*(state.spare + 53), write)
[parf] alarm (165): Pointer_comparison(s, sb)
[parf] alarm (166): Signed_overflow(nhi - nccut >= -2147483648)
[parf] alarm (167): Signed_overflow(nhi - nccut <= 2147483647)
[parf] alarm (168): Signed_overflow(state.a + 53 <= 2147483647)
[parf] alarm (169): Signed_overflow(((state.a + 53) - kval) % 53 <= 2147483647)
[parf] alarm (170): Signed_overflow(state.a + 53 >= -2147483648)
[parf] alarm (171): Signed_overflow((state.a + 53) - kval >= -2147483648)
[parf] alarm (172): Signed_overflow(((state.a + 53) - kval) % 53 >= -2147483648)
[parf] alarm (173): Signed_overflow((state.a + 53) - kval <= 2147483647)
[parf] alarm (174): Signed_overflow(lo - 1 >= -2147483648)
[parf] alarm (175): Signed_overflow(lo - 1 <= 2147483647)
[parf] alarm (176): Pointer_comparison(s, sb)
[parf] alarm (177): Signed_overflow((state.b + 53) - kval <= 2147483647)
[parf] alarm (178): Signed_overflow(state.b + 53 <= 2147483647)
[parf] alarm (179): Signed_overflow((state.b + 53) - kval >= -2147483648)
[parf] alarm (180): Signed_overflow(((state.b + 53) - kval) % 53 >= -2147483648)
[parf] alarm (181): Signed_overflow(state.b + 53 >= -2147483648)
[parf] alarm (182): Signed_overflow(((state.b + 53) - kval) % 53 <= 2147483647)
[parf] alarm (183): Memory_access(*tmp_22, read)
[parf] alarm (184): Memory_access(*tmp_21, write)
[parf] alarm (185): Signed_overflow(lo - 1 >= -2147483648)
[parf] alarm (186): Signed_overflow(lo - 1 <= 2147483647)
[parf] alarm (187): Pointer_comparison(s, sb)
[parf] alarm (188): Memory_access(*tmp_4, read)
[parf] alarm (189): Memory_access(*tmp_3, write)
[parf] alarm (190): Memory_access(*key, read)
[parf] alarm (191): Memory_access(*tmp_5, read)
[parf] alarm (192): Memory_access(*(state.spare + 53), write)
[parf] alarm (193): Signed_overflow(nlo - nccut <= 2147483647)
[parf] alarm (194): Signed_overflow(nlo - nccut >= -2147483648)
[parf] alarm (195): Memory_access(*tmp_23, write)
[parf] alarm (196): Memory_access(*tmp_24, read)
[parf] alarm (197): Pointer_comparison(s, sb)
[parf] alarm (198): Memory_access(*(state.spare + 53), write)
[parf] alarm (199): Memory_access(*tmp_25, read)
[parf] alarm (200): Signed_overflow((53 - nccut) + nlo >= -2147483648)
[parf] alarm (201): Signed_overflow(53 - nccut <= 2147483647)
[parf] alarm (202): Signed_overflow((53 - nccut) + nlo <= 2147483647)
[parf] alarm (203): Signed_overflow(53 - nccut >= -2147483648)
[parf] alarm (204): Pointer_comparison(s, sb)
[parf] alarm (205): Memory_access(*tmp_7, read)
[parf] alarm (206): Memory_access(*tmp_6, write)
[parf] alarm (207): Signed_overflow(53 - nccut >= -2147483648)
[parf] alarm (208): Signed_overflow(53 - nccut <= 2147483647)
[parf] alarm (209): Signed_overflow(nccut + hi >= -2147483648)
[parf] alarm (210): Signed_overflow(nccut + hi <= 2147483647)
[parf] alarm (211): Pointer_comparison(s, sb)
[parf] alarm (212): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm (213): Memory_access(*tmp_26, write)
[parf] alarm (214): Memory_access(*tmp_27, read)
[parf] alarm (215): Signed_overflow(53 - nccut <= 2147483647)
[parf] alarm (216): Signed_overflow(53 - nccut >= -2147483648)
[parf] ============================================================================
[parf] ====== project "base00-sample00 2" ======
[parf] Parameter: -eva-widening-delay 2 -eva-subdivide-non-linear 3 -eva-slevel 9 -eva-plevel 33 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 17 -eva-equality-through-calls formals -eva-domains cvalue,equality,octagon -eva-auto-loop-unroll 10
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*tmp_10, write)
[parf] alarm (  7): Memory_access(*(av + 0), read)
[parf] alarm (  8): Memory_access(*(av + 1), read)
[parf] alarm (  9): Signed_overflow(cocount + (lastout == output) <= 2147483647)
[parf] alarm ( 10): Memory_access(*tmp_12, write)
[parf] alarm ( 11): Memory_access(*tmp_15, write)
[parf] alarm ( 12): Memory_access(*tmp_17, write)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*key, read)
[parf] alarm ( 15): Memory_access(*tmp_19, write)
[parf] alarm ( 16): Memory_access(*key, read)
[parf] alarm ( 17): Memory_access(*key, read)
[parf] alarm ( 18): Memory_access(*tmp_1, write)
[parf] alarm ( 19): Memory_access(*tmp_21, write)
[parf] alarm ( 20): Memory_access(*tmp_3, write)
[parf] alarm ( 21): Memory_access(*tmp_23, write)
[parf] alarm ( 22): Memory_access(*tmp_6, write)
[parf] alarm ( 23): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 24): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] ====== project "base00-sample01 2" ======
[parf] Parameter: -eva-widening-delay 2 -eva-subdivide-non-linear 4 -eva-slevel 10 -eva-remove-redundant-alarms -eva-plevel 35 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 16 -eva-equality-through-calls formals -eva-domains cvalue,symbolic-locations -eva-auto-loop-unroll 11
[parf] alarms:
[parf] alarm (  1): Pointer_comparison(s, sb)
[parf] alarm (  2): Memory_access(*tmp_9, read)
[parf] alarm (  3): Memory_access(*tmp_8, write)
[parf] alarm (  4): Memory_access(*(state.deck + state.a), read)
[parf] alarm (  5): Memory_access(*(state.deck + state.b), read)
[parf] alarm (  6): Memory_access(*av, read)
[parf] alarm (  7): Pointer_comparison(s, sb)
[parf] alarm (  8): Signed_overflow(state.a + 1 <= 2147483647)
[parf] alarm (  9): Signed_overflow(state.a + 1 >= -2147483648)
[parf] alarm ( 10): Memory_access(*(source + (state.a + 1)), read)
[parf] alarm ( 11): Memory_access(*(source + state.a), write)
[parf] alarm ( 12): Memory_access(*av, read)
[parf] alarm ( 13): Signed_overflow(state.a + 1 >= -2147483648)
[parf] alarm ( 14): Signed_overflow(state.a + 1 <= 2147483647)
[parf] alarm ( 15): Memory_access(*tmp_28, write)
[parf] alarm ( 16): Memory_access(*tmp_29, read)
[parf] alarm ( 17): Signed_overflow(state.a + (((53 - nccut) + nlo) - lo) <= 2147483647)
[parf] alarm ( 18): Signed_overflow(state.a + (((53 - nccut) + nlo) - lo) >= -2147483648)
[parf] alarm ( 19): Signed_overflow(((53 - nccut) + nlo) - lo <= 2147483647)
[parf] alarm ( 20): Signed_overflow(((53 - nccut) + nlo) - lo >= -2147483648)
[parf] alarm ( 21): Signed_overflow(state.b + 1 >= -2147483648)
[parf] alarm ( 22): Signed_overflow(state.b + 1 <= 2147483647)
[parf] alarm ( 23): Signed_overflow(state.b + (((53 - nccut) + nlo) - lo) <= 2147483647)
[parf] alarm ( 24): Signed_overflow(state.b + (((53 - nccut) + nlo) - lo) >= -2147483648)
[parf] alarm ( 25): Memory_access(*av, read)
[parf] alarm ( 26): Memory_access(*(source + 0), write)
[parf] alarm ( 27): Memory_access(*(source + 1), read)
[parf] alarm ( 28): Memory_access(*(state.deck + 0), read)
[parf] alarm ( 29): Memory_access(*(state.deck + *(state.deck + 0)), read)
[parf] alarm ( 30): Memory_access(*tmp_11, read)
[parf] alarm ( 31): Memory_access(*tmp_10, write)
[parf] alarm ( 32): Memory_access(*(av + 0), read)
[parf] alarm ( 33): Memory_access(*(av + 1), read)
[parf] alarm ( 34): Signed_overflow((nlo - nccut) - lo <= 2147483647)
[parf] alarm ( 35): Signed_overflow(state.a + ((nlo - nccut) - lo) >= -2147483648)
[parf] alarm ( 36): Signed_overflow(state.a + ((nlo - nccut) - lo) <= 2147483647)
[parf] alarm ( 37): Signed_overflow((nlo - nccut) - lo >= -2147483648)
[parf] alarm ( 38): Signed_overflow(state.b - 1 <= 2147483647)
[parf] alarm ( 39): Signed_overflow(state.b - 1 >= -2147483648)
[parf] alarm ( 40): Signed_overflow(state.b + ((nlo - nccut) - lo) <= 2147483647)
[parf] alarm ( 41): Signed_overflow(state.b + ((nlo - nccut) - lo) >= -2147483648)
[parf] alarm ( 42): Signed_overflow(nhi - nccut >= -2147483648)
[parf] alarm ( 43): Signed_overflow(nhi - nccut <= 2147483647)
[parf] alarm ( 44): Memory_access(*(source + (state.b + 1)), read)
[parf] alarm ( 45): Signed_overflow(state.b + 1 >= -2147483648)
[parf] alarm ( 46): Signed_overflow(state.b + 1 <= 2147483647)
[parf] alarm ( 47): Memory_access(*(source + state.b), write)
[parf] alarm ( 48): Signed_overflow(lo - 1 <= 2147483647)
[parf] alarm ( 49): Signed_overflow(lo - 1 >= -2147483648)
[parf] alarm ( 50): Signed_overflow(state.b + 1 >= -2147483648)
[parf] alarm ( 51): Signed_overflow(state.b + 1 <= 2147483647)
[parf] alarm ( 52): Signed_overflow(state.a + 1 >= -2147483648)
[parf] alarm ( 53): Signed_overflow(state.a + 1 <= 2147483647)
[parf] alarm ( 54): Memory_access(*(source + 0), write)
[parf] alarm ( 55): Memory_access(*(source + 1), read)
[parf] alarm ( 56): Pointer_comparison(s, sb)
[parf] alarm ( 57): Signed_overflow(output - 26 >= -2147483648)
[parf] alarm ( 58): Signed_overflow(output - 26 <= 2147483647)
[parf] alarm ( 59): Signed_overflow(cocount + (lastout == output) <= 2147483647)
[parf] alarm ( 60): Signed_overflow(state.a - 1 >= -2147483648)
[parf] alarm ( 61): Signed_overflow(state.a - 1 <= 2147483647)
[parf] alarm ( 62): Signed_overflow(state.b + 1 <= 2147483647)
[parf] alarm ( 63): Memory_access(*(source + (state.b + 1)), read)
[parf] alarm ( 64): Signed_overflow(state.b + 1 >= -2147483648)
[parf] alarm ( 65): Memory_access(*(source + state.b), write)
[parf] alarm ( 66): Memory_access(*tmp_12, write)
[parf] alarm ( 67): Memory_access(*tmp_13, read)
[parf] alarm ( 68): Signed_overflow(state.b + 1 <= 2147483647)
[parf] alarm ( 69): Signed_overflow(state.b + 1 >= -2147483648)
[parf] alarm ( 70): Signed_overflow(state.a + 1 <= 2147483647)
[parf] alarm ( 71): Signed_overflow(state.a + 1 >= -2147483648)
[parf] alarm ( 72): Memory_access(*(source + 0), write)
[parf] alarm ( 73): Memory_access(*(source + 1), read)
[parf] alarm ( 74): Memory_access(*(state.spare + 53), write)
[parf] alarm ( 75): Memory_access(*tmp_14, read)
[parf] alarm ( 76): Signed_overflow((53 - nccut) + nlo <= 2147483647)
[parf] alarm ( 77): Signed_overflow((53 - nccut) + nlo >= -2147483648)
[parf] alarm ( 78): Signed_overflow(53 - nccut >= -2147483648)
[parf] alarm ( 79): Signed_overflow(53 - nccut <= 2147483647)
[parf] alarm ( 80): Signed_overflow(nccut - nlo <= 2147483647)
[parf] alarm ( 81): Signed_overflow((nccut - nlo) + lo <= 2147483647)
[parf] alarm ( 82): Signed_overflow((nccut - nlo) + lo >= -2147483648)
[parf] alarm ( 83): Signed_overflow(nccut - nlo >= -2147483648)
[parf] alarm ( 84): Signed_overflow(state.a - 1 <= 2147483647)
[parf] alarm ( 85): Signed_overflow(state.a - 1 >= -2147483648)
[parf] alarm ( 86): Pointer_comparison(s, sb)
[parf] alarm ( 87): Memory_access(*(source + state.a), write)
[parf] alarm ( 88): Memory_access(*(source + state.b), write)
[parf] alarm ( 89): Signed_overflow(state.b + 1 >= -2147483648)
[parf] alarm ( 90): Signed_overflow(state.b + 1 <= 2147483647)
[parf] alarm ( 91): Signed_overflow(state.a + 1 <= 2147483647)
[parf] alarm ( 92): Signed_overflow(state.a + 1 >= -2147483648)
[parf] alarm ( 93): Memory_access(*tmp_15, write)
[parf] alarm ( 94): Memory_access(*tmp_16, read)
[parf] alarm ( 95): Signed_overflow(54 - hi <= 2147483647)
[parf] alarm ( 96): Signed_overflow(54 - hi >= -2147483648)
[parf] alarm ( 97): Signed_overflow(54 - lo <= 2147483647)
[parf] alarm ( 98): Signed_overflow(54 - lo >= -2147483648)
[parf] alarm ( 99): Signed_overflow(lo - 1 <= 2147483647)
[parf] alarm (100): Signed_overflow(lo - 1 >= -2147483648)
[parf] alarm (101): Memory_access(*(source + (lo - 1)), read)
[parf] alarm (102): Pointer_comparison(s, sb)
[parf] alarm (103): Pointer_comparison(s, sb)
[parf] alarm (104): Memory_access(*tmp_18, read)
[parf] alarm (105): Memory_access(*tmp_17, write)
[parf] alarm (106): Signed_overflow(53 - nccut >= -2147483648)
[parf] alarm (107): Signed_overflow(53 - nccut <= 2147483647)
[parf] alarm (108): Pointer_comparison(s, sb)
[parf] alarm (109): Memory_access(*tmp, write)
[parf] alarm (110): Memory_access(*tmp_0, read)
[parf] alarm (111): Memory_access(*key, read)
[parf] alarm (112): Memory_access(*key, read)
[parf] alarm (113): Pointer_comparison(s, sb)
[parf] alarm (114): Memory_access(*tmp_19, write)
[parf] alarm (115): Memory_access(*tmp_20, read)
[parf] alarm (116): Memory_access(*key, read)
[parf] alarm (117): Memory_access(*key, read)
[parf] alarm (118): Signed_overflow((nhi - nccut) - 1 >= -2147483648)
[parf] alarm (119): Signed_overflow((nhi - nccut) - 1 <= 2147483647)
[parf] alarm (120): Signed_overflow((nhi - nccut) - 1 >= -2147483648)
[parf] alarm (121): Signed_overflow((nhi - nccut) - 1 <= 2147483647)
[parf] alarm (122): Signed_overflow((53 - nccut) + nhi <= 2147483647)
[parf] alarm (123): Signed_overflow(53 - nccut <= 2147483647)
[parf] alarm (124): Signed_overflow((53 - nccut) + nhi >= -2147483648)
[parf] alarm (125): Signed_overflow(53 - nccut >= -2147483648)
[parf] alarm (126): Signed_overflow(nccut - nhi <= 2147483647)
[parf] alarm (127): Signed_overflow(nccut - nhi >= -2147483648)
[parf] alarm (128): Memory_access(*tmp_2, read)
[parf] alarm (129): Memory_access(*tmp_1, write)
[parf] alarm (130): Memory_access(*(state.deck + (i + kval) % 53), read)
[parf] alarm (131): Memory_access(*(state.spare + i), write)
[parf] alarm (132): Memory_access(*(state.deck + 53), read)
[parf] alarm (133): Memory_access(*(state.spare + 53), write)
[parf] alarm (134): Pointer_comparison(s, sb)
[parf] alarm (135): Signed_overflow(nhi - nccut >= -2147483648)
[parf] alarm (136): Signed_overflow(nhi - nccut <= 2147483647)
[parf] alarm (137): Signed_overflow(state.a + 53 <= 2147483647)
[parf] alarm (138): Signed_overflow(((state.a + 53) - kval) % 53 <= 2147483647)
[parf] alarm (139): Signed_overflow(state.a + 53 >= -2147483648)
[parf] alarm (140): Signed_overflow((state.a + 53) - kval >= -2147483648)
[parf] alarm (141): Signed_overflow(((state.a + 53) - kval) % 53 >= -2147483648)
[parf] alarm (142): Signed_overflow((state.a + 53) - kval <= 2147483647)
[parf] alarm (143): Signed_overflow(lo - 1 >= -2147483648)
[parf] alarm (144): Signed_overflow(lo - 1 <= 2147483647)
[parf] alarm (145): Pointer_comparison(s, sb)
[parf] alarm (146): Signed_overflow((state.b + 53) - kval <= 2147483647)
[parf] alarm (147): Signed_overflow(state.b + 53 <= 2147483647)
[parf] alarm (148): Signed_overflow((state.b + 53) - kval >= -2147483648)
[parf] alarm (149): Signed_overflow(((state.b + 53) - kval) % 53 >= -2147483648)
[parf] alarm (150): Signed_overflow(state.b + 53 >= -2147483648)
[parf] alarm (151): Signed_overflow(((state.b + 53) - kval) % 53 <= 2147483647)
[parf] alarm (152): Memory_access(*tmp_22, read)
[parf] alarm (153): Memory_access(*tmp_21, write)
[parf] alarm (154): Signed_overflow(lo - 1 >= -2147483648)
[parf] alarm (155): Signed_overflow(lo - 1 <= 2147483647)
[parf] alarm (156): Pointer_comparison(s, sb)
[parf] alarm (157): Memory_access(*tmp_4, read)
[parf] alarm (158): Memory_access(*tmp_3, write)
[parf] alarm (159): Memory_access(*tmp_5, read)
[parf] alarm (160): Memory_access(*(state.spare + 53), write)
[parf] alarm (161): Signed_overflow(nlo - nccut <= 2147483647)
[parf] alarm (162): Signed_overflow(nlo - nccut >= -2147483648)
[parf] alarm (163): Memory_access(*tmp_23, write)
[parf] alarm (164): Memory_access(*tmp_24, read)
[parf] alarm (165): Pointer_comparison(s, sb)
[parf] alarm (166): Memory_access(*(state.spare + 53), write)
[parf] alarm (167): Memory_access(*tmp_25, read)
[parf] alarm (168): Signed_overflow((53 - nccut) + nlo >= -2147483648)
[parf] alarm (169): Signed_overflow(53 - nccut <= 2147483647)
[parf] alarm (170): Signed_overflow((53 - nccut) + nlo <= 2147483647)
[parf] alarm (171): Signed_overflow(53 - nccut >= -2147483648)
[parf] alarm (172): Pointer_comparison(s, sb)
[parf] alarm (173): Memory_access(*tmp_7, read)
[parf] alarm (174): Memory_access(*tmp_6, write)
[parf] alarm (175): Signed_overflow(53 - nccut >= -2147483648)
[parf] alarm (176): Signed_overflow(53 - nccut <= 2147483647)
[parf] alarm (177): Signed_overflow(nccut + hi >= -2147483648)
[parf] alarm (178): Signed_overflow(nccut + hi <= 2147483647)
[parf] alarm (179): Pointer_comparison(s, sb)
[parf] alarm (180): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm (181): Memory_access(*tmp_26, write)
[parf] alarm (182): Memory_access(*tmp_27, read)
[parf] alarm (183): Signed_overflow(53 - nccut <= 2147483647)
[parf] alarm (184): Signed_overflow(53 - nccut >= -2147483648)
[parf] ============================================================================
[parf] ====== project "base00-sample02 2" ======
[parf] Parameter: -eva-widening-delay 2 -eva-subdivide-non-linear 5 -eva-slevel 12 -eva-plevel 35 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 18 -eva-equality-through-calls formals -eva-domains cvalue,gauges -eva-auto-loop-unroll 12
[parf] alarms:
[parf] alarm (  1): Pointer_comparison(s, sb)
[parf] alarm (  2): Memory_access(*tmp_9, read)
[parf] alarm (  3): Memory_access(*tmp_8, write)
[parf] alarm (  4): Memory_access(*(state.deck + state.a), read)
[parf] alarm (  5): Memory_access(*(state.deck + state.b), read)
[parf] alarm (  6): Memory_access(*av, read)
[parf] alarm (  7): Pointer_comparison(s, sb)
[parf] alarm (  8): Signed_overflow(state.a + 1 <= 2147483647)
[parf] alarm (  9): Signed_overflow(state.a + 1 >= -2147483648)
[parf] alarm ( 10): Memory_access(*(source + (state.a + 1)), read)
[parf] alarm ( 11): Memory_access(*(source + state.a), write)
[parf] alarm ( 12): Memory_access(*av, read)
[parf] alarm ( 13): Signed_overflow(state.a + 1 >= -2147483648)
[parf] alarm ( 14): Signed_overflow(state.a + 1 <= 2147483647)
[parf] alarm ( 15): Memory_access(*tmp_28, write)
[parf] alarm ( 16): Memory_access(*tmp_29, read)
[parf] alarm ( 17): Signed_overflow(state.a + (((53 - nccut) + nlo) - lo) <= 2147483647)
[parf] alarm ( 18): Signed_overflow(state.a + (((53 - nccut) + nlo) - lo) >= -2147483648)
[parf] alarm ( 19): Signed_overflow(53 - nccut <= 2147483647)
[parf] alarm ( 20): Signed_overflow(((53 - nccut) + nlo) - lo <= 2147483647)
[parf] alarm ( 21): Signed_overflow((53 - nccut) + nlo >= -2147483648)
[parf] alarm ( 22): Signed_overflow((53 - nccut) + nlo <= 2147483647)
[parf] alarm ( 23): Signed_overflow(53 - nccut >= -2147483648)
[parf] alarm ( 24): Signed_overflow(((53 - nccut) + nlo) - lo >= -2147483648)
[parf] alarm ( 25): Signed_overflow(state.b + 1 >= -2147483648)
[parf] alarm ( 26): Signed_overflow(state.b + 1 <= 2147483647)
[parf] alarm ( 27): Signed_overflow((53 - nccut) + nlo <= 2147483647)
[parf] alarm ( 28): Signed_overflow((53 - nccut) + nlo >= -2147483648)
[parf] alarm ( 29): Signed_overflow(((53 - nccut) + nlo) - lo <= 2147483647)
[parf] alarm ( 30): Signed_overflow(53 - nccut >= -2147483648)
[parf] alarm ( 31): Signed_overflow(state.b + (((53 - nccut) + nlo) - lo) <= 2147483647)
[parf] alarm ( 32): Signed_overflow(53 - nccut <= 2147483647)
[parf] alarm ( 33): Signed_overflow(state.b + (((53 - nccut) + nlo) - lo) >= -2147483648)
[parf] alarm ( 34): Signed_overflow(((53 - nccut) + nlo) - lo >= -2147483648)
[parf] alarm ( 35): Memory_access(*av, read)
[parf] alarm ( 36): Memory_access(*(source + 0), write)
[parf] alarm ( 37): Memory_access(*(source + 1), read)
[parf] alarm ( 38): Memory_access(*(state.deck + 0), read)
[parf] alarm ( 39): Memory_access(*(state.deck + *(state.deck + 0)), read)
[parf] alarm ( 40): Memory_access(*tmp_11, read)
[parf] alarm ( 41): Memory_access(*tmp_10, write)
[parf] alarm ( 42): Memory_access(*(av + 0), read)
[parf] alarm ( 43): Memory_access(*(av + 1), read)
[parf] alarm ( 44): Signed_overflow(nlo - nccut >= -2147483648)
[parf] alarm ( 45): Signed_overflow((nlo - nccut) - lo <= 2147483647)
[parf] alarm ( 46): Signed_overflow(nlo - nccut <= 2147483647)
[parf] alarm ( 47): Signed_overflow(state.a + ((nlo - nccut) - lo) >= -2147483648)
[parf] alarm ( 48): Signed_overflow(state.a + ((nlo - nccut) - lo) <= 2147483647)
[parf] alarm ( 49): Signed_overflow((nlo - nccut) - lo >= -2147483648)
[parf] alarm ( 50): Signed_overflow(state.b - 1 <= 2147483647)
[parf] alarm ( 51): Signed_overflow(state.b - 1 >= -2147483648)
[parf] alarm ( 52): Signed_overflow(state.b + ((nlo - nccut) - lo) <= 2147483647)
[parf] alarm ( 53): Signed_overflow(state.b + ((nlo - nccut) - lo) >= -2147483648)
[parf] alarm ( 54): Signed_overflow((nlo - nccut) - lo >= -2147483648)
[parf] alarm ( 55): Signed_overflow(nlo - nccut >= -2147483648)
[parf] alarm ( 56): Signed_overflow((nlo - nccut) - lo <= 2147483647)
[parf] alarm ( 57): Signed_overflow(nlo - nccut <= 2147483647)
[parf] alarm ( 58): Signed_overflow(nhi - nccut >= -2147483648)
[parf] alarm ( 59): Signed_overflow(nhi - nccut <= 2147483647)
[parf] alarm ( 60): Memory_access(*(source + (state.b + 1)), read)
[parf] alarm ( 61): Signed_overflow(state.b + 1 >= -2147483648)
[parf] alarm ( 62): Signed_overflow(state.b + 1 <= 2147483647)
[parf] alarm ( 63): Memory_access(*(source + state.b), write)
[parf] alarm ( 64): Signed_overflow(lo - 1 <= 2147483647)
[parf] alarm ( 65): Signed_overflow(lo - 1 >= -2147483648)
[parf] alarm ( 66): Signed_overflow(state.b + 1 >= -2147483648)
[parf] alarm ( 67): Signed_overflow(state.b + 1 <= 2147483647)
[parf] alarm ( 68): Signed_overflow(state.a + 1 >= -2147483648)
[parf] alarm ( 69): Signed_overflow(state.a + 1 <= 2147483647)
[parf] alarm ( 70): Memory_access(*(source + 0), write)
[parf] alarm ( 71): Memory_access(*(source + 1), read)
[parf] alarm ( 72): Pointer_comparison(s, sb)
[parf] alarm ( 73): Signed_overflow(output - 26 >= -2147483648)
[parf] alarm ( 74): Signed_overflow(output - 26 <= 2147483647)
[parf] alarm ( 75): Signed_overflow(cocount + (lastout == output) <= 2147483647)
[parf] alarm ( 76): Signed_overflow(state.a - 1 >= -2147483648)
[parf] alarm ( 77): Signed_overflow(state.a - 1 <= 2147483647)
[parf] alarm ( 78): Signed_overflow(state.b + 1 <= 2147483647)
[parf] alarm ( 79): Memory_access(*(source + (state.b + 1)), read)
[parf] alarm ( 80): Signed_overflow(state.b + 1 >= -2147483648)
[parf] alarm ( 81): Memory_access(*(source + state.b), write)
[parf] alarm ( 82): Memory_access(*tmp_12, write)
[parf] alarm ( 83): Memory_access(*tmp_13, read)
[parf] alarm ( 84): Signed_overflow(state.b + 1 <= 2147483647)
[parf] alarm ( 85): Signed_overflow(state.b + 1 >= -2147483648)
[parf] alarm ( 86): Signed_overflow(state.a + 1 <= 2147483647)
[parf] alarm ( 87): Signed_overflow(state.a + 1 >= -2147483648)
[parf] alarm ( 88): Memory_access(*(source + 0), write)
[parf] alarm ( 89): Memory_access(*(source + 1), read)
[parf] alarm ( 90): Memory_access(*(state.spare + 53), write)
[parf] alarm ( 91): Memory_access(*tmp_14, read)
[parf] alarm ( 92): Signed_overflow((53 - nccut) + nlo <= 2147483647)
[parf] alarm ( 93): Signed_overflow((53 - nccut) + nlo >= -2147483648)
[parf] alarm ( 94): Signed_overflow(53 - nccut >= -2147483648)
[parf] alarm ( 95): Signed_overflow(53 - nccut <= 2147483647)
[parf] alarm ( 96): Signed_overflow(nccut - nlo <= 2147483647)
[parf] alarm ( 97): Signed_overflow((nccut - nlo) + lo <= 2147483647)
[parf] alarm ( 98): Signed_overflow((nccut - nlo) + lo >= -2147483648)
[parf] alarm ( 99): Signed_overflow(nccut - nlo >= -2147483648)
[parf] alarm (100): Signed_overflow(state.a - 1 <= 2147483647)
[parf] alarm (101): Signed_overflow(state.a - 1 >= -2147483648)
[parf] alarm (102): Pointer_comparison(s, sb)
[parf] alarm (103): Memory_access(*(source + state.a), write)
[parf] alarm (104): Memory_access(*(source + state.b), write)
[parf] alarm (105): Signed_overflow(state.b + 1 >= -2147483648)
[parf] alarm (106): Signed_overflow(state.b + 1 <= 2147483647)
[parf] alarm (107): Signed_overflow(state.a + 1 <= 2147483647)
[parf] alarm (108): Signed_overflow(state.a + 1 >= -2147483648)
[parf] alarm (109): Memory_access(*tmp_15, write)
[parf] alarm (110): Memory_access(*tmp_16, read)
[parf] alarm (111): Signed_overflow(54 - hi <= 2147483647)
[parf] alarm (112): Signed_overflow(54 - hi >= -2147483648)
[parf] alarm (113): Signed_overflow(54 - lo <= 2147483647)
[parf] alarm (114): Signed_overflow(54 - lo >= -2147483648)
[parf] alarm (115): Signed_overflow(lo - 1 <= 2147483647)
[parf] alarm (116): Signed_overflow(lo - 1 >= -2147483648)
[parf] alarm (117): Memory_access(*(source + (lo - 1)), read)
[parf] alarm (118): Pointer_comparison(s, sb)
[parf] alarm (119): Pointer_comparison(s, sb)
[parf] alarm (120): Memory_access(*tmp_18, read)
[parf] alarm (121): Memory_access(*tmp_17, write)
[parf] alarm (122): Signed_overflow(53 - nccut >= -2147483648)
[parf] alarm (123): Signed_overflow(53 - nccut <= 2147483647)
[parf] alarm (124): Pointer_comparison(s, sb)
[parf] alarm (125): Memory_access(*tmp, write)
[parf] alarm (126): Memory_access(*tmp_0, read)
[parf] alarm (127): Memory_access(*key, read)
[parf] alarm (128): Memory_access(*key, read)
[parf] alarm (129): Pointer_comparison(s, sb)
[parf] alarm (130): Memory_access(*tmp_19, write)
[parf] alarm (131): Memory_access(*tmp_20, read)
[parf] alarm (132): Memory_access(*key, read)
[parf] alarm (133): Signed_overflow((53 - nccut) + nlo <= 2147483647)
[parf] alarm (134): Signed_overflow(53 - nccut <= 2147483647)
[parf] alarm (135): Signed_overflow(53 - nccut >= -2147483648)
[parf] alarm (136): Signed_overflow((53 - nccut) + nlo >= -2147483648)
[parf] alarm (137): Memory_access(*key, read)
[parf] alarm (138): Signed_overflow((nhi - nccut) - 1 >= -2147483648)
[parf] alarm (139): Signed_overflow((nhi - nccut) - 1 <= 2147483647)
[parf] alarm (140): Signed_overflow(nhi - nccut >= -2147483648)
[parf] alarm (141): Signed_overflow(nhi - nccut <= 2147483647)
[parf] alarm (142): Signed_overflow(53 - nccut >= -2147483648)
[parf] alarm (143): Signed_overflow(53 - nccut <= 2147483647)
[parf] alarm (144): Signed_overflow((53 - nccut) + nlo <= 2147483647)
[parf] alarm (145): Signed_overflow((53 - nccut) + nlo >= -2147483648)
[parf] alarm (146): Signed_overflow(nhi - nccut <= 2147483647)
[parf] alarm (147): Signed_overflow((nhi - nccut) - 1 >= -2147483648)
[parf] alarm (148): Signed_overflow(nhi - nccut >= -2147483648)
[parf] alarm (149): Signed_overflow((nhi - nccut) - 1 <= 2147483647)
[parf] alarm (150): Signed_overflow((53 - nccut) + nhi <= 2147483647)
[parf] alarm (151): Signed_overflow(53 - nccut <= 2147483647)
[parf] alarm (152): Signed_overflow((53 - nccut) + nhi >= -2147483648)
[parf] alarm (153): Signed_overflow(53 - nccut >= -2147483648)
[parf] alarm (154): Signed_overflow(nccut - nhi <= 2147483647)
[parf] alarm (155): Signed_overflow(nccut - nhi >= -2147483648)
[parf] alarm (156): Memory_access(*tmp_2, read)
[parf] alarm (157): Memory_access(*tmp_1, write)
[parf] alarm (158): Memory_access(*(state.deck + (i + kval) % 53), read)
[parf] alarm (159): Memory_access(*(state.spare + i), write)
[parf] alarm (160): Memory_access(*(state.deck + 53), read)
[parf] alarm (161): Memory_access(*(state.spare + 53), write)
[parf] alarm (162): Pointer_comparison(s, sb)
[parf] alarm (163): Signed_overflow(nhi - nccut >= -2147483648)
[parf] alarm (164): Signed_overflow(nhi - nccut <= 2147483647)
[parf] alarm (165): Signed_overflow(state.a + 53 <= 2147483647)
[parf] alarm (166): Signed_overflow(((state.a + 53) - kval) % 53 <= 2147483647)
[parf] alarm (167): Signed_overflow(state.a + 53 >= -2147483648)
[parf] alarm (168): Signed_overflow((state.a + 53) - kval >= -2147483648)
[parf] alarm (169): Signed_overflow(((state.a + 53) - kval) % 53 >= -2147483648)
[parf] alarm (170): Signed_overflow((state.a + 53) - kval <= 2147483647)
[parf] alarm (171): Signed_overflow(lo - 1 >= -2147483648)
[parf] alarm (172): Signed_overflow(lo - 1 <= 2147483647)
[parf] alarm (173): Pointer_comparison(s, sb)
[parf] alarm (174): Signed_overflow((state.b + 53) - kval <= 2147483647)
[parf] alarm (175): Signed_overflow(state.b + 53 <= 2147483647)
[parf] alarm (176): Signed_overflow((state.b + 53) - kval >= -2147483648)
[parf] alarm (177): Signed_overflow(((state.b + 53) - kval) % 53 >= -2147483648)
[parf] alarm (178): Signed_overflow(state.b + 53 >= -2147483648)
[parf] alarm (179): Signed_overflow(((state.b + 53) - kval) % 53 <= 2147483647)
[parf] alarm (180): Memory_access(*tmp_22, read)
[parf] alarm (181): Memory_access(*tmp_21, write)
[parf] alarm (182): Signed_overflow(lo - 1 >= -2147483648)
[parf] alarm (183): Signed_overflow(lo - 1 <= 2147483647)
[parf] alarm (184): Pointer_comparison(s, sb)
[parf] alarm (185): Memory_access(*tmp_4, read)
[parf] alarm (186): Memory_access(*tmp_3, write)
[parf] alarm (187): Memory_access(*tmp_5, read)
[parf] alarm (188): Memory_access(*(state.spare + 53), write)
[parf] alarm (189): Signed_overflow(nlo - nccut <= 2147483647)
[parf] alarm (190): Signed_overflow(nlo - nccut >= -2147483648)
[parf] alarm (191): Memory_access(*tmp_23, write)
[parf] alarm (192): Memory_access(*tmp_24, read)
[parf] alarm (193): Pointer_comparison(s, sb)
[parf] alarm (194): Memory_access(*(state.spare + 53), write)
[parf] alarm (195): Memory_access(*tmp_25, read)
[parf] alarm (196): Signed_overflow((53 - nccut) + nlo >= -2147483648)
[parf] alarm (197): Signed_overflow(53 - nccut <= 2147483647)
[parf] alarm (198): Signed_overflow((53 - nccut) + nlo <= 2147483647)
[parf] alarm (199): Signed_overflow(53 - nccut >= -2147483648)
[parf] alarm (200): Pointer_comparison(s, sb)
[parf] alarm (201): Memory_access(*tmp_7, read)
[parf] alarm (202): Memory_access(*tmp_6, write)
[parf] alarm (203): Signed_overflow(53 - nccut >= -2147483648)
[parf] alarm (204): Signed_overflow(53 - nccut <= 2147483647)
[parf] alarm (205): Signed_overflow(nccut + hi >= -2147483648)
[parf] alarm (206): Signed_overflow(nccut + hi <= 2147483647)
[parf] alarm (207): Pointer_comparison(s, sb)
[parf] alarm (208): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm (209): Memory_access(*tmp_26, write)
[parf] alarm (210): Memory_access(*tmp_27, read)
[parf] alarm (211): Signed_overflow(53 - nccut <= 2147483647)
[parf] alarm (212): Signed_overflow(53 - nccut >= -2147483648)
[parf] ============================================================================
[parf] ====== project "base00-sample03 2" ======
[parf] Parameter: -eva-widening-delay 2 -eva-subdivide-non-linear 6 -eva-split-return auto -eva-slevel 13 -eva-remove-redundant-alarms -eva-plevel 21 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 22 -eva-equality-through-calls none -eva-domains cvalue,gauges,octagon -eva-auto-loop-unroll 16
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Signed_overflow(cocount + (lastout == output) <= 2147483647)
[parf] alarm (  9): Memory_access(*tmp_12, write)
[parf] alarm ( 10): Memory_access(*tmp_15, write)
[parf] alarm ( 11): Memory_access(*tmp_17, write)
[parf] alarm ( 12): Memory_access(*key, read)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*tmp_19, write)
[parf] alarm ( 15): Memory_access(*key, read)
[parf] alarm ( 16): Memory_access(*key, read)
[parf] alarm ( 17): Memory_access(*tmp_21, write)
[parf] alarm ( 18): Memory_access(*tmp_3, write)
[parf] alarm ( 19): Memory_access(*tmp_6, write)
[parf] alarm ( 20): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 21): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] ====== project "base01-sample00 2" ======
[parf] Parameter: -eva-widening-delay 5 -eva-subdivide-non-linear 9 -eva-split-return auto -eva-slevel 25 -eva-remove-redundant-alarms -eva-plevel 43 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 34 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon -eva-auto-loop-unroll 33
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Signed_overflow(cocount + (lastout == output) <= 2147483647)
[parf] alarm (  9): Memory_access(*tmp_12, write)
[parf] alarm ( 10): Memory_access(*tmp_15, write)
[parf] alarm ( 11): Memory_access(*tmp_17, write)
[parf] alarm ( 12): Memory_access(*key, read)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*tmp_19, write)
[parf] alarm ( 15): Memory_access(*key, read)
[parf] alarm ( 16): Memory_access(*key, read)
[parf] alarm ( 17): Memory_access(*tmp_21, write)
[parf] alarm ( 18): Memory_access(*tmp_3, write)
[parf] alarm ( 19): Memory_access(*tmp_6, write)
[parf] alarm ( 20): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 21): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] ====== project "base01-sample01 2" ======
[parf] Parameter: -eva-widening-delay 4 -eva-subdivide-non-linear 8 -eva-split-return auto -eva-slevel 29 -eva-remove-redundant-alarms -eva-plevel 38 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 47 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 29
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Signed_overflow(cocount + (lastout == output) <= 2147483647)
[parf] alarm (  9): Memory_access(*tmp_12, write)
[parf] alarm ( 10): Memory_access(*tmp_15, write)
[parf] alarm ( 11): Memory_access(*tmp_17, write)
[parf] alarm ( 12): Memory_access(*key, read)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*tmp_19, write)
[parf] alarm ( 15): Memory_access(*key, read)
[parf] alarm ( 16): Memory_access(*key, read)
[parf] alarm ( 17): Memory_access(*tmp_21, write)
[parf] alarm ( 18): Memory_access(*tmp_3, write)
[parf] alarm ( 19): Memory_access(*tmp_6, write)
[parf] alarm ( 20): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 21): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] ====== project "base01-sample02 2" ======
[parf] Parameter: -eva-widening-delay 3 -eva-subdivide-non-linear 15 -eva-split-return auto -eva-slevel 29 -eva-remove-redundant-alarms -eva-plevel 47 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 48 -eva-equality-through-calls formals -eva-domains cvalue,gauges,octagon -eva-auto-loop-unroll 30
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Signed_overflow(cocount + (lastout == output) <= 2147483647)
[parf] alarm (  9): Memory_access(*tmp_12, write)
[parf] alarm ( 10): Memory_access(*tmp_15, write)
[parf] alarm ( 11): Memory_access(*tmp_17, write)
[parf] alarm ( 12): Memory_access(*key, read)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*tmp_19, write)
[parf] alarm ( 15): Memory_access(*key, read)
[parf] alarm ( 16): Memory_access(*key, read)
[parf] alarm ( 17): Memory_access(*tmp_21, write)
[parf] alarm ( 18): Memory_access(*tmp_3, write)
[parf] alarm ( 19): Memory_access(*tmp_6, write)
[parf] alarm ( 20): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 21): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] ====== project "base01-sample03 2" ======
[parf] Parameter: -eva-widening-delay 4 -eva-subdivide-non-linear 17 -eva-split-return auto -eva-slevel 29 -eva-remove-redundant-alarms -eva-plevel 43 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 50 -eva-equality-through-calls none -eva-domains cvalue,gauges,octagon -eva-auto-loop-unroll 29
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Signed_overflow(cocount + (lastout == output) <= 2147483647)
[parf] alarm (  9): Memory_access(*tmp_12, write)
[parf] alarm ( 10): Memory_access(*tmp_15, write)
[parf] alarm ( 11): Memory_access(*tmp_17, write)
[parf] alarm ( 12): Memory_access(*key, read)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*tmp_19, write)
[parf] alarm ( 15): Memory_access(*key, read)
[parf] alarm ( 16): Memory_access(*key, read)
[parf] alarm ( 17): Memory_access(*tmp_21, write)
[parf] alarm ( 18): Memory_access(*tmp_3, write)
[parf] alarm ( 19): Memory_access(*tmp_6, write)
[parf] alarm ( 20): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 21): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] ====== project "base02-sample00 2" ======
[parf] Parameter: -eva-widening-delay 9 -eva-subdivide-non-linear 18 -eva-split-return auto -eva-slevel 50 -eva-remove-redundant-alarms -eva-plevel 72 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 63 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 62
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Signed_overflow(cocount + (lastout == output) <= 2147483647)
[parf] alarm (  9): Memory_access(*tmp_12, write)
[parf] alarm ( 10): Memory_access(*tmp_15, write)
[parf] alarm ( 11): Memory_access(*tmp_17, write)
[parf] alarm ( 12): Memory_access(*key, read)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*tmp_19, write)
[parf] alarm ( 15): Memory_access(*key, read)
[parf] alarm ( 16): Memory_access(*key, read)
[parf] alarm ( 17): Memory_access(*tmp_21, write)
[parf] alarm ( 18): Memory_access(*tmp_3, write)
[parf] alarm ( 19): Memory_access(*tmp_6, write)
[parf] alarm ( 20): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 21): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] ====== project "base02-sample01 2" ======
[parf] Parameter: -eva-widening-delay 6 -eva-subdivide-non-linear 23 -eva-split-return auto -eva-slevel 51 -eva-remove-redundant-alarms -eva-plevel 67 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 72 -eva-equality-through-calls formals -eva-domains cvalue,gauges,octagon -eva-auto-loop-unroll 57
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Signed_overflow(cocount + (lastout == output) <= 2147483647)
[parf] alarm (  9): Memory_access(*tmp_12, write)
[parf] alarm ( 10): Memory_access(*tmp_15, write)
[parf] alarm ( 11): Memory_access(*tmp_17, write)
[parf] alarm ( 12): Memory_access(*key, read)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*tmp_19, write)
[parf] alarm ( 15): Memory_access(*key, read)
[parf] alarm ( 16): Memory_access(*key, read)
[parf] alarm ( 17): Memory_access(*tmp_21, write)
[parf] alarm ( 18): Memory_access(*tmp_3, write)
[parf] alarm ( 19): Memory_access(*tmp_6, write)
[parf] alarm ( 20): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 21): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] ====== project "base02-sample02 2" ======
[parf] Parameter: -eva-widening-delay 4 -eva-subdivide-non-linear 13 -eva-split-return auto -eva-slevel 54 -eva-remove-redundant-alarms -eva-plevel 75 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 69 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 60
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Memory_access(*tmp_12, write)
[parf] alarm (  9): Memory_access(*tmp_15, write)
[parf] alarm ( 10): Memory_access(*key, read)
[parf] alarm ( 11): Memory_access(*key, read)
[parf] alarm ( 12): Memory_access(*tmp_19, write)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*key, read)
[parf] alarm ( 15): Memory_access(*tmp_21, write)
[parf] alarm ( 16): Memory_access(*tmp_3, write)
[parf] alarm ( 17): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 18): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] ====== project "base02-sample03 2" ======
[parf] Parameter: -eva-widening-delay 6 -eva-subdivide-non-linear 16 -eva-split-return auto -eva-slevel 50 -eva-remove-redundant-alarms -eva-plevel 69 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 62 -eva-equality-through-calls formals -eva-domains cvalue,gauges,octagon -eva-auto-loop-unroll 58
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Signed_overflow(cocount + (lastout == output) <= 2147483647)
[parf] alarm (  9): Memory_access(*tmp_12, write)
[parf] alarm ( 10): Memory_access(*tmp_15, write)
[parf] alarm ( 11): Memory_access(*tmp_17, write)
[parf] alarm ( 12): Memory_access(*key, read)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*tmp_19, write)
[parf] alarm ( 15): Memory_access(*key, read)
[parf] alarm ( 16): Memory_access(*key, read)
[parf] alarm ( 17): Memory_access(*tmp_21, write)
[parf] alarm ( 18): Memory_access(*tmp_3, write)
[parf] alarm ( 19): Memory_access(*tmp_6, write)
[parf] alarm ( 20): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 21): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] ====== project "base03-sample00 2" ======
[parf] Parameter: -eva-widening-delay 7 -eva-subdivide-non-linear 22 -eva-split-return auto -eva-slevel 96 -eva-remove-redundant-alarms -eva-plevel 135 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 130 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 126
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Memory_access(*tmp_12, write)
[parf] alarm (  9): Memory_access(*tmp_15, write)
[parf] alarm ( 10): Memory_access(*key, read)
[parf] alarm ( 11): Memory_access(*key, read)
[parf] alarm ( 12): Memory_access(*tmp_19, write)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*key, read)
[parf] alarm ( 15): Memory_access(*tmp_21, write)
[parf] alarm ( 16): Memory_access(*tmp_3, write)
[parf] alarm ( 17): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 18): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] ====== project "base03-sample01 2" ======
[parf] Parameter: -eva-widening-delay 13 -eva-subdivide-non-linear 29 -eva-split-return auto -eva-slevel 104 -eva-remove-redundant-alarms -eva-plevel 155 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 139 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 104
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Memory_access(*tmp_12, write)
[parf] alarm (  9): Memory_access(*tmp_15, write)
[parf] alarm ( 10): Memory_access(*key, read)
[parf] alarm ( 11): Memory_access(*key, read)
[parf] alarm ( 12): Memory_access(*tmp_19, write)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*key, read)
[parf] alarm ( 15): Memory_access(*tmp_21, write)
[parf] alarm ( 16): Memory_access(*tmp_3, write)
[parf] alarm ( 17): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 18): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] ====== project "base03-sample02 2" ======
[parf] Parameter: -eva-widening-delay 7 -eva-subdivide-non-linear 22 -eva-split-return auto -eva-slevel 103 -eva-remove-redundant-alarms -eva-plevel 140 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 134 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 128
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Memory_access(*tmp_12, write)
[parf] alarm (  9): Memory_access(*tmp_15, write)
[parf] alarm ( 10): Memory_access(*key, read)
[parf] alarm ( 11): Memory_access(*key, read)
[parf] alarm ( 12): Memory_access(*tmp_19, write)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*key, read)
[parf] alarm ( 15): Memory_access(*tmp_21, write)
[parf] alarm ( 16): Memory_access(*tmp_3, write)
[parf] alarm ( 17): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 18): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] ====== project "base03-sample03 2" ======
[parf] Parameter: -eva-widening-delay 8 -eva-subdivide-non-linear 25 -eva-split-return auto -eva-slevel 108 -eva-remove-redundant-alarms -eva-plevel 155 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 133 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 109
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Memory_access(*tmp_12, write)
[parf] alarm (  9): Memory_access(*tmp_15, write)
[parf] alarm ( 10): Memory_access(*key, read)
[parf] alarm ( 11): Memory_access(*key, read)
[parf] alarm ( 12): Memory_access(*tmp_19, write)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*key, read)
[parf] alarm ( 15): Memory_access(*tmp_21, write)
[parf] alarm ( 16): Memory_access(*tmp_3, write)
[parf] alarm ( 17): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 18): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] ====== project "base04-sample00 2" ======
[parf] Parameter: -eva-widening-delay 14 -eva-subdivide-non-linear 41 -eva-split-return auto -eva-slevel 190 -eva-remove-redundant-alarms -eva-plevel 274 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 245 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 201
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Memory_access(*tmp_12, write)
[parf] alarm (  9): Memory_access(*tmp_15, write)
[parf] alarm ( 10): Memory_access(*key, read)
[parf] alarm ( 11): Memory_access(*key, read)
[parf] alarm ( 12): Memory_access(*tmp_19, write)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*key, read)
[parf] alarm ( 15): Memory_access(*tmp_21, write)
[parf] alarm ( 16): Memory_access(*tmp_3, write)
[parf] alarm ( 17): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 18): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] ====== project "base04-sample01 2" ======
[parf] Parameter: -eva-widening-delay 11 -eva-subdivide-non-linear 48 -eva-split-return auto -eva-slevel 194 -eva-remove-redundant-alarms -eva-plevel 277 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 246 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 202
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Memory_access(*tmp_12, write)
[parf] alarm (  9): Memory_access(*tmp_15, write)
[parf] alarm ( 10): Memory_access(*key, read)
[parf] alarm ( 11): Memory_access(*key, read)
[parf] alarm ( 12): Memory_access(*tmp_19, write)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*key, read)
[parf] alarm ( 15): Memory_access(*tmp_21, write)
[parf] alarm ( 16): Memory_access(*tmp_3, write)
[parf] alarm ( 17): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 18): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] ====== project "base04-sample02 2" ======
[parf] Parameter: -eva-widening-delay 12 -eva-subdivide-non-linear 44 -eva-split-return auto -eva-slevel 189 -eva-remove-redundant-alarms -eva-plevel 274 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 281 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 204
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Memory_access(*tmp_12, write)
[parf] alarm (  9): Memory_access(*tmp_15, write)
[parf] alarm ( 10): Memory_access(*key, read)
[parf] alarm ( 11): Memory_access(*key, read)
[parf] alarm ( 12): Memory_access(*tmp_19, write)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*key, read)
[parf] alarm ( 15): Memory_access(*tmp_21, write)
[parf] alarm ( 16): Memory_access(*tmp_3, write)
[parf] alarm ( 17): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 18): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] ====== project "base04-sample03 2" ======
[parf] Parameter: -eva-widening-delay 16 -eva-subdivide-non-linear 48 -eva-split-return auto -eva-slevel 191 -eva-remove-redundant-alarms -eva-plevel 262 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 270 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 216
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Memory_access(*tmp_12, write)
[parf] alarm (  9): Memory_access(*tmp_15, write)
[parf] alarm ( 10): Memory_access(*key, read)
[parf] alarm ( 11): Memory_access(*key, read)
[parf] alarm ( 12): Memory_access(*tmp_19, write)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*key, read)
[parf] alarm ( 15): Memory_access(*tmp_21, write)
[parf] alarm ( 16): Memory_access(*tmp_3, write)
[parf] alarm ( 17): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 18): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] ====== project "base05-sample00 2" ======
[parf] Parameter: -eva-widening-delay 21 -eva-subdivide-non-linear 90 -eva-split-return auto -eva-slevel 369 -eva-remove-redundant-alarms -eva-plevel 507 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 497 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 391
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Memory_access(*tmp_12, write)
[parf] alarm (  9): Memory_access(*tmp_15, write)
[parf] alarm ( 10): Memory_access(*key, read)
[parf] alarm ( 11): Memory_access(*key, read)
[parf] alarm ( 12): Memory_access(*tmp_19, write)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*key, read)
[parf] alarm ( 15): Memory_access(*tmp_21, write)
[parf] alarm ( 16): Memory_access(*tmp_3, write)
[parf] alarm ( 17): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 18): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] ====== project "base05-sample01 2" ======
[parf] Parameter: -eva-widening-delay 20 -eva-subdivide-non-linear 88 -eva-split-return auto -eva-slevel 377 -eva-remove-redundant-alarms -eva-plevel 522 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 484 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 407
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Memory_access(*tmp_12, write)
[parf] alarm (  9): Memory_access(*tmp_15, write)
[parf] alarm ( 10): Memory_access(*key, read)
[parf] alarm ( 11): Memory_access(*key, read)
[parf] alarm ( 12): Memory_access(*tmp_19, write)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*key, read)
[parf] alarm ( 15): Memory_access(*tmp_21, write)
[parf] alarm ( 16): Memory_access(*tmp_3, write)
[parf] alarm ( 17): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 18): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] ====== project "base05-sample02 2" ======
[parf] Parameter: -eva-widening-delay 21 -eva-subdivide-non-linear 88 -eva-split-return auto -eva-slevel 398 -eva-remove-redundant-alarms -eva-plevel 536 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 490 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 390
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Memory_access(*tmp_12, write)
[parf] alarm (  9): Memory_access(*tmp_15, write)
[parf] alarm ( 10): Memory_access(*key, read)
[parf] alarm ( 11): Memory_access(*key, read)
[parf] alarm ( 12): Memory_access(*tmp_19, write)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*key, read)
[parf] alarm ( 15): Memory_access(*tmp_21, write)
[parf] alarm ( 16): Memory_access(*tmp_3, write)
[parf] alarm ( 17): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 18): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] ====== project "base05-sample03 2" ======
[parf] Parameter: -eva-widening-delay 18 -eva-subdivide-non-linear 79 -eva-split-return auto -eva-slevel 385 -eva-remove-redundant-alarms -eva-plevel 502 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 491 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 391
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Memory_access(*tmp_12, write)
[parf] alarm (  9): Memory_access(*tmp_15, write)
[parf] alarm ( 10): Memory_access(*key, read)
[parf] alarm ( 11): Memory_access(*key, read)
[parf] alarm ( 12): Memory_access(*tmp_19, write)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*key, read)
[parf] alarm ( 15): Memory_access(*tmp_21, write)
[parf] alarm ( 16): Memory_access(*tmp_3, write)
[parf] alarm ( 17): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 18): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] ====== project "base06-sample00 2" ======
[parf] Parameter: -eva-widening-delay 17 -eva-subdivide-non-linear 169 -eva-split-return auto -eva-slevel 759 -eva-remove-redundant-alarms -eva-plevel 1014 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 510 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 751
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Memory_access(*tmp_12, write)
[parf] alarm (  9): Memory_access(*tmp_15, write)
[parf] alarm ( 10): Memory_access(*key, read)
[parf] alarm ( 11): Memory_access(*key, read)
[parf] alarm ( 12): Memory_access(*tmp_19, write)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*key, read)
[parf] alarm ( 15): Memory_access(*tmp_21, write)
[parf] alarm ( 16): Memory_access(*tmp_3, write)
[parf] alarm ( 17): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 18): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] ====== project "base06-sample01 2" ======
[parf] Parameter: -eva-widening-delay 19 -eva-subdivide-non-linear 174 -eva-split-return auto -eva-slevel 735 -eva-remove-redundant-alarms -eva-plevel 1026 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 504 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 802
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Memory_access(*tmp_12, write)
[parf] alarm (  9): Memory_access(*tmp_15, write)
[parf] alarm ( 10): Memory_access(*key, read)
[parf] alarm ( 11): Memory_access(*key, read)
[parf] alarm ( 12): Memory_access(*tmp_19, write)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*key, read)
[parf] alarm ( 15): Memory_access(*tmp_21, write)
[parf] alarm ( 16): Memory_access(*tmp_3, write)
[parf] alarm ( 17): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 18): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] ====== project "base06-sample02 2" ======
[parf] Parameter: -eva-widening-delay 21 -eva-subdivide-non-linear 160 -eva-split-return auto -eva-slevel 728 -eva-remove-redundant-alarms -eva-plevel 1015 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 513 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 781
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Memory_access(*tmp_12, write)
[parf] alarm (  9): Memory_access(*tmp_15, write)
[parf] alarm ( 10): Memory_access(*key, read)
[parf] alarm ( 11): Memory_access(*key, read)
[parf] alarm ( 12): Memory_access(*tmp_19, write)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*key, read)
[parf] alarm ( 15): Memory_access(*tmp_21, write)
[parf] alarm ( 16): Memory_access(*tmp_3, write)
[parf] alarm ( 17): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 18): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] ====== project "base06-sample03 2" ======
[parf] Parameter: -eva-widening-delay 21 -eva-subdivide-non-linear 144 -eva-split-return auto -eva-slevel 722 -eva-remove-redundant-alarms -eva-plevel 984 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 513 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 788
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Memory_access(*tmp_12, write)
[parf] alarm (  9): Memory_access(*tmp_15, write)
[parf] alarm ( 10): Memory_access(*key, read)
[parf] alarm ( 11): Memory_access(*key, read)
[parf] alarm ( 12): Memory_access(*tmp_19, write)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*key, read)
[parf] alarm ( 15): Memory_access(*tmp_21, write)
[parf] alarm ( 16): Memory_access(*tmp_3, write)
[parf] alarm ( 17): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 18): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] ====== project "base07-sample00 2" ======
[parf] Parameter: -eva-widening-delay 20 -eva-subdivide-non-linear 286 -eva-split-return auto -eva-slevel 1531 -eva-remove-redundant-alarms -eva-plevel 2985 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 492 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 1776
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Memory_access(*tmp_12, write)
[parf] alarm (  9): Memory_access(*tmp_15, write)
[parf] alarm ( 10): Memory_access(*key, read)
[parf] alarm ( 11): Memory_access(*key, read)
[parf] alarm ( 12): Memory_access(*tmp_19, write)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*key, read)
[parf] alarm ( 15): Memory_access(*tmp_21, write)
[parf] alarm ( 16): Memory_access(*tmp_3, write)
[parf] alarm ( 17): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 18): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] ====== project "base07-sample01 2" ======
[parf] Parameter: -eva-widening-delay 21 -eva-subdivide-non-linear 296 -eva-split-return auto -eva-slevel 1392 -eva-remove-redundant-alarms -eva-plevel 2985 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 513 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 1776
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Memory_access(*tmp_12, write)
[parf] alarm (  9): Memory_access(*tmp_15, write)
[parf] alarm ( 10): Memory_access(*key, read)
[parf] alarm ( 11): Memory_access(*key, read)
[parf] alarm ( 12): Memory_access(*tmp_19, write)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*key, read)
[parf] alarm ( 15): Memory_access(*tmp_21, write)
[parf] alarm ( 16): Memory_access(*tmp_3, write)
[parf] alarm ( 17): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 18): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] ====== project "base07-sample02 2" ======
[parf] Parameter: -eva-widening-delay 20 -eva-subdivide-non-linear 305 -eva-split-return auto -eva-slevel 1477 -eva-remove-redundant-alarms -eva-plevel 2985 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 513 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 1776
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Memory_access(*tmp_12, write)
[parf] alarm (  9): Memory_access(*tmp_15, write)
[parf] alarm ( 10): Memory_access(*key, read)
[parf] alarm ( 11): Memory_access(*key, read)
[parf] alarm ( 12): Memory_access(*tmp_19, write)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*key, read)
[parf] alarm ( 15): Memory_access(*tmp_21, write)
[parf] alarm ( 16): Memory_access(*tmp_3, write)
[parf] alarm ( 17): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 18): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] ====== project "base07-sample03 2" ======
[parf] Parameter: -eva-widening-delay 21 -eva-subdivide-non-linear 288 -eva-split-return auto -eva-slevel 1421 -eva-remove-redundant-alarms -eva-plevel 2985 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 513 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 1776
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Memory_access(*tmp_12, write)
[parf] alarm (  9): Memory_access(*tmp_15, write)
[parf] alarm ( 10): Memory_access(*key, read)
[parf] alarm ( 11): Memory_access(*key, read)
[parf] alarm ( 12): Memory_access(*tmp_19, write)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*key, read)
[parf] alarm ( 15): Memory_access(*tmp_21, write)
[parf] alarm ( 16): Memory_access(*tmp_3, write)
[parf] alarm ( 17): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 18): Memory_access(*tmp_26, write)
[parf] ============================================================================
[parf] Final parameter: -eva-widening-delay 4 -eva-subdivide-non-linear 13 -eva-split-return auto -eva-slevel 54 -eva-remove-redundant-alarms -eva-plevel 75 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 0 -eva-ilevel 69 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 60
[parf] alarms:
[parf] alarm (  1): Memory_access(*tmp_8, write)
[parf] alarm (  2): Memory_access(*av, read)
[parf] alarm (  3): Memory_access(*av, read)
[parf] alarm (  4): Memory_access(*tmp_28, write)
[parf] alarm (  5): Memory_access(*av, read)
[parf] alarm (  6): Memory_access(*(av + 0), read)
[parf] alarm (  7): Memory_access(*(av + 1), read)
[parf] alarm (  8): Memory_access(*tmp_12, write)
[parf] alarm (  9): Memory_access(*tmp_15, write)
[parf] alarm ( 10): Memory_access(*key, read)
[parf] alarm ( 11): Memory_access(*key, read)
[parf] alarm ( 12): Memory_access(*tmp_19, write)
[parf] alarm ( 13): Memory_access(*key, read)
[parf] alarm ( 14): Memory_access(*key, read)
[parf] alarm ( 15): Memory_access(*tmp_21, write)
[parf] alarm ( 16): Memory_access(*tmp_3, write)
[parf] alarm ( 17): Signed_overflow(argc - 1 >= -2147483648)
[parf] alarm ( 18): Memory_access(*tmp_26, write)

real	2m12.370s
user	6m41.058s
sys	0m4.456s
