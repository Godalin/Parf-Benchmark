/* Generated by Frama-C */
#include "__fc_builtin.h"
#include "assert.h"
#include "errno.h"
#include "stdarg.h"
#include "stddef.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "strings.h"
struct SolState_t {
   int a ;
   int b ;
   int *deck ;
   int *spare ;
   int deck1[57] ;
   int deck2[57] ;
};
typedef struct SolState_t SolState_t;
SolState_t state;
int verbose = 0;
int lastout;
int cocount;
static void cycle_deck(int rounds)
{
  int *source;
  int *s;
  int *sb;
  int *d;
  int lo;
  int hi;
  int nlo;
  int nhi;
  int nccut;
  int output;
  while (1) {
    __FC_assert((state.a != state.b) != 0,"solitaire.c",67,
                "state.a != state.b");
    __FC_assert((*(state.deck + state.a) == 53) != 0,"solitaire.c",68,
                "state.deck[state.a] == 53");
    __FC_assert((*(state.deck + state.b) == 53) != 0,"solitaire.c",69,
                "state.deck[state.b] == 53");
    source = state.deck;
    if (state.a != 53) {
      *(source + state.a) = *(source + (state.a + 1));
      (state.a) ++;
    }
    else {
      source --;
      (state.b) ++;
      *(source + 0) = *(source + 1);
      state.a = 1;
    }
    if (state.a == state.b) (state.b) --;
    if (state.b != 53) {
      *(source + state.b) = *(source + (state.b + 1));
      (state.b) ++;
    }
    else {
      source --;
      (state.a) ++;
      *(source + 0) = *(source + 1);
      state.b = 1;
    }
    if (state.b == state.a) (state.a) --;
    if (state.b != 53) {
      *(source + state.b) = *(source + (state.b + 1));
      (state.b) ++;
    }
    else {
      source --;
      (state.a) ++;
      *(source + 0) = *(source + 1);
      state.b = 1;
    }
    if (state.b == state.a) (state.a) --;
    *(source + state.a) = 53;
    *(source + state.b) = 53;
    if (state.a < state.b) {
      lo = state.a;
      hi = state.b + 1;
    }
    else {
      lo = state.b;
      hi = state.a + 1;
    }
    nlo = 54 - hi;
    nhi = 54 - lo;
    nccut = *(source + (lo - 1));
    s = source;
    if (lo == 0) {
      __FC_assert((state.a == 0) != 0,"solitaire.c",93,"state.a == 0");
      __FC_assert((state.b == 2) != 0,"solitaire.c",94,"state.b == 2");
      d = state.spare + 51;
      sb = source + 3;
      while (s < sb) {
        int *tmp;
        int *tmp_0;
        tmp = d;
        d ++;
        tmp_0 = s;
        s ++;
        *tmp = *tmp_0;
      }
      d = state.spare + 0;
      sb = source + 54;
      while (s < sb) {
        int *tmp_1;
        int *tmp_2;
        tmp_1 = d;
        d ++;
        tmp_2 = s;
        s ++;
        *tmp_1 = *tmp_2;
      }
      state.a = 51;
      state.b = 53;
    }
    else 
      if (nccut <= nlo) {
        int *tmp_5;
        d = state.spare + (nhi - nccut);
        sb = source + (lo - 1);
        while (s < sb) {
          int *tmp_3;
          int *tmp_4;
          tmp_3 = d;
          d ++;
          tmp_4 = s;
          s ++;
          *tmp_3 = *tmp_4;
        }
        tmp_5 = s;
        s ++;
        *(state.spare + 53) = *tmp_5;
        d = state.spare + (nlo - nccut);
        sb = source + hi;
        while (s < sb) {
          int *tmp_6;
          int *tmp_7;
          tmp_6 = d;
          d ++;
          tmp_7 = s;
          s ++;
          *tmp_6 = *tmp_7;
        }
        d = state.spare + (53 - nccut);
        sb = source + (nccut + hi);
        while (s < sb) {
          int *tmp_8;
          int *tmp_9;
          tmp_8 = d;
          d ++;
          tmp_9 = s;
          s ++;
          *tmp_8 = *tmp_9;
        }
        d = state.spare + 0;
        sb = source + 54;
        while (s < sb) {
          int *tmp_10;
          int *tmp_11;
          tmp_10 = d;
          d ++;
          tmp_11 = s;
          s ++;
          *tmp_10 = *tmp_11;
        }
        state.a += (nlo - nccut) - lo;
        state.b += (nlo - nccut) - lo;
      }
      else 
        if (nccut < nhi) {
          int *tmp_14;
          d = state.spare + (nhi - nccut);
          sb = source + (lo - 1);
          while (s < sb) {
            int *tmp_12;
            int *tmp_13;
            tmp_12 = d;
            d ++;
            tmp_13 = s;
            s ++;
            *tmp_12 = *tmp_13;
          }
          tmp_14 = s;
          s ++;
          *(state.spare + 53) = *tmp_14;
          d = state.spare + ((53 - nccut) + nlo);
          sb = source + ((nccut - nlo) + lo);
          while (s < sb) {
            int *tmp_15;
            int *tmp_16;
            tmp_15 = d;
            d ++;
            tmp_16 = s;
            s ++;
            *tmp_15 = *tmp_16;
          }
          d = state.spare + 0;
          sb = source + hi;
          while (s < sb) {
            int *tmp_17;
            int *tmp_18;
            tmp_17 = d;
            d ++;
            tmp_18 = s;
            s ++;
            *tmp_17 = *tmp_18;
          }
          d = state.spare + (53 - nccut);
          sb = source + 54;
          while (s < sb) {
            int *tmp_19;
            int *tmp_20;
            tmp_19 = d;
            d ++;
            tmp_20 = s;
            s ++;
            *tmp_19 = *tmp_20;
          }
          if (state.a < state.b) {
            state.a = (53 - nccut) + nlo;
            state.b = (nhi - nccut) - 1;
          }
          else {
            state.b = (53 - nccut) + nlo;
            state.a = (nhi - nccut) - 1;
          }
        }
        else {
          int *tmp_25;
          d = state.spare + ((53 - nccut) + nhi);
          sb = source + (nccut - nhi);
          while (s < sb) {
            int *tmp_21;
            int *tmp_22;
            tmp_21 = d;
            d ++;
            tmp_22 = s;
            s ++;
            *tmp_21 = *tmp_22;
          }
          d = state.spare + 0;
          sb = source + (lo - 1);
          while (s < sb) {
            int *tmp_23;
            int *tmp_24;
            tmp_23 = d;
            d ++;
            tmp_24 = s;
            s ++;
            *tmp_23 = *tmp_24;
          }
          tmp_25 = s;
          s ++;
          *(state.spare + 53) = *tmp_25;
          d = state.spare + ((53 - nccut) + nlo);
          sb = source + hi;
          while (s < sb) {
            int *tmp_26;
            int *tmp_27;
            tmp_26 = d;
            d ++;
            tmp_27 = s;
            s ++;
            *tmp_26 = *tmp_27;
          }
          d = state.spare + (53 - nccut);
          sb = source + 54;
          while (s < sb) {
            int *tmp_28;
            int *tmp_29;
            tmp_28 = d;
            d ++;
            tmp_29 = s;
            s ++;
            *tmp_28 = *tmp_29;
          }
          state.a += ((53 - nccut) + nlo) - lo;
          state.b += ((53 - nccut) + nlo) - lo;
        }
    source = state.deck;
    state.deck = state.spare;
    state.spare = source;
    output = *(state.deck + *(state.deck + 0));
    if (output >= 26) 
      if (output >= 52) {
        if (output > 52) goto __Cont;
        output = 0;
      }
      else output -= 26;
    cocount += lastout == output;
    lastout = output;
    rounds --;
    __Cont: ;
    if (! (rounds > 0)) break;
  }
  return;
}

static void print_deck(void)
{
  int i;
  i = 0;
  /*@ loop unroll 54; */
  while (i < 54) {
    if (*(state.deck + i) < 53) putchar(' ' + *(state.deck + i));
    else 
      if (i == state.a) putchar('U');
      else {
        __FC_assert((i == state.b) != 0,"solitaire.c",191,"i == state.b");
        putchar('V');
      }
    i ++;
  }
  return;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_1(char const * restrict format, int param0);

static void key_deck(char *key)
{
  int i;
  int kval;
  int *tmp;
  state.deck = & state.deck1[3];
  state.spare = & state.deck2[3];
  i = 0;
  /*@ loop unroll 52; */
  while (i < 52) {
    *(state.deck + i) = i + 1;
    i ++;
  }
  state.a = 52;
  *(state.deck + state.a) = 53;
  state.b = 53;
  *(state.deck + state.b) = 53;
  while ((int)*key != '\000') {
    if ((int)*key >= 'A') 
      if ((int)*key <= 'Z') {
        cycle_deck(0);
        kval = ((int)*key - 'A') + 1;
        i = 0;
        /*@ loop unroll 53; */
        while (i < 53) {
          *(state.spare + i) = *(state.deck + (i + kval) % 53);
          i ++;
        }
        *(state.spare + 53) = *(state.deck + 53);
        if (state.a != 53) state.a = ((state.a + 53) - kval) % 53;
        if (state.b != 53) state.b = ((state.b + 53) - kval) % 53;
        tmp = state.deck;
        state.deck = state.spare;
        state.spare = tmp;
        if (verbose) {
          print_deck();
          printf(" after %c\n",(int)*key); /* printf_va_1 */
        }
      }
    key ++;
  }
  lastout = 100;
  cocount = 0;
  return;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, param0;
 */
int printf_va_2(char const * restrict format, int param0, int param1);

static char encrypt_char(char char_in)
{
  char char_out;
  cycle_deck(1);
  char_out = (char)('A' + (((int)char_in - 'A') + lastout) % 26);
  if (verbose) {
    print_deck();
    printf(" %c -> %c\n",(int)char_in,(int)char_out); /* printf_va_2 */
  }
  return char_out;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_3(char const * restrict format);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_4(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_5(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, param0;
 */
int printf_va_6(char const * restrict format, int param0, long param1);

int main(int argc, char **argv)
{
  int __retres;
  char *tmp;
  long rounds;
  char **av = argv;
  int slow_mode = 0;
  av ++;
  argc --;
  if (argc < 2) printf("Usage: [flags] key message|len\n"); /* printf_va_3 */
  /*@ loop unroll 3; */
  while (argc > 2) {
    int tmp_1;
    tmp_1 = strcmp((char const *)*av,"-v");
    if (tmp_1 == 0) verbose = 1;
    else {
      int tmp_0;
      tmp_0 = strcmp((char const *)*av,"-s");
      if (tmp_0 == 0) slow_mode = 1;
      else {
        printf("Unrecognised flag: %s\n",*av); /* printf_va_4 */
        exit(-1);
      }
    }
    av ++;
    argc --;
  }
  key_deck(*(av + 0));
  rounds = strtol((char const *)*(av + 1),& tmp,0);
  if ((int)*tmp != '\000') {
    char *text = *(av + 1);
    int i = 0;
    /*@ loop unroll 256; */
    while ((int)*text != '\000') {
      if ((int)*text >= 'A') 
        if ((int)*text <= 'Z') {
          char tmp_2;
          if (i > 0) 
            if (i % 5 == 0) putchar(' ');
          tmp_2 = encrypt_char(*text);
          putchar((int)tmp_2);
          i ++;
        }
      text ++;
    }
    while (i % 5 != 0) {
      char tmp_3;
      tmp_3 = encrypt_char((char)'X');
      putchar((int)tmp_3);
      i ++;
    }
    putchar('\n');
  }
  else {
    int i_0;
    if (rounds <= (long)0) {
      printf("Rounds number must be greater than zero\n"); /* printf_va_5 */
      exit(-1);
    }
    if (verbose) goto _LOR;
    else 
      if (slow_mode) {
        _LOR:
        {
          i_0 = 0;
          while ((long)i_0 < rounds) {
            encrypt_char((char)'A');
            i_0 ++;
          }
        }
      }
      else cycle_deck((int)rounds);
    printf("Coincidences: %d / %ld\n",cocount,rounds - (long)1); /* printf_va_6 */
  }
  __retres = 0;
  return __retres;
}

int volatile nondet;
int eva_main(void)
{
  char argv0[256];
  char argv1[256];
  char argv2[256];
  char argv3[256];
  char argv4[256];
  int tmp_0;
  int argc = Frama_C_interval(0,5);
  char *argv[6] = {argv0, argv1, argv2, argv3, argv4, (char *)0};
  {
    int i = 0;
    /*@ loop unroll 5; */
    while (i < 5) {
      Frama_C_make_unknown(argv[i],(size_t)255);
      *(argv[i] + 255) = (char)0;
      i ++;
    }
  }
  tmp_0 = main(argc,argv);
  return tmp_0;
}


