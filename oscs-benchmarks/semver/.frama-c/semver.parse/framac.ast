/* Generated by Frama-C */
#include "assert.h"
#include "errno.h"
#include "stdarg.h"
#include "stddef.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "strings.h"
struct semver_version_s {
   int major ;
   int minor ;
   int patch ;
   char *metadata ;
   char *prerelease ;
};
typedef struct semver_version_s semver_t;
enum operators {
    SYMBOL_GT = 0x3e,
    SYMBOL_LT = 0x3c,
    SYMBOL_EQ = 0x3d,
    SYMBOL_TF = 0x7e,
    SYMBOL_CF = 0x5e
};
struct test_case {
   char *x ;
   char *y ;
   int expected ;
};
struct test_case_match {
   char *x ;
   char *y ;
   char *op ;
   int expected ;
};
int semver_satisfies(semver_t x, semver_t y, char const *op);

int semver_satisfies_caret(semver_t x, semver_t y);

int semver_satisfies_patch(semver_t x, semver_t y);

int semver_compare(semver_t x, semver_t y);

int semver_compare_version(semver_t x, semver_t y);

int semver_compare_prerelease(semver_t x, semver_t y);

int semver_gt(semver_t x, semver_t y);

int semver_gte(semver_t x, semver_t y);

int semver_lt(semver_t x, semver_t y);

int semver_lte(semver_t x, semver_t y);

int semver_eq(semver_t x, semver_t y);

int semver_neq(semver_t x, semver_t y);

int semver_parse(char const *str, semver_t *ver);

int semver_parse_version(char const *str, semver_t *ver);

void semver_render(semver_t *x, char *dest);

int semver_numeric(semver_t *x);

void semver_bump(semver_t *x);

void semver_bump_minor(semver_t *x);

void semver_bump_patch(semver_t *x);

void semver_free(semver_t *x);

int semver_is_valid(char const *s);

int semver_clean(char *s);

static size_t const MAX_SIZE = sizeof(char) * (unsigned int)255;
static int const MAX_SAFE_INT = (int)((unsigned int)(-1) >> 1);
static int strcut(char *str, int begin, int len)
{
  int __retres;
  size_t l;
  l = strlen((char const *)str);
  if ((int)l < 0) {
    __retres = -1;
    goto return_label;
  }
  else 
    if ((int)l > MAX_SAFE_INT) {
      __retres = -1;
      goto return_label;
    }
  if (len < 0) len = (int)((l - (size_t)begin) + (size_t)1);
  if (begin + len > (int)l) len = (int)(l - (size_t)begin);
  memmove((void *)(str + begin),(void const *)((str + begin) + len),
          ((l - (size_t)len) + (size_t)1) - (size_t)begin);
  __retres = len;
  return_label: return __retres;
}

static int contains(char const c, char const *matrix, size_t len)
{
  int __retres;
  size_t x;
  x = (size_t)0;
  while (x < len) {
    if ((int)*(matrix + x) == (int)c) {
      __retres = 1;
      goto return_label;
    }
    x ++;
  }
  __retres = 0;
  return_label: return __retres;
}

static int has_valid_chars(char const *str, char const *matrix)
{
  int __retres;
  size_t i;
  size_t len;
  size_t mlen;
  len = strlen(str);
  mlen = strlen(matrix);
  i = (size_t)0;
  while (i < len) {
    int tmp;
    tmp = contains(*(str + i),matrix,mlen);
    if (tmp == 0) {
      __retres = 0;
      goto return_label;
    }
    i ++;
  }
  __retres = 1;
  return_label: return __retres;
}

static int binary_comparison(int x, int y)
{
  int __retres;
  if (x == y) {
    __retres = 0;
    goto return_label;
  }
  if (x > y) {
    __retres = 1;
    goto return_label;
  }
  __retres = -1;
  return_label: return __retres;
}

static int parse_int(char const *s)
{
  int __retres;
  int valid;
  int num;
  valid = has_valid_chars(s,"0123456789");
  if (valid == 0) {
    __retres = -1;
    goto return_label;
  }
  num = (int)strtol(s,(char **)0,10);
  if (num > MAX_SAFE_INT) {
    __retres = -1;
    goto return_label;
  }
  __retres = num;
  return_label: return __retres;
}

static char *parse_slice(char *buf, char sep)
{
  char *__retres;
  char *pr;
  char *part;
  int plen;
  size_t tmp;
  pr = strchr((char const *)buf,(int)sep);
  if (pr == (char *)0) {
    __retres = (char *)0;
    goto return_label;
  }
  tmp = strlen((char const *)pr);
  plen = (int)tmp;
  part = (char *)calloc((size_t)(plen + 1),sizeof(*part));
  if (part == (char *)0) {
    __retres = (char *)0;
    goto return_label;
  }
  memcpy((void *)part,(void const *)(pr + 1),(size_t)plen);
  *(part + plen) = (char)'\000';
  *pr = (char)'\000';
  __retres = part;
  return_label: return __retres;
}

int semver_parse(char const *str, semver_t *ver)
{
  int __retres;
  int valid;
  int res;
  size_t len;
  char *buf;
  valid = semver_is_valid(str);
  if (! valid) {
    __retres = -1;
    goto return_label;
  }
  len = strlen(str);
  buf = (char *)calloc(len + (size_t)1,sizeof(*buf));
  if (buf == (char *)0) {
    __retres = -1;
    goto return_label;
  }
  strcpy(buf,str);
  ver->metadata = parse_slice(buf,*("+" + 0));
  ver->prerelease = parse_slice(buf,*("-" + 0));
  res = semver_parse_version((char const *)buf,ver);
  free((void *)buf);
  __retres = res;
  return_label: return __retres;
}

int semver_parse_version(char const *str, semver_t *ver)
{
  int __retres;
  size_t len;
  int index_0;
  int value;
  char *slice;
  char *next;
  char *endptr;
  slice = (char *)str;
  index_0 = 0;
  while (1) {
    if (slice != (char *)0) {
      int tmp;
      tmp = index_0;
      index_0 ++;
      ;
      if (! (tmp < 4)) break;
    }
    else break;
    next = strchr((char const *)slice,(int)*("." + 0));
    if (next == (char *)0) len = strlen((char const *)slice);
    else len = (size_t)(next - slice);
    if (len > (size_t)50) {
      __retres = -1;
      goto return_label;
    }
    value = (int)strtol((char const *)slice,& endptr,10);
    if (endptr != next) 
      if ((int)*endptr != '\000') {
        __retres = -1;
        goto return_label;
      }
    switch (index_0) {
      case 1: ver->major = value;
      break;
      case 2: ver->minor = value;
      break;
      case 3: ver->patch = value;
      break;
    }
    if (next == (char *)0) slice = (char *)0; else slice = next + 1;
  }
  __retres = 0;
  return_label: return __retres;
}

static int compare_prerelease(char *x, char *y)
{
  int __retres;
  char *lastx;
  char *lasty;
  char *xptr;
  char *yptr;
  char *endptr;
  int xlen;
  int ylen;
  int xisnum;
  int yisnum;
  int xnum;
  int ynum;
  int xn;
  int yn;
  int min;
  int res;
  size_t tmp;
  size_t tmp_0;
  if (x == (char *)0) 
    if (y == (char *)0) {
      __retres = 0;
      goto return_label;
    }
  if (y == (char *)0) 
    if (x) {
      __retres = -1;
      goto return_label;
    }
  if (x == (char *)0) 
    if (y) {
      __retres = 1;
      goto return_label;
    }
  lastx = x;
  lasty = y;
  tmp = strlen((char const *)x);
  xlen = (int)tmp;
  tmp_0 = strlen((char const *)y);
  ylen = (int)tmp_0;
  while (1) {
    xptr = strchr((char const *)lastx,(int)*("." + 0));
    if (xptr == (char *)0) xptr = x + xlen;
    yptr = strchr((char const *)lasty,(int)*("." + 0));
    if (yptr == (char *)0) yptr = y + ylen;
    xnum = (int)strtol((char const *)lastx,& endptr,10);
    if (endptr == xptr) xisnum = 1; else xisnum = 0;
    ynum = (int)strtol((char const *)lasty,& endptr,10);
    if (endptr == yptr) yisnum = 1; else yisnum = 0;
    if (xisnum) 
      if (! yisnum) {
        __retres = -1;
        goto return_label;
      }
    if (! xisnum) 
      if (yisnum) {
        __retres = 1;
        goto return_label;
      }
    if (xisnum) {
      if (yisnum) {
        if (xnum != ynum) {
          int tmp_1;
          if (xnum < ynum) tmp_1 = -1; else tmp_1 = 1;
          __retres = tmp_1;
          goto return_label;
        }
      }
      else goto _LAND;
    }
    else {
      _LAND:
      {
        xn = xptr - lastx;
        yn = yptr - lasty;
        if (xn < yn) min = xn; else min = yn;
        res = strncmp((char const *)lastx,(char const *)lasty,(size_t)min);
        if (res) {
          int tmp_2;
          if (res < 0) tmp_2 = -1; else tmp_2 = 1;
          __retres = tmp_2;
          goto return_label;
        }
        if (xn != yn) {
          int tmp_3;
          if (xn < yn) tmp_3 = -1; else tmp_3 = 1;
          __retres = tmp_3;
          goto return_label;
        }
      }
    }
    lastx = xptr + 1;
    lasty = yptr + 1;
    if (lastx == (x + xlen) + 1) 
      if (lasty == (y + ylen) + 1) break;
    if (lastx == (x + xlen) + 1) {
      __retres = -1;
      goto return_label;
    }
    if (lasty == (y + ylen) + 1) {
      __retres = 1;
      goto return_label;
    }
  }
  __retres = 0;
  return_label: return __retres;
}

int semver_compare_prerelease(semver_t x, semver_t y)
{
  int tmp;
  tmp = compare_prerelease(x.prerelease,y.prerelease);
  return tmp;
}

int semver_compare_version(semver_t x, semver_t y)
{
  int __retres;
  int res;
  res = binary_comparison(x.major,y.major);
  if (res == 0) {
    res = binary_comparison(x.minor,y.minor);
    if (res == 0) {
      int tmp;
      tmp = binary_comparison(x.patch,y.patch);
      __retres = tmp;
      goto return_label;
    }
  }
  __retres = res;
  return_label: return __retres;
}

int semver_compare(semver_t x, semver_t y)
{
  int __retres;
  int res;
  res = semver_compare_version(x,y);
  if (res == 0) {
    int tmp;
    tmp = semver_compare_prerelease(x,y);
    __retres = tmp;
    goto return_label;
  }
  __retres = res;
  return_label: return __retres;
}

int semver_gt(semver_t x, semver_t y)
{
  int __retres;
  int tmp;
  tmp = semver_compare(x,y);
  __retres = tmp == 1;
  return __retres;
}

int semver_lt(semver_t x, semver_t y)
{
  int __retres;
  int tmp;
  tmp = semver_compare(x,y);
  __retres = tmp == -1;
  return __retres;
}

int semver_eq(semver_t x, semver_t y)
{
  int __retres;
  int tmp;
  tmp = semver_compare(x,y);
  __retres = tmp == 0;
  return __retres;
}

int semver_neq(semver_t x, semver_t y)
{
  int __retres;
  int tmp;
  tmp = semver_compare(x,y);
  __retres = tmp != 0;
  return __retres;
}

int semver_gte(semver_t x, semver_t y)
{
  int __retres;
  int tmp;
  tmp = semver_compare(x,y);
  __retres = tmp >= 0;
  return __retres;
}

int semver_lte(semver_t x, semver_t y)
{
  int __retres;
  int tmp;
  tmp = semver_compare(x,y);
  __retres = tmp <= 0;
  return __retres;
}

int semver_satisfies_caret(semver_t x, semver_t y)
{
  int __retres;
  if (x.major == y.major) {
    if (x.major == 0) {
      __retres = x.minor >= y.minor;
      goto return_label;
    }
    __retres = 1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int semver_satisfies_patch(semver_t x, semver_t y)
{
  int tmp;
  if (x.major == y.major) 
    if (x.minor == y.minor) tmp = 1; else tmp = 0;
  else tmp = 0;
  return tmp;
}

int semver_satisfies(semver_t x, semver_t y, char const *op)
{
  int __retres;
  int first;
  int second;
  first = (int)*(op + 0);
  second = (int)*(op + 1);
  if (first == SYMBOL_CF) {
    int tmp;
    tmp = semver_satisfies_caret(x,y);
    __retres = tmp;
    goto return_label;
  }
  if (first == SYMBOL_TF) {
    int tmp_0;
    tmp_0 = semver_satisfies_patch(x,y);
    __retres = tmp_0;
    goto return_label;
  }
  if (first == SYMBOL_EQ) {
    int tmp_1;
    tmp_1 = semver_eq(x,y);
    __retres = tmp_1;
    goto return_label;
  }
  if (first == SYMBOL_GT) {
    int tmp_3;
    if (second == SYMBOL_EQ) {
      int tmp_2;
      tmp_2 = semver_gte(x,y);
      __retres = tmp_2;
      goto return_label;
    }
    tmp_3 = semver_gt(x,y);
    __retres = tmp_3;
    goto return_label;
  }
  if (first == SYMBOL_LT) {
    int tmp_5;
    if (second == SYMBOL_EQ) {
      int tmp_4;
      tmp_4 = semver_lte(x,y);
      __retres = tmp_4;
      goto return_label;
    }
    tmp_5 = semver_lt(x,y);
    __retres = tmp_5;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

void semver_free(semver_t *x)
{
  if (x->metadata) {
    free((void *)x->metadata);
    x->metadata = (char *)0;
  }
  if (x->prerelease) {
    free((void *)x->prerelease);
    x->prerelease = (char *)0;
  }
  return;
}

/*@ requires valid_read_string(format);
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: *(format + (0 ..))), (indirect: param0);
    assigns *(s + (0 ..)) \from (indirect: *(format + (0 ..))), param0;
 */
int sprintf_va_1(char * restrict s, char const * restrict format, int param0);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: *(format + (0 ..))), param1, *(param0 + (0 ..));
 */
int sprintf_va_2(char * restrict s, char const * restrict format,
                 char *param0, int param1);

static void concat_num(char *str, int x, char *sep)
{
  char buf[50] = {(char)0};
  if (sep == (char *)0) sprintf(buf,"%d",x); /* sprintf_va_1 */
  else sprintf(buf,"%s%d",sep,x); /* sprintf_va_2 */
  strcat(str,(char const *)(buf));
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: *(format + (0 ..))), *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int sprintf_va_3(char * restrict s, char const * restrict format,
                 char *param0, char *param1);

static void concat_char(char *str, char *x, char *sep)
{
  char buf[50] = {(char)0};
  sprintf(buf,"%s%s",sep,x); /* sprintf_va_3 */
  strcat(str,(char const *)(buf));
  return;
}

void semver_render(semver_t *x, char *dest)
{
  if (x->major) concat_num(dest,x->major,(char *)0);
  if (x->minor) concat_num(dest,x->minor,(char *)".");
  if (x->patch) concat_num(dest,x->patch,(char *)".");
  if (x->prerelease) concat_char(dest,x->prerelease,(char *)"-");
  if (x->metadata) concat_char(dest,x->metadata,(char *)"+");
  return;
}

void semver_bump(semver_t *x)
{
  (x->major) ++;
  return;
}

void semver_bump_minor(semver_t *x)
{
  (x->minor) ++;
  return;
}

void semver_bump_patch(semver_t *x)
{
  (x->patch) ++;
  return;
}

static int has_valid_length(char const *s)
{
  int __retres;
  size_t tmp;
  tmp = strlen(s);
  ;
  __retres = tmp <= MAX_SIZE;
  return __retres;
}

int semver_is_valid(char const *s)
{
  int tmp_1;
  int tmp;
  tmp = has_valid_length(s);
  if (tmp) {
    int tmp_0;
    tmp_0 = has_valid_chars(s,
                            "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-+");
    if (tmp_0) tmp_1 = 1; else tmp_1 = 0;
  }
  else tmp_1 = 0;
  return tmp_1;
}

int semver_clean(char *s)
{
  int __retres;
  size_t i;
  size_t len;
  size_t mlen;
  int res;
  int tmp;
  tmp = has_valid_length((char const *)s);
  if (tmp == 0) {
    __retres = -1;
    goto return_label;
  }
  len = strlen((char const *)s);
  mlen = strlen("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-+");
  i = (size_t)0;
  while (i < len) {
    {
      int tmp_0;
      tmp_0 = contains(*(s + i),
                       "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-+",
                       mlen);
      if (tmp_0 == 0) {
        res = strcut(s,(int)i,1);
        if (res == -1) {
          __retres = -1;
          goto return_label;
        }
        len --;
        i --;
      }
    }
    i ++;
  }
  __retres = 0;
  return_label: return __retres;
}

static int char_to_int(char const *str)
{
  int buf;
  size_t i;
  size_t len;
  size_t mlen;
  buf = 0;
  len = strlen(str);
  mlen = strlen("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-+");
  i = (size_t)0;
  while (i < len) {
    int tmp;
    tmp = contains(*(str + i),
                   "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-+",
                   mlen);
    if (tmp) buf += (int)*(str + i);
    i ++;
  }
  return buf;
}

int semver_numeric(semver_t *x)
{
  int __retres;
  int num;
  char buf[50 * 3];
  memset((void *)(& buf),0,(size_t)(50 * 3));
  if (x->major) concat_num(buf,x->major,(char *)0);
  if (x->minor) concat_num(buf,x->minor,(char *)0);
  if (x->patch) concat_num(buf,x->patch,(char *)0);
  num = parse_int((char const *)(buf));
  if (num == -1) {
    __retres = -1;
    goto return_label;
  }
  if (x->prerelease) {
    int tmp;
    tmp = char_to_int((char const *)x->prerelease);
    num += tmp;
  }
  if (x->metadata) {
    int tmp_0;
    tmp_0 = char_to_int((char const *)x->metadata);
    num += tmp_0;
  }
  __retres = num;
  return_label: return __retres;
}

static void compare_helper(char *a, char *b, int expected,
                           int (*test_fn)(semver_t , semver_t ))
{
  int tmp;
  semver_t verX =
    {.major = 0,
     .minor = 0,
     .patch = 0,
     .metadata = (char *)0,
     .prerelease = (char *)0};
  semver_t verY =
    {.major = 0,
     .minor = 0,
     .patch = 0,
     .metadata = (char *)0,
     .prerelease = (char *)0};
  semver_parse((char const *)a,& verX);
  semver_parse((char const *)b,& verY);
  tmp = (*test_fn)(verX,verY);
  int resolution = tmp;
  __FC_assert((resolution == expected) != 0,"semver_test.c",44,
              "resolution == expected");
  semver_free(& verX);
  semver_free(& verY);
  return;
}

static void suite_runner(struct test_case *cases, int len,
                         int (*test_fn)(semver_t , semver_t ))
{
  int i;
  i = 0;
  while (i < len) {
    {
      struct test_case args = *(cases + i);
      compare_helper(args.x,args.y,args.expected,test_fn);
    }
    i ++;
  }
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_1(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_2(char const * restrict format);

void test_parse_simple(void)
{
  semver_t ver;
  printf("\n# Test: %s\n",(char *)"parse_simple"); /* printf_va_1 */
  char buf[7] =
    {(char)'1',
     (char)'.',
     (char)'2',
     (char)'.',
     (char)'1',
     (char)'2',
     (char)'\000'};
  int error = semver_parse((char const *)(buf),& ver);
  __FC_assert((error == 0) != 0,"semver_test.c",68,"error == 0");
  __FC_assert((ver.major == 1) != 0,"semver_test.c",69,"ver.major == 1");
  __FC_assert((ver.minor == 2) != 0,"semver_test.c",70,"ver.minor == 2");
  __FC_assert((ver.patch == 12) != 0,"semver_test.c",71,"ver.patch == 12");
  semver_free(& ver);
  printf("OK\n"); /* printf_va_2 */
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_3(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_4(char const * restrict format);

void test_parse_major(void)
{
  printf("\n# Test: %s\n",(char *)"parse_major"); /* printf_va_3 */
  char buf[2] = {(char)'2', (char)'\000'};
  semver_t ver =
    {.major = 0,
     .minor = 0,
     .patch = 0,
     .metadata = (char *)0,
     .prerelease = (char *)0};
  int error = semver_parse((char const *)(buf),& ver);
  __FC_assert((error == 0) != 0,"semver_test.c",87,"error == 0");
  __FC_assert((ver.major == 2) != 0,"semver_test.c",88,"ver.major == 2");
  __FC_assert((ver.minor == 0) != 0,"semver_test.c",89,"ver.minor == 0");
  __FC_assert((ver.patch == 0) != 0,"semver_test.c",90,"ver.patch == 0");
  semver_free(& ver);
  printf("OK\n"); /* printf_va_4 */
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_5(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_6(char const * restrict format);

void test_parse_minor(void)
{
  printf("\n# Test: %s\n",(char *)"parse_minor"); /* printf_va_5 */
  char buf[4] = {(char)'1', (char)'.', (char)'2', (char)'\000'};
  semver_t ver =
    {.major = 0,
     .minor = 0,
     .patch = 0,
     .metadata = (char *)0,
     .prerelease = (char *)0};
  int error = semver_parse((char const *)(buf),& ver);
  __FC_assert((error == 0) != 0,"semver_test.c",106,"error == 0");
  __FC_assert((ver.major == 1) != 0,"semver_test.c",107,"ver.major == 1");
  __FC_assert((ver.minor == 2) != 0,"semver_test.c",108,"ver.minor == 2");
  __FC_assert((ver.patch == 0) != 0,"semver_test.c",109,"ver.patch == 0");
  semver_free(& ver);
  printf("OK\n"); /* printf_va_6 */
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_7(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_8(char const * restrict format);

void test_parse_prerelease(void)
{
  int tmp_0;
  printf("\n# Test: %s\n",(char *)"parse_prerelease"); /* printf_va_7 */
  char buf[22] =
    {(char)'1',
     (char)'.',
     (char)'2',
     (char)'.',
     (char)'1',
     (char)'2',
     (char)'-',
     (char)'b',
     (char)'e',
     (char)'t',
     (char)'a',
     (char)'.',
     (char)'a',
     (char)'l',
     (char)'p',
     (char)'h',
     (char)'a',
     (char)'.',
     (char)'1',
     (char)'.',
     (char)'1',
     (char)'\000'};
  semver_t ver =
    {.major = 0,
     .minor = 0,
     .patch = 0,
     .metadata = (char *)0,
     .prerelease = (char *)0};
  int error = semver_parse((char const *)(buf),& ver);
  __FC_assert((error == 0) != 0,"semver_test.c",125,"error == 0");
  __FC_assert((ver.major == 1) != 0,"semver_test.c",126,"ver.major == 1");
  __FC_assert((ver.minor == 2) != 0,"semver_test.c",127,"ver.minor == 2");
  __FC_assert((ver.patch == 12) != 0,"semver_test.c",128,"ver.patch == 12");
  tmp_0 = strcmp((char const *)ver.prerelease,"beta.alpha.1.1");
  __FC_assert((tmp_0 == 0) != 0,"semver_test.c",129,
              "strcmp(ver.prerelease, \"beta.alpha.1.1\") == 0");
  semver_free(& ver);
  printf("OK\n"); /* printf_va_8 */
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_9(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_10(char const * restrict format);

void test_parse_metadata(void)
{
  int tmp_0;
  printf("\n# Test: %s\n",(char *)"parse_metadata"); /* printf_va_9 */
  char buf[22] =
    {(char)'1',
     (char)'.',
     (char)'2',
     (char)'.',
     (char)'1',
     (char)'2',
     (char)'+',
     (char)'2',
     (char)'0',
     (char)'1',
     (char)'3',
     (char)'0',
     (char)'3',
     (char)'1',
     (char)'3',
     (char)'1',
     (char)'4',
     (char)'4',
     (char)'7',
     (char)'0',
     (char)'0',
     (char)'\000'};
  semver_t ver =
    {.major = 0,
     .minor = 0,
     .patch = 0,
     .metadata = (char *)0,
     .prerelease = (char *)0};
  int error = semver_parse((char const *)(buf),& ver);
  __FC_assert((error == 0) != 0,"semver_test.c",145,"error == 0");
  __FC_assert((ver.major == 1) != 0,"semver_test.c",146,"ver.major == 1");
  __FC_assert((ver.minor == 2) != 0,"semver_test.c",147,"ver.minor == 2");
  __FC_assert((ver.patch == 12) != 0,"semver_test.c",148,"ver.patch == 12");
  tmp_0 = strcmp((char const *)ver.metadata,"20130313144700");
  __FC_assert((tmp_0 == 0) != 0,"semver_test.c",149,
              "strcmp(ver.metadata, \"20130313144700\") == 0");
  semver_free(& ver);
  printf("OK\n"); /* printf_va_10 */
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_11(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_12(char const * restrict format);

void test_parse_prerelerease_metadata(void)
{
  int tmp_0;
  int tmp_1;
  printf("\n# Test: %s\n",(char *)"parse_prerelease_metadata"); /* printf_va_11 */
  char buf[30] =
    {(char)'1',
     (char)'.',
     (char)'2',
     (char)'.',
     (char)'1',
     (char)'2',
     (char)'-',
     (char)'a',
     (char)'l',
     (char)'p',
     (char)'h',
     (char)'a',
     (char)'.',
     (char)'1',
     (char)'+',
     (char)'2',
     (char)'0',
     (char)'1',
     (char)'3',
     (char)'0',
     (char)'3',
     (char)'1',
     (char)'3',
     (char)'1',
     (char)'4',
     (char)'4',
     (char)'7',
     (char)'0',
     (char)'0',
     (char)'\000'};
  semver_t ver =
    {.major = 0,
     .minor = 0,
     .patch = 0,
     .metadata = (char *)0,
     .prerelease = (char *)0};
  int error = semver_parse((char const *)(buf),& ver);
  __FC_assert((error == 0) != 0,"semver_test.c",165,"error == 0");
  __FC_assert((ver.major == 1) != 0,"semver_test.c",166,"ver.major == 1");
  __FC_assert((ver.minor == 2) != 0,"semver_test.c",167,"ver.minor == 2");
  __FC_assert((ver.patch == 12) != 0,"semver_test.c",168,"ver.patch == 12");
  tmp_0 = strcmp((char const *)ver.prerelease,"alpha.1");
  __FC_assert((tmp_0 == 0) != 0,"semver_test.c",169,
              "strcmp(ver.prerelease, \"alpha.1\") == 0");
  tmp_1 = strcmp((char const *)ver.metadata,"20130313144700");
  __FC_assert((tmp_1 == 0) != 0,"semver_test.c",170,
              "strcmp(ver.metadata, \"20130313144700\") == 0");
  semver_free(& ver);
  printf("OK\n"); /* printf_va_12 */
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_13(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_14(char const * restrict format);

void test_compare(void)
{
  printf("\n# Test: %s\n",(char *)"semver_compare"); /* printf_va_13 */
  struct test_case cases[13] =
    {{.x = (char *)"1", .y = (char *)"0", .expected = 1},
     {.x = (char *)"1", .y = (char *)"1", .expected = 0},
     {.x = (char *)"1", .y = (char *)"3", .expected = -1},
     {.x = (char *)"1.5", .y = (char *)"0.8", .expected = 1},
     {.x = (char *)"1.5", .y = (char *)"1.3", .expected = 1},
     {.x = (char *)"1.2", .y = (char *)"2.2", .expected = -1},
     {.x = (char *)"3.0", .y = (char *)"1.5", .expected = 1},
     {.x = (char *)"1.5", .y = (char *)"1.5", .expected = 0},
     {.x = (char *)"1.0.9", .y = (char *)"1.0.0", .expected = 1},
     {.x = (char *)"1.0.9", .y = (char *)"1.0.9", .expected = 0},
     {.x = (char *)"1.1.5", .y = (char *)"1.1.9", .expected = -1},
     {.x = (char *)"1.2.2", .y = (char *)"1.1.9", .expected = 1},
     {.x = (char *)"1.2.2", .y = (char *)"1.2.9", .expected = -1}};
  suite_runner(cases,13,& semver_compare);
  printf("OK\n"); /* printf_va_14 */
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_15(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_16(char const * restrict format);

void test_compare_full(void)
{
  printf("\n# Test: %s\n",(char *)"semver_compare_full"); /* printf_va_15 */
  struct test_case cases[21] =
    {{.x = (char *)"1.5.1", .y = (char *)"1.5.1-beta", .expected = 1},
     {.x = (char *)"1.5.1-beta", .y = (char *)"1.5.1", .expected = -1},
     {.x = (char *)"1.5.1-beta", .y = (char *)"1.5.1-beta", .expected = 0},
     {.x = (char *)"1.5.1-beta", .y = (char *)"1.5.1-alpha", .expected = 1},
     {.x = (char *)"1.5.1-beta.1",
      .y = (char *)"1.5.1-alpha.1",
      .expected = 1},
     {.x = (char *)"1.5.1-beta.1", .y = (char *)"1.5.1-beta.0", .expected = 1},
     {.x = (char *)"1.5.1-beta.1.5",
      .y = (char *)"1.5.1-beta.1.5",
      .expected = 0},
     {.x = (char *)"1.5.1-beta.1.5",
      .y = (char *)"1.5.1-beta.1.4",
      .expected = 1},
     {.x = (char *)"1.5.1-beta.1.0",
      .y = (char *)"1.5.1-beta.1.4",
      .expected = -1},
     {.x = (char *)"1.5.1-beta.1.0",
      .y = (char *)"1.5.1-alpha.1.0",
      .expected = 1},
     {.x = (char *)"1.5.1-beta.1.100",
      .y = (char *)"1.5.1-alpha.1.99",
      .expected = 1},
     {.x = (char *)"1.5.1-beta.1.123456789",
      .y = (char *)"1.5.1-alpha.1.12345678",
      .expected = 1},
     {.x = (char *)"1.5.1-beta.alpha.1",
      .y = (char *)"1.5.1-beta.alpha.1.12345678",
      .expected = -1},
     {.x = (char *)"1.5.1-beta.alpha.1",
      .y = (char *)"1.5.1-beta.alpha.1+123",
      .expected = 0},
     {.x = (char *)"1.5.1-beta.1+20130313144700",
      .y = (char *)"1.5.1-beta.1+20120313144700",
      .expected = 0},
     {.x = (char *)"1.5.1-beta.1+20130313144700",
      .y = (char *)"1.5.1-beta.1+20130313144700",
      .expected = 0},
     {.x = (char *)"1.5.1-beta.1+20130313144700",
      .y = (char *)"1.5.1-beta.1+exp.sha.5114f85",
      .expected = 0},
     {.x = (char *)"1.5.1-beta.1+exp.sha.5114f85",
      .y = (char *)"1.5.1-beta.1+exp.sha.5114f84",
      .expected = 0},
     {.x = (char *)"1.5.1-beta.1+exp.sha.5114f85",
      .y = (char *)"1.5.1-beta.1+exp.sha1.5114f84",
      .expected = 0},
     {.x = (char *)"1.5.1-beta.1+exp.sha",
      .y = (char *)"1.5.1-beta.1+exp.sha256",
      .expected = 0},
     {.x = (char *)"1.5.1-alpha.beta",
      .y = (char *)"1.5.1-1.beta",
      .expected = 1}};
  suite_runner(cases,21,& semver_compare);
  printf("OK\n"); /* printf_va_16 */
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_17(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_18(char const * restrict format);

void test_compare_spec(void)
{
  printf("\n# Test: %s\n",(char *)"semver_compare_spec"); /* printf_va_17 */
  struct test_case cases[7] =
    {{.x = (char *)"1.0.0-alpha",
      .y = (char *)"1.0.0-alpha.1",
      .expected = -1},
     {.x = (char *)"1.0.0-alpha.1",
      .y = (char *)"1.0.0-alpha.beta",
      .expected = -1},
     {.x = (char *)"1.0.0-alpha.beta",
      .y = (char *)"1.0.0-beta",
      .expected = -1},
     {.x = (char *)"1.0.0-beta", .y = (char *)"1.0.0-beta.2", .expected = -1},
     {.x = (char *)"1.0.0-beta.2",
      .y = (char *)"1.0.0-beta.11",
      .expected = -1},
     {.x = (char *)"1.0.0-beta.11", .y = (char *)"1.0.0-rc.1", .expected = -1},
     {.x = (char *)"1.0.0-rc.1", .y = (char *)"1.0.0", .expected = -1}};
  suite_runner(cases,7,& semver_compare);
  printf("OK\n"); /* printf_va_18 */
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_19(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_20(char const * restrict format);

void test_compare_gt(void)
{
  printf("\n# Test: %s\n",(char *)"semver_gt"); /* printf_va_19 */
  struct test_case cases[15] =
    {{.x = (char *)"1", .y = (char *)"0", .expected = 1},
     {.x = (char *)"1", .y = (char *)"3", .expected = 0},
     {.x = (char *)"3.0", .y = (char *)"1", .expected = 1},
     {.x = (char *)"1.0", .y = (char *)"3", .expected = 0},
     {.x = (char *)"1.0", .y = (char *)"1", .expected = 0},
     {.x = (char *)"1.5", .y = (char *)"0.8", .expected = 1},
     {.x = (char *)"1.2", .y = (char *)"2.2", .expected = 0},
     {.x = (char *)"3.0", .y = (char *)"1.5", .expected = 1},
     {.x = (char *)"1.1", .y = (char *)"1.0.9", .expected = 1},
     {.x = (char *)"1.0", .y = (char *)"1.0.0", .expected = 0},
     {.x = (char *)"1.1.9", .y = (char *)"1.2", .expected = 0},
     {.x = (char *)"1.0.9", .y = (char *)"1.0.0", .expected = 1},
     {.x = (char *)"1.0.9", .y = (char *)"1.0.9", .expected = 0},
     {.x = (char *)"1.1.5", .y = (char *)"1.1.9", .expected = 0},
     {.x = (char *)"1.2.2", .y = (char *)"1.2.9", .expected = 0}};
  suite_runner(cases,15,& semver_gt);
  printf("OK\n"); /* printf_va_20 */
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_21(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_22(char const * restrict format);

void test_compare_lt(void)
{
  printf("\n# Test: %s\n",(char *)"semver_lt"); /* printf_va_21 */
  struct test_case cases[9] =
    {{.x = (char *)"1", .y = (char *)"0", .expected = 0},
     {.x = (char *)"1", .y = (char *)"3", .expected = 1},
     {.x = (char *)"1.5", .y = (char *)"0.8", .expected = 0},
     {.x = (char *)"1.2", .y = (char *)"2.2", .expected = 1},
     {.x = (char *)"3.0", .y = (char *)"1.5", .expected = 0},
     {.x = (char *)"1.0.9", .y = (char *)"1.0.0", .expected = 0},
     {.x = (char *)"1.0.9", .y = (char *)"1.0.9", .expected = 0},
     {.x = (char *)"1.1.5", .y = (char *)"1.1.9", .expected = 1},
     {.x = (char *)"1.2.2", .y = (char *)"1.2.9", .expected = 1}};
  suite_runner(cases,9,& semver_lt);
  printf("OK\n"); /* printf_va_22 */
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_23(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_24(char const * restrict format);

void test_compare_eq(void)
{
  printf("\n# Test: %s\n",(char *)"semver_eq"); /* printf_va_23 */
  struct test_case cases[11] =
    {{.x = (char *)"1", .y = (char *)"0", .expected = 0},
     {.x = (char *)"1", .y = (char *)"3", .expected = 0},
     {.x = (char *)"1", .y = (char *)"1", .expected = 1},
     {.x = (char *)"1.5", .y = (char *)"0.8", .expected = 0},
     {.x = (char *)"1.2", .y = (char *)"2.2", .expected = 0},
     {.x = (char *)"3.0", .y = (char *)"1.5", .expected = 0},
     {.x = (char *)"1.0", .y = (char *)"1.0", .expected = 1},
     {.x = (char *)"1.0.9", .y = (char *)"1.0.0", .expected = 0},
     {.x = (char *)"1.1.5", .y = (char *)"1.1.9", .expected = 0},
     {.x = (char *)"1.2.2", .y = (char *)"1.2.9", .expected = 0},
     {.x = (char *)"1.0.0", .y = (char *)"1.0.0", .expected = 1}};
  suite_runner(cases,11,& semver_eq);
  printf("OK\n"); /* printf_va_24 */
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_25(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_26(char const * restrict format);

void test_compare_neq(void)
{
  printf("\n# Test: %s\n",(char *)"semver_neq"); /* printf_va_25 */
  struct test_case cases[11] =
    {{.x = (char *)"1", .y = (char *)"0", .expected = 1},
     {.x = (char *)"1", .y = (char *)"3", .expected = 1},
     {.x = (char *)"1", .y = (char *)"1", .expected = 0},
     {.x = (char *)"1.5", .y = (char *)"0.8", .expected = 1},
     {.x = (char *)"1.2", .y = (char *)"2.2", .expected = 1},
     {.x = (char *)"3.0", .y = (char *)"1.5", .expected = 1},
     {.x = (char *)"1.0", .y = (char *)"1.0", .expected = 0},
     {.x = (char *)"1.0.9", .y = (char *)"1.0.0", .expected = 1},
     {.x = (char *)"1.1.5", .y = (char *)"1.1.9", .expected = 1},
     {.x = (char *)"1.2.2", .y = (char *)"1.2.9", .expected = 1},
     {.x = (char *)"1.0.0", .y = (char *)"1.0.0", .expected = 0}};
  suite_runner(cases,11,& semver_neq);
  printf("OK\n"); /* printf_va_26 */
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_27(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_28(char const * restrict format);

void test_compare_gte(void)
{
  printf("\n# Test: %s\n",(char *)"semver_gte"); /* printf_va_27 */
  struct test_case cases[11] =
    {{.x = (char *)"1", .y = (char *)"0", .expected = 1},
     {.x = (char *)"1", .y = (char *)"3", .expected = 0},
     {.x = (char *)"1", .y = (char *)"1", .expected = 1},
     {.x = (char *)"1.5", .y = (char *)"0.8", .expected = 1},
     {.x = (char *)"1.2", .y = (char *)"2.2", .expected = 0},
     {.x = (char *)"3.0", .y = (char *)"1.5", .expected = 1},
     {.x = (char *)"1.0", .y = (char *)"1.0", .expected = 1},
     {.x = (char *)"1.0.9", .y = (char *)"1.0.0", .expected = 1},
     {.x = (char *)"1.1.5", .y = (char *)"1.1.9", .expected = 0},
     {.x = (char *)"1.2.2", .y = (char *)"1.2.9", .expected = 0},
     {.x = (char *)"1.0.0", .y = (char *)"1.0.0", .expected = 1}};
  suite_runner(cases,11,& semver_gte);
  printf("OK\n"); /* printf_va_28 */
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_29(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_30(char const * restrict format);

void test_compare_lte(void)
{
  printf("\n# Test: %s\n",(char *)"semver_lte"); /* printf_va_29 */
  struct test_case cases[11] =
    {{.x = (char *)"1", .y = (char *)"0", .expected = 0},
     {.x = (char *)"1", .y = (char *)"3", .expected = 1},
     {.x = (char *)"1", .y = (char *)"1", .expected = 1},
     {.x = (char *)"1.5", .y = (char *)"0.8", .expected = 0},
     {.x = (char *)"1.2", .y = (char *)"2.2", .expected = 1},
     {.x = (char *)"3.0", .y = (char *)"1.5", .expected = 0},
     {.x = (char *)"1.0", .y = (char *)"1.0", .expected = 1},
     {.x = (char *)"1.0.9", .y = (char *)"1.0.0", .expected = 0},
     {.x = (char *)"1.1.5", .y = (char *)"1.1.9", .expected = 1},
     {.x = (char *)"1.2.2", .y = (char *)"1.2.9", .expected = 1},
     {.x = (char *)"1.0.0", .y = (char *)"1.0.0", .expected = 1}};
  suite_runner(cases,11,& semver_lte);
  printf("OK\n"); /* printf_va_30 */
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_31(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_32(char const * restrict format);

void test_satisfies(void)
{
  int i;
  printf("\n# Test: %s\n",(char *)"semver_satisfies"); /* printf_va_31 */
  struct test_case_match cases[82] =
    {{.x = (char *)"1", .y = (char *)"0", .op = (char *)">=", .expected = 1},
     {.x = (char *)"1", .y = (char *)"3", .op = (char *)">=", .expected = 0},
     {.x = (char *)"1", .y = (char *)"1", .op = (char *)">=", .expected = 1},
     {.x = (char *)"1.5",
      .y = (char *)"0.8",
      .op = (char *)">=",
      .expected = 1},
     {.x = (char *)"1.2",
      .y = (char *)"2.2",
      .op = (char *)">=",
      .expected = 0},
     {.x = (char *)"3.0",
      .y = (char *)"1.5",
      .op = (char *)">=",
      .expected = 1},
     {.x = (char *)"1.0",
      .y = (char *)"1.0",
      .op = (char *)">=",
      .expected = 1},
     {.x = (char *)"1.0.9",
      .y = (char *)"1.0.0",
      .op = (char *)">=",
      .expected = 1},
     {.x = (char *)"1.1.5",
      .y = (char *)"1.1.9",
      .op = (char *)">=",
      .expected = 0},
     {.x = (char *)"1.2.2",
      .y = (char *)"1.2.9",
      .op = (char *)">=",
      .expected = 0},
     {.x = (char *)"1.0.0",
      .y = (char *)"1.0.0",
      .op = (char *)">=",
      .expected = 1},
     {.x = (char *)"1", .y = (char *)"0", .op = (char *)"<=", .expected = 0},
     {.x = (char *)"1", .y = (char *)"3", .op = (char *)"<=", .expected = 1},
     {.x = (char *)"1", .y = (char *)"1", .op = (char *)"<=", .expected = 1},
     {.x = (char *)"1.5",
      .y = (char *)"0.8",
      .op = (char *)"<=",
      .expected = 0},
     {.x = (char *)"1.2",
      .y = (char *)"2.2",
      .op = (char *)"<=",
      .expected = 1},
     {.x = (char *)"3.0",
      .y = (char *)"1.5",
      .op = (char *)"<=",
      .expected = 0},
     {.x = (char *)"1.0",
      .y = (char *)"1.0",
      .op = (char *)"<=",
      .expected = 1},
     {.x = (char *)"1.0.9",
      .y = (char *)"1.0.0",
      .op = (char *)"<=",
      .expected = 0},
     {.x = (char *)"1.1.5",
      .y = (char *)"1.1.9",
      .op = (char *)"<=",
      .expected = 1},
     {.x = (char *)"1.2.2",
      .y = (char *)"1.2.9",
      .op = (char *)"<=",
      .expected = 1},
     {.x = (char *)"1.0.0",
      .y = (char *)"1.0.0",
      .op = (char *)"<=",
      .expected = 1},
     {.x = (char *)"1", .y = (char *)"0", .op = (char *)"=", .expected = 0},
     {.x = (char *)"1", .y = (char *)"3", .op = (char *)"=", .expected = 0},
     {.x = (char *)"1", .y = (char *)"1", .op = (char *)"=", .expected = 1},
     {.x = (char *)"1.5",
      .y = (char *)"0.8",
      .op = (char *)"=",
      .expected = 0},
     {.x = (char *)"1.2",
      .y = (char *)"2.2",
      .op = (char *)"=",
      .expected = 0},
     {.x = (char *)"3.0",
      .y = (char *)"1.5",
      .op = (char *)"=",
      .expected = 0},
     {.x = (char *)"1.0",
      .y = (char *)"1.0",
      .op = (char *)"=",
      .expected = 1},
     {.x = (char *)"1.0.9",
      .y = (char *)"1.0.0",
      .op = (char *)"=",
      .expected = 0},
     {.x = (char *)"1.1.5",
      .y = (char *)"1.1.9",
      .op = (char *)"=",
      .expected = 0},
     {.x = (char *)"1.2.2",
      .y = (char *)"1.2.9",
      .op = (char *)"=",
      .expected = 0},
     {.x = (char *)"1.0.0",
      .y = (char *)"1.0.0",
      .op = (char *)"=",
      .expected = 1},
     {.x = (char *)"1", .y = (char *)"0", .op = (char *)">", .expected = 1},
     {.x = (char *)"1", .y = (char *)"3", .op = (char *)">", .expected = 0},
     {.x = (char *)"1", .y = (char *)"1", .op = (char *)">", .expected = 0},
     {.x = (char *)"1.5",
      .y = (char *)"0.8",
      .op = (char *)">",
      .expected = 1},
     {.x = (char *)"1.2",
      .y = (char *)"2.2",
      .op = (char *)">",
      .expected = 0},
     {.x = (char *)"3.0",
      .y = (char *)"1.5",
      .op = (char *)">",
      .expected = 1},
     {.x = (char *)"1.0",
      .y = (char *)"1.0",
      .op = (char *)">",
      .expected = 0},
     {.x = (char *)"1.0.9",
      .y = (char *)"1.0.0",
      .op = (char *)">",
      .expected = 1},
     {.x = (char *)"1.1.5",
      .y = (char *)"1.1.9",
      .op = (char *)">",
      .expected = 0},
     {.x = (char *)"1.2.2",
      .y = (char *)"1.2.9",
      .op = (char *)">",
      .expected = 0},
     {.x = (char *)"1.0.0",
      .y = (char *)"1.0.0",
      .op = (char *)">",
      .expected = 0},
     {.x = (char *)"1", .y = (char *)"0", .op = (char *)"<", .expected = 0},
     {.x = (char *)"1", .y = (char *)"3", .op = (char *)"<", .expected = 1},
     {.x = (char *)"1", .y = (char *)"1", .op = (char *)"<", .expected = 0},
     {.x = (char *)"1.5",
      .y = (char *)"0.8",
      .op = (char *)"<",
      .expected = 0},
     {.x = (char *)"1.2",
      .y = (char *)"2.2",
      .op = (char *)"<",
      .expected = 1},
     {.x = (char *)"3.0",
      .y = (char *)"1.5",
      .op = (char *)"<",
      .expected = 0},
     {.x = (char *)"1.0",
      .y = (char *)"1.0",
      .op = (char *)"<",
      .expected = 0},
     {.x = (char *)"1.0.9",
      .y = (char *)"1.0.0",
      .op = (char *)"<",
      .expected = 0},
     {.x = (char *)"1.1.5",
      .y = (char *)"1.1.9",
      .op = (char *)"<",
      .expected = 1},
     {.x = (char *)"1.2.2",
      .y = (char *)"1.2.9",
      .op = (char *)"<",
      .expected = 1},
     {.x = (char *)"1.0.0",
      .y = (char *)"1.0.0",
      .op = (char *)"<",
      .expected = 0},
     {.x = (char *)"1", .y = (char *)"0", .op = (char *)"^", .expected = 0},
     {.x = (char *)"1", .y = (char *)"3", .op = (char *)"^", .expected = 0},
     {.x = (char *)"1", .y = (char *)"1", .op = (char *)"^", .expected = 1},
     {.x = (char *)"1.5",
      .y = (char *)"0.8",
      .op = (char *)"^",
      .expected = 0},
     {.x = (char *)"1.2",
      .y = (char *)"2.2",
      .op = (char *)"^",
      .expected = 0},
     {.x = (char *)"3.0",
      .y = (char *)"1.5",
      .op = (char *)"^",
      .expected = 0},
     {.x = (char *)"1.0",
      .y = (char *)"1.0",
      .op = (char *)"^",
      .expected = 1},
     {.x = (char *)"1.0.9",
      .y = (char *)"1.0.0",
      .op = (char *)"^",
      .expected = 1},
     {.x = (char *)"1.1.5",
      .y = (char *)"1.1.9",
      .op = (char *)"^",
      .expected = 1},
     {.x = (char *)"1.3.2",
      .y = (char *)"1.1.9",
      .op = (char *)"^",
      .expected = 1},
     {.x = (char *)"1.1.2",
      .y = (char *)"1.5.9",
      .op = (char *)"^",
      .expected = 1},
     {.x = (char *)"0.1.2",
      .y = (char *)"1.5.9",
      .op = (char *)"^",
      .expected = 0},
     {.x = (char *)"0.1.2",
      .y = (char *)"0.2.9",
      .op = (char *)"^",
      .expected = 0},
     {.x = (char *)"1.2.2",
      .y = (char *)"1.2.9",
      .op = (char *)"^",
      .expected = 1},
     {.x = (char *)"1.0.0",
      .y = (char *)"1.0.0",
      .op = (char *)"^",
      .expected = 1},
     {.x = (char *)"1", .y = (char *)"0", .op = (char *)"~", .expected = 0},
     {.x = (char *)"1", .y = (char *)"3", .op = (char *)"~", .expected = 0},
     {.x = (char *)"1", .y = (char *)"1", .op = (char *)"~", .expected = 1},
     {.x = (char *)"1.5",
      .y = (char *)"0.8",
      .op = (char *)"~",
      .expected = 0},
     {.x = (char *)"1.2",
      .y = (char *)"2.2",
      .op = (char *)"~",
      .expected = 0},
     {.x = (char *)"3.0",
      .y = (char *)"1.5",
      .op = (char *)"~",
      .expected = 0},
     {.x = (char *)"1.0",
      .y = (char *)"1.0",
      .op = (char *)"~",
      .expected = 1},
     {.x = (char *)"1.0.9",
      .y = (char *)"1.0.0",
      .op = (char *)"~",
      .expected = 1},
     {.x = (char *)"1.1.5",
      .y = (char *)"1.1.9",
      .op = (char *)"~",
      .expected = 1},
     {.x = (char *)"1.1.9",
      .y = (char *)"1.1.3",
      .op = (char *)"~",
      .expected = 1},
     {.x = (char *)"1.2.2",
      .y = (char *)"1.3.9",
      .op = (char *)"~",
      .expected = 0},
     {.x = (char *)"1.0.0",
      .y = (char *)"1.0.0",
      .op = (char *)"~",
      .expected = 1}};
  i = 0;
  while (i < 82) {
    {
      struct test_case_match args = cases[i];
      semver_t verX =
        {.major = 0,
         .minor = 0,
         .patch = 0,
         .metadata = (char *)0,
         .prerelease = (char *)0};
      semver_t verY =
        {.major = 0,
         .minor = 0,
         .patch = 0,
         .metadata = (char *)0,
         .prerelease = (char *)0};
      semver_parse((char const *)args.x,& verX);
      semver_parse((char const *)args.y,& verY);
      int resolution = semver_satisfies(verX,verY,(char const *)args.op);
      __FC_assert((resolution == args.expected) != 0,"semver_test.c",492,
                  "resolution == args.expected");
      semver_free(& verX);
      semver_free(& verY);
    }
    i ++;
  }
  printf("OK\n"); /* printf_va_32 */
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_33(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_34(char const * restrict format);

void test_render(void)
{
  int tmp;
  int tmp_0;
  printf("\n# Test: %s\n",(char *)"render"); /* printf_va_33 */
  semver_t ver =
    {.major = 1,
     .minor = 5,
     .patch = 8,
     .metadata = (char *)0,
     .prerelease = (char *)0};
  char *str[10] = {(char *)0};
  semver_render(& ver,(char *)(str));
  tmp = strcmp((char const *)(str),"1.5.8");
  __FC_assert((tmp == 0) != 0,"semver_test.c",513,
              "strcmp((char *) str, \"1.5.8\") == 0");
  semver_t ver2 =
    {.major = 1,
     .minor = 5,
     .patch = 8,
     .metadata = (char *)0,
     .prerelease = (char *)0};
  ver2.prerelease = (char *)"alpha.1";
  ver2.metadata = (char *)"1232323";
  char *str2[22] = {(char *)0};
  semver_render(& ver2,(char *)(str2));
  tmp_0 = strcmp((char const *)(str2),"1.5.8-alpha.1+1232323");
  __FC_assert((tmp_0 == 0) != 0,"semver_test.c",520,
              "strcmp((char *) str2, \"1.5.8-alpha.1+1232323\") == 0");
  printf("OK\n"); /* printf_va_34 */
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_35(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_36(char const * restrict format);

void test_numeric(void)
{
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  printf("\n# Test: %s\n",(char *)"numeric"); /* printf_va_35 */
  semver_t v0 =
    {.major = 0,
     .minor = 5,
     .patch = 9,
     .metadata = (char *)0,
     .prerelease = (char *)0};
  tmp = semver_numeric(& v0);
  __FC_assert((tmp == 59) != 0,"semver_test.c",530,
              "semver_numeric(&v0) == 59");
  semver_t v1 =
    {.major = 1,
     .minor = 3,
     .patch = 6,
     .metadata = (char *)0,
     .prerelease = (char *)0};
  tmp_0 = semver_numeric(& v1);
  __FC_assert((tmp_0 == 136) != 0,"semver_test.c",533,
              "semver_numeric(&v1) == 136");
  semver_t v2 =
    {.major = 1,
     .minor = 3,
     .patch = 6,
     .metadata = (char *)"beta",
     .prerelease = (char *)"123456789"};
  tmp_1 = semver_numeric(& v2);
  __FC_assert((tmp_1 == 1025) != 0,"semver_test.c",536,
              "semver_numeric(&v2) == 1025");
  semver_t v3 =
    {.major = 1,
     .minor = 3,
     .patch = 6,
     .metadata = (char *)"be$ta",
     .prerelease = (char *)"12&345@67(89"};
  tmp_2 = semver_numeric(& v3);
  __FC_assert((tmp_2 == 1025) != 0,"semver_test.c",539,
              "semver_numeric(&v3) == 1025");
  printf("OK\n"); /* printf_va_36 */
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_37(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_38(char const * restrict format);

void test_bump(void)
{
  printf("\n# Test: %s\n",(char *)"bump"); /* printf_va_37 */
  semver_t ver =
    {.major = 1,
     .minor = 5,
     .patch = 8,
     .metadata = (char *)0,
     .prerelease = (char *)0};
  semver_bump(& ver);
  __FC_assert((ver.major == 2) != 0,"semver_test.c",554,"ver.major == 2");
  semver_free(& ver);
  semver_t ver2 =
    {.major = 1,
     .minor = 0,
     .patch = 0,
     .metadata = (char *)0,
     .prerelease = (char *)0};
  semver_bump(& ver2);
  __FC_assert((ver2.major == 2) != 0,"semver_test.c",559,"ver2.major == 2");
  semver_free(& ver2);
  semver_t ver3 =
    {.major = 0,
     .minor = 0,
     .patch = 0,
     .metadata = (char *)0,
     .prerelease = (char *)0};
  semver_bump(& ver3);
  __FC_assert((ver3.major == 1) != 0,"semver_test.c",564,"ver3.major == 1");
  semver_free(& ver3);
  printf("OK\n"); /* printf_va_38 */
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_39(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_40(char const * restrict format);

void test_bump_minor(void)
{
  printf("\n# Test: %s\n",(char *)"bump_minor"); /* printf_va_39 */
  semver_t ver =
    {.major = 1,
     .minor = 5,
     .patch = 8,
     .metadata = (char *)0,
     .prerelease = (char *)0};
  semver_bump_minor(& ver);
  __FC_assert((ver.minor == 6) != 0,"semver_test.c",576,"ver.minor == 6");
  semver_free(& ver);
  semver_t ver2 =
    {.major = 1,
     .minor = 0,
     .patch = 0,
     .metadata = (char *)0,
     .prerelease = (char *)0};
  semver_bump_minor(& ver2);
  __FC_assert((ver2.minor == 1) != 0,"semver_test.c",581,"ver2.minor == 1");
  semver_free(& ver2);
  printf("OK\n"); /* printf_va_40 */
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_41(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_42(char const * restrict format);

void test_bump_patch(void)
{
  printf("\n# Test: %s\n",(char *)"bump_patch"); /* printf_va_41 */
  semver_t ver =
    {.major = 1,
     .minor = 5,
     .patch = 8,
     .metadata = (char *)0,
     .prerelease = (char *)0};
  semver_bump_patch(& ver);
  __FC_assert((ver.patch == 9) != 0,"semver_test.c",593,"ver.patch == 9");
  semver_free(& ver);
  semver_t ver2 =
    {.major = 1,
     .minor = 5,
     .patch = 0,
     .metadata = (char *)0,
     .prerelease = (char *)0};
  semver_bump_patch(& ver2);
  __FC_assert((ver2.patch == 1) != 0,"semver_test.c",598,"ver2.patch == 1");
  semver_free(& ver2);
  printf("OK\n"); /* printf_va_42 */
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_43(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_44(char const * restrict format);

void test_free(void)
{
  printf("\n# Test: %s\n",(char *)"free"); /* printf_va_43 */
  semver_t ver =
    {.major = 0,
     .minor = 0,
     .patch = 0,
     .metadata = (char *)0,
     .prerelease = (char *)0};
  char *str = (char *)"1.5.6";
  semver_parse((char const *)str,& ver);
  __FC_assert((ver.major == 1) != 0,"semver_test.c",615,"ver.major == 1");
  __FC_assert((ver.patch == 6) != 0,"semver_test.c",616,"ver.patch == 6");
  semver_free(& ver);
  semver_t ver2 =
    {.major = 0,
     .minor = 0,
     .patch = 0,
     .metadata = (char *)0,
     .prerelease = (char *)0};
  char *str2 = (char *)"1.5.6-beta.1+12345";
  semver_parse((char const *)str2,& ver2);
  __FC_assert((ver2.prerelease != (char *)0) != 0,"semver_test.c",622,
              "ver2.prerelease != NULL");
  semver_free(& ver2);
  __FC_assert((ver2.prerelease == (char *)0) != 0,"semver_test.c",624,
              "ver2.prerelease == NULL");
  printf("OK\n"); /* printf_va_44 */
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_45(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_46(char const * restrict format);

void test_valid_chars(void)
{
  int valid;
  printf("\n# Test: %s\n",(char *)"valid_chars"); /* printf_va_45 */
  valid = semver_is_valid("1");
  __FC_assert((valid == 1) != 0,"semver_test.c",640,"valid == 1");
  valid = semver_is_valid("159");
  __FC_assert((valid == 1) != 0,"semver_test.c",643,"valid == 1");
  valid = semver_is_valid("1b3");
  __FC_assert((valid == 1) != 0,"semver_test.c",646,"valid == 1");
  valid = semver_is_valid("3 0 1");
  __FC_assert((valid == 0) != 0,"semver_test.c",649,"valid == 0");
  valid = semver_is_valid("&3@(");
  __FC_assert((valid == 0) != 0,"semver_test.c",652,"valid == 0");
  printf("OK\n"); /* printf_va_46 */
  return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_47(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_48(char const * restrict format);

void test_clean(void)
{
  int error;
  int tmp;
  int tmp_0;
  printf("\n# Test: %s\n",(char *)"clean"); /* printf_va_47 */
  char str[6] =
    {(char)'1', (char)'.', (char)'2', (char)'.', (char)'3', (char)'\000'};
  error = semver_clean(str);
  tmp = strcmp((char const *)(str),"1.2.3");
  __FC_assert((tmp == 0) != 0,"semver_test.c",665,
              "strcmp(str, \"1.2.3\") == 0");
  __FC_assert((error == 0) != 0,"semver_test.c",666,"error == 0");
  char str2[29] =
    {(char)' ',
     (char)'1',
     (char)'.',
     (char)'@',
     (char)'2',
     (char)'.',
     (char)'3',
     (char)'-',
     (char)'b',
     (char)'e',
     (char)'t',
     (char)'a',
     (char)' ',
     (char)'#',
     (char)'.',
     (char)'a',
     (char)'l',
     (char)'p',
     (char)'h',
     (char)'a',
     (char)'+',
     (char)'1',
     (char)'2',
     (char)'@',
     (char)'3',
     (char)'4',
     (char)' ',
     (char)' ',
     (char)'\000'};
  error = semver_clean(str2);
  tmp_0 = strcmp((char const *)(str2),"1.2.3-beta.alpha+1234");
  __FC_assert((tmp_0 == 0) != 0,"semver_test.c",670,
              "strcmp(str2, \"1.2.3-beta.alpha+1234\") == 0");
  __FC_assert((error == 0) != 0,"semver_test.c",671,"error == 0");
  printf("OK\n"); /* printf_va_48 */
  return;
}

int main(void)
{
  int __retres;
  test_parse_simple();
  test_parse_major();
  test_parse_minor();
  test_parse_prerelease();
  test_parse_metadata();
  test_parse_prerelerease_metadata();
  test_compare();
  test_compare_full();
  test_compare_spec();
  test_compare_gt();
  test_compare_lt();
  test_compare_eq();
  test_compare_neq();
  test_compare_gte();
  test_compare_lte();
  test_satisfies();
  test_render();
  test_numeric();
  test_bump();
  test_bump_minor();
  test_bump_patch();
  test_free();
  test_valid_chars();
  test_clean();
  __retres = 0;
  return __retres;
}


