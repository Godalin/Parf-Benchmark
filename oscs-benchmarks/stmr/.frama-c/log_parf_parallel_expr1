Entering directory '/Users/carolt/Abstract_Interpretation/Tools_Development/Frama-c-Plugin/src/demo_1'
Leaving directory '/Users/carolt/Abstract_Interpretation/Tools_Development/Frama-c-Plugin/src/demo_1'
[kernel] Parsing stmr.c (with preprocessing)
[kernel] Parsing test.c (with preprocessing)
[kernel] Parsing FRAMAC_SHARE/libc/stdio.c (with preprocessing)
[kernel] Parsing FRAMAC_SHARE/libc/string.c (with preprocessing)
mkdir: .parf_temp_files: File exists
rm: .parf_temp_files/*.sav: No such file or directory
[parf] checkout project: project "default"
[parf] init parameters: -eva-widening-delay 1 -eva-subdivide-non-linear 0 -eva-slevel 0 -eva-plevel 10 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 8 -eva-equality-through-calls none -eva-domains cvalue -eva-auto-loop-unroll 0
[parf] run eva: start
[parf] set eva options
[parf] parameters: -eva-widening-delay 1 -eva-subdivide-non-linear 0 -eva-slevel 0 -eva-plevel 10 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 8 -eva-equality-through-calls none -eva-domains cvalue -eva-auto-loop-unroll 0
[parf] @default,cvalue
[eva] Analyzing a complete application starting at main
[eva] using specification for function fopen
[eva] using specification for function ferror
[eva] using specification for function feof
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73
[eva] using specification for function Frama_C_interval
[eva] using specification for function Frama_C_unsigned_char_interval
[eva] FRAMAC_SHARE/libc/stdio.c:83: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:104: allocating variable __realloc_getline_l104
[eva] FRAMAC_SHARE/libc/stdio.c:82: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_0
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_0
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_0
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_1
[eva] FRAMAC_SHARE/libc/string.c:168: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.h:124: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] stmr.c:99: starting to merge loop iterations
[eva] using specification for function isConsonant
[eva] stmr.c:113: starting to merge loop iterations
[eva] stmr.c:114: starting to merge loop iterations
[eva] stmr.c:129: starting to merge loop iterations
[eva] stmr.c:152: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:146: starting to merge loop iterations
[eva] using specification for function fprintf_va_1
[eva] using specification for function fprintf_va_2
[eva] using specification for function fprintf_va_3
[eva] using specification for function fprintf_va_4
[eva] using specification for function printf_va_1
[eva] test.c:59: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_2
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_3
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_4
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_5
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_6
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_7
[eva] using specification for function printf_va_2
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function exit
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_9
[eva] using specification for function printf_va_10
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  17 functions analyzed (out of 17): 100% coverage.
  In these functions, 497 statements reached (out of 500): 99% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  63 alarms generated by the analysis:
      28 invalid memory accesses
      22 accesses to uninitialized left-values
      13 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    32 valid    10 unknown     0 invalid     42 total
  76% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[parf] base: base00
[parf] Analysis time for this epoch: 180
[parf] sample: base00-sample00
[parf] sample: base00-sample01
[parf] sample: base00-sample02
[parf] sample: base00-sample03
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] run eva: start
[parf] parameters: -eva-widening-delay 2 -eva-subdivide-non-linear 4 -eva-split-return auto -eva-slevel 11 -eva-plevel 32 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 19 -eva-equality-through-calls none -eva-domains cvalue,octagon,symbolic-locations -eva-auto-loop-unroll 11
[parf] run eva: start
[parf] set eva options
[parf] parameters: -eva-widening-delay 2 -eva-subdivide-non-linear 3 -eva-slevel 9 -eva-plevel 25 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 16 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon -eva-auto-loop-unroll 18
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 2 -eva-subdivide-non-linear 1 -eva-split-return auto -eva-slevel 5 -eva-remove-redundant-alarms -eva-plevel 29 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 16 -eva-equality-through-calls formals -eva-domains cvalue,gauges,octagon -eva-auto-loop-unroll 7
[parf] parameters: -eva-widening-delay 2 -eva-subdivide-non-linear 2 -eva-split-return auto -eva-slevel 10 -eva-remove-redundant-alarms -eva-plevel 31 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 19 -eva-equality-through-calls formals -eva-domains cvalue,octagon -eva-auto-loop-unroll 12
[parf] @default,cvalue,octagon
[parf] @default,cvalue,gauges,octagon
[parf] @default,cvalue,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon
[eva] Splitting return states on:
  \return(memcmp) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memrchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgetc) == -1, 10 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(feof) == 0 (auto)
  \return(ferror) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(getline) == -1 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_interval) == 0, 10 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
  \return(isConsonant) == 0 (auto)
  \return(getMeasure) == 1 (auto)
  \return(vowelInStem) == 0 (auto)
  \return(isDoubleConsonant) == 0 (auto)
  \return(cvc) == 0 (auto)
  \return(ends) == 0 (auto)
  \return(is_valid_mode) == 0 (auto)
  \return(char_equal_ignore_case) == 0 (auto)
[eva] Splitting return states on:
  \return(memcmp) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memrchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgetc) == -1, 10 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(feof) == 0 (auto)
  \return(ferror) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(getline) == -1 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_interval) == 0, 10 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
  \return(isConsonant) == 0 (auto)
  \return(getMeasure) == 1 (auto)
  \return(vowelInStem) == 0 (auto)
  \return(isDoubleConsonant) == 0 (auto)
  \return(cvc) == 0 (auto)
  \return(ends) == 0 (auto)
  \return(is_valid_mode) == 0 (auto)
  \return(char_equal_ignore_case) == 0 (auto)
[eva] Splitting return states on:
  \return(memcmp) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memrchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgetc) == -1, 10 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(feof) == 0 (auto)
  \return(ferror) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(getline) == -1 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_interval) == 0, 10 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
  \return(isConsonant) == 0 (auto)
  \return(getMeasure) == 1 (auto)
  \return(vowelInStem) == 0 (auto)
  \return(isDoubleConsonant) == 0 (auto)
  \return(cvc) == 0 (auto)
  \return(ends) == 0 (auto)
  \return(is_valid_mode) == 0 (auto)
  \return(char_equal_ignore_case) == 0 (auto)
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] using specification for function fopen
[eva] using specification for function fopen
[eva] using specification for function fopen
[eva] using specification for function fopen
[eva] using specification for function ferror
[eva] using specification for function ferror
[eva] using specification for function feof
[eva] using specification for function ferror
[eva] using specification for function ferror
[eva] using specification for function feof
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_1
[eva] using specification for function feof
[eva] using specification for function feof
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_1
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_1
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_1
[eva] using specification for function Frama_C_interval
[eva] using specification for function Frama_C_interval
[eva] using specification for function Frama_C_interval
[eva] using specification for function Frama_C_interval
[eva] using specification for function Frama_C_unsigned_char_interval
[eva] FRAMAC_SHARE/libc/stdio.c:190: cannot properly split on \result == 10
[eva] using specification for function Frama_C_unsigned_char_interval
[eva] using specification for function Frama_C_unsigned_char_interval
[eva] FRAMAC_SHARE/libc/stdio.c:190: cannot properly split on \result == 10
[eva] FRAMAC_SHARE/libc/stdio.c:190: cannot properly split on \result == 10
[eva] using specification for function Frama_C_unsigned_char_interval
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_1
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_1
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_1
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_1
[eva] FRAMAC_SHARE/libc/stdio.c:83: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:83: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:83: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:83: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:82: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:82: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:82: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:82: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_2
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_2
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_2
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_2
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_8
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_2
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_9
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_2
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_10
[eva] FRAMAC_SHARE/libc/string.c:170: cannot properly split on \result == 0
[eva] FRAMAC_SHARE/libc/string.h:124: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_8
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_9
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_10
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_2
[eva] using specification for function isConsonant
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_2
[eva] FRAMAC_SHARE/libc/string.c:170: cannot properly split on \result == 0
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_8
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_9
[eva] stmr.c:99: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.h:124: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_10
[eva] FRAMAC_SHARE/libc/string.c:170: cannot properly split on \result == 0
[eva] using specification for function isConsonant
[eva] FRAMAC_SHARE/libc/string.h:124: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] stmr.c:114: starting to merge loop iterations
[eva] stmr.c:129: starting to merge loop iterations
[eva] stmr.c:113: starting to merge loop iterations
[eva] stmr.c:113: cannot properly split on \result == 1
[eva] using specification for function isConsonant
[eva] stmr.c:99: starting to merge loop iterations
[eva] stmr.c:152: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_8
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_9
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_10
[eva] FRAMAC_SHARE/libc/string.h:124: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] stmr.c:114: starting to merge loop iterations
[eva] stmr.c:99: starting to merge loop iterations
[eva] stmr.c:113: starting to merge loop iterations
[eva] stmr.c:129: starting to merge loop iterations
[eva] stmr.c:113: cannot properly split on \result == 1
[eva] using specification for function isConsonant
[eva] stmr.c:114: starting to merge loop iterations
[eva] stmr.c:129: starting to merge loop iterations
[eva] stmr.c:113: starting to merge loop iterations
[eva] stmr.c:113: cannot properly split on \result == 1
[eva] stmr.c:152: starting to merge loop iterations
[eva] stmr.c:99: starting to merge loop iterations
[eva] stmr.c:114: starting to merge loop iterations
[eva] stmr.c:129: starting to merge loop iterations
[eva] stmr.c:113: starting to merge loop iterations
[eva] stmr.c:152: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:146: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:149: cannot properly split on \result == 0
[eva] using specification for function fprintf_va_1
[eva] using specification for function fprintf_va_2
[eva] using specification for function fprintf_va_3
[eva] using specification for function fprintf_va_4
[eva] using specification for function printf_va_1
[eva] stmr.c:152: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:146: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:149: cannot properly split on \result == 0
[eva] using specification for function fprintf_va_1
[eva] using specification for function fprintf_va_2
[eva] using specification for function fprintf_va_3
[eva] using specification for function fprintf_va_4
[eva] using specification for function printf_va_1
[eva] test.c:59: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_11
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_12
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_13
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_14
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_15
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_16
[eva] using specification for function printf_va_2
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function exit
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_9
[eva] using specification for function printf_va_10
[eva] test.c:59: starting to merge loop iterations
[scope:rm_asserts] removing 6 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  17 functions analyzed (out of 17): 100% coverage.
  In these functions, 497 statements reached (out of 500): 99% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  62 alarms generated by the analysis:
      28 invalid memory accesses
      22 accesses to uninitialized left-values
      12 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    32 valid    10 unknown     0 invalid     42 total
  76% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_11
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_12
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_13
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_14
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_15
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_16
[eva] using specification for function printf_va_2
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function exit
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_9
[eva] using specification for function printf_va_10
[scope:rm_asserts] removing 6 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  17 functions analyzed (out of 17): 100% coverage.
  In these functions, 497 statements reached (out of 500): 99% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  62 alarms generated by the analysis:
      28 invalid memory accesses
      22 accesses to uninitialized left-values
      12 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    32 valid    10 unknown     0 invalid     42 total
  76% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] FRAMAC_SHARE/libc/string.c:146: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:149: cannot properly split on \result == 0
[eva] using specification for function fprintf_va_1
[eva] using specification for function fprintf_va_2
[eva] using specification for function fprintf_va_3
[eva] using specification for function fprintf_va_4
[eva] using specification for function printf_va_1
[eva] FRAMAC_SHARE/libc/string.c:146: starting to merge loop iterations
[eva] using specification for function fprintf_va_1
[eva] using specification for function fprintf_va_2
[eva] using specification for function fprintf_va_3
[eva] using specification for function fprintf_va_4
[eva] using specification for function printf_va_1
[eva] test.c:59: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_11
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_12
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_13
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_14
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_15
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_16
[eva] using specification for function printf_va_2
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function exit
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_9
[eva] using specification for function printf_va_10
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  17 functions analyzed (out of 17): 100% coverage.
  In these functions, 497 statements reached (out of 500): 99% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  60 alarms generated by the analysis:
      28 invalid memory accesses
      20 accesses to uninitialized left-values
      12 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    32 valid    10 unknown     0 invalid     42 total
  76% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] test.c:59: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_11
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_12
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_13
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_14
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_15
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_16
[eva] using specification for function printf_va_2
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function exit
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_9
[eva] using specification for function printf_va_10
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  17 functions analyzed (out of 17): 100% coverage.
  In these functions, 497 statements reached (out of 500): 99% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  61 alarms generated by the analysis:
      27 invalid memory accesses
      21 accesses to uninitialized left-values
      13 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    32 valid    10 unknown     0 invalid     42 total
  76% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] sample base00-sample00: subset of base? true
[parf] sample base00-sample01: subset of base? true
[parf] sample base00-sample03: subset of base? true
[parf] sample base00-sample02: subset of base? true
[parf] base: base01
[parf] Analysis time for this epoch: 360
[parf] sample: base01-sample00
[parf] sample: base01-sample01
[parf] sample: base01-sample02
[parf] sample: base01-sample03
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 3 -eva-subdivide-non-linear 9 -eva-split-return auto -eva-slevel 23 -eva-plevel 66 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 4 -eva-ilevel 34 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 33
[parf] set eva options
[parf] parameters: -eva-widening-delay 8 -eva-subdivide-non-linear 8 -eva-split-return auto -eva-slevel 26 -eva-plevel 67 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 2 -eva-ilevel 45 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 33
[parf] parameters: -eva-widening-delay 5 -eva-subdivide-non-linear 9 -eva-split-return auto -eva-slevel 16 -eva-plevel 59 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 33 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 45
[parf] set eva options
[parf] parameters: -eva-widening-delay 4 -eva-subdivide-non-linear 15 -eva-split-return auto -eva-slevel 18 -eva-plevel 60 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 36 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 34
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[eva] Splitting return states on:
  \return(memcmp) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memrchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgetc) == -1, 10 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(feof) == 0 (auto)
  \return(ferror) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(getline) == -1 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_interval) == 0, 10 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
  \return(isConsonant) == 0 (auto)
  \return(getMeasure) == 1 (auto)
  \return(vowelInStem) == 0 (auto)
  \return(isDoubleConsonant) == 0 (auto)
  \return(cvc) == 0 (auto)
  \return(ends) == 0 (auto)
  \return(is_valid_mode) == 0 (auto)
  \return(char_equal_ignore_case) == 0 (auto)
[eva] Splitting return states on:
  \return(memcmp) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memrchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgetc) == -1, 10 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(feof) == 0 (auto)
  \return(ferror) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(getline) == -1 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_interval) == 0, 10 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
  \return(isConsonant) == 0 (auto)
  \return(getMeasure) == 1 (auto)
  \return(vowelInStem) == 0 (auto)
  \return(isDoubleConsonant) == 0 (auto)
  \return(cvc) == 0 (auto)
  \return(ends) == 0 (auto)
  \return(is_valid_mode) == 0 (auto)
  \return(char_equal_ignore_case) == 0 (auto)
[eva] Splitting return states on:
  \return(memcmp) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memrchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgetc) == -1, 10 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(feof) == 0 (auto)
  \return(ferror) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(getline) == -1 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_interval) == 0, 10 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
  \return(isConsonant) == 0 (auto)
  \return(getMeasure) == 1 (auto)
  \return(vowelInStem) == 0 (auto)
  \return(isDoubleConsonant) == 0 (auto)
  \return(cvc) == 0 (auto)
  \return(ends) == 0 (auto)
  \return(is_valid_mode) == 0 (auto)
  \return(char_equal_ignore_case) == 0 (auto)
[eva] Splitting return states on:
  \return(memcmp) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memrchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgetc) == -1, 10 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(feof) == 0 (auto)
  \return(ferror) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(getline) == -1 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_interval) == 0, 10 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
  \return(isConsonant) == 0 (auto)
  \return(getMeasure) == 1 (auto)
  \return(vowelInStem) == 0 (auto)
  \return(isDoubleConsonant) == 0 (auto)
  \return(cvc) == 0 (auto)
  \return(ends) == 0 (auto)
  \return(is_valid_mode) == 0 (auto)
  \return(char_equal_ignore_case) == 0 (auto)
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] using specification for function fopen
[eva] using specification for function fopen
[eva] using specification for function fopen
[eva] using specification for function fopen
[eva] using specification for function ferror
[eva] using specification for function ferror
[eva] using specification for function ferror
[eva] using specification for function ferror
[eva] using specification for function feof
[eva] using specification for function feof
[eva] using specification for function feof
[eva] using specification for function feof
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_1
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_1
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_1
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_1
[eva] using specification for function Frama_C_interval
[eva] using specification for function Frama_C_interval
[eva] using specification for function Frama_C_interval
[eva] using specification for function Frama_C_interval
[eva] using specification for function Frama_C_unsigned_char_interval
[eva] using specification for function Frama_C_unsigned_char_interval
[eva] using specification for function Frama_C_unsigned_char_interval
[eva] using specification for function Frama_C_unsigned_char_interval
[eva] FRAMAC_SHARE/libc/stdio.c:190: cannot properly split on \result == 10
[eva] FRAMAC_SHARE/libc/stdio.c:190: cannot properly split on \result == 10
[eva] FRAMAC_SHARE/libc/stdio.c:190: cannot properly split on \result == 10
[eva] FRAMAC_SHARE/libc/stdio.c:190: cannot properly split on \result == 10
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_1
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_1
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_1
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_1
[eva] FRAMAC_SHARE/libc/stdio.c:83: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:83: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:83: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:83: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 100 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 100 states
[eva] FRAMAC_SHARE/libc/stdio.c:82: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:82: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 100 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 100 states
[eva] FRAMAC_SHARE/libc/stdio.c:82: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:82: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 200 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 200 states
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_2
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_2
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_2
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_2
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_8
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_9
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_8
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_9
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_10
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_10
[eva] FRAMAC_SHARE/libc/string.c:170: cannot properly split on \result == 0
[eva] FRAMAC_SHARE/libc/string.c:170: cannot properly split on \result == 0
[eva] FRAMAC_SHARE/libc/string.h:124: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.h:124: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] using specification for function isConsonant
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_2
[eva] using specification for function isConsonant
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_2
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_2
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_2
[eva] stmr.c:99: starting to merge loop iterations
[eva] stmr.c:99: starting to merge loop iterations
[eva] stmr.c:114: starting to merge loop iterations
[eva] stmr.c:114: starting to merge loop iterations
[eva] stmr.c:129: starting to merge loop iterations
[eva] stmr.c:129: starting to merge loop iterations
[eva] stmr.c:113: starting to merge loop iterations
[eva] stmr.c:113: starting to merge loop iterations
[eva] stmr.c:113: cannot properly split on \result == 1
[eva] stmr.c:113: cannot properly split on \result == 1
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_8
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_9
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_10
[eva] FRAMAC_SHARE/libc/string.c:170: cannot properly split on \result == 0
[eva] FRAMAC_SHARE/libc/string.h:124: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_8
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_9
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_10
[eva] FRAMAC_SHARE/libc/string.c:170: cannot properly split on \result == 0
[eva] using specification for function isConsonant
[eva] FRAMAC_SHARE/libc/string.h:124: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] using specification for function isConsonant
[eva] stmr.c:99: starting to merge loop iterations
[eva] stmr.c:99: starting to merge loop iterations
[eva] stmr.c:114: starting to merge loop iterations
[eva] stmr.c:129: starting to merge loop iterations
[eva] stmr.c:119: Trace partitioning superposing up to 100 states
[eva] stmr.c:114: starting to merge loop iterations
[eva] stmr.c:113: starting to merge loop iterations
[eva] stmr.c:129: starting to merge loop iterations
[eva] stmr.c:113: cannot properly split on \result == 1
[eva] stmr.c:119: Trace partitioning superposing up to 100 states
[eva] stmr.c:113: starting to merge loop iterations
[eva] stmr.c:113: cannot properly split on \result == 1
[eva] stmr.c:152: starting to merge loop iterations
[eva] stmr.c:152: starting to merge loop iterations
[eva] stmr.c:152: starting to merge loop iterations
[eva] stmr.c:152: starting to merge loop iterations
[eva] stmr.c:301: Trace partitioning superposing up to 100 states
[eva] FRAMAC_SHARE/libc/string.c:146: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:149: cannot properly split on \result == 0
[eva] using specification for function fprintf_va_1
[eva] using specification for function fprintf_va_2
[eva] using specification for function fprintf_va_3
[eva] using specification for function fprintf_va_4
[eva] using specification for function printf_va_1
[eva] FRAMAC_SHARE/libc/string.c:146: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:149: cannot properly split on \result == 0
[eva] using specification for function fprintf_va_1
[eva] using specification for function fprintf_va_2
[eva] using specification for function fprintf_va_3
[eva] using specification for function fprintf_va_4
[eva] using specification for function printf_va_1
[eva] test.c:59: starting to merge loop iterations
[eva] test.c:59: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_11
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_12
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_13
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_14
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_15
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_16
[eva] using specification for function printf_va_2
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function exit
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_9
[eva] using specification for function printf_va_10
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  17 functions analyzed (out of 17): 100% coverage.
  In these functions, 497 statements reached (out of 500): 99% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  58 alarms generated by the analysis:
      27 invalid memory accesses
      19 accesses to uninitialized left-values
      12 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    32 valid    10 unknown     0 invalid     42 total
  76% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_11
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_12
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_13
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_14
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_15
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_16
[eva] using specification for function printf_va_2
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function exit
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_9
[eva] using specification for function printf_va_10
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  17 functions analyzed (out of 17): 100% coverage.
  In these functions, 497 statements reached (out of 500): 99% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  58 alarms generated by the analysis:
      27 invalid memory accesses
      19 accesses to uninitialized left-values
      12 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    32 valid    10 unknown     0 invalid     42 total
  76% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] FRAMAC_SHARE/libc/string.c:146: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:149: cannot properly split on \result == 0
[eva] using specification for function fprintf_va_1
[eva] using specification for function fprintf_va_2
[eva] using specification for function fprintf_va_3
[eva] using specification for function fprintf_va_4
[eva] using specification for function printf_va_1
[eva] FRAMAC_SHARE/libc/string.c:146: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:149: cannot properly split on \result == 0
[eva] using specification for function fprintf_va_1
[eva] using specification for function fprintf_va_2
[eva] using specification for function fprintf_va_3
[eva] using specification for function fprintf_va_4
[eva] using specification for function printf_va_1
[eva] test.c:59: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_11
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_12
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_13
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_14
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_15
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_16
[eva] using specification for function printf_va_2
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function exit
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_9
[eva] using specification for function printf_va_10
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  17 functions analyzed (out of 17): 100% coverage.
  In these functions, 497 statements reached (out of 500): 99% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  58 alarms generated by the analysis:
      27 invalid memory accesses
      19 accesses to uninitialized left-values
      12 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    32 valid    10 unknown     0 invalid     42 total
  76% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] test.c:59: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_11
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_12
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_13
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_14
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_15
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_16
[eva] using specification for function printf_va_2
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function exit
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_9
[eva] using specification for function printf_va_10
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  17 functions analyzed (out of 17): 100% coverage.
  In these functions, 497 statements reached (out of 500): 99% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  58 alarms generated by the analysis:
      27 invalid memory accesses
      19 accesses to uninitialized left-values
      12 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    32 valid    10 unknown     0 invalid     42 total
  76% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] sample base01-sample01: subset of base? true
[parf] sample base01-sample00: subset of base? true
[parf] sample base01-sample02: subset of base? true
[parf] sample base01-sample03: subset of base? true
[parf] base: base02
[parf] Analysis time for this epoch: 720
[parf] sample: base02-sample00
[parf] sample: base02-sample01
[parf] sample: base02-sample02
[parf] sample: base02-sample03
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 5 -eva-subdivide-non-linear 15 -eva-split-return auto -eva-slevel 33 -eva-plevel 117 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 2 -eva-ilevel 60 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 64
[parf] parameters: -eva-widening-delay 8 -eva-subdivide-non-linear 16 -eva-split-return auto -eva-slevel 38 -eva-plevel 99 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 2 -eva-ilevel 55 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 73
[parf] parameters: -eva-widening-delay 7 -eva-subdivide-non-linear 15 -eva-split-return auto -eva-slevel 29 -eva-plevel 127 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 2 -eva-ilevel 76 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 74
[parf] set eva options
[parf] parameters: -eva-widening-delay 4 -eva-subdivide-non-linear 16 -eva-split-return auto -eva-slevel 33 -eva-plevel 129 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 3 -eva-ilevel 58 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 75
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[eva] Splitting return states on:
  \return(memcmp) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memrchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgetc) == -1, 10 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(feof) == 0 (auto)
  \return(ferror) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(getline) == -1 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_interval) == 0, 10 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
  \return(isConsonant) == 0 (auto)
  \return(getMeasure) == 1 (auto)
  \return(vowelInStem) == 0 (auto)
  \return(isDoubleConsonant) == 0 (auto)
  \return(cvc) == 0 (auto)
  \return(ends) == 0 (auto)
  \return(is_valid_mode) == 0 (auto)
  \return(char_equal_ignore_case) == 0 (auto)
[eva] Splitting return states on:
  \return(memcmp) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memrchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgetc) == -1, 10 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(feof) == 0 (auto)
  \return(ferror) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(getline) == -1 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_interval) == 0, 10 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
  \return(isConsonant) == 0 (auto)
  \return(getMeasure) == 1 (auto)
  \return(vowelInStem) == 0 (auto)
  \return(isDoubleConsonant) == 0 (auto)
  \return(cvc) == 0 (auto)
  \return(ends) == 0 (auto)
  \return(is_valid_mode) == 0 (auto)
  \return(char_equal_ignore_case) == 0 (auto)
[eva] Splitting return states on:
  \return(memcmp) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memrchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgetc) == -1, 10 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(feof) == 0 (auto)
  \return(ferror) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(getline) == -1 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_interval) == 0, 10 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
  \return(isConsonant) == 0 (auto)
  \return(getMeasure) == 1 (auto)
  \return(vowelInStem) == 0 (auto)
  \return(isDoubleConsonant) == 0 (auto)
  \return(cvc) == 0 (auto)
  \return(ends) == 0 (auto)
  \return(is_valid_mode) == 0 (auto)
  \return(char_equal_ignore_case) == 0 (auto)
[eva] Splitting return states on:
  \return(memcmp) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memrchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgetc) == -1, 10 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(feof) == 0 (auto)
  \return(ferror) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(getline) == -1 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_interval) == 0, 10 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
  \return(isConsonant) == 0 (auto)
  \return(getMeasure) == 1 (auto)
  \return(vowelInStem) == 0 (auto)
  \return(isDoubleConsonant) == 0 (auto)
  \return(cvc) == 0 (auto)
  \return(ends) == 0 (auto)
  \return(is_valid_mode) == 0 (auto)
  \return(char_equal_ignore_case) == 0 (auto)
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] using specification for function fopen
[eva] using specification for function fopen
[eva] using specification for function fopen
[eva] using specification for function fopen
[eva] using specification for function ferror
[eva] using specification for function ferror
[eva] using specification for function ferror
[eva] using specification for function ferror
[eva] using specification for function feof
[eva] using specification for function feof
[eva] using specification for function feof
[eva] using specification for function feof
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_1
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_1
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_1
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_1
[eva] using specification for function Frama_C_interval
[eva] using specification for function Frama_C_interval
[eva] using specification for function Frama_C_interval
[eva] using specification for function Frama_C_interval
[eva] using specification for function Frama_C_unsigned_char_interval
[eva] using specification for function Frama_C_unsigned_char_interval
[eva] using specification for function Frama_C_unsigned_char_interval
[eva] using specification for function Frama_C_unsigned_char_interval
[eva] FRAMAC_SHARE/libc/stdio.c:190: cannot properly split on \result == 10
[eva] FRAMAC_SHARE/libc/stdio.c:190: cannot properly split on \result == 10
[eva] FRAMAC_SHARE/libc/stdio.c:190: cannot properly split on \result == 10
[eva] FRAMAC_SHARE/libc/stdio.c:190: cannot properly split on \result == 10
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_1
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_1
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_1
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_1
[eva] FRAMAC_SHARE/libc/stdio.c:83: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:83: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:83: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:83: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 100 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 100 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 100 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 100 states
[eva] FRAMAC_SHARE/libc/stdio.c:82: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 200 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 200 states
[eva] FRAMAC_SHARE/libc/stdio.c:82: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 200 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 200 states
[eva] FRAMAC_SHARE/libc/stdio.c:82: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:82: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_2
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_2
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_2
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_2
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_2
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_2
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_2
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_2
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_8
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_9
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_10
[eva] FRAMAC_SHARE/libc/string.c:170: cannot properly split on \result == 0
[eva] FRAMAC_SHARE/libc/string.h:124: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_8
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_9
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_10
[eva] FRAMAC_SHARE/libc/string.c:170: cannot properly split on \result == 0
[eva] using specification for function isConsonant
[eva] FRAMAC_SHARE/libc/string.h:124: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] using specification for function isConsonant
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_8
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_9
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_10
[eva] FRAMAC_SHARE/libc/string.c:170: cannot properly split on \result == 0
[eva] FRAMAC_SHARE/libc/string.h:124: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] using specification for function isConsonant
[eva] stmr.c:99: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_8
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_9
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_10
[eva] FRAMAC_SHARE/libc/string.c:170: cannot properly split on \result == 0
[eva] FRAMAC_SHARE/libc/string.h:124: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] stmr.c:99: starting to merge loop iterations
[eva] using specification for function isConsonant
[eva] stmr.c:114: starting to merge loop iterations
[eva] stmr.c:99: starting to merge loop iterations
[eva] stmr.c:129: starting to merge loop iterations
[eva] stmr.c:119: Trace partitioning superposing up to 100 states
[eva] stmr.c:114: starting to merge loop iterations
[eva] stmr.c:113: starting to merge loop iterations
[eva] stmr.c:129: starting to merge loop iterations
[eva] stmr.c:119: Trace partitioning superposing up to 100 states
[eva] stmr.c:113: cannot properly split on \result == 1
[eva] stmr.c:114: starting to merge loop iterations
[eva] stmr.c:99: starting to merge loop iterations
[eva] stmr.c:113: starting to merge loop iterations
[eva] stmr.c:129: starting to merge loop iterations
[eva] stmr.c:119: Trace partitioning superposing up to 100 states
[eva] stmr.c:113: cannot properly split on \result == 1
[eva] stmr.c:113: starting to merge loop iterations
[eva] stmr.c:113: cannot properly split on \result == 1
[eva] stmr.c:114: starting to merge loop iterations
[eva] stmr.c:129: starting to merge loop iterations
[eva] stmr.c:119: Trace partitioning superposing up to 100 states
[eva] stmr.c:113: starting to merge loop iterations
[eva] stmr.c:119: Trace partitioning superposing up to 200 states
[eva] stmr.c:113: cannot properly split on \result == 1
[eva] stmr.c:152: starting to merge loop iterations
[eva] stmr.c:152: starting to merge loop iterations
[eva] stmr.c:152: starting to merge loop iterations
[eva] stmr.c:152: starting to merge loop iterations
[eva] stmr.c:301: Trace partitioning superposing up to 100 states
[eva] stmr.c:301: Trace partitioning superposing up to 100 states
[eva] stmr.c:301: Trace partitioning superposing up to 100 states
[eva] stmr.c:301: Trace partitioning superposing up to 100 states
[eva] FRAMAC_SHARE/libc/string.c:146: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:149: cannot properly split on \result == 0
[eva] using specification for function fprintf_va_1
[eva] using specification for function fprintf_va_2
[eva] using specification for function fprintf_va_3
[eva] using specification for function fprintf_va_4
[eva] using specification for function printf_va_1
[eva] FRAMAC_SHARE/libc/string.c:146: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:149: cannot properly split on \result == 0
[eva] using specification for function fprintf_va_1
[eva] using specification for function fprintf_va_2
[eva] using specification for function fprintf_va_3
[eva] using specification for function fprintf_va_4
[eva] using specification for function printf_va_1
[eva] FRAMAC_SHARE/libc/string.c:146: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:149: cannot properly split on \result == 0
[eva] using specification for function fprintf_va_1
[eva] using specification for function fprintf_va_2
[eva] using specification for function fprintf_va_3
[eva] using specification for function fprintf_va_4
[eva] using specification for function printf_va_1
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 300 states
[eva] FRAMAC_SHARE/libc/string.c:146: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:149: cannot properly split on \result == 0
[eva] using specification for function fprintf_va_1
[eva] using specification for function fprintf_va_2
[eva] using specification for function fprintf_va_3
[eva] using specification for function fprintf_va_4
[eva] using specification for function printf_va_1
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 300 states
[eva] test.c:59: starting to merge loop iterations
[eva] test.c:59: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_11
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_12
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_13
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_14
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_15
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_16
[eva] using specification for function printf_va_2
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function exit
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_9
[eva] using specification for function printf_va_10
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  17 functions analyzed (out of 17): 100% coverage.
  In these functions, 497 statements reached (out of 500): 99% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  58 alarms generated by the analysis:
      27 invalid memory accesses
      19 accesses to uninitialized left-values
      12 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    32 valid    10 unknown     0 invalid     42 total
  76% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] test.c:59: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_11
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_12
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_13
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_14
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_15
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_16
[eva] using specification for function printf_va_2
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function exit
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_9
[eva] using specification for function printf_va_10
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  17 functions analyzed (out of 17): 100% coverage.
  In these functions, 497 statements reached (out of 500): 99% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  58 alarms generated by the analysis:
      27 invalid memory accesses
      19 accesses to uninitialized left-values
      12 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    32 valid    10 unknown     0 invalid     42 total
  76% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_11
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_12
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_13
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_14
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_15
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_16
[eva] using specification for function printf_va_2
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function exit
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_9
[eva] using specification for function printf_va_10
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  17 functions analyzed (out of 17): 100% coverage.
  In these functions, 497 statements reached (out of 500): 99% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  58 alarms generated by the analysis:
      27 invalid memory accesses
      19 accesses to uninitialized left-values
      12 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    32 valid    10 unknown     0 invalid     42 total
  76% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] test.c:59: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_11
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_12
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_13
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_14
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_15
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_16
[eva] using specification for function printf_va_2
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function exit
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_9
[eva] using specification for function printf_va_10
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  17 functions analyzed (out of 17): 100% coverage.
  In these functions, 497 statements reached (out of 500): 99% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  58 alarms generated by the analysis:
      27 invalid memory accesses
      19 accesses to uninitialized left-values
      12 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    32 valid    10 unknown     0 invalid     42 total
  76% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] sample base02-sample00: subset of base? true
[parf] sample base02-sample01: subset of base? true
[parf] sample base02-sample03: subset of base? true
[parf] sample base02-sample02: subset of base? true
[parf] base: base03
[parf] Analysis time for this epoch: 1440
[parf] sample: base03-sample00
[parf] sample: base03-sample01
[parf] sample: base03-sample02
[parf] sample: base03-sample03
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 10 -eva-subdivide-non-linear 26 -eva-split-return auto -eva-slevel 56 -eva-plevel 189 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 7 -eva-ilevel 127 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 138
[parf] parameters: -eva-widening-delay 11 -eva-subdivide-non-linear 28 -eva-split-return auto -eva-slevel 52 -eva-plevel 191 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 7 -eva-ilevel 118 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 127
[parf] set eva options
[parf] parameters: -eva-widening-delay 8 -eva-subdivide-non-linear 33 -eva-split-return auto -eva-slevel 52 -eva-plevel 186 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 5 -eva-ilevel 108 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 142
[parf] parameters: -eva-widening-delay 6 -eva-subdivide-non-linear 30 -eva-split-return auto -eva-slevel 52 -eva-plevel 189 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 6 -eva-ilevel 117 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 114
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[eva] Splitting return states on:
  \return(memcmp) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memrchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgetc) == -1, 10 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(feof) == 0 (auto)
  \return(ferror) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(getline) == -1 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_interval) == 0, 10 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
  \return(isConsonant) == 0 (auto)
  \return(getMeasure) == 1 (auto)
  \return(vowelInStem) == 0 (auto)
  \return(isDoubleConsonant) == 0 (auto)
  \return(cvc) == 0 (auto)
  \return(ends) == 0 (auto)
  \return(is_valid_mode) == 0 (auto)
  \return(char_equal_ignore_case) == 0 (auto)
[eva] Splitting return states on:
  \return(memcmp) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memrchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgetc) == -1, 10 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(feof) == 0 (auto)
  \return(ferror) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(getline) == -1 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_interval) == 0, 10 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
  \return(isConsonant) == 0 (auto)
  \return(getMeasure) == 1 (auto)
  \return(vowelInStem) == 0 (auto)
  \return(isDoubleConsonant) == 0 (auto)
  \return(cvc) == 0 (auto)
  \return(ends) == 0 (auto)
  \return(is_valid_mode) == 0 (auto)
  \return(char_equal_ignore_case) == 0 (auto)
[eva] Splitting return states on:
  \return(memcmp) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memrchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgetc) == -1, 10 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(feof) == 0 (auto)
  \return(ferror) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(getline) == -1 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_interval) == 0, 10 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
  \return(isConsonant) == 0 (auto)
  \return(getMeasure) == 1 (auto)
  \return(vowelInStem) == 0 (auto)
  \return(isDoubleConsonant) == 0 (auto)
  \return(cvc) == 0 (auto)
  \return(ends) == 0 (auto)
  \return(is_valid_mode) == 0 (auto)
  \return(char_equal_ignore_case) == 0 (auto)
[eva] Splitting return states on:
  \return(memcmp) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memrchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgetc) == -1, 10 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(feof) == 0 (auto)
  \return(ferror) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(getline) == -1 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_interval) == 0, 10 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
  \return(isConsonant) == 0 (auto)
  \return(getMeasure) == 1 (auto)
  \return(vowelInStem) == 0 (auto)
  \return(isDoubleConsonant) == 0 (auto)
  \return(cvc) == 0 (auto)
  \return(ends) == 0 (auto)
  \return(is_valid_mode) == 0 (auto)
  \return(char_equal_ignore_case) == 0 (auto)
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] using specification for function fopen
[eva] using specification for function fopen
[eva] using specification for function fopen
[eva] using specification for function ferror
[eva] using specification for function ferror
[eva] Analyzing a complete application starting at main
[eva] using specification for function feof
[eva] using specification for function feof
[eva] using specification for function fopen
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_1
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_1
[eva] using specification for function ferror
[eva] using specification for function feof
[eva] using specification for function Frama_C_interval
[eva] using specification for function Frama_C_interval
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_1
[eva] using specification for function Frama_C_unsigned_char_interval
[eva] using specification for function Frama_C_unsigned_char_interval
[eva] using specification for function Frama_C_interval
[eva] using specification for function ferror
[eva] FRAMAC_SHARE/libc/stdio.c:190: cannot properly split on \result == 10
[eva] FRAMAC_SHARE/libc/stdio.c:190: cannot properly split on \result == 10
[eva] using specification for function feof
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_1
[eva] using specification for function Frama_C_unsigned_char_interval
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_1
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_1
[eva] FRAMAC_SHARE/libc/stdio.c:190: cannot properly split on \result == 10
[eva] using specification for function Frama_C_interval
[eva] using specification for function Frama_C_unsigned_char_interval
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_1
[eva] FRAMAC_SHARE/libc/stdio.c:190: cannot properly split on \result == 10
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_1
[eva] FRAMAC_SHARE/libc/stdio.c:83: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 100 states
[eva] FRAMAC_SHARE/libc/stdio.c:83: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 100 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 100 states
[eva] FRAMAC_SHARE/libc/stdio.c:83: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:83: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 100 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 200 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 200 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 200 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 200 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 300 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 300 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 300 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 300 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 400 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 400 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 400 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 400 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 500 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 500 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 500 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 500 states
[eva] FRAMAC_SHARE/libc/stdio.c:82: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 600 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 600 states
[eva] FRAMAC_SHARE/libc/stdio.c:82: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 600 states
[eva] FRAMAC_SHARE/libc/stdio.c:82: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 600 states
[eva] FRAMAC_SHARE/libc/stdio.c:82: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 700 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 700 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 800 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 800 states
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_2
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_2
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_2
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_2
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_2
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_2
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_2
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_2
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_8
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_9
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_10
[eva] FRAMAC_SHARE/libc/string.c:170: cannot properly split on \result == 0
[eva] FRAMAC_SHARE/libc/string.h:124: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] using specification for function isConsonant
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_8
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_9
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_10
[eva] FRAMAC_SHARE/libc/string.c:170: cannot properly split on \result == 0
[eva] FRAMAC_SHARE/libc/string.h:124: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] using specification for function isConsonant
[eva] stmr.c:104: Trace partitioning superposing up to 100 states
[eva] stmr.c:99: starting to merge loop iterations
[eva] stmr.c:104: Trace partitioning superposing up to 100 states
[eva] stmr.c:99: starting to merge loop iterations
[eva] stmr.c:114: starting to merge loop iterations
[eva] stmr.c:129: starting to merge loop iterations
[eva] stmr.c:119: Trace partitioning superposing up to 200 states
[eva] stmr.c:114: starting to merge loop iterations
[eva] stmr.c:129: starting to merge loop iterations
[eva] stmr.c:113: starting to merge loop iterations
[eva] stmr.c:119: Trace partitioning superposing up to 300 states
[eva] stmr.c:119: Trace partitioning superposing up to 200 states
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_8
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_9
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_10
[eva] FRAMAC_SHARE/libc/string.c:170: cannot properly split on \result == 0
[eva] stmr.c:113: cannot properly split on \result == 1
[eva] FRAMAC_SHARE/libc/string.h:124: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] using specification for function isConsonant
[eva] stmr.c:113: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_8
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_9
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_10
[eva] stmr.c:119: Trace partitioning superposing up to 300 states
[eva] FRAMAC_SHARE/libc/string.c:170: cannot properly split on \result == 0
[eva] FRAMAC_SHARE/libc/string.h:124: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] using specification for function isConsonant
[eva] stmr.c:113: cannot properly split on \result == 1
[eva] stmr.c:104: Trace partitioning superposing up to 100 states
[eva] stmr.c:99: starting to merge loop iterations
[eva] stmr.c:104: Trace partitioning superposing up to 100 states
[eva] stmr.c:99: starting to merge loop iterations
[eva] stmr.c:114: starting to merge loop iterations
[eva] stmr.c:129: starting to merge loop iterations
[eva] stmr.c:119: Trace partitioning superposing up to 200 states
[eva] stmr.c:114: starting to merge loop iterations
[eva] stmr.c:129: starting to merge loop iterations
[eva] stmr.c:119: Trace partitioning superposing up to 300 states
[eva] stmr.c:119: Trace partitioning superposing up to 200 states
[eva] stmr.c:113: starting to merge loop iterations
[eva] stmr.c:119: Trace partitioning superposing up to 400 states
[eva] stmr.c:119: Trace partitioning superposing up to 300 states
[eva] stmr.c:119: Trace partitioning superposing up to 500 states
[eva] stmr.c:113: starting to merge loop iterations
[eva] stmr.c:119: Trace partitioning superposing up to 400 states
[eva] stmr.c:113: cannot properly split on \result == 1
[eva] stmr.c:119: Trace partitioning superposing up to 500 states
[eva] stmr.c:113: cannot properly split on \result == 1
[eva] stmr.c:153: Trace partitioning superposing up to 100 states
[eva] stmr.c:152: starting to merge loop iterations
[eva] stmr.c:153: Trace partitioning superposing up to 100 states
[eva] stmr.c:152: starting to merge loop iterations
[eva] stmr.c:153: Trace partitioning superposing up to 100 states
[eva] stmr.c:152: starting to merge loop iterations
[eva] stmr.c:153: Trace partitioning superposing up to 100 states
[eva] stmr.c:152: starting to merge loop iterations
[eva] stmr.c:301: Trace partitioning superposing up to 100 states
[eva] stmr.c:301: Trace partitioning superposing up to 100 states
[eva] stmr.c:301: Trace partitioning superposing up to 100 states
[eva] stmr.c:301: Trace partitioning superposing up to 100 states
[eva] FRAMAC_SHARE/libc/string.c:146: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:149: cannot properly split on \result == 0
[eva] using specification for function fprintf_va_1
[eva] using specification for function fprintf_va_2
[eva] using specification for function fprintf_va_3
[eva] using specification for function fprintf_va_4
[eva] using specification for function printf_va_1
[eva] FRAMAC_SHARE/libc/string.c:146: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:149: cannot properly split on \result == 0
[eva] using specification for function fprintf_va_1
[eva] using specification for function fprintf_va_2
[eva] using specification for function fprintf_va_3
[eva] using specification for function fprintf_va_4
[eva] using specification for function printf_va_1
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 700 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 700 states
[eva] FRAMAC_SHARE/libc/string.c:146: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:149: cannot properly split on \result == 0
[eva] using specification for function fprintf_va_1
[eva] using specification for function fprintf_va_2
[eva] using specification for function fprintf_va_3
[eva] using specification for function fprintf_va_4
[eva] using specification for function printf_va_1
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 900 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1000 states
[eva] FRAMAC_SHARE/libc/string.c:146: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:149: cannot properly split on \result == 0
[eva] using specification for function fprintf_va_1
[eva] using specification for function fprintf_va_2
[eva] using specification for function fprintf_va_3
[eva] using specification for function fprintf_va_4
[eva] using specification for function printf_va_1
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 900 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1000 states
[eva] test.c:60: Trace partitioning superposing up to 100 states
[eva] test.c:59: starting to merge loop iterations
[eva] test.c:60: Trace partitioning superposing up to 100 states
[eva] test.c:59: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_11
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_12
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_13
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_14
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_15
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_16
[eva] using specification for function printf_va_2
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function exit
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_9
[eva] using specification for function printf_va_10
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  17 functions analyzed (out of 17): 100% coverage.
  In these functions, 497 statements reached (out of 500): 99% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  58 alarms generated by the analysis:
      27 invalid memory accesses
      19 accesses to uninitialized left-values
      12 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    32 valid    10 unknown     0 invalid     42 total
  76% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_11
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_12
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_13
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_14
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_15
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_16
[eva] using specification for function printf_va_2
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function exit
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_9
[eva] using specification for function printf_va_10
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  17 functions analyzed (out of 17): 100% coverage.
  In these functions, 497 statements reached (out of 500): 99% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  58 alarms generated by the analysis:
      27 invalid memory accesses
      19 accesses to uninitialized left-values
      12 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    32 valid    10 unknown     0 invalid     42 total
  76% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] test.c:60: Trace partitioning superposing up to 100 states
[eva] test.c:60: Trace partitioning superposing up to 100 states
[eva] test.c:59: starting to merge loop iterations
[eva] test.c:59: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_11
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_12
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_13
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_14
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_15
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_16
[eva] using specification for function printf_va_2
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function exit
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_9
[eva] using specification for function printf_va_10
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  17 functions analyzed (out of 17): 100% coverage.
  In these functions, 497 statements reached (out of 500): 99% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  58 alarms generated by the analysis:
      27 invalid memory accesses
      19 accesses to uninitialized left-values
      12 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    32 valid    10 unknown     0 invalid     42 total
  76% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_11
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_12
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_13
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_14
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_15
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_16
[eva] using specification for function printf_va_2
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function exit
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_9
[eva] using specification for function printf_va_10
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  17 functions analyzed (out of 17): 100% coverage.
  In these functions, 497 statements reached (out of 500): 99% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  58 alarms generated by the analysis:
      27 invalid memory accesses
      19 accesses to uninitialized left-values
      12 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    32 valid    10 unknown     0 invalid     42 total
  76% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] sample base03-sample01: subset of base? true
[parf] sample base03-sample00: subset of base? true
[parf] sample base03-sample02: subset of base? true
[parf] sample base03-sample03: subset of base? true
[parf] base: base04
[parf] Analysis time for this epoch: 1427
[parf] sample: base04-sample00
[parf] sample: base04-sample01
[parf] sample: base04-sample02
[parf] sample: base04-sample03
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] set eva options
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 11 -eva-subdivide-non-linear 39 -eva-split-return auto -eva-slevel 92 -eva-plevel 365 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 6 -eva-ilevel 232 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 220
[parf] parameters: -eva-widening-delay 12 -eva-subdivide-non-linear 53 -eva-split-return auto -eva-slevel 113 -eva-remove-redundant-alarms -eva-plevel 367 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 7 -eva-ilevel 221 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 222
[parf] parameters: -eva-widening-delay 8 -eva-subdivide-non-linear 59 -eva-split-return auto -eva-slevel 126 -eva-plevel 366 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 7 -eva-ilevel 228 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 231
[parf] parameters: -eva-widening-delay 9 -eva-subdivide-non-linear 48 -eva-split-return auto -eva-slevel 99 -eva-plevel 375 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 7 -eva-ilevel 225 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 226
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[eva] Splitting return states on:
  \return(memcmp) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memrchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgetc) == -1, 10 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(feof) == 0 (auto)
  \return(ferror) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(getline) == -1 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_interval) == 0, 10 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
  \return(isConsonant) == 0 (auto)
  \return(getMeasure) == 1 (auto)
  \return(vowelInStem) == 0 (auto)
  \return(isDoubleConsonant) == 0 (auto)
  \return(cvc) == 0 (auto)
  \return(ends) == 0 (auto)
  \return(is_valid_mode) == 0 (auto)
  \return(char_equal_ignore_case) == 0 (auto)
[eva] Splitting return states on:
  \return(memcmp) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memrchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgetc) == -1, 10 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(feof) == 0 (auto)
  \return(ferror) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(getline) == -1 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_interval) == 0, 10 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
  \return(isConsonant) == 0 (auto)
  \return(getMeasure) == 1 (auto)
  \return(vowelInStem) == 0 (auto)
  \return(isDoubleConsonant) == 0 (auto)
  \return(cvc) == 0 (auto)
  \return(ends) == 0 (auto)
  \return(is_valid_mode) == 0 (auto)
  \return(char_equal_ignore_case) == 0 (auto)
[eva] Splitting return states on:
  \return(memcmp) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memrchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgetc) == -1, 10 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(feof) == 0 (auto)
  \return(ferror) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(getline) == -1 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_interval) == 0, 10 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
  \return(isConsonant) == 0 (auto)
  \return(getMeasure) == 1 (auto)
  \return(vowelInStem) == 0 (auto)
  \return(isDoubleConsonant) == 0 (auto)
  \return(cvc) == 0 (auto)
  \return(ends) == 0 (auto)
  \return(is_valid_mode) == 0 (auto)
  \return(char_equal_ignore_case) == 0 (auto)
[eva] Splitting return states on:
  \return(memcmp) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memrchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgetc) == -1, 10 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(feof) == 0 (auto)
  \return(ferror) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(getline) == -1 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_interval) == 0, 10 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
  \return(isConsonant) == 0 (auto)
  \return(getMeasure) == 1 (auto)
  \return(vowelInStem) == 0 (auto)
  \return(isDoubleConsonant) == 0 (auto)
  \return(cvc) == 0 (auto)
  \return(ends) == 0 (auto)
  \return(is_valid_mode) == 0 (auto)
  \return(char_equal_ignore_case) == 0 (auto)
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] using specification for function fopen
[eva] using specification for function fopen
[eva] using specification for function fopen
[eva] using specification for function fopen
[eva] using specification for function ferror
[eva] using specification for function ferror
[eva] using specification for function ferror
[eva] using specification for function ferror
[eva] using specification for function feof
[eva] using specification for function feof
[eva] using specification for function feof
[eva] using specification for function feof
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_1
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_1
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_1
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_1
[eva] using specification for function Frama_C_interval
[eva] using specification for function Frama_C_interval
[eva] using specification for function Frama_C_interval
[eva] using specification for function Frama_C_interval
[eva] using specification for function Frama_C_unsigned_char_interval
[eva] using specification for function Frama_C_unsigned_char_interval
[eva] using specification for function Frama_C_unsigned_char_interval
[eva] using specification for function Frama_C_unsigned_char_interval
[eva] FRAMAC_SHARE/libc/stdio.c:190: cannot properly split on \result == 10
[eva] FRAMAC_SHARE/libc/stdio.c:190: cannot properly split on \result == 10
[eva] FRAMAC_SHARE/libc/stdio.c:190: cannot properly split on \result == 10
[eva] FRAMAC_SHARE/libc/stdio.c:190: cannot properly split on \result == 10
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_1
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_1
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_1
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_1
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 100 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 100 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 100 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 100 states
[eva] FRAMAC_SHARE/libc/stdio.c:83: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:83: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 200 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 200 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 200 states
[eva] FRAMAC_SHARE/libc/stdio.c:83: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 200 states
[eva] FRAMAC_SHARE/libc/stdio.c:83: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 300 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 300 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 300 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 300 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 400 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 400 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 400 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 400 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 500 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 500 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 500 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 500 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 600 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 600 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 600 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 600 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 700 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 700 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 700 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 700 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 800 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 800 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 800 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 800 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 900 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 900 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 900 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 900 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1000 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1000 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1000 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1000 states
[eva] FRAMAC_SHARE/libc/stdio.c:82: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1100 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1100 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1100 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1100 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1200 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1200 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1200 states
[eva] FRAMAC_SHARE/libc/stdio.c:82: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1300 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1300 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1300 states
[eva] FRAMAC_SHARE/libc/stdio.c:82: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1400 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1400 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1500 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1500 states
[eva] FRAMAC_SHARE/libc/stdio.c:82: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1600 states
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_2
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_2
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_2
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_2
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_8
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_9
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_10
[eva] FRAMAC_SHARE/libc/string.c:170: cannot properly split on \result == 0
[eva] FRAMAC_SHARE/libc/string.h:124: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] using specification for function isConsonant
[eva] stmr.c:104: Trace partitioning superposing up to 100 states
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_2
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_2
[eva] stmr.c:99: starting to merge loop iterations
[eva] stmr.c:104: Trace partitioning superposing up to 200 states
[eva] stmr.c:114: starting to merge loop iterations
[eva] stmr.c:129: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_8
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_9
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_10
[eva] stmr.c:119: Trace partitioning superposing up to 300 states
[eva] FRAMAC_SHARE/libc/string.c:170: cannot properly split on \result == 0
[eva] FRAMAC_SHARE/libc/string.h:124: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_2
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_2
[eva] using specification for function isConsonant
[eva] stmr.c:119: Trace partitioning superposing up to 400 states
[eva] stmr.c:113: starting to merge loop iterations
[eva] stmr.c:119: Trace partitioning superposing up to 500 states
[eva] stmr.c:104: Trace partitioning superposing up to 100 states
[eva] stmr.c:113: cannot properly split on \result == 1
[eva] stmr.c:104: Trace partitioning superposing up to 200 states
[eva] stmr.c:99: starting to merge loop iterations
[eva] stmr.c:114: starting to merge loop iterations
[eva] stmr.c:129: starting to merge loop iterations
[eva] stmr.c:119: Trace partitioning superposing up to 300 states
[eva] stmr.c:119: Trace partitioning superposing up to 400 states
[eva] stmr.c:113: starting to merge loop iterations
[eva] stmr.c:119: Trace partitioning superposing up to 500 states
[eva] stmr.c:119: Trace partitioning superposing up to 600 states
[eva] stmr.c:113: cannot properly split on \result == 1
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_8
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_9
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_10
[eva] FRAMAC_SHARE/libc/string.c:170: cannot properly split on \result == 0
[eva] FRAMAC_SHARE/libc/string.h:124: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] using specification for function isConsonant
[eva] stmr.c:104: Trace partitioning superposing up to 100 states
[eva] stmr.c:104: Trace partitioning superposing up to 200 states
[eva] stmr.c:99: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_8
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_9
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_10
[eva] FRAMAC_SHARE/libc/string.c:170: cannot properly split on \result == 0
[eva] FRAMAC_SHARE/libc/string.h:124: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] using specification for function isConsonant
[eva] stmr.c:104: Trace partitioning superposing up to 100 states
[eva] stmr.c:114: starting to merge loop iterations
[eva] stmr.c:129: starting to merge loop iterations
[eva] stmr.c:119: Trace partitioning superposing up to 300 states
[eva] stmr.c:119: Trace partitioning superposing up to 400 states
[eva] stmr.c:104: Trace partitioning superposing up to 200 states
[eva] stmr.c:119: Trace partitioning superposing up to 500 states
[eva] stmr.c:113: starting to merge loop iterations
[eva] stmr.c:119: Trace partitioning superposing up to 600 states
[eva] stmr.c:119: Trace partitioning superposing up to 700 states
[eva] stmr.c:113: cannot properly split on \result == 1
[eva] stmr.c:99: starting to merge loop iterations
[eva] stmr.c:114: starting to merge loop iterations
[eva] stmr.c:129: starting to merge loop iterations
[eva] stmr.c:119: Trace partitioning superposing up to 300 states
[eva] stmr.c:153: Trace partitioning superposing up to 100 states
[eva] stmr.c:119: Trace partitioning superposing up to 400 states
[eva] stmr.c:119: Trace partitioning superposing up to 500 states
[eva] stmr.c:113: starting to merge loop iterations
[eva] stmr.c:119: Trace partitioning superposing up to 600 states
[eva] stmr.c:113: cannot properly split on \result == 1
[eva] stmr.c:152: starting to merge loop iterations
[eva] stmr.c:153: Trace partitioning superposing up to 200 states
[eva] stmr.c:153: Trace partitioning superposing up to 100 states
[eva] stmr.c:153: Trace partitioning superposing up to 200 states
[eva] stmr.c:152: starting to merge loop iterations
[eva] stmr.c:153: Trace partitioning superposing up to 100 states
[eva] stmr.c:153: Trace partitioning superposing up to 200 states
[eva] stmr.c:152: starting to merge loop iterations
[eva] stmr.c:153: Trace partitioning superposing up to 100 states
[eva] stmr.c:153: Trace partitioning superposing up to 200 states
[eva] stmr.c:152: starting to merge loop iterations
[eva] stmr.c:301: Trace partitioning superposing up to 100 states
[eva] stmr.c:301: Trace partitioning superposing up to 100 states
[eva] stmr.c:301: Trace partitioning superposing up to 100 states
[eva] stmr.c:301: Trace partitioning superposing up to 100 states
[eva] FRAMAC_SHARE/libc/string.c:146: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:146: 
  Trace partitioning superposing up to 100 states
[eva] FRAMAC_SHARE/libc/string.c:149: cannot properly split on \result == 0
[eva] using specification for function fprintf_va_1
[eva] using specification for function fprintf_va_2
[eva] using specification for function fprintf_va_3
[eva] using specification for function fprintf_va_4
[eva] using specification for function printf_va_1
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1200 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1300 states
[eva] FRAMAC_SHARE/libc/string.c:146: 
  Trace partitioning superposing up to 100 states
[eva] FRAMAC_SHARE/libc/string.c:146: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:149: cannot properly split on \result == 0
[eva] using specification for function fprintf_va_1
[eva] using specification for function fprintf_va_2
[eva] using specification for function fprintf_va_3
[eva] using specification for function fprintf_va_4
[eva] using specification for function printf_va_1
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1400 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1500 states
[eva] FRAMAC_SHARE/libc/string.c:146: 
  Trace partitioning superposing up to 100 states
[eva] FRAMAC_SHARE/libc/string.c:146: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:149: cannot properly split on \result == 0
[eva] using specification for function fprintf_va_1
[eva] using specification for function fprintf_va_2
[eva] using specification for function fprintf_va_3
[eva] using specification for function fprintf_va_4
[eva] using specification for function printf_va_1
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1700 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1800 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1900 states
[eva] FRAMAC_SHARE/libc/string.c:146: 
  Trace partitioning superposing up to 100 states
[eva] FRAMAC_SHARE/libc/string.c:146: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:149: cannot properly split on \result == 0
[eva] using specification for function fprintf_va_1
[eva] using specification for function fprintf_va_2
[eva] using specification for function fprintf_va_3
[eva] using specification for function fprintf_va_4
[eva] using specification for function printf_va_1
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1600 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1700 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1800 states
[eva] test.c:60: Trace partitioning superposing up to 100 states
[eva] test.c:60: Trace partitioning superposing up to 100 states
[eva] test.c:60: Trace partitioning superposing up to 100 states
[eva] test.c:60: Trace partitioning superposing up to 100 states
[eva] test.c:59: starting to merge loop iterations
[eva] test.c:60: Trace partitioning superposing up to 200 states
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_11
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_12
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_13
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_14
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_15
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_16
[eva] using specification for function printf_va_2
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function exit
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_9
[eva] using specification for function printf_va_10
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  17 functions analyzed (out of 17): 100% coverage.
  In these functions, 497 statements reached (out of 500): 99% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  58 alarms generated by the analysis:
      27 invalid memory accesses
      19 accesses to uninitialized left-values
      12 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    32 valid    10 unknown     0 invalid     42 total
  76% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] test.c:59: starting to merge loop iterations
[eva] test.c:60: Trace partitioning superposing up to 200 states
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_11
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_12
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_13
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_14
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_15
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_16
[eva] using specification for function printf_va_2
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function exit
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_9
[eva] using specification for function printf_va_10
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  17 functions analyzed (out of 17): 100% coverage.
  In these functions, 497 statements reached (out of 500): 99% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  58 alarms generated by the analysis:
      27 invalid memory accesses
      19 accesses to uninitialized left-values
      12 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    32 valid    10 unknown     0 invalid     42 total
  76% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] test.c:60: Trace partitioning superposing up to 200 states
[eva] test.c:60: Trace partitioning superposing up to 200 states
[eva] test.c:59: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_11
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_12
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_13
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_14
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_15
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_16
[eva] using specification for function printf_va_2
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function exit
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_9
[eva] using specification for function printf_va_10
[scope:rm_asserts] removing 2 assertion(s)
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  17 functions analyzed (out of 17): 100% coverage.
  In these functions, 497 statements reached (out of 500): 99% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  58 alarms generated by the analysis:
      27 invalid memory accesses
      19 accesses to uninitialized left-values
      12 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    32 valid    10 unknown     0 invalid     42 total
  76% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[eva] test.c:59: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_11
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_12
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_13
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_14
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_15
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_16
[eva] using specification for function printf_va_2
[eva] using specification for function printf_va_3
[eva] using specification for function printf_va_4
[eva] using specification for function printf_va_5
[eva] using specification for function printf_va_6
[eva] using specification for function exit
[eva] using specification for function printf_va_7
[eva] using specification for function printf_va_8
[eva] using specification for function printf_va_9
[eva] using specification for function printf_va_10
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  17 functions analyzed (out of 17): 100% coverage.
  In these functions, 497 statements reached (out of 500): 99% coverage.
  ----------------------------------------------------------------------------
  No errors or warnings raised during the analysis.
  ----------------------------------------------------------------------------
  58 alarms generated by the analysis:
      27 invalid memory accesses
      19 accesses to uninitialized left-values
      12 integer overflows
  ----------------------------------------------------------------------------
  Evaluation of the logical properties reached by the analysis:
    Assertions        0 valid     0 unknown     0 invalid      0 total
    Preconditions    32 valid    10 unknown     0 invalid     42 total
  76% of the logical properties reached have been proven.
  ----------------------------------------------------------------------------
[parf] run eva: finished
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] sample base04-sample01: subset of base? true
[parf] sample base04-sample00: subset of base? true
[parf] sample base04-sample02: subset of base? true
[parf] sample base04-sample03: subset of base? true
[parf] base: base05
[parf] Analysis time for this epoch: 193
[parf] sample: base05-sample00
[parf] sample: base05-sample01
[parf] sample: base05-sample02
[parf] sample: base05-sample03
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] run eva: start
[parf] set eva options
[parf] set eva options
[parf] parameters: -eva-widening-delay 19 -eva-subdivide-non-linear 74 -eva-split-return auto -eva-slevel 171 -eva-remove-redundant-alarms -eva-plevel 746 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 9 -eva-ilevel 422 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 412
[parf] set eva options
[parf] parameters: -eva-widening-delay 12 -eva-subdivide-non-linear 77 -eva-split-return auto -eva-slevel 199 -eva-plevel 731 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 6 -eva-ilevel 424 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 463
[parf] set eva options
[parf] parameters: -eva-widening-delay 14 -eva-subdivide-non-linear 81 -eva-split-return auto -eva-slevel 177 -eva-remove-redundant-alarms -eva-plevel 770 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 8 -eva-ilevel 445 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 414
[parf] parameters: -eva-widening-delay 15 -eva-subdivide-non-linear 80 -eva-split-return auto -eva-slevel 182 -eva-remove-redundant-alarms -eva-plevel 735 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 7 -eva-ilevel 409 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 432
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[parf] @default,cvalue,equality,gauges,octagon,symbolic-locations
[eva] Splitting return states on:
  \return(memcmp) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memrchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgetc) == -1, 10 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(feof) == 0 (auto)
  \return(ferror) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(getline) == -1 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_interval) == 0, 10 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
  \return(isConsonant) == 0 (auto)
  \return(getMeasure) == 1 (auto)
  \return(vowelInStem) == 0 (auto)
  \return(isDoubleConsonant) == 0 (auto)
  \return(cvc) == 0 (auto)
  \return(ends) == 0 (auto)
  \return(is_valid_mode) == 0 (auto)
  \return(char_equal_ignore_case) == 0 (auto)
[eva] Splitting return states on:
  \return(memcmp) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memrchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgetc) == -1, 10 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(feof) == 0 (auto)
  \return(ferror) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(getline) == -1 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_interval) == 0, 10 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
  \return(isConsonant) == 0 (auto)
  \return(getMeasure) == 1 (auto)
  \return(vowelInStem) == 0 (auto)
  \return(isDoubleConsonant) == 0 (auto)
  \return(cvc) == 0 (auto)
  \return(ends) == 0 (auto)
  \return(is_valid_mode) == 0 (auto)
  \return(char_equal_ignore_case) == 0 (auto)
[eva] Splitting return states on:
  \return(memcmp) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memrchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgetc) == -1, 10 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(feof) == 0 (auto)
  \return(ferror) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(getline) == -1 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_interval) == 0, 10 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
  \return(isConsonant) == 0 (auto)
  \return(getMeasure) == 1 (auto)
  \return(vowelInStem) == 0 (auto)
  \return(isDoubleConsonant) == 0 (auto)
  \return(cvc) == 0 (auto)
  \return(ends) == 0 (auto)
  \return(is_valid_mode) == 0 (auto)
  \return(char_equal_ignore_case) == 0 (auto)
[eva] Splitting return states on:
  \return(memcmp) == 0 (auto)
  \return(memchr) == 0 (auto)
  \return(memrchr) == 0 (auto)
  \return(memcpy) == 0 (auto)
  \return(mempcpy) == 0 (auto)
  \return(memmove) == 0 (auto)
  \return(memset) == 0 (auto)
  \return(strcmp) == 0 (auto)
  \return(strchr) == 0 (auto)
  \return(strchrnul) == 0 (auto)
  \return(strrchr) == 0 (auto)
  \return(strpbrk) == 0 (auto)
  \return(strstr) == 0 (auto)
  \return(strcasestr) == 0 (auto)
  \return(strtok) == 0 (auto)
  \return(strtok_r) == 0 (auto)
  \return(strsep) == 0 (auto)
  \return(strerror) == 0 (auto)
  \return(strcpy) == 0 (auto)
  \return(strncpy) == 0 (auto)
  \return(stpcpy) == 0 (auto)
  \return(strcat) == 0 (auto)
  \return(strncat) == 0 (auto)
  \return(strdup) == 0 (auto)
  \return(strndup) == 0 (auto)
  \return(strsignal) == 0 (auto)
  \return(tmpfile) == 0 (auto)
  \return(tmpnam) == 0 (auto)
  \return(fopen) == 0 (auto)
  \return(fdopen) == 0 (auto)
  \return(freopen) == 0 (auto)
  \return(fgetc) == -1, 10 (auto)
  \return(fgets) == 0 (auto)
  \return(gets) == 0 (auto)
  \return(feof) == 0 (auto)
  \return(ferror) == 0 (auto)
  \return(popen) == 0 (auto)
  \return(getline) == -1 (auto)
  \return(fmemopen) == 0 (auto)
  \return(seed48) == 0 (auto)
  \return(calloc) == 0 (auto)
  \return(malloc) == 0 (auto)
  \return(realloc) == 0 (auto)
  \return(reallocarray) == 0 (auto)
  \return(getenv) == 0 (auto)
  \return(bsearch) == 0 (auto)
  \return(Frama_C_nondet_ptr) == 0 (auto)
  \return(Frama_C_interval) == 0, 10 (auto)
  \return(Frama_C_malloc_fresh) == 0 (auto)
  \return(isConsonant) == 0 (auto)
  \return(getMeasure) == 1 (auto)
  \return(vowelInStem) == 0 (auto)
  \return(isDoubleConsonant) == 0 (auto)
  \return(cvc) == 0 (auto)
  \return(ends) == 0 (auto)
  \return(is_valid_mode) == 0 (auto)
  \return(char_equal_ignore_case) == 0 (auto)
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] Analyzing a complete application starting at main
[eva] using specification for function fopen
[eva] using specification for function fopen
[eva] using specification for function fopen
[eva] using specification for function fopen
[eva] using specification for function ferror
[eva] using specification for function ferror
[eva] using specification for function ferror
[eva] using specification for function ferror
[eva] using specification for function feof
[eva] using specification for function feof
[eva] using specification for function feof
[eva] using specification for function feof
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_1
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_1
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_1
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_1
[eva] using specification for function Frama_C_interval
[eva] using specification for function Frama_C_interval
[eva] using specification for function Frama_C_interval
[eva] using specification for function Frama_C_interval
[eva] using specification for function Frama_C_unsigned_char_interval
[eva] using specification for function Frama_C_unsigned_char_interval
[eva] using specification for function Frama_C_unsigned_char_interval
[eva] using specification for function Frama_C_unsigned_char_interval
[eva] FRAMAC_SHARE/libc/stdio.c:190: cannot properly split on \result == 10
[eva] FRAMAC_SHARE/libc/stdio.c:190: cannot properly split on \result == 10
[eva] FRAMAC_SHARE/libc/stdio.c:190: cannot properly split on \result == 10
[eva] FRAMAC_SHARE/libc/stdio.c:190: cannot properly split on \result == 10
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_1
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_1
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_1
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_1
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 100 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 100 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 100 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 100 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 200 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 200 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 200 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 200 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 300 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 300 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 300 states
[eva] FRAMAC_SHARE/libc/stdio.c:83: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 300 states
[eva] FRAMAC_SHARE/libc/stdio.c:83: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:83: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:83: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 400 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 400 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 400 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 400 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 500 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 500 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 500 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 500 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 600 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 600 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 600 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 600 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 700 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 700 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 700 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 700 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 800 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 800 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 800 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 800 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 900 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 900 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 900 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 900 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1000 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1000 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1000 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1000 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1100 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1100 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1100 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1100 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1200 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1200 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1200 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1300 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1200 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1300 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1300 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1400 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1300 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1400 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1400 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1500 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1400 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1500 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1500 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1600 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1500 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1600 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1600 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1700 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1600 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1700 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1700 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1800 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1800 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1700 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1800 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1900 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1900 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1800 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1900 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 2000 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 2000 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 1900 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 2000 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 2100 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 2100 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 2000 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 2200 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 2100 states
[eva] FRAMAC_SHARE/libc/stdio.c:82: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 2200 states
[eva] FRAMAC_SHARE/libc/stdio.c:82: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 2100 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 2300 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 2300 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 2200 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 2200 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 2400 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 2400 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 2300 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 2300 states
[eva] FRAMAC_SHARE/libc/stdio.c:82: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:82: starting to merge loop iterations
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 2500 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 2400 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 2600 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 2500 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 2700 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 2600 states
[eva] FRAMAC_SHARE/libc/stdio.c:90: 
  Trace partitioning superposing up to 2800 states
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_2
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_2
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_2
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_2
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_2
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_2
[eva] FRAMAC_SHARE/libc/stdio.c:73: allocating variable __malloc_getline_l73_2
[eva] FRAMAC_SHARE/libc/stdio.c:104: 
  allocating variable __realloc_getline_l104_2
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_8
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_9
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_10
[eva] FRAMAC_SHARE/libc/string.h:124: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] using specification for function isConsonant
[eva] stmr.c:104: Trace partitioning superposing up to 100 states
[eva] stmr.c:104: Trace partitioning superposing up to 200 states
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_8
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_9
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_10
[eva] FRAMAC_SHARE/libc/string.h:124: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] using specification for function isConsonant
[eva] stmr.c:104: Trace partitioning superposing up to 300 states
[eva] stmr.c:104: Trace partitioning superposing up to 100 states
[eva] stmr.c:104: Trace partitioning superposing up to 200 states
[eva] stmr.c:104: Trace partitioning superposing up to 400 states
[eva] stmr.c:99: starting to merge loop iterations
[eva] stmr.c:104: Trace partitioning superposing up to 300 states
[eva] stmr.c:99: starting to merge loop iterations
[eva] stmr.c:114: starting to merge loop iterations
[eva] stmr.c:129: starting to merge loop iterations
[eva] stmr.c:119: Trace partitioning superposing up to 500 states
[eva] stmr.c:119: Trace partitioning superposing up to 600 states
[eva] stmr.c:119: Trace partitioning superposing up to 700 states
[eva] stmr.c:119: Trace partitioning superposing up to 800 states
[eva] stmr.c:119: Trace partitioning superposing up to 900 states
[eva] stmr.c:119: Trace partitioning superposing up to 1000 states
[eva] stmr.c:119: Trace partitioning superposing up to 1100 states
[eva] stmr.c:119: Trace partitioning superposing up to 1200 states
[eva] stmr.c:113: starting to merge loop iterations
[eva] stmr.c:119: Trace partitioning superposing up to 1300 states
[eva] stmr.c:114: starting to merge loop iterations
[eva] stmr.c:129: starting to merge loop iterations
[eva] stmr.c:119: Trace partitioning superposing up to 400 states
[eva] stmr.c:119: Trace partitioning superposing up to 1400 states
[eva] stmr.c:119: Trace partitioning superposing up to 500 states
[eva] stmr.c:113: cannot properly split on \result == 1
[eva] stmr.c:119: Trace partitioning superposing up to 600 states
[eva] stmr.c:119: Trace partitioning superposing up to 700 states
[eva] stmr.c:119: Trace partitioning superposing up to 800 states
[eva] stmr.c:119: Trace partitioning superposing up to 900 states
[eva] stmr.c:119: Trace partitioning superposing up to 1000 states
[eva] stmr.c:119: Trace partitioning superposing up to 1100 states
[eva] stmr.c:113: starting to merge loop iterations
[eva] stmr.c:119: Trace partitioning superposing up to 1200 states
[eva] stmr.c:119: Trace partitioning superposing up to 1300 states
[eva] stmr.c:113: cannot properly split on \result == 1
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_8
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_9
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_10
[eva] FRAMAC_SHARE/libc/string.h:124: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] using specification for function isConsonant
[eva] stmr.c:104: Trace partitioning superposing up to 100 states
[eva] stmr.c:104: Trace partitioning superposing up to 200 states
[eva] stmr.c:104: Trace partitioning superposing up to 300 states
[eva] stmr.c:99: starting to merge loop iterations
[eva] stmr.c:114: starting to merge loop iterations
[eva] stmr.c:129: starting to merge loop iterations
[eva] stmr.c:119: Trace partitioning superposing up to 400 states
[eva] stmr.c:119: Trace partitioning superposing up to 500 states
[eva] stmr.c:119: Trace partitioning superposing up to 600 states
[eva] stmr.c:119: Trace partitioning superposing up to 700 states
[eva] stmr.c:119: Trace partitioning superposing up to 800 states
[eva] stmr.c:113: starting to merge loop iterations
[eva] stmr.c:119: Trace partitioning superposing up to 900 states
[eva] stmr.c:119: Trace partitioning superposing up to 1000 states
[eva] stmr.c:119: Trace partitioning superposing up to 1100 states
[eva] stmr.c:113: cannot properly split on \result == 1
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_8
[eva] FRAMAC_SHARE/libc/string.h:101: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] FRAMAC_SHARE/libc/string.c:319: allocating variable __malloc_strdup_l319_9
[eva] FRAMAC_SHARE/libc/string.c:319: 
  allocating variable __malloc_strdup_l319_10
[eva] FRAMAC_SHARE/libc/string.h:124: 
  cannot evaluate ACSL term, unsupported ACSL construct: logic function memcmp
[eva] using specification for function isConsonant
[eva] stmr.c:104: Trace partitioning superposing up to 100 states
[eva] stmr.c:104: Trace partitioning superposing up to 200 states
[eva] stmr.c:104: Trace partitioning superposing up to 300 states
[eva] stmr.c:99: starting to merge loop iterations
[eva] stmr.c:153: Trace partitioning superposing up to 100 states
[eva] stmr.c:153: Trace partitioning superposing up to 200 states
[eva] stmr.c:114: starting to merge loop iterations
[eva] stmr.c:129: starting to merge loop iterations
[eva] stmr.c:119: Trace partitioning superposing up to 400 states
[eva] stmr.c:119: Trace partitioning superposing up to 500 states
[eva] stmr.c:119: Trace partitioning superposing up to 600 states
[eva] stmr.c:119: Trace partitioning superposing up to 700 states
[eva] stmr.c:119: Trace partitioning superposing up to 800 states
[eva] stmr.c:119: Trace partitioning superposing up to 900 states
[eva] stmr.c:113: starting to merge loop iterations
[eva] stmr.c:119: Trace partitioning superposing up to 1000 states
[eva] stmr.c:153: Trace partitioning superposing up to 300 states
[eva] stmr.c:119: Trace partitioning superposing up to 1100 states
[eva] stmr.c:119: Trace partitioning superposing up to 1200 states
[eva] stmr.c:153: Trace partitioning superposing up to 100 states
[eva] stmr.c:113: cannot properly split on \result == 1
[eva] stmr.c:153: Trace partitioning superposing up to 200 states
[eva] stmr.c:152: starting to merge loop iterations
[eva] stmr.c:153: Trace partitioning superposing up to 300 states
[eva] stmr.c:153: Trace partitioning superposing up to 400 states
[eva] stmr.c:152: starting to merge loop iterations
[eva] stmr.c:153: Trace partitioning superposing up to 100 states
[eva] stmr.c:153: Trace partitioning superposing up to 200 states
[eva] stmr.c:153: Trace partitioning superposing up to 300 states
[eva] stmr.c:152: starting to merge loop iterations
[eva] stmr.c:153: Trace partitioning superposing up to 100 states
[eva] stmr.c:153: Trace partitioning superposing up to 200 states
[eva] stmr.c:153: Trace partitioning superposing up to 300 states
[eva] stmr.c:152: starting to merge loop iterations
[parf] Final parameters: -eva-widening-delay 8 -eva-subdivide-non-linear 39 -eva-split-return auto -eva-slevel 92 -eva-plevel 365 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 4 -eva-ilevel 221 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 220
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[kernel] Warning: 1 state in saved file ignored. It is invalid in this Frama-C configuration.
[parf] ================================= Summary ==================================
[parf] ====== project "Initial Base 2" ======
[parf] Parameter: -eva-widening-delay 1 -eva-subdivide-non-linear 0 -eva-slevel 0 -eva-plevel 10 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 8 -eva-equality-through-calls none -eva-domains cvalue -eva-auto-loop-unroll 0
[parf] alarms:
[parf] alarm (  1): Signed_overflow(j + length <= 2147483647)
[parf] alarm (  2): Memory_access(*(b + index_0), read)
[parf] alarm (  3): Uninitialized(*(b + index_0))
[parf] alarm (  4): Memory_access(*(b + k), read)
[parf] alarm (  5): Uninitialized(*(b + k))
[parf] alarm (  6): Uninitialized(*(s2 + i))
[parf] alarm (  7): Uninitialized(*(s1 + i))
[parf] alarm (  8): Memory_access(*(s1 + i), read)
[parf] alarm (  9): Memory_access(*(s2 + i), read)
[parf] alarm ( 10): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 11): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 12): Signed_overflow(tmp_0 + 1 <= 2147483647)
[parf] alarm ( 13): Memory_access(*(result + (tmp_0 + 1)), write)
[parf] alarm ( 14): Memory_access(*(s1 + i), read)
[parf] alarm ( 15): Uninitialized(*(s1 + i))
[parf] alarm ( 16): Signed_overflow(errorCount + 1 <= 2147483647)
[parf] alarm ( 17): Uninitialized(*((unsigned char *)s1 + i))
[parf] alarm ( 18): Memory_access(*((unsigned char *)s2 + i), read)
[parf] alarm ( 19): Uninitialized(*((unsigned char *)s2 + i))
[parf] alarm ( 20): Memory_access(*((unsigned char *)s1 + i), read)
[parf] alarm ( 21): Signed_overflow(assertionCount + 1 <= 2147483647)
[parf] alarm ( 22): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 23): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 24): Memory_access(*(*lineptr + tmp_2), write)
[parf] alarm ( 25): Uninitialized(*(b + j))
[parf] alarm ( 26): Memory_access(*(b + j), read)
[parf] alarm ( 27): Uninitialized(*(b + j))
[parf] alarm ( 28): Memory_access(*(b + j), read)
[parf] alarm ( 29): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 30): Memory_access(*(*lineptr + cur), write)
[parf] alarm ( 31): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 32): Signed_overflow(position + 1 <= 2147483647)
[parf] alarm ( 33): Uninitialized(*(b + k))
[parf] alarm ( 34): Memory_access(*(b + k), read)
[parf] alarm ( 35): Memory_access(*(lineIn + (tmp - (size_t)1)), write)
[parf] alarm ( 36): Memory_access(*(lineOut + (tmp_0 - (size_t)1)), write)
[parf] alarm ( 37): Memory_access(*(p1 + i), read)
[parf] alarm ( 38): Uninitialized(*(p1 + i))
[parf] alarm ( 39): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 40): Uninitialized(*(p1 + i))
[parf] alarm ( 41): Memory_access(*(p1 + i), read)
[parf] alarm ( 42): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 43): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 44): Memory_access(*(b + k), read)
[parf] alarm ( 45): Uninitialized(*(b + k))
[parf] alarm ( 46): Memory_access(*(b + k), write)
[parf] alarm ( 47): Memory_access(*(b + (index_0 - 1)), read)
[parf] alarm ( 48): Uninitialized(*(b + index_0))
[parf] alarm ( 49): Uninitialized(*(b + (index_0 - 1)))
[parf] alarm ( 50): Memory_access(*(b + index_0), read)
[parf] alarm ( 51): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 52): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 53): Uninitialized(*(b + k))
[parf] alarm ( 54): Memory_access(*(b + k), read)
[parf] alarm ( 55): Memory_access(*(b + index_0), read)
[parf] alarm ( 56): Uninitialized(*(b + index_0))
[parf] alarm ( 57): Memory_access(*(b + k), read)
[parf] alarm ( 58): Uninitialized(*(b + k))
[parf] alarm ( 59): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 60): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 61): Memory_access(*(b + k), read)
[parf] alarm ( 62): Uninitialized(*(b + k))
[parf] alarm ( 63): Signed_overflow((k - k0) + 1 <= 2147483647)
[parf] ============================================================================
[parf] ====== project "base00-sample00 2" ======
[parf] Parameter: -eva-widening-delay 2 -eva-subdivide-non-linear 3 -eva-slevel 9 -eva-plevel 25 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 16 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon -eva-auto-loop-unroll 18
[parf] alarms:
[parf] alarm (  1): Signed_overflow(j + length <= 2147483647)
[parf] alarm (  2): Memory_access(*(b + index_0), read)
[parf] alarm (  3): Uninitialized(*(b + index_0))
[parf] alarm (  4): Memory_access(*(b + k), read)
[parf] alarm (  5): Uninitialized(*(b + k))
[parf] alarm (  6): Uninitialized(*(s2 + i))
[parf] alarm (  7): Uninitialized(*(s1 + i))
[parf] alarm (  8): Memory_access(*(s1 + i), read)
[parf] alarm (  9): Memory_access(*(s2 + i), read)
[parf] alarm ( 10): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 11): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 12): Signed_overflow(tmp_0 + 1 <= 2147483647)
[parf] alarm ( 13): Memory_access(*(result + (tmp_0 + 1)), write)
[parf] alarm ( 14): Signed_overflow(errorCount + 1 <= 2147483647)
[parf] alarm ( 15): Uninitialized(*((unsigned char *)s1 + i))
[parf] alarm ( 16): Memory_access(*((unsigned char *)s2 + i), read)
[parf] alarm ( 17): Uninitialized(*((unsigned char *)s2 + i))
[parf] alarm ( 18): Memory_access(*((unsigned char *)s1 + i), read)
[parf] alarm ( 19): Signed_overflow(assertionCount + 1 <= 2147483647)
[parf] alarm ( 20): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 21): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 22): Memory_access(*(*lineptr + tmp_2), write)
[parf] alarm ( 23): Uninitialized(*(b + j))
[parf] alarm ( 24): Memory_access(*(b + j), read)
[parf] alarm ( 25): Uninitialized(*(b + j))
[parf] alarm ( 26): Memory_access(*(b + j), read)
[parf] alarm ( 27): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 28): Memory_access(*(*lineptr + cur), write)
[parf] alarm ( 29): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 30): Signed_overflow(position + 1 <= 2147483647)
[parf] alarm ( 31): Uninitialized(*(b + k))
[parf] alarm ( 32): Memory_access(*(b + k), read)
[parf] alarm ( 33): Memory_access(*(lineIn + (tmp - (size_t)1)), write)
[parf] alarm ( 34): Memory_access(*(lineOut + (tmp_0 - (size_t)1)), write)
[parf] alarm ( 35): Memory_access(*(p1 + i), read)
[parf] alarm ( 36): Uninitialized(*(p1 + i))
[parf] alarm ( 37): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 38): Uninitialized(*(p1 + i))
[parf] alarm ( 39): Memory_access(*(p1 + i), read)
[parf] alarm ( 40): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 41): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 42): Memory_access(*(b + k), read)
[parf] alarm ( 43): Uninitialized(*(b + k))
[parf] alarm ( 44): Memory_access(*(b + k), write)
[parf] alarm ( 45): Memory_access(*(b + (index_0 - 1)), read)
[parf] alarm ( 46): Uninitialized(*(b + index_0))
[parf] alarm ( 47): Uninitialized(*(b + (index_0 - 1)))
[parf] alarm ( 48): Memory_access(*(b + index_0), read)
[parf] alarm ( 49): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 50): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 51): Uninitialized(*(b + k))
[parf] alarm ( 52): Memory_access(*(b + k), read)
[parf] alarm ( 53): Memory_access(*(b + index_0), read)
[parf] alarm ( 54): Uninitialized(*(b + index_0))
[parf] alarm ( 55): Memory_access(*(b + k), read)
[parf] alarm ( 56): Uninitialized(*(b + k))
[parf] alarm ( 57): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 58): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 59): Memory_access(*(b + k), read)
[parf] alarm ( 60): Uninitialized(*(b + k))
[parf] alarm ( 61): Signed_overflow((k - k0) + 1 <= 2147483647)
[parf] ============================================================================
[parf] ====== project "base00-sample01 2" ======
[parf] Parameter: -eva-widening-delay 2 -eva-subdivide-non-linear 1 -eva-split-return auto -eva-slevel 5 -eva-remove-redundant-alarms -eva-plevel 29 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 16 -eva-equality-through-calls formals -eva-domains cvalue,gauges,octagon -eva-auto-loop-unroll 7
[parf] alarms:
[parf] alarm (  1): Memory_access(*(b + index_0), read)
[parf] alarm (  2): Uninitialized(*(b + index_0))
[parf] alarm (  3): Memory_access(*(b + k), read)
[parf] alarm (  4): Uninitialized(*(b + k))
[parf] alarm (  5): Uninitialized(*(s2 + i))
[parf] alarm (  6): Uninitialized(*(s1 + i))
[parf] alarm (  7): Memory_access(*(s1 + i), read)
[parf] alarm (  8): Memory_access(*(s2 + i), read)
[parf] alarm (  9): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 10): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 11): Signed_overflow(tmp_0 + 1 <= 2147483647)
[parf] alarm ( 12): Memory_access(*(result + (tmp_0 + 1)), write)
[parf] alarm ( 13): Uninitialized(*(s1 + i))
[parf] alarm ( 14): Memory_access(*(s1 + i), read)
[parf] alarm ( 15): Signed_overflow(errorCount + 1 <= 2147483647)
[parf] alarm ( 16): Uninitialized(*((unsigned char *)s1 + i))
[parf] alarm ( 17): Memory_access(*((unsigned char *)s2 + i), read)
[parf] alarm ( 18): Uninitialized(*((unsigned char *)s2 + i))
[parf] alarm ( 19): Memory_access(*((unsigned char *)s1 + i), read)
[parf] alarm ( 20): Signed_overflow(assertionCount + 1 <= 2147483647)
[parf] alarm ( 21): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 22): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 23): Memory_access(*(*lineptr + tmp_2), write)
[parf] alarm ( 24): Uninitialized(*(b + j))
[parf] alarm ( 25): Memory_access(*(b + j), read)
[parf] alarm ( 26): Uninitialized(*(b + j))
[parf] alarm ( 27): Memory_access(*(b + j), read)
[parf] alarm ( 28): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 29): Memory_access(*(*lineptr + cur), write)
[parf] alarm ( 30): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 31): Signed_overflow(position + 1 <= 2147483647)
[parf] alarm ( 32): Uninitialized(*(b + k))
[parf] alarm ( 33): Memory_access(*(b + k), read)
[parf] alarm ( 34): Memory_access(*(lineIn + (tmp - (size_t)1)), write)
[parf] alarm ( 35): Memory_access(*(lineOut + (tmp_0 - (size_t)1)), write)
[parf] alarm ( 36): Memory_access(*(p1 + i), read)
[parf] alarm ( 37): Uninitialized(*(p1 + i))
[parf] alarm ( 38): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 39): Uninitialized(*(p1 + i))
[parf] alarm ( 40): Memory_access(*(p1 + i), read)
[parf] alarm ( 41): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 42): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 43): Memory_access(*(b + k), read)
[parf] alarm ( 44): Uninitialized(*(b + k))
[parf] alarm ( 45): Memory_access(*(b + k), write)
[parf] alarm ( 46): Memory_access(*(b + (index_0 - 1)), read)
[parf] alarm ( 47): Uninitialized(*(b + index_0))
[parf] alarm ( 48): Uninitialized(*(b + (index_0 - 1)))
[parf] alarm ( 49): Memory_access(*(b + index_0), read)
[parf] alarm ( 50): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 51): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 52): Uninitialized(*(b + k))
[parf] alarm ( 53): Memory_access(*(b + k), read)
[parf] alarm ( 54): Memory_access(*(b + index_0), read)
[parf] alarm ( 55): Uninitialized(*(b + index_0))
[parf] alarm ( 56): Memory_access(*(b + k), read)
[parf] alarm ( 57): Uninitialized(*(b + k))
[parf] alarm ( 58): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 59): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 60): Memory_access(*(b + k), read)
[parf] alarm ( 61): Uninitialized(*(b + k))
[parf] alarm ( 62): Signed_overflow((k - k0) + 1 <= 2147483647)
[parf] ============================================================================
[parf] ====== project "base00-sample02 2" ======
[parf] Parameter: -eva-widening-delay 2 -eva-subdivide-non-linear 4 -eva-split-return auto -eva-slevel 11 -eva-plevel 32 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 19 -eva-equality-through-calls none -eva-domains cvalue,octagon,symbolic-locations -eva-auto-loop-unroll 11
[parf] alarms:
[parf] alarm (  1): Memory_access(*(b + index_0), read)
[parf] alarm (  2): Uninitialized(*(b + index_0))
[parf] alarm (  3): Memory_access(*(b + k), read)
[parf] alarm (  4): Uninitialized(*(b + k))
[parf] alarm (  5): Uninitialized(*(s2 + i))
[parf] alarm (  6): Uninitialized(*(s1 + i))
[parf] alarm (  7): Memory_access(*(s1 + i), read)
[parf] alarm (  8): Memory_access(*(s2 + i), read)
[parf] alarm (  9): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 10): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 11): Signed_overflow(tmp_0 + 1 <= 2147483647)
[parf] alarm ( 12): Memory_access(*(result + (tmp_0 + 1)), write)
[parf] alarm ( 13): Uninitialized(*(s1 + i))
[parf] alarm ( 14): Memory_access(*(s1 + i), read)
[parf] alarm ( 15): Signed_overflow(errorCount + 1 <= 2147483647)
[parf] alarm ( 16): Uninitialized(*((unsigned char *)s1 + i))
[parf] alarm ( 17): Memory_access(*((unsigned char *)s2 + i), read)
[parf] alarm ( 18): Uninitialized(*((unsigned char *)s2 + i))
[parf] alarm ( 19): Memory_access(*((unsigned char *)s1 + i), read)
[parf] alarm ( 20): Signed_overflow(assertionCount + 1 <= 2147483647)
[parf] alarm ( 21): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 22): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 23): Memory_access(*(*lineptr + tmp_2), write)
[parf] alarm ( 24): Uninitialized(*(b + j))
[parf] alarm ( 25): Memory_access(*(b + j), read)
[parf] alarm ( 26): Memory_access(*(b + j), read)
[parf] alarm ( 27): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 28): Memory_access(*(*lineptr + cur), write)
[parf] alarm ( 29): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 30): Signed_overflow(position + 1 <= 2147483647)
[parf] alarm ( 31): Uninitialized(*(b + k))
[parf] alarm ( 32): Memory_access(*(b + k), read)
[parf] alarm ( 33): Memory_access(*(lineIn + (tmp - (size_t)1)), write)
[parf] alarm ( 34): Memory_access(*(lineOut + (tmp_0 - (size_t)1)), write)
[parf] alarm ( 35): Memory_access(*(p1 + i), read)
[parf] alarm ( 36): Uninitialized(*(p1 + i))
[parf] alarm ( 37): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 38): Memory_access(*(p1 + i), read)
[parf] alarm ( 39): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 40): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 41): Memory_access(*(b + k), read)
[parf] alarm ( 42): Uninitialized(*(b + k))
[parf] alarm ( 43): Memory_access(*(b + k), write)
[parf] alarm ( 44): Memory_access(*(b + (index_0 - 1)), read)
[parf] alarm ( 45): Uninitialized(*(b + index_0))
[parf] alarm ( 46): Uninitialized(*(b + (index_0 - 1)))
[parf] alarm ( 47): Memory_access(*(b + index_0), read)
[parf] alarm ( 48): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 49): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 50): Uninitialized(*(b + k))
[parf] alarm ( 51): Memory_access(*(b + k), read)
[parf] alarm ( 52): Memory_access(*(b + index_0), read)
[parf] alarm ( 53): Uninitialized(*(b + index_0))
[parf] alarm ( 54): Uninitialized(*(b + k))
[parf] alarm ( 55): Memory_access(*(b + k), read)
[parf] alarm ( 56): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 57): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 58): Memory_access(*(b + k), read)
[parf] alarm ( 59): Uninitialized(*(b + k))
[parf] alarm ( 60): Signed_overflow((k - k0) + 1 <= 2147483647)
[parf] ============================================================================
[parf] ====== project "base00-sample03 2" ======
[parf] Parameter: -eva-widening-delay 2 -eva-subdivide-non-linear 2 -eva-split-return auto -eva-slevel 10 -eva-remove-redundant-alarms -eva-plevel 31 -eva-partition-history 0 -eva-min-loop-unroll 0 -eva-ilevel 19 -eva-equality-through-calls formals -eva-domains cvalue,octagon -eva-auto-loop-unroll 12
[parf] alarms:
[parf] alarm (  1): Memory_access(*(b + index_0), read)
[parf] alarm (  2): Uninitialized(*(b + index_0))
[parf] alarm (  3): Memory_access(*(b + k), read)
[parf] alarm (  4): Uninitialized(*(b + k))
[parf] alarm (  5): Uninitialized(*(s2 + i))
[parf] alarm (  6): Uninitialized(*(s1 + i))
[parf] alarm (  7): Memory_access(*(s1 + i), read)
[parf] alarm (  8): Memory_access(*(s2 + i), read)
[parf] alarm (  9): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 10): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 11): Signed_overflow(tmp_0 + 1 <= 2147483647)
[parf] alarm ( 12): Memory_access(*(result + (tmp_0 + 1)), write)
[parf] alarm ( 13): Uninitialized(*(s1 + i))
[parf] alarm ( 14): Memory_access(*(s1 + i), read)
[parf] alarm ( 15): Signed_overflow(errorCount + 1 <= 2147483647)
[parf] alarm ( 16): Uninitialized(*((unsigned char *)s1 + i))
[parf] alarm ( 17): Memory_access(*((unsigned char *)s2 + i), read)
[parf] alarm ( 18): Uninitialized(*((unsigned char *)s2 + i))
[parf] alarm ( 19): Memory_access(*((unsigned char *)s1 + i), read)
[parf] alarm ( 20): Signed_overflow(assertionCount + 1 <= 2147483647)
[parf] alarm ( 21): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 22): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 23): Memory_access(*(*lineptr + tmp_2), write)
[parf] alarm ( 24): Uninitialized(*(b + j))
[parf] alarm ( 25): Memory_access(*(b + j), read)
[parf] alarm ( 26): Uninitialized(*(b + j))
[parf] alarm ( 27): Memory_access(*(b + j), read)
[parf] alarm ( 28): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 29): Memory_access(*(*lineptr + cur), write)
[parf] alarm ( 30): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 31): Signed_overflow(position + 1 <= 2147483647)
[parf] alarm ( 32): Uninitialized(*(b + k))
[parf] alarm ( 33): Memory_access(*(b + k), read)
[parf] alarm ( 34): Memory_access(*(lineIn + (tmp - (size_t)1)), write)
[parf] alarm ( 35): Memory_access(*(lineOut + (tmp_0 - (size_t)1)), write)
[parf] alarm ( 36): Memory_access(*(p1 + i), read)
[parf] alarm ( 37): Uninitialized(*(p1 + i))
[parf] alarm ( 38): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 39): Uninitialized(*(p1 + i))
[parf] alarm ( 40): Memory_access(*(p1 + i), read)
[parf] alarm ( 41): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 42): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 43): Memory_access(*(b + k), read)
[parf] alarm ( 44): Uninitialized(*(b + k))
[parf] alarm ( 45): Memory_access(*(b + k), write)
[parf] alarm ( 46): Memory_access(*(b + (index_0 - 1)), read)
[parf] alarm ( 47): Uninitialized(*(b + index_0))
[parf] alarm ( 48): Uninitialized(*(b + (index_0 - 1)))
[parf] alarm ( 49): Memory_access(*(b + index_0), read)
[parf] alarm ( 50): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 51): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 52): Uninitialized(*(b + k))
[parf] alarm ( 53): Memory_access(*(b + k), read)
[parf] alarm ( 54): Memory_access(*(b + index_0), read)
[parf] alarm ( 55): Uninitialized(*(b + index_0))
[parf] alarm ( 56): Memory_access(*(b + k), read)
[parf] alarm ( 57): Uninitialized(*(b + k))
[parf] alarm ( 58): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 59): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 60): Memory_access(*(b + k), read)
[parf] alarm ( 61): Uninitialized(*(b + k))
[parf] alarm ( 62): Signed_overflow((k - k0) + 1 <= 2147483647)
[parf] ============================================================================
[parf] ====== project "base01-sample00 2" ======
[parf] Parameter: -eva-widening-delay 8 -eva-subdivide-non-linear 8 -eva-split-return auto -eva-slevel 26 -eva-plevel 67 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 2 -eva-ilevel 45 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 33
[parf] alarms:
[parf] alarm (  1): Memory_access(*(b + index_0), read)
[parf] alarm (  2): Uninitialized(*(b + index_0))
[parf] alarm (  3): Memory_access(*(b + k), read)
[parf] alarm (  4): Uninitialized(*(b + k))
[parf] alarm (  5): Uninitialized(*(s2 + i))
[parf] alarm (  6): Uninitialized(*(s1 + i))
[parf] alarm (  7): Memory_access(*(s1 + i), read)
[parf] alarm (  8): Memory_access(*(s2 + i), read)
[parf] alarm (  9): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 10): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 11): Signed_overflow(tmp_0 + 1 <= 2147483647)
[parf] alarm ( 12): Memory_access(*(result + (tmp_0 + 1)), write)
[parf] alarm ( 13): Signed_overflow(errorCount + 1 <= 2147483647)
[parf] alarm ( 14): Uninitialized(*((unsigned char *)s1 + i))
[parf] alarm ( 15): Memory_access(*((unsigned char *)s2 + i), read)
[parf] alarm ( 16): Uninitialized(*((unsigned char *)s2 + i))
[parf] alarm ( 17): Memory_access(*((unsigned char *)s1 + i), read)
[parf] alarm ( 18): Signed_overflow(assertionCount + 1 <= 2147483647)
[parf] alarm ( 19): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 20): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 21): Memory_access(*(*lineptr + tmp_2), write)
[parf] alarm ( 22): Uninitialized(*(b + j))
[parf] alarm ( 23): Memory_access(*(b + j), read)
[parf] alarm ( 24): Memory_access(*(b + j), read)
[parf] alarm ( 25): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 26): Memory_access(*(*lineptr + cur), write)
[parf] alarm ( 27): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 28): Signed_overflow(position + 1 <= 2147483647)
[parf] alarm ( 29): Uninitialized(*(b + k))
[parf] alarm ( 30): Memory_access(*(b + k), read)
[parf] alarm ( 31): Memory_access(*(lineIn + (tmp - (size_t)1)), write)
[parf] alarm ( 32): Memory_access(*(lineOut + (tmp_0 - (size_t)1)), write)
[parf] alarm ( 33): Memory_access(*(p1 + i), read)
[parf] alarm ( 34): Uninitialized(*(p1 + i))
[parf] alarm ( 35): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 36): Memory_access(*(p1 + i), read)
[parf] alarm ( 37): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 38): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 39): Memory_access(*(b + k), read)
[parf] alarm ( 40): Uninitialized(*(b + k))
[parf] alarm ( 41): Memory_access(*(b + k), write)
[parf] alarm ( 42): Memory_access(*(b + (index_0 - 1)), read)
[parf] alarm ( 43): Uninitialized(*(b + index_0))
[parf] alarm ( 44): Uninitialized(*(b + (index_0 - 1)))
[parf] alarm ( 45): Memory_access(*(b + index_0), read)
[parf] alarm ( 46): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 47): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 48): Uninitialized(*(b + k))
[parf] alarm ( 49): Memory_access(*(b + k), read)
[parf] alarm ( 50): Memory_access(*(b + index_0), read)
[parf] alarm ( 51): Uninitialized(*(b + index_0))
[parf] alarm ( 52): Uninitialized(*(b + k))
[parf] alarm ( 53): Memory_access(*(b + k), read)
[parf] alarm ( 54): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 55): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 56): Memory_access(*(b + k), read)
[parf] alarm ( 57): Uninitialized(*(b + k))
[parf] alarm ( 58): Signed_overflow((k - k0) + 1 <= 2147483647)
[parf] ============================================================================
[parf] ====== project "base01-sample01 2" ======
[parf] Parameter: -eva-widening-delay 4 -eva-subdivide-non-linear 15 -eva-split-return auto -eva-slevel 18 -eva-plevel 60 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 36 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 34
[parf] alarms:
[parf] alarm (  1): Memory_access(*(b + index_0), read)
[parf] alarm (  2): Uninitialized(*(b + index_0))
[parf] alarm (  3): Memory_access(*(b + k), read)
[parf] alarm (  4): Uninitialized(*(b + k))
[parf] alarm (  5): Uninitialized(*(s2 + i))
[parf] alarm (  6): Uninitialized(*(s1 + i))
[parf] alarm (  7): Memory_access(*(s1 + i), read)
[parf] alarm (  8): Memory_access(*(s2 + i), read)
[parf] alarm (  9): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 10): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 11): Signed_overflow(tmp_0 + 1 <= 2147483647)
[parf] alarm ( 12): Memory_access(*(result + (tmp_0 + 1)), write)
[parf] alarm ( 13): Signed_overflow(errorCount + 1 <= 2147483647)
[parf] alarm ( 14): Uninitialized(*((unsigned char *)s1 + i))
[parf] alarm ( 15): Memory_access(*((unsigned char *)s2 + i), read)
[parf] alarm ( 16): Uninitialized(*((unsigned char *)s2 + i))
[parf] alarm ( 17): Memory_access(*((unsigned char *)s1 + i), read)
[parf] alarm ( 18): Signed_overflow(assertionCount + 1 <= 2147483647)
[parf] alarm ( 19): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 20): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 21): Memory_access(*(*lineptr + tmp_2), write)
[parf] alarm ( 22): Uninitialized(*(b + j))
[parf] alarm ( 23): Memory_access(*(b + j), read)
[parf] alarm ( 24): Memory_access(*(b + j), read)
[parf] alarm ( 25): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 26): Memory_access(*(*lineptr + cur), write)
[parf] alarm ( 27): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 28): Signed_overflow(position + 1 <= 2147483647)
[parf] alarm ( 29): Uninitialized(*(b + k))
[parf] alarm ( 30): Memory_access(*(b + k), read)
[parf] alarm ( 31): Memory_access(*(lineIn + (tmp - (size_t)1)), write)
[parf] alarm ( 32): Memory_access(*(lineOut + (tmp_0 - (size_t)1)), write)
[parf] alarm ( 33): Memory_access(*(p1 + i), read)
[parf] alarm ( 34): Uninitialized(*(p1 + i))
[parf] alarm ( 35): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 36): Memory_access(*(p1 + i), read)
[parf] alarm ( 37): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 38): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 39): Memory_access(*(b + k), read)
[parf] alarm ( 40): Uninitialized(*(b + k))
[parf] alarm ( 41): Memory_access(*(b + k), write)
[parf] alarm ( 42): Memory_access(*(b + (index_0 - 1)), read)
[parf] alarm ( 43): Uninitialized(*(b + index_0))
[parf] alarm ( 44): Uninitialized(*(b + (index_0 - 1)))
[parf] alarm ( 45): Memory_access(*(b + index_0), read)
[parf] alarm ( 46): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 47): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 48): Uninitialized(*(b + k))
[parf] alarm ( 49): Memory_access(*(b + k), read)
[parf] alarm ( 50): Memory_access(*(b + index_0), read)
[parf] alarm ( 51): Uninitialized(*(b + index_0))
[parf] alarm ( 52): Uninitialized(*(b + k))
[parf] alarm ( 53): Memory_access(*(b + k), read)
[parf] alarm ( 54): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 55): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 56): Memory_access(*(b + k), read)
[parf] alarm ( 57): Uninitialized(*(b + k))
[parf] alarm ( 58): Signed_overflow((k - k0) + 1 <= 2147483647)
[parf] ============================================================================
[parf] ====== project "base01-sample02 2" ======
[parf] Parameter: -eva-widening-delay 3 -eva-subdivide-non-linear 9 -eva-split-return auto -eva-slevel 23 -eva-plevel 66 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 4 -eva-ilevel 34 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 33
[parf] alarms:
[parf] alarm (  1): Memory_access(*(b + index_0), read)
[parf] alarm (  2): Uninitialized(*(b + index_0))
[parf] alarm (  3): Memory_access(*(b + k), read)
[parf] alarm (  4): Uninitialized(*(b + k))
[parf] alarm (  5): Uninitialized(*(s2 + i))
[parf] alarm (  6): Uninitialized(*(s1 + i))
[parf] alarm (  7): Memory_access(*(s1 + i), read)
[parf] alarm (  8): Memory_access(*(s2 + i), read)
[parf] alarm (  9): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 10): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 11): Signed_overflow(tmp_0 + 1 <= 2147483647)
[parf] alarm ( 12): Memory_access(*(result + (tmp_0 + 1)), write)
[parf] alarm ( 13): Signed_overflow(errorCount + 1 <= 2147483647)
[parf] alarm ( 14): Uninitialized(*((unsigned char *)s1 + i))
[parf] alarm ( 15): Memory_access(*((unsigned char *)s2 + i), read)
[parf] alarm ( 16): Uninitialized(*((unsigned char *)s2 + i))
[parf] alarm ( 17): Memory_access(*((unsigned char *)s1 + i), read)
[parf] alarm ( 18): Signed_overflow(assertionCount + 1 <= 2147483647)
[parf] alarm ( 19): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 20): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 21): Memory_access(*(*lineptr + tmp_2), write)
[parf] alarm ( 22): Uninitialized(*(b + j))
[parf] alarm ( 23): Memory_access(*(b + j), read)
[parf] alarm ( 24): Memory_access(*(b + j), read)
[parf] alarm ( 25): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 26): Memory_access(*(*lineptr + cur), write)
[parf] alarm ( 27): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 28): Signed_overflow(position + 1 <= 2147483647)
[parf] alarm ( 29): Uninitialized(*(b + k))
[parf] alarm ( 30): Memory_access(*(b + k), read)
[parf] alarm ( 31): Memory_access(*(lineIn + (tmp - (size_t)1)), write)
[parf] alarm ( 32): Memory_access(*(lineOut + (tmp_0 - (size_t)1)), write)
[parf] alarm ( 33): Memory_access(*(p1 + i), read)
[parf] alarm ( 34): Uninitialized(*(p1 + i))
[parf] alarm ( 35): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 36): Memory_access(*(p1 + i), read)
[parf] alarm ( 37): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 38): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 39): Memory_access(*(b + k), read)
[parf] alarm ( 40): Uninitialized(*(b + k))
[parf] alarm ( 41): Memory_access(*(b + k), write)
[parf] alarm ( 42): Memory_access(*(b + (index_0 - 1)), read)
[parf] alarm ( 43): Uninitialized(*(b + index_0))
[parf] alarm ( 44): Uninitialized(*(b + (index_0 - 1)))
[parf] alarm ( 45): Memory_access(*(b + index_0), read)
[parf] alarm ( 46): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 47): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 48): Uninitialized(*(b + k))
[parf] alarm ( 49): Memory_access(*(b + k), read)
[parf] alarm ( 50): Memory_access(*(b + index_0), read)
[parf] alarm ( 51): Uninitialized(*(b + index_0))
[parf] alarm ( 52): Uninitialized(*(b + k))
[parf] alarm ( 53): Memory_access(*(b + k), read)
[parf] alarm ( 54): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 55): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 56): Memory_access(*(b + k), read)
[parf] alarm ( 57): Uninitialized(*(b + k))
[parf] alarm ( 58): Signed_overflow((k - k0) + 1 <= 2147483647)
[parf] ============================================================================
[parf] ====== project "base01-sample03 2" ======
[parf] Parameter: -eva-widening-delay 5 -eva-subdivide-non-linear 9 -eva-split-return auto -eva-slevel 16 -eva-plevel 59 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 1 -eva-ilevel 33 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 45
[parf] alarms:
[parf] alarm (  1): Memory_access(*(b + index_0), read)
[parf] alarm (  2): Uninitialized(*(b + index_0))
[parf] alarm (  3): Memory_access(*(b + k), read)
[parf] alarm (  4): Uninitialized(*(b + k))
[parf] alarm (  5): Uninitialized(*(s2 + i))
[parf] alarm (  6): Uninitialized(*(s1 + i))
[parf] alarm (  7): Memory_access(*(s1 + i), read)
[parf] alarm (  8): Memory_access(*(s2 + i), read)
[parf] alarm (  9): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 10): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 11): Signed_overflow(tmp_0 + 1 <= 2147483647)
[parf] alarm ( 12): Memory_access(*(result + (tmp_0 + 1)), write)
[parf] alarm ( 13): Signed_overflow(errorCount + 1 <= 2147483647)
[parf] alarm ( 14): Uninitialized(*((unsigned char *)s1 + i))
[parf] alarm ( 15): Memory_access(*((unsigned char *)s2 + i), read)
[parf] alarm ( 16): Uninitialized(*((unsigned char *)s2 + i))
[parf] alarm ( 17): Memory_access(*((unsigned char *)s1 + i), read)
[parf] alarm ( 18): Signed_overflow(assertionCount + 1 <= 2147483647)
[parf] alarm ( 19): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 20): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 21): Memory_access(*(*lineptr + tmp_2), write)
[parf] alarm ( 22): Uninitialized(*(b + j))
[parf] alarm ( 23): Memory_access(*(b + j), read)
[parf] alarm ( 24): Memory_access(*(b + j), read)
[parf] alarm ( 25): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 26): Memory_access(*(*lineptr + cur), write)
[parf] alarm ( 27): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 28): Signed_overflow(position + 1 <= 2147483647)
[parf] alarm ( 29): Uninitialized(*(b + k))
[parf] alarm ( 30): Memory_access(*(b + k), read)
[parf] alarm ( 31): Memory_access(*(lineIn + (tmp - (size_t)1)), write)
[parf] alarm ( 32): Memory_access(*(lineOut + (tmp_0 - (size_t)1)), write)
[parf] alarm ( 33): Memory_access(*(p1 + i), read)
[parf] alarm ( 34): Uninitialized(*(p1 + i))
[parf] alarm ( 35): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 36): Memory_access(*(p1 + i), read)
[parf] alarm ( 37): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 38): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 39): Memory_access(*(b + k), read)
[parf] alarm ( 40): Uninitialized(*(b + k))
[parf] alarm ( 41): Memory_access(*(b + k), write)
[parf] alarm ( 42): Memory_access(*(b + (index_0 - 1)), read)
[parf] alarm ( 43): Uninitialized(*(b + index_0))
[parf] alarm ( 44): Uninitialized(*(b + (index_0 - 1)))
[parf] alarm ( 45): Memory_access(*(b + index_0), read)
[parf] alarm ( 46): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 47): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 48): Uninitialized(*(b + k))
[parf] alarm ( 49): Memory_access(*(b + k), read)
[parf] alarm ( 50): Memory_access(*(b + index_0), read)
[parf] alarm ( 51): Uninitialized(*(b + index_0))
[parf] alarm ( 52): Uninitialized(*(b + k))
[parf] alarm ( 53): Memory_access(*(b + k), read)
[parf] alarm ( 54): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 55): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 56): Memory_access(*(b + k), read)
[parf] alarm ( 57): Uninitialized(*(b + k))
[parf] alarm ( 58): Signed_overflow((k - k0) + 1 <= 2147483647)
[parf] ============================================================================
[parf] ====== project "base02-sample00 2" ======
[parf] Parameter: -eva-widening-delay 5 -eva-subdivide-non-linear 15 -eva-split-return auto -eva-slevel 33 -eva-plevel 117 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 2 -eva-ilevel 60 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 64
[parf] alarms:
[parf] alarm (  1): Memory_access(*(b + index_0), read)
[parf] alarm (  2): Uninitialized(*(b + index_0))
[parf] alarm (  3): Memory_access(*(b + k), read)
[parf] alarm (  4): Uninitialized(*(b + k))
[parf] alarm (  5): Uninitialized(*(s2 + i))
[parf] alarm (  6): Uninitialized(*(s1 + i))
[parf] alarm (  7): Memory_access(*(s1 + i), read)
[parf] alarm (  8): Memory_access(*(s2 + i), read)
[parf] alarm (  9): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 10): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 11): Signed_overflow(tmp_0 + 1 <= 2147483647)
[parf] alarm ( 12): Memory_access(*(result + (tmp_0 + 1)), write)
[parf] alarm ( 13): Signed_overflow(errorCount + 1 <= 2147483647)
[parf] alarm ( 14): Uninitialized(*((unsigned char *)s1 + i))
[parf] alarm ( 15): Memory_access(*((unsigned char *)s2 + i), read)
[parf] alarm ( 16): Uninitialized(*((unsigned char *)s2 + i))
[parf] alarm ( 17): Memory_access(*((unsigned char *)s1 + i), read)
[parf] alarm ( 18): Signed_overflow(assertionCount + 1 <= 2147483647)
[parf] alarm ( 19): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 20): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 21): Memory_access(*(*lineptr + tmp_2), write)
[parf] alarm ( 22): Uninitialized(*(b + j))
[parf] alarm ( 23): Memory_access(*(b + j), read)
[parf] alarm ( 24): Memory_access(*(b + j), read)
[parf] alarm ( 25): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 26): Memory_access(*(*lineptr + cur), write)
[parf] alarm ( 27): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 28): Signed_overflow(position + 1 <= 2147483647)
[parf] alarm ( 29): Uninitialized(*(b + k))
[parf] alarm ( 30): Memory_access(*(b + k), read)
[parf] alarm ( 31): Memory_access(*(lineIn + (tmp - (size_t)1)), write)
[parf] alarm ( 32): Memory_access(*(lineOut + (tmp_0 - (size_t)1)), write)
[parf] alarm ( 33): Memory_access(*(p1 + i), read)
[parf] alarm ( 34): Uninitialized(*(p1 + i))
[parf] alarm ( 35): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 36): Memory_access(*(p1 + i), read)
[parf] alarm ( 37): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 38): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 39): Memory_access(*(b + k), read)
[parf] alarm ( 40): Uninitialized(*(b + k))
[parf] alarm ( 41): Memory_access(*(b + k), write)
[parf] alarm ( 42): Memory_access(*(b + (index_0 - 1)), read)
[parf] alarm ( 43): Uninitialized(*(b + index_0))
[parf] alarm ( 44): Uninitialized(*(b + (index_0 - 1)))
[parf] alarm ( 45): Memory_access(*(b + index_0), read)
[parf] alarm ( 46): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 47): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 48): Uninitialized(*(b + k))
[parf] alarm ( 49): Memory_access(*(b + k), read)
[parf] alarm ( 50): Memory_access(*(b + index_0), read)
[parf] alarm ( 51): Uninitialized(*(b + index_0))
[parf] alarm ( 52): Uninitialized(*(b + k))
[parf] alarm ( 53): Memory_access(*(b + k), read)
[parf] alarm ( 54): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 55): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 56): Memory_access(*(b + k), read)
[parf] alarm ( 57): Uninitialized(*(b + k))
[parf] alarm ( 58): Signed_overflow((k - k0) + 1 <= 2147483647)
[parf] ============================================================================
[parf] ====== project "base02-sample01 2" ======
[parf] Parameter: -eva-widening-delay 7 -eva-subdivide-non-linear 15 -eva-split-return auto -eva-slevel 29 -eva-plevel 127 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 2 -eva-ilevel 76 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 74
[parf] alarms:
[parf] alarm (  1): Memory_access(*(b + index_0), read)
[parf] alarm (  2): Uninitialized(*(b + index_0))
[parf] alarm (  3): Memory_access(*(b + k), read)
[parf] alarm (  4): Uninitialized(*(b + k))
[parf] alarm (  5): Uninitialized(*(s2 + i))
[parf] alarm (  6): Uninitialized(*(s1 + i))
[parf] alarm (  7): Memory_access(*(s1 + i), read)
[parf] alarm (  8): Memory_access(*(s2 + i), read)
[parf] alarm (  9): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 10): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 11): Signed_overflow(tmp_0 + 1 <= 2147483647)
[parf] alarm ( 12): Memory_access(*(result + (tmp_0 + 1)), write)
[parf] alarm ( 13): Signed_overflow(errorCount + 1 <= 2147483647)
[parf] alarm ( 14): Uninitialized(*((unsigned char *)s1 + i))
[parf] alarm ( 15): Memory_access(*((unsigned char *)s2 + i), read)
[parf] alarm ( 16): Uninitialized(*((unsigned char *)s2 + i))
[parf] alarm ( 17): Memory_access(*((unsigned char *)s1 + i), read)
[parf] alarm ( 18): Signed_overflow(assertionCount + 1 <= 2147483647)
[parf] alarm ( 19): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 20): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 21): Memory_access(*(*lineptr + tmp_2), write)
[parf] alarm ( 22): Uninitialized(*(b + j))
[parf] alarm ( 23): Memory_access(*(b + j), read)
[parf] alarm ( 24): Memory_access(*(b + j), read)
[parf] alarm ( 25): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 26): Memory_access(*(*lineptr + cur), write)
[parf] alarm ( 27): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 28): Signed_overflow(position + 1 <= 2147483647)
[parf] alarm ( 29): Uninitialized(*(b + k))
[parf] alarm ( 30): Memory_access(*(b + k), read)
[parf] alarm ( 31): Memory_access(*(lineIn + (tmp - (size_t)1)), write)
[parf] alarm ( 32): Memory_access(*(lineOut + (tmp_0 - (size_t)1)), write)
[parf] alarm ( 33): Memory_access(*(p1 + i), read)
[parf] alarm ( 34): Uninitialized(*(p1 + i))
[parf] alarm ( 35): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 36): Memory_access(*(p1 + i), read)
[parf] alarm ( 37): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 38): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 39): Memory_access(*(b + k), read)
[parf] alarm ( 40): Uninitialized(*(b + k))
[parf] alarm ( 41): Memory_access(*(b + k), write)
[parf] alarm ( 42): Memory_access(*(b + (index_0 - 1)), read)
[parf] alarm ( 43): Uninitialized(*(b + index_0))
[parf] alarm ( 44): Uninitialized(*(b + (index_0 - 1)))
[parf] alarm ( 45): Memory_access(*(b + index_0), read)
[parf] alarm ( 46): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 47): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 48): Uninitialized(*(b + k))
[parf] alarm ( 49): Memory_access(*(b + k), read)
[parf] alarm ( 50): Memory_access(*(b + index_0), read)
[parf] alarm ( 51): Uninitialized(*(b + index_0))
[parf] alarm ( 52): Uninitialized(*(b + k))
[parf] alarm ( 53): Memory_access(*(b + k), read)
[parf] alarm ( 54): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 55): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 56): Memory_access(*(b + k), read)
[parf] alarm ( 57): Uninitialized(*(b + k))
[parf] alarm ( 58): Signed_overflow((k - k0) + 1 <= 2147483647)
[parf] ============================================================================
[parf] ====== project "base02-sample02 2" ======
[parf] Parameter: -eva-widening-delay 8 -eva-subdivide-non-linear 16 -eva-split-return auto -eva-slevel 38 -eva-plevel 99 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 2 -eva-ilevel 55 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 73
[parf] alarms:
[parf] alarm (  1): Memory_access(*(b + index_0), read)
[parf] alarm (  2): Uninitialized(*(b + index_0))
[parf] alarm (  3): Memory_access(*(b + k), read)
[parf] alarm (  4): Uninitialized(*(b + k))
[parf] alarm (  5): Uninitialized(*(s2 + i))
[parf] alarm (  6): Uninitialized(*(s1 + i))
[parf] alarm (  7): Memory_access(*(s1 + i), read)
[parf] alarm (  8): Memory_access(*(s2 + i), read)
[parf] alarm (  9): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 10): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 11): Signed_overflow(tmp_0 + 1 <= 2147483647)
[parf] alarm ( 12): Memory_access(*(result + (tmp_0 + 1)), write)
[parf] alarm ( 13): Signed_overflow(errorCount + 1 <= 2147483647)
[parf] alarm ( 14): Uninitialized(*((unsigned char *)s1 + i))
[parf] alarm ( 15): Memory_access(*((unsigned char *)s2 + i), read)
[parf] alarm ( 16): Uninitialized(*((unsigned char *)s2 + i))
[parf] alarm ( 17): Memory_access(*((unsigned char *)s1 + i), read)
[parf] alarm ( 18): Signed_overflow(assertionCount + 1 <= 2147483647)
[parf] alarm ( 19): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 20): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 21): Memory_access(*(*lineptr + tmp_2), write)
[parf] alarm ( 22): Uninitialized(*(b + j))
[parf] alarm ( 23): Memory_access(*(b + j), read)
[parf] alarm ( 24): Memory_access(*(b + j), read)
[parf] alarm ( 25): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 26): Memory_access(*(*lineptr + cur), write)
[parf] alarm ( 27): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 28): Signed_overflow(position + 1 <= 2147483647)
[parf] alarm ( 29): Uninitialized(*(b + k))
[parf] alarm ( 30): Memory_access(*(b + k), read)
[parf] alarm ( 31): Memory_access(*(lineIn + (tmp - (size_t)1)), write)
[parf] alarm ( 32): Memory_access(*(lineOut + (tmp_0 - (size_t)1)), write)
[parf] alarm ( 33): Memory_access(*(p1 + i), read)
[parf] alarm ( 34): Uninitialized(*(p1 + i))
[parf] alarm ( 35): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 36): Memory_access(*(p1 + i), read)
[parf] alarm ( 37): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 38): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 39): Memory_access(*(b + k), read)
[parf] alarm ( 40): Uninitialized(*(b + k))
[parf] alarm ( 41): Memory_access(*(b + k), write)
[parf] alarm ( 42): Memory_access(*(b + (index_0 - 1)), read)
[parf] alarm ( 43): Uninitialized(*(b + index_0))
[parf] alarm ( 44): Uninitialized(*(b + (index_0 - 1)))
[parf] alarm ( 45): Memory_access(*(b + index_0), read)
[parf] alarm ( 46): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 47): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 48): Uninitialized(*(b + k))
[parf] alarm ( 49): Memory_access(*(b + k), read)
[parf] alarm ( 50): Memory_access(*(b + index_0), read)
[parf] alarm ( 51): Uninitialized(*(b + index_0))
[parf] alarm ( 52): Uninitialized(*(b + k))
[parf] alarm ( 53): Memory_access(*(b + k), read)
[parf] alarm ( 54): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 55): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 56): Memory_access(*(b + k), read)
[parf] alarm ( 57): Uninitialized(*(b + k))
[parf] alarm ( 58): Signed_overflow((k - k0) + 1 <= 2147483647)
[parf] ============================================================================
[parf] ====== project "base02-sample03 2" ======
[parf] Parameter: -eva-widening-delay 4 -eva-subdivide-non-linear 16 -eva-split-return auto -eva-slevel 33 -eva-plevel 129 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 3 -eva-ilevel 58 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 75
[parf] alarms:
[parf] alarm (  1): Memory_access(*(b + index_0), read)
[parf] alarm (  2): Uninitialized(*(b + index_0))
[parf] alarm (  3): Memory_access(*(b + k), read)
[parf] alarm (  4): Uninitialized(*(b + k))
[parf] alarm (  5): Uninitialized(*(s2 + i))
[parf] alarm (  6): Uninitialized(*(s1 + i))
[parf] alarm (  7): Memory_access(*(s1 + i), read)
[parf] alarm (  8): Memory_access(*(s2 + i), read)
[parf] alarm (  9): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 10): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 11): Signed_overflow(tmp_0 + 1 <= 2147483647)
[parf] alarm ( 12): Memory_access(*(result + (tmp_0 + 1)), write)
[parf] alarm ( 13): Signed_overflow(errorCount + 1 <= 2147483647)
[parf] alarm ( 14): Uninitialized(*((unsigned char *)s1 + i))
[parf] alarm ( 15): Memory_access(*((unsigned char *)s2 + i), read)
[parf] alarm ( 16): Uninitialized(*((unsigned char *)s2 + i))
[parf] alarm ( 17): Memory_access(*((unsigned char *)s1 + i), read)
[parf] alarm ( 18): Signed_overflow(assertionCount + 1 <= 2147483647)
[parf] alarm ( 19): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 20): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 21): Memory_access(*(*lineptr + tmp_2), write)
[parf] alarm ( 22): Uninitialized(*(b + j))
[parf] alarm ( 23): Memory_access(*(b + j), read)
[parf] alarm ( 24): Memory_access(*(b + j), read)
[parf] alarm ( 25): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 26): Memory_access(*(*lineptr + cur), write)
[parf] alarm ( 27): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 28): Signed_overflow(position + 1 <= 2147483647)
[parf] alarm ( 29): Uninitialized(*(b + k))
[parf] alarm ( 30): Memory_access(*(b + k), read)
[parf] alarm ( 31): Memory_access(*(lineIn + (tmp - (size_t)1)), write)
[parf] alarm ( 32): Memory_access(*(lineOut + (tmp_0 - (size_t)1)), write)
[parf] alarm ( 33): Memory_access(*(p1 + i), read)
[parf] alarm ( 34): Uninitialized(*(p1 + i))
[parf] alarm ( 35): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 36): Memory_access(*(p1 + i), read)
[parf] alarm ( 37): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 38): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 39): Memory_access(*(b + k), read)
[parf] alarm ( 40): Uninitialized(*(b + k))
[parf] alarm ( 41): Memory_access(*(b + k), write)
[parf] alarm ( 42): Memory_access(*(b + (index_0 - 1)), read)
[parf] alarm ( 43): Uninitialized(*(b + index_0))
[parf] alarm ( 44): Uninitialized(*(b + (index_0 - 1)))
[parf] alarm ( 45): Memory_access(*(b + index_0), read)
[parf] alarm ( 46): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 47): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 48): Uninitialized(*(b + k))
[parf] alarm ( 49): Memory_access(*(b + k), read)
[parf] alarm ( 50): Memory_access(*(b + index_0), read)
[parf] alarm ( 51): Uninitialized(*(b + index_0))
[parf] alarm ( 52): Uninitialized(*(b + k))
[parf] alarm ( 53): Memory_access(*(b + k), read)
[parf] alarm ( 54): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 55): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 56): Memory_access(*(b + k), read)
[parf] alarm ( 57): Uninitialized(*(b + k))
[parf] alarm ( 58): Signed_overflow((k - k0) + 1 <= 2147483647)
[parf] ============================================================================
[parf] ====== project "base03-sample00 2" ======
[parf] Parameter: -eva-widening-delay 6 -eva-subdivide-non-linear 30 -eva-split-return auto -eva-slevel 52 -eva-plevel 189 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 6 -eva-ilevel 117 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 114
[parf] alarms:
[parf] alarm (  1): Memory_access(*(b + index_0), read)
[parf] alarm (  2): Uninitialized(*(b + index_0))
[parf] alarm (  3): Memory_access(*(b + k), read)
[parf] alarm (  4): Uninitialized(*(b + k))
[parf] alarm (  5): Uninitialized(*(s2 + i))
[parf] alarm (  6): Uninitialized(*(s1 + i))
[parf] alarm (  7): Memory_access(*(s1 + i), read)
[parf] alarm (  8): Memory_access(*(s2 + i), read)
[parf] alarm (  9): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 10): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 11): Signed_overflow(tmp_0 + 1 <= 2147483647)
[parf] alarm ( 12): Memory_access(*(result + (tmp_0 + 1)), write)
[parf] alarm ( 13): Signed_overflow(errorCount + 1 <= 2147483647)
[parf] alarm ( 14): Uninitialized(*((unsigned char *)s1 + i))
[parf] alarm ( 15): Memory_access(*((unsigned char *)s2 + i), read)
[parf] alarm ( 16): Uninitialized(*((unsigned char *)s2 + i))
[parf] alarm ( 17): Memory_access(*((unsigned char *)s1 + i), read)
[parf] alarm ( 18): Signed_overflow(assertionCount + 1 <= 2147483647)
[parf] alarm ( 19): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 20): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 21): Memory_access(*(*lineptr + tmp_2), write)
[parf] alarm ( 22): Uninitialized(*(b + j))
[parf] alarm ( 23): Memory_access(*(b + j), read)
[parf] alarm ( 24): Memory_access(*(b + j), read)
[parf] alarm ( 25): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 26): Memory_access(*(*lineptr + cur), write)
[parf] alarm ( 27): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 28): Signed_overflow(position + 1 <= 2147483647)
[parf] alarm ( 29): Uninitialized(*(b + k))
[parf] alarm ( 30): Memory_access(*(b + k), read)
[parf] alarm ( 31): Memory_access(*(lineIn + (tmp - (size_t)1)), write)
[parf] alarm ( 32): Memory_access(*(lineOut + (tmp_0 - (size_t)1)), write)
[parf] alarm ( 33): Memory_access(*(p1 + i), read)
[parf] alarm ( 34): Uninitialized(*(p1 + i))
[parf] alarm ( 35): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 36): Memory_access(*(p1 + i), read)
[parf] alarm ( 37): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 38): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 39): Memory_access(*(b + k), read)
[parf] alarm ( 40): Uninitialized(*(b + k))
[parf] alarm ( 41): Memory_access(*(b + k), write)
[parf] alarm ( 42): Memory_access(*(b + (index_0 - 1)), read)
[parf] alarm ( 43): Uninitialized(*(b + index_0))
[parf] alarm ( 44): Uninitialized(*(b + (index_0 - 1)))
[parf] alarm ( 45): Memory_access(*(b + index_0), read)
[parf] alarm ( 46): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 47): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 48): Uninitialized(*(b + k))
[parf] alarm ( 49): Memory_access(*(b + k), read)
[parf] alarm ( 50): Memory_access(*(b + index_0), read)
[parf] alarm ( 51): Uninitialized(*(b + index_0))
[parf] alarm ( 52): Uninitialized(*(b + k))
[parf] alarm ( 53): Memory_access(*(b + k), read)
[parf] alarm ( 54): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 55): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 56): Memory_access(*(b + k), read)
[parf] alarm ( 57): Uninitialized(*(b + k))
[parf] alarm ( 58): Signed_overflow((k - k0) + 1 <= 2147483647)
[parf] ============================================================================
[parf] ====== project "base03-sample01 2" ======
[parf] Parameter: -eva-widening-delay 10 -eva-subdivide-non-linear 26 -eva-split-return auto -eva-slevel 56 -eva-plevel 189 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 7 -eva-ilevel 127 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 138
[parf] alarms:
[parf] alarm (  1): Memory_access(*(b + index_0), read)
[parf] alarm (  2): Uninitialized(*(b + index_0))
[parf] alarm (  3): Memory_access(*(b + k), read)
[parf] alarm (  4): Uninitialized(*(b + k))
[parf] alarm (  5): Uninitialized(*(s2 + i))
[parf] alarm (  6): Uninitialized(*(s1 + i))
[parf] alarm (  7): Memory_access(*(s1 + i), read)
[parf] alarm (  8): Memory_access(*(s2 + i), read)
[parf] alarm (  9): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 10): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 11): Signed_overflow(tmp_0 + 1 <= 2147483647)
[parf] alarm ( 12): Memory_access(*(result + (tmp_0 + 1)), write)
[parf] alarm ( 13): Signed_overflow(errorCount + 1 <= 2147483647)
[parf] alarm ( 14): Uninitialized(*((unsigned char *)s1 + i))
[parf] alarm ( 15): Memory_access(*((unsigned char *)s2 + i), read)
[parf] alarm ( 16): Uninitialized(*((unsigned char *)s2 + i))
[parf] alarm ( 17): Memory_access(*((unsigned char *)s1 + i), read)
[parf] alarm ( 18): Signed_overflow(assertionCount + 1 <= 2147483647)
[parf] alarm ( 19): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 20): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 21): Memory_access(*(*lineptr + tmp_2), write)
[parf] alarm ( 22): Uninitialized(*(b + j))
[parf] alarm ( 23): Memory_access(*(b + j), read)
[parf] alarm ( 24): Memory_access(*(b + j), read)
[parf] alarm ( 25): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 26): Memory_access(*(*lineptr + cur), write)
[parf] alarm ( 27): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 28): Signed_overflow(position + 1 <= 2147483647)
[parf] alarm ( 29): Uninitialized(*(b + k))
[parf] alarm ( 30): Memory_access(*(b + k), read)
[parf] alarm ( 31): Memory_access(*(lineIn + (tmp - (size_t)1)), write)
[parf] alarm ( 32): Memory_access(*(lineOut + (tmp_0 - (size_t)1)), write)
[parf] alarm ( 33): Memory_access(*(p1 + i), read)
[parf] alarm ( 34): Uninitialized(*(p1 + i))
[parf] alarm ( 35): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 36): Memory_access(*(p1 + i), read)
[parf] alarm ( 37): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 38): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 39): Memory_access(*(b + k), read)
[parf] alarm ( 40): Uninitialized(*(b + k))
[parf] alarm ( 41): Memory_access(*(b + k), write)
[parf] alarm ( 42): Memory_access(*(b + (index_0 - 1)), read)
[parf] alarm ( 43): Uninitialized(*(b + index_0))
[parf] alarm ( 44): Uninitialized(*(b + (index_0 - 1)))
[parf] alarm ( 45): Memory_access(*(b + index_0), read)
[parf] alarm ( 46): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 47): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 48): Uninitialized(*(b + k))
[parf] alarm ( 49): Memory_access(*(b + k), read)
[parf] alarm ( 50): Memory_access(*(b + index_0), read)
[parf] alarm ( 51): Uninitialized(*(b + index_0))
[parf] alarm ( 52): Uninitialized(*(b + k))
[parf] alarm ( 53): Memory_access(*(b + k), read)
[parf] alarm ( 54): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 55): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 56): Memory_access(*(b + k), read)
[parf] alarm ( 57): Uninitialized(*(b + k))
[parf] alarm ( 58): Signed_overflow((k - k0) + 1 <= 2147483647)
[parf] ============================================================================
[parf] ====== project "base03-sample02 2" ======
[parf] Parameter: -eva-widening-delay 11 -eva-subdivide-non-linear 28 -eva-split-return auto -eva-slevel 52 -eva-plevel 191 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 7 -eva-ilevel 118 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 127
[parf] alarms:
[parf] alarm (  1): Memory_access(*(b + index_0), read)
[parf] alarm (  2): Uninitialized(*(b + index_0))
[parf] alarm (  3): Memory_access(*(b + k), read)
[parf] alarm (  4): Uninitialized(*(b + k))
[parf] alarm (  5): Uninitialized(*(s2 + i))
[parf] alarm (  6): Uninitialized(*(s1 + i))
[parf] alarm (  7): Memory_access(*(s1 + i), read)
[parf] alarm (  8): Memory_access(*(s2 + i), read)
[parf] alarm (  9): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 10): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 11): Signed_overflow(tmp_0 + 1 <= 2147483647)
[parf] alarm ( 12): Memory_access(*(result + (tmp_0 + 1)), write)
[parf] alarm ( 13): Signed_overflow(errorCount + 1 <= 2147483647)
[parf] alarm ( 14): Uninitialized(*((unsigned char *)s1 + i))
[parf] alarm ( 15): Memory_access(*((unsigned char *)s2 + i), read)
[parf] alarm ( 16): Uninitialized(*((unsigned char *)s2 + i))
[parf] alarm ( 17): Memory_access(*((unsigned char *)s1 + i), read)
[parf] alarm ( 18): Signed_overflow(assertionCount + 1 <= 2147483647)
[parf] alarm ( 19): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 20): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 21): Memory_access(*(*lineptr + tmp_2), write)
[parf] alarm ( 22): Uninitialized(*(b + j))
[parf] alarm ( 23): Memory_access(*(b + j), read)
[parf] alarm ( 24): Memory_access(*(b + j), read)
[parf] alarm ( 25): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 26): Memory_access(*(*lineptr + cur), write)
[parf] alarm ( 27): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 28): Signed_overflow(position + 1 <= 2147483647)
[parf] alarm ( 29): Uninitialized(*(b + k))
[parf] alarm ( 30): Memory_access(*(b + k), read)
[parf] alarm ( 31): Memory_access(*(lineIn + (tmp - (size_t)1)), write)
[parf] alarm ( 32): Memory_access(*(lineOut + (tmp_0 - (size_t)1)), write)
[parf] alarm ( 33): Memory_access(*(p1 + i), read)
[parf] alarm ( 34): Uninitialized(*(p1 + i))
[parf] alarm ( 35): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 36): Memory_access(*(p1 + i), read)
[parf] alarm ( 37): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 38): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 39): Memory_access(*(b + k), read)
[parf] alarm ( 40): Uninitialized(*(b + k))
[parf] alarm ( 41): Memory_access(*(b + k), write)
[parf] alarm ( 42): Memory_access(*(b + (index_0 - 1)), read)
[parf] alarm ( 43): Uninitialized(*(b + index_0))
[parf] alarm ( 44): Uninitialized(*(b + (index_0 - 1)))
[parf] alarm ( 45): Memory_access(*(b + index_0), read)
[parf] alarm ( 46): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 47): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 48): Uninitialized(*(b + k))
[parf] alarm ( 49): Memory_access(*(b + k), read)
[parf] alarm ( 50): Memory_access(*(b + index_0), read)
[parf] alarm ( 51): Uninitialized(*(b + index_0))
[parf] alarm ( 52): Uninitialized(*(b + k))
[parf] alarm ( 53): Memory_access(*(b + k), read)
[parf] alarm ( 54): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 55): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 56): Memory_access(*(b + k), read)
[parf] alarm ( 57): Uninitialized(*(b + k))
[parf] alarm ( 58): Signed_overflow((k - k0) + 1 <= 2147483647)
[parf] ============================================================================
[parf] ====== project "base03-sample03 2" ======
[parf] Parameter: -eva-widening-delay 8 -eva-subdivide-non-linear 33 -eva-split-return auto -eva-slevel 52 -eva-plevel 186 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 5 -eva-ilevel 108 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 142
[parf] alarms:
[parf] alarm (  1): Memory_access(*(b + index_0), read)
[parf] alarm (  2): Uninitialized(*(b + index_0))
[parf] alarm (  3): Memory_access(*(b + k), read)
[parf] alarm (  4): Uninitialized(*(b + k))
[parf] alarm (  5): Uninitialized(*(s2 + i))
[parf] alarm (  6): Uninitialized(*(s1 + i))
[parf] alarm (  7): Memory_access(*(s1 + i), read)
[parf] alarm (  8): Memory_access(*(s2 + i), read)
[parf] alarm (  9): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 10): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 11): Signed_overflow(tmp_0 + 1 <= 2147483647)
[parf] alarm ( 12): Memory_access(*(result + (tmp_0 + 1)), write)
[parf] alarm ( 13): Signed_overflow(errorCount + 1 <= 2147483647)
[parf] alarm ( 14): Uninitialized(*((unsigned char *)s1 + i))
[parf] alarm ( 15): Memory_access(*((unsigned char *)s2 + i), read)
[parf] alarm ( 16): Uninitialized(*((unsigned char *)s2 + i))
[parf] alarm ( 17): Memory_access(*((unsigned char *)s1 + i), read)
[parf] alarm ( 18): Signed_overflow(assertionCount + 1 <= 2147483647)
[parf] alarm ( 19): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 20): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 21): Memory_access(*(*lineptr + tmp_2), write)
[parf] alarm ( 22): Uninitialized(*(b + j))
[parf] alarm ( 23): Memory_access(*(b + j), read)
[parf] alarm ( 24): Memory_access(*(b + j), read)
[parf] alarm ( 25): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 26): Memory_access(*(*lineptr + cur), write)
[parf] alarm ( 27): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 28): Signed_overflow(position + 1 <= 2147483647)
[parf] alarm ( 29): Uninitialized(*(b + k))
[parf] alarm ( 30): Memory_access(*(b + k), read)
[parf] alarm ( 31): Memory_access(*(lineIn + (tmp - (size_t)1)), write)
[parf] alarm ( 32): Memory_access(*(lineOut + (tmp_0 - (size_t)1)), write)
[parf] alarm ( 33): Memory_access(*(p1 + i), read)
[parf] alarm ( 34): Uninitialized(*(p1 + i))
[parf] alarm ( 35): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 36): Memory_access(*(p1 + i), read)
[parf] alarm ( 37): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 38): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 39): Memory_access(*(b + k), read)
[parf] alarm ( 40): Uninitialized(*(b + k))
[parf] alarm ( 41): Memory_access(*(b + k), write)
[parf] alarm ( 42): Memory_access(*(b + (index_0 - 1)), read)
[parf] alarm ( 43): Uninitialized(*(b + index_0))
[parf] alarm ( 44): Uninitialized(*(b + (index_0 - 1)))
[parf] alarm ( 45): Memory_access(*(b + index_0), read)
[parf] alarm ( 46): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 47): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 48): Uninitialized(*(b + k))
[parf] alarm ( 49): Memory_access(*(b + k), read)
[parf] alarm ( 50): Memory_access(*(b + index_0), read)
[parf] alarm ( 51): Uninitialized(*(b + index_0))
[parf] alarm ( 52): Uninitialized(*(b + k))
[parf] alarm ( 53): Memory_access(*(b + k), read)
[parf] alarm ( 54): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 55): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 56): Memory_access(*(b + k), read)
[parf] alarm ( 57): Uninitialized(*(b + k))
[parf] alarm ( 58): Signed_overflow((k - k0) + 1 <= 2147483647)
[parf] ============================================================================
[parf] ====== project "base04-sample00 2" ======
[parf] Parameter: -eva-widening-delay 11 -eva-subdivide-non-linear 39 -eva-split-return auto -eva-slevel 92 -eva-plevel 365 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 6 -eva-ilevel 232 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 220
[parf] alarms:
[parf] alarm (  1): Memory_access(*(b + index_0), read)
[parf] alarm (  2): Uninitialized(*(b + index_0))
[parf] alarm (  3): Memory_access(*(b + k), read)
[parf] alarm (  4): Uninitialized(*(b + k))
[parf] alarm (  5): Uninitialized(*(s2 + i))
[parf] alarm (  6): Uninitialized(*(s1 + i))
[parf] alarm (  7): Memory_access(*(s1 + i), read)
[parf] alarm (  8): Memory_access(*(s2 + i), read)
[parf] alarm (  9): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 10): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 11): Signed_overflow(tmp_0 + 1 <= 2147483647)
[parf] alarm ( 12): Memory_access(*(result + (tmp_0 + 1)), write)
[parf] alarm ( 13): Signed_overflow(errorCount + 1 <= 2147483647)
[parf] alarm ( 14): Uninitialized(*((unsigned char *)s1 + i))
[parf] alarm ( 15): Memory_access(*((unsigned char *)s2 + i), read)
[parf] alarm ( 16): Uninitialized(*((unsigned char *)s2 + i))
[parf] alarm ( 17): Memory_access(*((unsigned char *)s1 + i), read)
[parf] alarm ( 18): Signed_overflow(assertionCount + 1 <= 2147483647)
[parf] alarm ( 19): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 20): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 21): Memory_access(*(*lineptr + tmp_2), write)
[parf] alarm ( 22): Uninitialized(*(b + j))
[parf] alarm ( 23): Memory_access(*(b + j), read)
[parf] alarm ( 24): Memory_access(*(b + j), read)
[parf] alarm ( 25): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 26): Memory_access(*(*lineptr + cur), write)
[parf] alarm ( 27): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 28): Signed_overflow(position + 1 <= 2147483647)
[parf] alarm ( 29): Uninitialized(*(b + k))
[parf] alarm ( 30): Memory_access(*(b + k), read)
[parf] alarm ( 31): Memory_access(*(lineIn + (tmp - (size_t)1)), write)
[parf] alarm ( 32): Memory_access(*(lineOut + (tmp_0 - (size_t)1)), write)
[parf] alarm ( 33): Memory_access(*(p1 + i), read)
[parf] alarm ( 34): Uninitialized(*(p1 + i))
[parf] alarm ( 35): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 36): Memory_access(*(p1 + i), read)
[parf] alarm ( 37): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 38): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 39): Memory_access(*(b + k), read)
[parf] alarm ( 40): Uninitialized(*(b + k))
[parf] alarm ( 41): Memory_access(*(b + k), write)
[parf] alarm ( 42): Memory_access(*(b + (index_0 - 1)), read)
[parf] alarm ( 43): Uninitialized(*(b + index_0))
[parf] alarm ( 44): Uninitialized(*(b + (index_0 - 1)))
[parf] alarm ( 45): Memory_access(*(b + index_0), read)
[parf] alarm ( 46): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 47): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 48): Uninitialized(*(b + k))
[parf] alarm ( 49): Memory_access(*(b + k), read)
[parf] alarm ( 50): Memory_access(*(b + index_0), read)
[parf] alarm ( 51): Uninitialized(*(b + index_0))
[parf] alarm ( 52): Uninitialized(*(b + k))
[parf] alarm ( 53): Memory_access(*(b + k), read)
[parf] alarm ( 54): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 55): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 56): Memory_access(*(b + k), read)
[parf] alarm ( 57): Uninitialized(*(b + k))
[parf] alarm ( 58): Signed_overflow((k - k0) + 1 <= 2147483647)
[parf] ============================================================================
[parf] ====== project "base04-sample01 2" ======
[parf] Parameter: -eva-widening-delay 12 -eva-subdivide-non-linear 53 -eva-split-return auto -eva-slevel 113 -eva-remove-redundant-alarms -eva-plevel 367 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 7 -eva-ilevel 221 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 222
[parf] alarms:
[parf] alarm (  1): Memory_access(*(b + index_0), read)
[parf] alarm (  2): Uninitialized(*(b + index_0))
[parf] alarm (  3): Memory_access(*(b + k), read)
[parf] alarm (  4): Uninitialized(*(b + k))
[parf] alarm (  5): Uninitialized(*(s2 + i))
[parf] alarm (  6): Uninitialized(*(s1 + i))
[parf] alarm (  7): Memory_access(*(s1 + i), read)
[parf] alarm (  8): Memory_access(*(s2 + i), read)
[parf] alarm (  9): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 10): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 11): Signed_overflow(tmp_0 + 1 <= 2147483647)
[parf] alarm ( 12): Memory_access(*(result + (tmp_0 + 1)), write)
[parf] alarm ( 13): Signed_overflow(errorCount + 1 <= 2147483647)
[parf] alarm ( 14): Uninitialized(*((unsigned char *)s1 + i))
[parf] alarm ( 15): Memory_access(*((unsigned char *)s2 + i), read)
[parf] alarm ( 16): Uninitialized(*((unsigned char *)s2 + i))
[parf] alarm ( 17): Memory_access(*((unsigned char *)s1 + i), read)
[parf] alarm ( 18): Signed_overflow(assertionCount + 1 <= 2147483647)
[parf] alarm ( 19): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 20): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 21): Memory_access(*(*lineptr + tmp_2), write)
[parf] alarm ( 22): Uninitialized(*(b + j))
[parf] alarm ( 23): Memory_access(*(b + j), read)
[parf] alarm ( 24): Memory_access(*(b + j), read)
[parf] alarm ( 25): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 26): Memory_access(*(*lineptr + cur), write)
[parf] alarm ( 27): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 28): Signed_overflow(position + 1 <= 2147483647)
[parf] alarm ( 29): Uninitialized(*(b + k))
[parf] alarm ( 30): Memory_access(*(b + k), read)
[parf] alarm ( 31): Memory_access(*(lineIn + (tmp - (size_t)1)), write)
[parf] alarm ( 32): Memory_access(*(lineOut + (tmp_0 - (size_t)1)), write)
[parf] alarm ( 33): Memory_access(*(p1 + i), read)
[parf] alarm ( 34): Uninitialized(*(p1 + i))
[parf] alarm ( 35): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 36): Memory_access(*(p1 + i), read)
[parf] alarm ( 37): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 38): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 39): Memory_access(*(b + k), read)
[parf] alarm ( 40): Uninitialized(*(b + k))
[parf] alarm ( 41): Memory_access(*(b + k), write)
[parf] alarm ( 42): Memory_access(*(b + (index_0 - 1)), read)
[parf] alarm ( 43): Uninitialized(*(b + index_0))
[parf] alarm ( 44): Uninitialized(*(b + (index_0 - 1)))
[parf] alarm ( 45): Memory_access(*(b + index_0), read)
[parf] alarm ( 46): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 47): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 48): Uninitialized(*(b + k))
[parf] alarm ( 49): Memory_access(*(b + k), read)
[parf] alarm ( 50): Memory_access(*(b + index_0), read)
[parf] alarm ( 51): Uninitialized(*(b + index_0))
[parf] alarm ( 52): Uninitialized(*(b + k))
[parf] alarm ( 53): Memory_access(*(b + k), read)
[parf] alarm ( 54): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 55): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 56): Memory_access(*(b + k), read)
[parf] alarm ( 57): Uninitialized(*(b + k))
[parf] alarm ( 58): Signed_overflow((k - k0) + 1 <= 2147483647)
[parf] ============================================================================
[parf] ====== project "base04-sample02 2" ======
[parf] Parameter: -eva-widening-delay 8 -eva-subdivide-non-linear 59 -eva-split-return auto -eva-slevel 126 -eva-plevel 366 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 7 -eva-ilevel 228 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 231
[parf] alarms:
[parf] alarm (  1): Memory_access(*(b + index_0), read)
[parf] alarm (  2): Uninitialized(*(b + index_0))
[parf] alarm (  3): Memory_access(*(b + k), read)
[parf] alarm (  4): Uninitialized(*(b + k))
[parf] alarm (  5): Uninitialized(*(s2 + i))
[parf] alarm (  6): Uninitialized(*(s1 + i))
[parf] alarm (  7): Memory_access(*(s1 + i), read)
[parf] alarm (  8): Memory_access(*(s2 + i), read)
[parf] alarm (  9): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 10): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 11): Signed_overflow(tmp_0 + 1 <= 2147483647)
[parf] alarm ( 12): Memory_access(*(result + (tmp_0 + 1)), write)
[parf] alarm ( 13): Signed_overflow(errorCount + 1 <= 2147483647)
[parf] alarm ( 14): Uninitialized(*((unsigned char *)s1 + i))
[parf] alarm ( 15): Memory_access(*((unsigned char *)s2 + i), read)
[parf] alarm ( 16): Uninitialized(*((unsigned char *)s2 + i))
[parf] alarm ( 17): Memory_access(*((unsigned char *)s1 + i), read)
[parf] alarm ( 18): Signed_overflow(assertionCount + 1 <= 2147483647)
[parf] alarm ( 19): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 20): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 21): Memory_access(*(*lineptr + tmp_2), write)
[parf] alarm ( 22): Uninitialized(*(b + j))
[parf] alarm ( 23): Memory_access(*(b + j), read)
[parf] alarm ( 24): Memory_access(*(b + j), read)
[parf] alarm ( 25): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 26): Memory_access(*(*lineptr + cur), write)
[parf] alarm ( 27): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 28): Signed_overflow(position + 1 <= 2147483647)
[parf] alarm ( 29): Uninitialized(*(b + k))
[parf] alarm ( 30): Memory_access(*(b + k), read)
[parf] alarm ( 31): Memory_access(*(lineIn + (tmp - (size_t)1)), write)
[parf] alarm ( 32): Memory_access(*(lineOut + (tmp_0 - (size_t)1)), write)
[parf] alarm ( 33): Memory_access(*(p1 + i), read)
[parf] alarm ( 34): Uninitialized(*(p1 + i))
[parf] alarm ( 35): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 36): Memory_access(*(p1 + i), read)
[parf] alarm ( 37): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 38): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 39): Memory_access(*(b + k), read)
[parf] alarm ( 40): Uninitialized(*(b + k))
[parf] alarm ( 41): Memory_access(*(b + k), write)
[parf] alarm ( 42): Memory_access(*(b + (index_0 - 1)), read)
[parf] alarm ( 43): Uninitialized(*(b + index_0))
[parf] alarm ( 44): Uninitialized(*(b + (index_0 - 1)))
[parf] alarm ( 45): Memory_access(*(b + index_0), read)
[parf] alarm ( 46): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 47): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 48): Uninitialized(*(b + k))
[parf] alarm ( 49): Memory_access(*(b + k), read)
[parf] alarm ( 50): Memory_access(*(b + index_0), read)
[parf] alarm ( 51): Uninitialized(*(b + index_0))
[parf] alarm ( 52): Uninitialized(*(b + k))
[parf] alarm ( 53): Memory_access(*(b + k), read)
[parf] alarm ( 54): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 55): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 56): Memory_access(*(b + k), read)
[parf] alarm ( 57): Uninitialized(*(b + k))
[parf] alarm ( 58): Signed_overflow((k - k0) + 1 <= 2147483647)
[parf] ============================================================================
[parf] ====== project "base04-sample03 2" ======
[parf] Parameter: -eva-widening-delay 9 -eva-subdivide-non-linear 48 -eva-split-return auto -eva-slevel 99 -eva-plevel 375 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 7 -eva-ilevel 225 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 226
[parf] alarms:
[parf] alarm (  1): Memory_access(*(b + index_0), read)
[parf] alarm (  2): Uninitialized(*(b + index_0))
[parf] alarm (  3): Memory_access(*(b + k), read)
[parf] alarm (  4): Uninitialized(*(b + k))
[parf] alarm (  5): Uninitialized(*(s2 + i))
[parf] alarm (  6): Uninitialized(*(s1 + i))
[parf] alarm (  7): Memory_access(*(s1 + i), read)
[parf] alarm (  8): Memory_access(*(s2 + i), read)
[parf] alarm (  9): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 10): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 11): Signed_overflow(tmp_0 + 1 <= 2147483647)
[parf] alarm ( 12): Memory_access(*(result + (tmp_0 + 1)), write)
[parf] alarm ( 13): Signed_overflow(errorCount + 1 <= 2147483647)
[parf] alarm ( 14): Uninitialized(*((unsigned char *)s1 + i))
[parf] alarm ( 15): Memory_access(*((unsigned char *)s2 + i), read)
[parf] alarm ( 16): Uninitialized(*((unsigned char *)s2 + i))
[parf] alarm ( 17): Memory_access(*((unsigned char *)s1 + i), read)
[parf] alarm ( 18): Signed_overflow(assertionCount + 1 <= 2147483647)
[parf] alarm ( 19): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 20): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 21): Memory_access(*(*lineptr + tmp_2), write)
[parf] alarm ( 22): Uninitialized(*(b + j))
[parf] alarm ( 23): Memory_access(*(b + j), read)
[parf] alarm ( 24): Memory_access(*(b + j), read)
[parf] alarm ( 25): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 26): Memory_access(*(*lineptr + cur), write)
[parf] alarm ( 27): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 28): Signed_overflow(position + 1 <= 2147483647)
[parf] alarm ( 29): Uninitialized(*(b + k))
[parf] alarm ( 30): Memory_access(*(b + k), read)
[parf] alarm ( 31): Memory_access(*(lineIn + (tmp - (size_t)1)), write)
[parf] alarm ( 32): Memory_access(*(lineOut + (tmp_0 - (size_t)1)), write)
[parf] alarm ( 33): Memory_access(*(p1 + i), read)
[parf] alarm ( 34): Uninitialized(*(p1 + i))
[parf] alarm ( 35): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 36): Memory_access(*(p1 + i), read)
[parf] alarm ( 37): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 38): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 39): Memory_access(*(b + k), read)
[parf] alarm ( 40): Uninitialized(*(b + k))
[parf] alarm ( 41): Memory_access(*(b + k), write)
[parf] alarm ( 42): Memory_access(*(b + (index_0 - 1)), read)
[parf] alarm ( 43): Uninitialized(*(b + index_0))
[parf] alarm ( 44): Uninitialized(*(b + (index_0 - 1)))
[parf] alarm ( 45): Memory_access(*(b + index_0), read)
[parf] alarm ( 46): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 47): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 48): Uninitialized(*(b + k))
[parf] alarm ( 49): Memory_access(*(b + k), read)
[parf] alarm ( 50): Memory_access(*(b + index_0), read)
[parf] alarm ( 51): Uninitialized(*(b + index_0))
[parf] alarm ( 52): Uninitialized(*(b + k))
[parf] alarm ( 53): Memory_access(*(b + k), read)
[parf] alarm ( 54): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 55): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 56): Memory_access(*(b + k), read)
[parf] alarm ( 57): Uninitialized(*(b + k))
[parf] alarm ( 58): Signed_overflow((k - k0) + 1 <= 2147483647)
[parf] ============================================================================
[parf] Final parameter: -eva-widening-delay 8 -eva-subdivide-non-linear 8 -eva-split-return auto -eva-slevel 26 -eva-plevel 67 -eva-partition-history 0 -eva-octagon-through-calls -eva-min-loop-unroll 2 -eva-ilevel 45 -eva-equality-through-calls formals -eva-domains cvalue,equality,gauges,octagon,symbolic-locations -eva-auto-loop-unroll 33
[parf] alarms:
[parf] alarm (  1): Memory_access(*(b + index_0), read)
[parf] alarm (  2): Uninitialized(*(b + index_0))
[parf] alarm (  3): Memory_access(*(b + k), read)
[parf] alarm (  4): Uninitialized(*(b + k))
[parf] alarm (  5): Uninitialized(*(s2 + i))
[parf] alarm (  6): Uninitialized(*(s1 + i))
[parf] alarm (  7): Memory_access(*(s1 + i), read)
[parf] alarm (  8): Memory_access(*(s2 + i), read)
[parf] alarm (  9): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 10): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 11): Signed_overflow(tmp_0 + 1 <= 2147483647)
[parf] alarm ( 12): Memory_access(*(result + (tmp_0 + 1)), write)
[parf] alarm ( 13): Signed_overflow(errorCount + 1 <= 2147483647)
[parf] alarm ( 14): Uninitialized(*((unsigned char *)s1 + i))
[parf] alarm ( 15): Memory_access(*((unsigned char *)s2 + i), read)
[parf] alarm ( 16): Uninitialized(*((unsigned char *)s2 + i))
[parf] alarm ( 17): Memory_access(*((unsigned char *)s1 + i), read)
[parf] alarm ( 18): Signed_overflow(assertionCount + 1 <= 2147483647)
[parf] alarm ( 19): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 20): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 21): Memory_access(*(*lineptr + tmp_2), write)
[parf] alarm ( 22): Uninitialized(*(b + j))
[parf] alarm ( 23): Memory_access(*(b + j), read)
[parf] alarm ( 24): Memory_access(*(b + j), read)
[parf] alarm ( 25): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 26): Memory_access(*(*lineptr + cur), write)
[parf] alarm ( 27): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 28): Signed_overflow(position + 1 <= 2147483647)
[parf] alarm ( 29): Uninitialized(*(b + k))
[parf] alarm ( 30): Memory_access(*(b + k), read)
[parf] alarm ( 31): Memory_access(*(lineIn + (tmp - (size_t)1)), write)
[parf] alarm ( 32): Memory_access(*(lineOut + (tmp_0 - (size_t)1)), write)
[parf] alarm ( 33): Memory_access(*(p1 + i), read)
[parf] alarm ( 34): Uninitialized(*(p1 + i))
[parf] alarm ( 35): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 36): Memory_access(*(p1 + i), read)
[parf] alarm ( 37): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 38): Signed_overflow(index_0 + 1 <= 2147483647)
[parf] alarm ( 39): Memory_access(*(b + k), read)
[parf] alarm ( 40): Uninitialized(*(b + k))
[parf] alarm ( 41): Memory_access(*(b + k), write)
[parf] alarm ( 42): Memory_access(*(b + (index_0 - 1)), read)
[parf] alarm ( 43): Uninitialized(*(b + index_0))
[parf] alarm ( 44): Uninitialized(*(b + (index_0 - 1)))
[parf] alarm ( 45): Memory_access(*(b + index_0), read)
[parf] alarm ( 46): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 47): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 48): Uninitialized(*(b + k))
[parf] alarm ( 49): Memory_access(*(b + k), read)
[parf] alarm ( 50): Memory_access(*(b + index_0), read)
[parf] alarm ( 51): Uninitialized(*(b + index_0))
[parf] alarm ( 52): Uninitialized(*(b + k))
[parf] alarm ( 53): Memory_access(*(b + k), read)
[parf] alarm ( 54): Uninitialized(*(b + (k - 1)))
[parf] alarm ( 55): Memory_access(*(b + (k - 1)), read)
[parf] alarm ( 56): Memory_access(*(b + k), read)
[parf] alarm ( 57): Uninitialized(*(b + k))
[parf] alarm ( 58): Signed_overflow((k - k0) + 1 <= 2147483647)

real	30m7.241s
user	95m16.933s
sys	5m29.254s
