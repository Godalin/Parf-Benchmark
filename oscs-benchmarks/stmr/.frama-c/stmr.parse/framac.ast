/* Generated by Frama-C */
#include "__fc_builtin.h"
#include "errno.h"
#include "stdarg.h"
#include "stddef.h"
#include "stdint.h"
#include "stdio.c"
#include "stdio.h"
#include "stdlib.h"
#include "string.c"
#include "string.h"
#include "strings.h"
int stem(char *p, int index_0, int position);

static char *b;
static int k;
static int k0;
static int j;
/*@ assigns \result;
    assigns \result \from (indirect: *(b + index_0)), (indirect: index_0);
 */
static int isConsonant(int index_0)
{
  int __retres;
  switch ((int)*(b + index_0)) {
    int tmp_1;
    case 'a': case 'e': case 'i': case 'o': case 'u': __retres = 0;
    goto return_label;
    case 'y': ;
    if (index_0 == k0) tmp_1 = 1;
    else {
      int tmp_0;
      int tmp;
      tmp = isConsonant(index_0 - 1);
      if (tmp) tmp_0 = 0; else tmp_0 = 1;
      tmp_1 = tmp_0;
    }
    __retres = tmp_1;
    goto return_label;
    default: __retres = 1;
    goto return_label;
  }
  return_label: return __retres;
}

static int getMeasure(void)
{
  int __retres;
  int position;
  int index_0;
  position = 0;
  index_0 = k0;
  while (1) {
    {
      int tmp;
      if (index_0 > j) {
        __retres = position;
        goto return_label;
      }
      tmp = isConsonant(index_0);
      if (! tmp) break;
      index_0 ++;
    }
  }
  index_0 ++;
  while (1) {
    while (1) {
      {
        int tmp_0;
        if (index_0 > j) {
          __retres = position;
          goto return_label;
        }
        tmp_0 = isConsonant(index_0);
        if (tmp_0) break;
        index_0 ++;
      }
    }
    index_0 ++;
    position ++;
    while (1) {
      {
        int tmp_1;
        if (index_0 > j) {
          __retres = position;
          goto return_label;
        }
        tmp_1 = isConsonant(index_0);
        if (! tmp_1) break;
        index_0 ++;
      }
    }
    index_0 ++;
  }
  return_label: return __retres;
}

static int vowelInStem(void)
{
  int __retres;
  int index_0;
  index_0 = k0 - 1;
  while (1) {
    index_0 ++;
    ;
    if (! (index_0 <= j)) break;
    {
      int tmp;
      tmp = isConsonant(index_0);
      if (! tmp) {
        __retres = 1;
        goto return_label;
      }
    }
  }
  __retres = 0;
  return_label: return __retres;
}

static int isDoubleConsonant(int index_0)
{
  int __retres;
  int tmp;
  if ((int)*(b + index_0) != (int)*(b + (index_0 - 1))) {
    __retres = 0;
    goto return_label;
  }
  tmp = isConsonant(index_0);
  __retres = tmp;
  return_label: return __retres;
}

static int cvc(int index_0)
{
  int __retres;
  int character;
  if (index_0 < k0 + 2) goto _LOR;
  else {
    int tmp;
    tmp = isConsonant(index_0);
    if (tmp) {
      int tmp_0;
      tmp_0 = isConsonant(index_0 - 1);
      if (tmp_0) goto _LOR;
      else {
        int tmp_1;
        tmp_1 = isConsonant(index_0 - 2);
        if (! tmp_1) {
          _LOR: {
                  __retres = 0;
                  goto return_label;
                }
        }
      }
    }
    else goto _LOR;
  }
  character = (int)*(b + index_0);
  if (character == 'w') goto _LOR_0;
  else 
    if (character == 'x') goto _LOR_0;
    else 
      if (character == 'y') {
        _LOR_0: {
                  __retres = 0;
                  goto return_label;
                }
      }
  __retres = 1;
  return_label: return __retres;
}

static int ends(char const *value)
{
  int __retres;
  int tmp;
  int length = (int)*(value + 0);
  if ((int)*(value + length) != (int)*(b + k)) {
    __retres = 0;
    goto return_label;
  }
  if (length > (k - k0) + 1) {
    __retres = 0;
    goto return_label;
  }
  tmp = memcmp((void const *)(((b + k) - length) + 1),
               (void const *)(value + 1),(size_t)length);
  if (tmp != 0) {
    __retres = 0;
    goto return_label;
  }
  j = k - length;
  __retres = 1;
  return_label: return __retres;
}

static void setTo(char const *value)
{
  int length = (int)*(value + 0);
  memmove((void *)((b + j) + 1),(void const *)(value + 1),(size_t)length);
  k = j + length;
  return;
}

static void replace(char const *value)
{
  int tmp;
  tmp = getMeasure();
  if (tmp > 0) setTo(value);
  return;
}

static void step1ab(void)
{
  int character;
  int tmp_11;
  if ((int)*(b + k) == 's') {
    int tmp_0;
    tmp_0 = ends("\004sses");
    if (tmp_0) k -= 2;
    else {
      int tmp;
      tmp = ends("\003ies");
      if (tmp) setTo("\001i");
      else 
        if ((int)*(b + (k - 1)) != 's') k --;
    }
  }
  tmp_11 = ends("\003eed");
  if (tmp_11) {
    int tmp_1;
    tmp_1 = getMeasure();
    if (tmp_1 > 0) k --;
  }
  else {
    int tmp_8;
    tmp_8 = ends("\002ed");
    if (tmp_8) goto _LOR_0;
    else {
      int tmp_9;
      tmp_9 = ends("\003ing");
      if (tmp_9) {
        int tmp_10;
        _LOR_0: tmp_10 = vowelInStem();
        if (tmp_10) {
          int tmp_7;
          k = j;
          tmp_7 = ends("\002at");
          if (tmp_7) setTo("\003ate");
          else {
            int tmp_6;
            tmp_6 = ends("\002bl");
            if (tmp_6) setTo("\003ble");
            else {
              int tmp_5;
              tmp_5 = ends("\002iz");
              if (tmp_5) setTo("\003ize");
              else {
                int tmp_4;
                tmp_4 = isDoubleConsonant(k);
                if (tmp_4) {
                  k --;
                  character = (int)*(b + k);
                  if (character == 'l') goto _LOR;
                  else 
                    if (character == 's') goto _LOR;
                    else 
                      if (character == 'z') _LOR: k ++;
                }
                else {
                  int tmp_2;
                  tmp_2 = getMeasure();
                  if (tmp_2 == 1) {
                    int tmp_3;
                    tmp_3 = cvc(k);
                    if (tmp_3) setTo("\001e");
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return;
}

static void step1c(void)
{
  int tmp;
  tmp = ends("\001y");
  if (tmp) {
    int tmp_0;
    tmp_0 = vowelInStem();
    if (tmp_0) *(b + k) = (char)'i';
  }
  return;
}

static void step2(void)
{
  switch ((int)*(b + (k - 1))) {
    int tmp;
    int tmp_0;
    int tmp_1;
    int tmp_2;
    int tmp_3;
    int tmp_4;
    int tmp_5;
    int tmp_6;
    int tmp_7;
    int tmp_8;
    int tmp_9;
    int tmp_10;
    int tmp_11;
    int tmp_12;
    int tmp_13;
    int tmp_14;
    int tmp_15;
    int tmp_16;
    int tmp_17;
    int tmp_18;
    int tmp_19;
    case 'a': tmp = ends("\aational");
    if (tmp) {
      replace("\003ate");
      break;
    }
    tmp_0 = ends("\006tional");
    if (tmp_0) {
      replace("\004tion");
      break;
    }
    break;
    case 'c': tmp_1 = ends("\004enci");
    if (tmp_1) {
      replace("\004ence");
      break;
    }
    tmp_2 = ends("\004anci");
    if (tmp_2) {
      replace("\004ance");
      break;
    }
    break;
    case 'e': tmp_3 = ends("\004izer");
    if (tmp_3) {
      replace("\003ize");
      break;
    }
    break;
    case 'l': tmp_4 = ends("\003bli");
    if (tmp_4) {
      replace("\003ble");
      break;
    }
    tmp_5 = ends("\004alli");
    if (tmp_5) {
      replace("\002al");
      break;
    }
    tmp_6 = ends("\005entli");
    if (tmp_6) {
      replace("\003ent");
      break;
    }
    tmp_7 = ends("\003eli");
    if (tmp_7) {
      replace("\001e");
      break;
    }
    tmp_8 = ends("\005ousli");
    if (tmp_8) {
      replace("\003ous");
      break;
    }
    break;
    case 'o': tmp_9 = ends("\aization");
    if (tmp_9) {
      replace("\003ize");
      break;
    }
    tmp_10 = ends("\005ation");
    if (tmp_10) {
      replace("\003ate");
      break;
    }
    tmp_11 = ends("\004ator");
    if (tmp_11) {
      replace("\003ate");
      break;
    }
    break;
    case 's': tmp_12 = ends("\005alism");
    if (tmp_12) {
      replace("\002al");
      break;
    }
    tmp_13 = ends("\aiveness");
    if (tmp_13) {
      replace("\003ive");
      break;
    }
    tmp_14 = ends("\afulness");
    if (tmp_14) {
      replace("\003ful");
      break;
    }
    tmp_15 = ends("\aousness");
    if (tmp_15) {
      replace("\003ous");
      break;
    }
    break;
    case 't': tmp_16 = ends("\005aliti");
    if (tmp_16) {
      replace("\002al");
      break;
    }
    tmp_17 = ends("\005iviti");
    if (tmp_17) {
      replace("\003ive");
      break;
    }
    tmp_18 = ends("\006biliti");
    if (tmp_18) {
      replace("\003ble");
      break;
    }
    break;
    case 'g': tmp_19 = ends("\004logi");
    if (tmp_19) {
      replace("\003log");
      break;
    }
  }
  return;
}

static void step3(void)
{
  switch ((int)*(b + k)) {
    int tmp;
    int tmp_0;
    int tmp_1;
    int tmp_2;
    int tmp_3;
    int tmp_4;
    int tmp_5;
    case 'e': tmp = ends("\005icate");
    if (tmp) {
      replace("\002ic");
      break;
    }
    tmp_0 = ends("\005ative");
    if (tmp_0) {
      replace("\000");
      break;
    }
    tmp_1 = ends("\005alize");
    if (tmp_1) {
      replace("\002al");
      break;
    }
    break;
    case 'i': tmp_2 = ends("\005iciti");
    if (tmp_2) {
      replace("\002ic");
      break;
    }
    break;
    case 'l': tmp_3 = ends("\004ical");
    if (tmp_3) {
      replace("\002ic");
      break;
    }
    tmp_4 = ends("\003ful");
    if (tmp_4) {
      replace("\000");
      break;
    }
    break;
    case 's': tmp_5 = ends("\004ness");
    if (tmp_5) {
      replace("\000");
      break;
    }
    break;
  }
  return;
}

static void step4(void)
{
  int tmp_18;
  switch ((int)*(b + (k - 1))) {
    int tmp;
    int tmp_0;
    int tmp_1;
    int tmp_2;
    int tmp_3;
    int tmp_4;
    int tmp_5;
    int tmp_6;
    int tmp_7;
    int tmp_8;
    int tmp_9;
    int tmp_10;
    int tmp_11;
    int tmp_12;
    int tmp_13;
    int tmp_14;
    int tmp_15;
    int tmp_16;
    int tmp_17;
    case 'a': tmp = ends("\002al");
    if (tmp) break;
    goto return_label;
    case 'c': tmp_0 = ends("\004ance");
    if (tmp_0) break;
    tmp_1 = ends("\004ence");
    if (tmp_1) break;
    goto return_label;
    case 'e': tmp_2 = ends("\002er");
    if (tmp_2) break;
    goto return_label;
    case 'i': tmp_3 = ends("\002ic");
    if (tmp_3) break;
    goto return_label;
    case 'l': tmp_4 = ends("\004able");
    if (tmp_4) break;
    tmp_5 = ends("\004ible");
    if (tmp_5) break;
    goto return_label;
    case 'n': tmp_6 = ends("\003ant");
    if (tmp_6) break;
    tmp_7 = ends("\005ement");
    if (tmp_7) break;
    tmp_8 = ends("\004ment");
    if (tmp_8) break;
    tmp_9 = ends("\003ent");
    if (tmp_9) break;
    goto return_label;
    case 'o': tmp_10 = ends("\003ion");
    if (tmp_10) 
      if (j >= k0) 
        if ((int)*(b + j) == 's') goto _LOR;
        else 
          if ((int)*(b + j) == 't') _LOR: break;
    tmp_11 = ends("\002ou");
    if (tmp_11) break;
    goto return_label;
    case 's': tmp_12 = ends("\003ism");
    if (tmp_12) break;
    goto return_label;
    case 't': tmp_13 = ends("\003ate");
    if (tmp_13) break;
    tmp_14 = ends("\003iti");
    if (tmp_14) break;
    goto return_label;
    case 'u': tmp_15 = ends("\003ous");
    if (tmp_15) break;
    goto return_label;
    case 'v': tmp_16 = ends("\003ive");
    if (tmp_16) break;
    goto return_label;
    case 'z': tmp_17 = ends("\003ize");
    if (tmp_17) break;
    goto return_label;
    default: ;
    goto return_label;
  }
  tmp_18 = getMeasure();
  if (tmp_18 > 1) k = j;
  return_label: return;
}

static void step5(void)
{
  int a;
  j = k;
  if ((int)*(b + k) == 'e') {
    a = getMeasure();
    if (a > 1) goto _LOR;
    else 
      if (a == 1) {
        int tmp;
        tmp = cvc(k - 1);
        if (! tmp) _LOR: k --;
      }
  }
  if ((int)*(b + k) == 'l') {
    int tmp_0;
    tmp_0 = isDoubleConsonant(k);
    if (tmp_0) {
      int tmp_1;
      tmp_1 = getMeasure();
      if (tmp_1 > 1) k --;
    }
  }
  return;
}

int stem(char *p, int index_0, int position)
{
  int __retres;
  b = p;
  k = position;
  k0 = index_0;
  if (k <= k0 + 1) {
    __retres = k;
    goto return_label;
  }
  step1ab();
  if (k > k0) {
    step1c();
    step2();
    step3();
    step4();
    step5();
  }
  __retres = k;
  return_label: return __retres;
}

static int assertionCount = 0;
static int errorCount = 0;
/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_1(FILE * restrict stream, char const * restrict format);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(param2);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param2 + (0 ..))),
            (indirect: *(param1 + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param2 + (0 ..)),
            *(param1 + (0 ..)), *(param0 + (0 ..));
 */
int fprintf_va_2(FILE * restrict stream, char const * restrict format,
                 char *param0, char *param1, char *param2);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_3(FILE * restrict stream, char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_4(FILE * restrict stream, char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_1(char const * restrict format);

static void assertStem(char const *input, char const *output)
{
  char *value;
  char *result;
  char *fixture;
  int tmp_0;
  size_t tmp;
  int tmp_1;
  value = strdup(input);
  result = strdup(input);
  fixture = strdup(output);
  tmp = strlen((char const *)result);
  ;
  tmp_0 = stem(result,0,(int)(tmp - (size_t)1));
  *(result + (tmp_0 + 1)) = (char)0;
  tmp_1 = strcmp((char const *)fixture,(char const *)result);
  if (tmp_1) {
    errorCount ++;
    fprintf(__fc_stderr,"\033[31m"); /* fprintf_va_1 */
    fprintf(__fc_stderr,"  (\342\234\226) For `%s`. Expected `%s`, got `%s`",
            value,fixture,result); /* fprintf_va_2 */
    fprintf(__fc_stderr,"\033[0m"); /* fprintf_va_3 */
    fprintf(__fc_stderr,"\n"); /* fprintf_va_4 */
  }
  else printf("\033[32m.\033[0m"); /* printf_va_1 */
  assertionCount ++;
  free((void *)value);
  free((void *)fixture);
  free((void *)result);
  return;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_2(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_3(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, param0;
 */
int printf_va_4(char const * restrict format, int param0, int param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_5(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_6(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_7(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_8(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_9(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_10(char const * restrict format);

int main(void)
{
  int __retres;
  FILE *input;
  FILE *output;
  char *lineIn;
  char *lineOut;
  size_t lengthIn;
  size_t lengthOut;
  lineIn = (char *)0;
  lineOut = (char *)0;
  lengthIn = (size_t)0;
  lengthOut = (size_t)0;
  input = fopen("fixture/input.txt","r");
  output = fopen("fixture/output.txt","r");
  while (1) {
    ssize_t tmp_1;
    tmp_1 = getline(& lineIn,& lengthIn,input);
    if (tmp_1 != (ssize_t)(-1)) {
      ssize_t tmp_2;
      tmp_2 = getline(& lineOut,& lengthOut,output);
      if (! (tmp_2 != (ssize_t)(-1))) break;
    }
    else break;
    {
      size_t tmp;
      size_t tmp_0;
      tmp = strlen((char const *)lineIn);
      *(lineIn + (tmp - (size_t)1)) = (char)0;
      tmp_0 = strlen((char const *)lineOut);
      *(lineOut + (tmp_0 - (size_t)1)) = (char)0;
      assertStem((char const *)lineIn,(char const *)lineOut);
    }
  }
  assertStem("nationalization","nation");
  assertStem("nationalism","nation");
  printf("\n"); /* printf_va_2 */
  if (errorCount != 0) {
    printf("\033[31m"); /* printf_va_3 */
    printf("(\342\234\226) Failed on %d of %d assertions",errorCount,
           assertionCount); /* printf_va_4 */
    printf("\033[0m"); /* printf_va_5 */
    printf("\n"); /* printf_va_6 */
    exit(1);
  }
  printf("\033[32m"); /* printf_va_7 */
  printf("(\342\234\223) Passed %d assertions without errors",assertionCount); /* printf_va_8 */
  printf("\033[0m"); /* printf_va_9 */
  printf("\n"); /* printf_va_10 */
  __retres = 0;
  return __retres;
}


