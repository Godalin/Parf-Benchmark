/* Generated by Frama-C */
#include "errno.h"
#include "math.h"
#include "stdarg.h"
#include "stddef.h"
#include "stdio.h"
typedef unsigned int uint32;
typedef int sint32;
typedef short sint16;
typedef unsigned char uint8;
typedef unsigned short uint16;
typedef char boolean;
typedef double real64;
typedef real64 PT1_t;
struct __anonstruct_Curve_t_1 {
   uint16 numPoints ;
   real64 x[10] ;
   real64 y[10] ;
};
typedef struct __anonstruct_Curve_t_1 Curve_t;
typedef real64 Delay_t;
typedef real64 Timer_t;
struct __anonstruct_Ramp_t_2 {
   sint16 dir ;
   real64 state ;
   real64 target ;
};
typedef struct __anonstruct_Ramp_t_2 Ramp_t;
real64 Engine_maxVoltage_PARAM;

real64 Engine_minVoltage_PARAM;

real64 Battery_voltage;
real64 dT;
real64 Engine_realVoltage;
real64 Env_humidity;
real64 Env_temperature;
boolean Global_emergencyMode;
boolean LegSensor_atMark;
real64 LegSensor_signal;
real64 PT1_Filter(PT1_t *state, real64 x, real64 t1, real64 dt);

real64 Interpolate_from_curve(Curve_t *curve, real64 x);

boolean Turn_on_delay(Delay_t *delay, boolean signal, real64 timeLimit,
                      real64 dt);

void Timer_start(Timer_t *timer);

real64 Timer_elapsedTime(Timer_t *timer);

void Timer_tick(Timer_t *timer, real64 dt);

real64 Ramp_out(Ramp_t *data, real64 target, real64 slopePos,
                real64 slopeNeg, real64 dt);

sint16 Ramp_getDir(Ramp_t *data);

real64 Ramp_getValue(Ramp_t *data);

boolean Ramp_targetReached(Ramp_t *data);

real64 Limiter_out(real64 min, real64 input, real64 max);

void Sleep(sint32 delayMs);

sint32 Time(void);

real64 PT1_Filter(PT1_t *state, real64 x, real64 t1, real64 dt)
{
  real64 __retres;
  if (t1 == 0.0) *state = x;
  else {
    real64 c = exp(- dt / t1);
    *state = (1.0 - c) * x + c * *state;
  }
  __retres = *state;
  return __retres;
}

real64 Interpolate_from_curve(Curve_t *curve, real64 x)
{
  sint16 i;
  real64 result = 0.0;
  if (x <= curve->x[0]) result = curve->y[0];
  else 
    if (x >= curve->x[(int)curve->numPoints - 1]) result = curve->y[(int)curve->numPoints - 1];
    else {
      i = (sint16)((int)curve->numPoints - 2);
      while ((int)i >= 0) {
        if (x >= curve->x[i]) {
          result = curve->y[i] + ((x - curve->x[i]) / (curve->x[(int)i + 1] - curve->x[i])) * (
                                 curve->y[(int)i + 1] - curve->y[i]);
          break;
        }
        i = (sint16)((int)i - 1);
      }
    }
  return result;
}

boolean Turn_on_delay(Delay_t *delay, boolean signal, real64 timeLimit,
                      real64 dt)
{
  boolean result;
  if (signal) 
    if (*delay < timeLimit) {
      *delay += dt;
      result = (boolean)0;
    }
    else result = (boolean)1;
  else {
    *delay = 0.0;
    result = (boolean)0;
  }
  return result;
}

void Timer_start(Timer_t *timer)
{
  *timer = 0.0;
  return;
}

real64 Timer_elapsedTime(Timer_t *timer)
{
  real64 __retres;
  __retres = *timer;
  return __retres;
}

void Timer_tick(Timer_t *timer, real64 dt)
{
  *timer += dt;
  return;
}

static sint32 _t;
void Sleep(sint32 delayMs)
{
  _t += delayMs;
  return;
}

sint32 Time(void)
{
  return _t;
}

real64 Ramp_out(Ramp_t *data, real64 target, real64 slopePos,
                real64 slopeNeg, real64 dt)
{
  real64 __retres;
  data->target = target;
  if (data->state < target) {
    if (slopePos != 0.0) 
      if ((int)data->dir == -1) data->state = target;
      else {
        data->state += slopePos * dt;
        if (data->state > target) data->state = target;
        data->dir = (sint16)1;
      }
    else goto _LAND;
  }
  else {
    _LAND: ;
    if (data->state > target) 
      if (slopeNeg != 0.0) 
        if ((int)data->dir == 1) data->state = target;
        else {
          data->state -= slopeNeg * dt;
          if (data->state < target) data->state = target;
          data->dir = (sint16)(-1);
        }
  }
  if (data->state == target) data->dir = (sint16)0;
  __retres = data->state;
  return __retres;
}

sint16 Ramp_getDir(Ramp_t *data)
{
  sint16 __retres;
  __retres = data->dir;
  return __retres;
}

real64 Ramp_getValue(Ramp_t *data)
{
  real64 __retres;
  __retres = data->state;
  return __retres;
}

boolean Ramp_targetReached(Ramp_t *data)
{
  boolean __retres;
  __retres = (boolean)(data->state == data->target);
  return __retres;
}

real64 Limiter_out(real64 min, real64 input, real64 max)
{
  real64 result = input;
  if (result < min) result = min;
  if (result > max) result = max;
  return result;
}

void RoCo_init(void);

void RoCo_process(void);

Curve_t RoCo_acceleration_CURVE;

Curve_t RoCo_accelerationFast_CURVE;

Curve_t RoCo_deceleration_CURVE;

Curve_t RoCo_decelerationFast_CURVE;

real64 RoCo_angleAtMark_PARAM;

Curve_t LegSensorSignalToAngle_CURVE;

real64 RoCo_angleReachedThreshold1_PARAM;

real64 RoCo_angleReachedThreshold2_PARAM;

real64 RoCo_batteryLowLimit_PARAM;

real64 RoCo_batteryLowDelay_PARAM;

boolean RoCo_checkBatteryVoltage_PARAM;

real64 RoCo_humidityLimit_PARAM;

boolean RoCo_checkHumidity_PARAM;

real64 RoCo_envTempLowerLimit_PARAM;

real64 RoCo_envTempUpperLimit_PARAM;

real64 RoCo_TempFltT_PARAM;

boolean RoCo_hasMinMaxAngles_PARAM;

real64 RoCo_maxAngle_PARAM;

real64 RoCo_minAngle_PARAM;

real64 RoCo_initMoveSpeed_PARAM;

real64 RoCo_initRampSlopeNeg_PARAM;

real64 RoCo_initRampSlopePos_PARAM;

real64 RoCo_idlePosition_PARAM;

real64 RoCo_initTimeout_PARAM;

real64 RoCo_shutdownTimeout_PARAM;

real64 RoCo_stepSpeed_PARAM;

real64 RoCo_TimeSlopeNeg_PARAM;

real64 RoCo_TimeSlopePos_PARAM;

Curve_t EngineSpeedToVoltage_CURVE;

real64 RoCo_voltageFilter_PARAM;

boolean RoCo_activeDesired;
boolean RoCo_commandMoveByAngle;
real64 RoCo_desiredDeltaAngle;
boolean RoCo_commandMoveToAngle;
real64 RoCo_desiredTargetAngle;
boolean RoCo_moveFast;
boolean RoCo_commandShutOff;
boolean RoCo_error;
boolean RoCo_isActive;
real64 RoCo_legAngle;
boolean RoCo_legAngleValid;
real64 RoCo_engineVoltage;
Curve_t RoCo_acceleration_CURVE =
  {.numPoints = (uint16)4,
   .x = {0.0, 0.33, 0.67, 1.0},
   .y = {0.0, 0.2, 0.5, 1.0}};
Curve_t RoCo_accelerationFast_CURVE =
  {.numPoints = (uint16)4,
   .x = {0.0, 0.33, 0.67, 1.0},
   .y = {0.0, 2.0, 4.0, 5.0}};
boolean RoCo_adaptationActive = (boolean)1;
real64 RoCo_angleAtMark_PARAM = 19.0;
real64 RoCo_angleReachedThreshold1_PARAM = 5.0;
real64 RoCo_angleReachedThreshold1Fast_PARAM = 10.0;
real64 RoCo_angleReachedThreshold2_PARAM = 0.5;
real64 RoCo_batteryLowLimit_PARAM = 19.5;
real64 RoCo_batteryLowDelay_PARAM = 60.0;
boolean RoCo_checkBatteryVoltage_PARAM = (boolean)1;
boolean RoCo_checkHumidity_PARAM = (boolean)0;
Curve_t RoCo_deceleration_CURVE =
  {.numPoints = (uint16)4,
   .x = {0.0, 0.33, 0.67, 1.0},
   .y = {0.0, 0.25, 0.75, 1.0}};
Curve_t RoCo_decelerationFast_CURVE =
  {.numPoints = (uint16)4,
   .x = {0.0, 0.33, 0.67, 1.0},
   .y = {0.0, 2.0, 4.0, 5.0}};
real64 RoCo_envTempLowerLimit_PARAM = 5.0;
real64 RoCo_envTempUpperLimit_PARAM = 30.0;
boolean RoCo_hasMinMaxAngles_PARAM = (boolean)1;
real64 RoCo_humidityLimit_PARAM = 0.8;
real64 RoCo_idlePosition_PARAM = 0.0;
real64 RoCo_initMoveSpeed_PARAM = 1.0;
real64 RoCo_initRampSlopeNeg_PARAM = 1.0;
real64 RoCo_initRampSlopePos_PARAM = 1.0;
real64 RoCo_initStandstillTimeout_PARAM = 2.0;
real64 RoCo_initTimeout_PARAM = 20.0;
real64 RoCo_initialDeltaSearchRange_PARAM = 2.0;
real64 RoCo_initialDeltaSearchTimeout_PARAM = 2.0;
real64 RoCo_maxAngle_PARAM = 120.0;
real64 RoCo_minAngle_PARAM = - 120.0;
real64 RoCo_shutdownTimeout_PARAM = 30.0;
real64 RoCo_stepSpeed_PARAM = 2.0;
real64 RoCo_TempFltT_PARAM = 0.1;
real64 RoCo_TimeSlopeNeg_PARAM = 1.0;
real64 RoCo_TimeSlopePos_PARAM = 0.5;
real64 RoCo_voltageFilter_PARAM = 0.1;
real64 Engine_maxVoltage_PARAM = 24.0;
real64 Engine_minVoltage_PARAM = - 24.0;
Curve_t EngineSpeedToVoltage_CURVE =
  {.numPoints = (uint16)5,
   .x = {- 3.0, - 1.5, 0.0, 1.5, 3.0},
   .y = {- 24.0, - 15.0, 0.0, 15.0, 24.0}};
Curve_t LegSensorSignalToAngle_CURVE =
  {.numPoints = (uint16)4,
   .x = {- 24.0, - 12.0, 12.0, 24.0},
   .y = {- 60.0, - 30.0, 30.0, 60.0}};
boolean RoCo_isAdapted;
static real64 angleDiffRequest;
static real64 desiredEngineVoltage;
static boolean initBackwards;
static boolean limitationActive;
static real64 prevAngleSignal;
static real64 rampValue;
static boolean wasActive;
static boolean wasInit;
static boolean enabled;
static real64 rampTarget;
static real64 filteredEnvTemp;
static sint32 direction;
static real64 targetAngle;
static boolean init;
static boolean final;
static boolean deltaSearchPhase;
static Ramp_t initRamp = {.dir = (sint16)0, .state = 0.0, .target = 0.0};
static Timer_t initTimer;
static Ramp_t moveTimeRamp = {.dir = (sint16)0, .state = 0.0, .target = 0.0};
static PT1_t envTempFilter;
static Timer_t shutdownTimer;
static real64 voltageFilter;
static Delay_t batteryLowDelay;
static Delay_t standstillDelay;
static real64 adaptation[2] = {0.0, 0.0};
static boolean rampHighReached = (boolean)0;
static boolean wasRampEnded;
void RoCo_init(void)
{
  enabled = (boolean)0;
  angleDiffRequest = 0.0;
  desiredEngineVoltage = 0.0;
  initBackwards = (boolean)0;
  initTimer = 0.0;
  limitationActive = (boolean)0;
  prevAngleSignal = 0.0;
  envTempFilter = Env_temperature;
  rampValue = 0.0;
  filteredEnvTemp = 0.0;
  direction = 0;
  targetAngle = 0.0;
  batteryLowDelay = 0.0;
  shutdownTimer = 0.0;
  rampTarget = 0.0;
  voltageFilter = 0.0;
  wasActive = (boolean)0;
  wasInit = (boolean)0;
  deltaSearchPhase = (boolean)0;
  init = (boolean)0;
  final = (boolean)0;
  RoCo_activeDesired = (boolean)0;
  RoCo_commandMoveByAngle = (boolean)0;
  RoCo_commandMoveToAngle = (boolean)0;
  RoCo_commandShutOff = (boolean)0;
  RoCo_desiredDeltaAngle = 0.0;
  RoCo_desiredTargetAngle = 0.0;
  RoCo_moveFast = (boolean)0;
  RoCo_isActive = (boolean)0;
  RoCo_legAngle = 0.0;
  RoCo_legAngleValid = (boolean)0;
  RoCo_error = (boolean)0;
  RoCo_engineVoltage = 0.0;
  RoCo_isAdapted = (boolean)0;
  return;
}

void RoCo_process(void)
{
  real64 t9;
  real64 t10;
  real64 t11;
  Curve_t *t12;
  real64 t13;
  boolean t14;
  real64 t15;
  int tmp_2;
  int tmp_0;
  real64 t1 = Battery_voltage;
  real64 t2 = Env_humidity;
  real64 t3 = Env_temperature;
  boolean t4 = LegSensor_atMark;
  real64 t5 = LegSensor_signal;
  filteredEnvTemp = PT1_Filter(& envTempFilter,t3,RoCo_TempFltT_PARAM,dT);
  if (filteredEnvTemp > RoCo_envTempLowerLimit_PARAM) 
    if (filteredEnvTemp < RoCo_envTempUpperLimit_PARAM) {
      int tmp;
      if (t2 < RoCo_humidityLimit_PARAM) tmp = 1;
      else 
        if (! RoCo_checkHumidity_PARAM) tmp = 1; else tmp = 0;
      tmp_0 = tmp;
    }
    else tmp_0 = 0;
  else tmp_0 = 0;
  if (tmp_0) {
    boolean tmp_1;
    tmp_1 = Turn_on_delay(& batteryLowDelay,
                          (boolean)(t1 < RoCo_batteryLowLimit_PARAM),
                          RoCo_batteryLowDelay_PARAM,dT);
    if (tmp_1) 
      if (! RoCo_checkBatteryVoltage_PARAM) 
        _LOR: if (! RoCo_error) tmp_2 = 1; else tmp_2 = 0;
      else tmp_2 = 0;
    else goto _LOR;
  }
  else tmp_2 = 0;
  enabled = (boolean)tmp_2;
  if (! enabled) {
    int tmp_3;
    if (wasActive) 
      if (RoCo_activeDesired) tmp_3 = 1; else tmp_3 = 0;
    else tmp_3 = 0;
    wasActive = (boolean)tmp_3;
    RoCo_isActive = (boolean)0;
    RoCo_engineVoltage = 0.0;
  }
  else 
    if (RoCo_activeDesired) goto _LOR_4;
    else 
      if (RoCo_isActive) {
        _LOR_4:
        {
          int tmp_19;
          t13 = RoCo_voltageFilter_PARAM;
          t15 = Interpolate_from_curve(& LegSensorSignalToAngle_CURVE,t5);
          RoCo_legAngle += t15;
          if (t4) {
            RoCo_legAngle = RoCo_angleAtMark_PARAM;
            RoCo_legAngleValid = (boolean)1;
          }
          if (RoCo_activeDesired) 
            if (! wasActive) {
              if (! RoCo_legAngleValid) init = (boolean)1;
              RoCo_isActive = (boolean)1;
            }
          if (! RoCo_activeDesired) 
            if (wasActive) 
              if (! init) 
                if (! final) RoCo_commandShutOff = (boolean)1;
          if (init) {
            real64 tmp_4;
            t14 = (boolean)(RoCo_angleAtMark_PARAM > RoCo_idlePosition_PARAM);
            if (! wasActive) Timer_start(& initTimer);
            tmp_4 = Timer_elapsedTime(& initTimer);
            ;
            if (tmp_4 > RoCo_initTimeout_PARAM) goto _LOR_0;
            else {
              boolean tmp_6;
              double tmp_5;
              ;
              ;
              tmp_5 = fabs(t15);
              tmp_6 = Turn_on_delay(& standstillDelay,
                                    (boolean)(tmp_5 < 0.001),
                                    RoCo_initStandstillTimeout_PARAM,dT);
              if (tmp_6) 
                _LOR_0:
                if (! initBackwards) {
                  initBackwards = (boolean)1;
                  Timer_start(& initTimer);
                  Turn_on_delay(& standstillDelay,(boolean)0,
                                RoCo_initStandstillTimeout_PARAM,dT);
                }
                else {
                  RoCo_error = (boolean)1;
                  RoCo_isActive = (boolean)0;
                  init = (boolean)0;
                }
            }
            if ((int)initBackwards ^ (int)t14) rampTarget = RoCo_initMoveSpeed_PARAM;
            else rampTarget = - RoCo_initMoveSpeed_PARAM;
            angleDiffRequest = Ramp_out(& initRamp,rampTarget,
                                        RoCo_initRampSlopePos_PARAM,
                                        RoCo_initRampSlopeNeg_PARAM,dT);
            if (RoCo_legAngleValid) {
              init = (boolean)0;
              initBackwards = (boolean)0;
            }
          }
          if (! init) {
            double tmp_9;
            sint16 tmp_11;
            double tmp_12;
            if (RoCo_commandShutOff) {
              final = (boolean)1;
              RoCo_commandShutOff = (boolean)0;
              targetAngle = RoCo_idlePosition_PARAM;
              Timer_start(& shutdownTimer);
              RoCo_activeDesired = (boolean)0;
            }
            if (! final) {
              if (RoCo_commandMoveToAngle) {
                targetAngle = RoCo_desiredTargetAngle;
                RoCo_commandMoveToAngle = (boolean)0;
                direction = 0;
              }
              else goto _LAND;
            }
            else 
              _LAND:
              if (! final) 
                if (RoCo_commandMoveByAngle) {
                  targetAngle = RoCo_legAngle + RoCo_desiredDeltaAngle;
                  if (RoCo_desiredDeltaAngle == 0.0) direction = 0;
                  else 
                    if (RoCo_desiredDeltaAngle > 0.0) direction = -1;
                    else direction = 1;
                  RoCo_commandMoveByAngle = (boolean)0;
                }
            if (RoCo_hasMinMaxAngles_PARAM) targetAngle = Limiter_out
                                            (RoCo_minAngle_PARAM,targetAngle,
                                             RoCo_maxAngle_PARAM);
            t9 = RoCo_legAngle - targetAngle;
            if (RoCo_moveFast) t11 = RoCo_angleReachedThreshold1Fast_PARAM;
            else t11 = RoCo_angleReachedThreshold1_PARAM;
            if (RoCo_adaptationActive) t11 += adaptation[RoCo_moveFast];
            tmp_9 = fabs(t9);
            ;
            if (tmp_9 > t11) 
              if (direction == 0) {
                real64 tmp_8;
                if (! RoCo_hasMinMaxAngles_PARAM) tmp_8 = t9;
                else {
                  double tmp_7;
                  tmp_7 = fabs(t9);
                  if (tmp_7 >= 180.0) tmp_8 = t9; else tmp_8 = - t9;
                }
                if (tmp_8 > 0.0) direction = 1; else direction = -1;
              }
            rampTarget = 0.0;
            if (RoCo_legAngleValid) {
              double tmp_10;
              tmp_10 = fabs(t9);
              ;
              if (tmp_10 > t11) 
                if (t9 > 0.0) {
                  if (0 > direction) goto _LOR_1; else goto _LAND_0;
                }
                else {
                  _LAND_0: ;
                  if (t9 < 0.0) 
                    if (0 < direction) _LOR_1: rampTarget = 1.0;
                }
            }
            rampValue = Ramp_out(& moveTimeRamp,rampTarget,
                                 RoCo_TimeSlopePos_PARAM,
                                 RoCo_TimeSlopeNeg_PARAM,dT);
            tmp_11 = Ramp_getDir(& moveTimeRamp);
            if (-1 == (int)tmp_11) 
              if (RoCo_moveFast) t12 = & RoCo_decelerationFast_CURVE;
              else t12 = & RoCo_deceleration_CURVE;
            else 
              if (RoCo_moveFast) t12 = & RoCo_accelerationFast_CURVE;
              else t12 = & RoCo_acceleration_CURVE;
            angleDiffRequest = Interpolate_from_curve(t12,rampValue);
            angleDiffRequest *= (real64)direction;
            t10 = RoCo_legAngle - targetAngle;
            tmp_12 = fabs(rampValue);
            if (tmp_12 == 1.0) rampHighReached = (boolean)1;
            if (rampValue == 0.0) {
              double tmp_15;
              if (RoCo_adaptationActive) 
                if (! wasRampEnded) 
                  if (rampHighReached) 
                    if (direction > 0) {
                      if (t10 > 0.0) goto _LOR_2; else goto _LAND_1;
                    }
                    else {
                      _LAND_1: ;
                      if (direction < 0) 
                        if (t10 < 0.0) {
                          _LOR_2:
                          {
                            double tmp_13;
                            tmp_13 = fabs(t10);
                            adaptation[RoCo_moveFast] += tmp_13;
                            RoCo_isAdapted = (boolean)1;
                          }
                        }
                    }
              tmp_15 = fabs(t10);
              ;
              if (tmp_15 > RoCo_angleReachedThreshold2_PARAM) {
                double tmp_14;
                if (t10 > 0.0) tmp_14 = - 1.0; else tmp_14 = 1.0;
                angleDiffRequest += (tmp_14 * RoCo_stepSpeed_PARAM) * dT;
              }
              rampHighReached = (boolean)0;
            }
            wasRampEnded = (boolean)(rampValue == 0.0);
          }
          if (final) 
            if (RoCo_legAngleValid) {
              double tmp_16;
              tmp_16 = fabs(RoCo_legAngle - RoCo_idlePosition_PARAM);
              ;
              if (tmp_16 < RoCo_angleReachedThreshold2_PARAM) {
                double tmp_17;
                tmp_17 = fabs(angleDiffRequest);
                if (tmp_17 < 0.05) goto _LOR_3; else goto _LAND_3;
              }
              else goto _LAND_3;
            }
            else {
              real64 tmp_18;
              _LAND_3:
              { /* sequence */
                tmp_18 = Timer_elapsedTime(& shutdownTimer);
                ;
              }
              if (tmp_18 > RoCo_shutdownTimeout_PARAM) {
                _LOR_3:
                {
                  final = (boolean)0;
                  RoCo_isActive = (boolean)0;
                  RoCo_legAngleValid = (boolean)0;
                }
              }
            }
          desiredEngineVoltage = Interpolate_from_curve(& EngineSpeedToVoltage_CURVE,
                                                        angleDiffRequest);
          desiredEngineVoltage = Limiter_out(Engine_minVoltage_PARAM,
                                             desiredEngineVoltage,
                                             Engine_maxVoltage_PARAM);
          if (Engine_maxVoltage_PARAM == desiredEngineVoltage) tmp_19 = 1;
          else 
            if (Engine_minVoltage_PARAM == desiredEngineVoltage) tmp_19 = 1;
            else tmp_19 = 0;
          limitationActive = (boolean)tmp_19;
          RoCo_engineVoltage = PT1_Filter(& voltageFilter,
                                          desiredEngineVoltage,t13,dT);
          wasInit = init;
          wasActive = RoCo_isActive;
          Timer_tick(& shutdownTimer,dT);
          Timer_tick(& initTimer,dT);
        }
      }
      else RoCo_engineVoltage = 0.0;
  return;
}

void Sim_process(void);

void Sim_init(void);

real64 buf1;
real64 buf2;
real64 buf3;
real64 buf4;
real64 buf5;
real64 internalPosition = 22.5;
real64 oldInternalPosition;
real64 Sim_maxPos_PARAM = 100.0;
real64 Sim_minPos_PARAM = - 100.0;
PT1_t Srv_PT1;
void Sim_process(void)
{
  real64 tmp;
  int tmp_0;
  real64 t1 = RoCo_engineVoltage;
  real64 t2 = Engine_realVoltage;
  uint32 t3 = (uint32)LegSensor_atMark;
  real64 t4 = LegSensor_signal;
  buf5 = buf4;
  buf4 = buf3;
  buf3 = buf2;
  buf2 = buf1;
  buf1 = t1;
  Sim_maxPos_PARAM = RoCo_maxAngle_PARAM + 1.0;
  Sim_minPos_PARAM = RoCo_minAngle_PARAM - 1.0;
  ;
  ;
  tmp = PT1_Filter(& Srv_PT1,buf5 * 0.9,0.15,dT);
  ;
  internalPosition = Limiter_out(internalPosition + tmp * dT,
                                 Sim_minPos_PARAM,Sim_maxPos_PARAM);
  t4 = internalPosition - oldInternalPosition;
  if (oldInternalPosition < RoCo_angleAtMark_PARAM) {
    if (RoCo_angleAtMark_PARAM <= internalPosition) tmp_0 = 1;
    else goto _LAND;
  }
  else {
    _LAND: ;
    if (oldInternalPosition > RoCo_angleAtMark_PARAM) 
      if (RoCo_angleAtMark_PARAM >= internalPosition) tmp_0 = 1;
      else tmp_0 = 0;
    else tmp_0 = 0;
  }
  t3 = (uint32)((uint8)tmp_0);
  t2 = buf5 * 0.9;
  oldInternalPosition = internalPosition;
  Engine_realVoltage = t2;
  LegSensor_atMark = (boolean)t3;
  LegSensor_signal = t4 / 2.5;
  return;
}

void Sim_init(void)
{
  Engine_realVoltage = 0.0;
  LegSensor_atMark = (boolean)0;
  LegSensor_signal = 0.0;
  buf1 = 0.0;
  buf2 = 0.0;
  buf3 = 0.0;
  buf4 = 0.0;
  buf5 = 0.0;
  internalPosition = 20.0;
  oldInternalPosition = 0.0;
  Srv_PT1 = 0.0;
  return;
}

char *output_header =
  (char *)"time(ms)\tengineVoltage\tlegAngle\tlegAngleValid\tisActive\n";
char *output_row_fmt_string = (char *)"%d\t%f\t%f\t%d\t%d\n";
/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_1(FILE * restrict stream, char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param4),
            (indirect: param3), (indirect: param2), (indirect: param1),
            (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param4, param3, param2, param1,
            param0;
 */
int fprintf_va_2(FILE * restrict stream, char const * restrict format,
                 int param0, double param1, double param2, int param3,
                 int param4);

int main(void)
{
  int __retres;
  sint32 lastTime = Time();
  dT = 0.02;
  RoCo_init();
  Sim_init();
  Battery_voltage = 21.3;
  Env_humidity = 0.5;
  Env_temperature = 20.0;
  Global_emergencyMode = (boolean)0;
  RoCo_activeDesired = (boolean)1;
  RoCo_moveFast = (boolean)0;
  int cnt = 0;
  fprintf(__fc_stderr,(char const *)output_header); /* fprintf_va_1 */
  while (cnt < 9000) {
    sint32 tmp_0;
    tmp_0 = Time();
    dT = (double)(tmp_0 - lastTime) / 1000.0;
    lastTime = Time();
    RoCo_process();
    Sim_process();
    if (cnt % 5 == 0) fprintf(__fc_stderr,
                              (char const *)output_row_fmt_string,lastTime,
                              RoCo_engineVoltage,RoCo_legAngle,
                              (int)RoCo_legAngleValid,(int)RoCo_isActive); /* fprintf_va_2 */
    Sleep(20);
    cnt ++;
    if (cnt == 2500) {
      RoCo_commandMoveToAngle = (boolean)1;
      RoCo_desiredTargetAngle = 15.0;
    }
    else 
      if (cnt == 3500) {
        RoCo_commandMoveToAngle = (boolean)1;
        RoCo_desiredTargetAngle = - 55.0;
      }
      else 
        if (cnt == 5000) {
          RoCo_commandMoveToAngle = (boolean)1;
          RoCo_desiredTargetAngle = 30.0;
        }
        else 
          if (cnt == 7000) {
            RoCo_commandMoveToAngle = (boolean)1;
            RoCo_desiredTargetAngle = - 5.0;
          }
          else 
            if (cnt == 8000) RoCo_commandShutOff = (boolean)1;
  }
  __retres = 0;
  return __retres;
}


